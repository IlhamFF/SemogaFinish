{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"EntityMetadata.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/metadata/EntityMetadata.ts"],"sourceRoot":"..","sourcesContent":["import { QueryRunner, SelectQueryBuilder } from \"..\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { CannotCreateEntityIdMapError } from \"../error/CannotCreateEntityIdMapError\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { TableMetadataArgs } from \"../metadata-args/TableMetadataArgs\"\nimport { TreeMetadataArgs } from \"../metadata-args/TreeMetadataArgs\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { CheckMetadata } from \"./CheckMetadata\"\nimport { ColumnMetadata } from \"./ColumnMetadata\"\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\nimport { EntityListenerMetadata } from \"./EntityListenerMetadata\"\nimport { ExclusionMetadata } from \"./ExclusionMetadata\"\nimport { ForeignKeyMetadata } from \"./ForeignKeyMetadata\"\nimport { IndexMetadata } from \"./IndexMetadata\"\nimport { RelationCountMetadata } from \"./RelationCountMetadata\"\nimport { RelationIdMetadata } from \"./RelationIdMetadata\"\nimport { RelationMetadata } from \"./RelationMetadata\"\nimport { TableType } from \"./types/TableTypes\"\nimport { TreeType } from \"./types/TreeTypes\"\nimport { UniqueMetadata } from \"./UniqueMetadata\"\nimport { ClosureTreeOptions } from \"./types/ClosureTreeOptions\"\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { shorten } from \"../util/StringUtils\"\n\n/**\n * Contains all entity metadata.\n */\nexport class EntityMetadata {\n    readonly \"@instanceof\" = Symbol.for(\"EntityMetadata\")\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection where this entity metadata is created.\n     */\n    connection: DataSource\n\n    /**\n     * Metadata arguments used to build this entity metadata.\n     */\n    tableMetadataArgs: TableMetadataArgs\n\n    /**\n     * If entity's table is a closure-typed table, then this entity will have a closure junction table metadata.\n     */\n    closureJunctionTable: EntityMetadata\n\n    /**\n     * If this is entity metadata for a junction closure table then its owner closure table metadata will be set here.\n     */\n    parentClosureEntityMetadata: EntityMetadata\n\n    /**\n     * Parent's entity metadata. Used in inheritance patterns.\n     */\n    parentEntityMetadata: EntityMetadata\n\n    /**\n     * Children entity metadatas. Used in inheritance patterns.\n     */\n    childEntityMetadatas: EntityMetadata[] = []\n\n    /**\n     * All \"inheritance tree\" from a target entity.\n     * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].\n     * It also contains child entities for single table inheritance.\n     */\n    inheritanceTree: Function[] = []\n\n    /**\n     * Table type. Tables can be closure, junction, etc.\n     */\n    tableType: TableType = \"regular\"\n\n    /**\n     * Target class to which this entity metadata is bind.\n     * Note, that when using table inheritance patterns target can be different rather then table's target.\n     * For virtual tables which lack of real entity (like junction tables) target is equal to their table name.\n     */\n    target: Function | string\n\n    /**\n     * Gets the name of the target.\n     */\n    targetName: string\n\n    /**\n     * Entity's name.\n     * Equal to entity target class's name if target is set to table.\n     * If target class is not then then it equals to table name.\n     */\n    name: string\n\n    /**\n     * View's expression.\n     * Used in views\n     */\n    expression?: string | ((connection: DataSource) => SelectQueryBuilder<any>)\n\n    /**\n     * View's dependencies.\n     * Used in views\n     */\n    dependsOn?: Set<Function | string>\n\n    /**\n     * Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement\n     */\n    withoutRowid?: boolean = false\n\n    /**\n     * Original user-given table name (taken from schema or @Entity(tableName) decorator).\n     * If user haven't specified a table name this property will be undefined.\n     */\n    givenTableName?: string\n\n    /**\n     * Entity table name in the database.\n     * This is final table name of the entity.\n     * This name already passed naming strategy, and generated based on\n     * multiple criteria, including user table name and global table prefix.\n     */\n    tableName: string\n\n    /**\n     * Entity table path. Contains database name, schema name and table name.\n     * E.g. myDB.mySchema.myTable\n     */\n    tablePath: string\n\n    /**\n     * Gets the table name without global table prefix.\n     * When querying table you need a table name with prefix, but in some scenarios,\n     * for example when you want to name a junction table that contains names of two other tables,\n     * you may want a table name without prefix.\n     */\n    tableNameWithoutPrefix: string\n\n    /**\n     * Indicates if schema will be synchronized for this entity or not.\n     */\n    synchronize: boolean = true\n\n    /**\n     * Table's database engine type (like \"InnoDB\", \"MyISAM\", etc).\n     */\n    engine?: string\n\n    /**\n     * Database name.\n     */\n    database?: string\n\n    /**\n     * Schema name. Used in Postgres and Sql Server.\n     */\n    schema?: string\n\n    /**\n     * Specifies a default order by used for queries from this table when no explicit order by is specified.\n     */\n    orderBy?: OrderByCondition\n\n    /**\n     * If this entity metadata's table using one of the inheritance patterns,\n     * then this will contain what pattern it uses.\n     */\n    inheritancePattern?: \"STI\" /*|\"CTI\"*/\n\n    /**\n     * Checks if there any non-nullable column exist in this entity.\n     */\n    hasNonNullableRelations: boolean = false\n\n    /**\n     * Indicates if this entity metadata of a junction table, or not.\n     * Junction table is a table created by many-to-many relationship.\n     *\n     * Its also possible to understand if entity is junction via tableType.\n     */\n    isJunction: boolean = false\n\n    /**\n     * Indicates if the entity should be instantiated using the constructor\n     * or via allocating a new object via `Object.create()`.\n     */\n    isAlwaysUsingConstructor: boolean = true\n\n    /**\n     * Indicates if this entity is a tree, what type of tree it is.\n     */\n    treeType?: TreeType\n\n    /**\n     * Indicates if this entity is a tree, what options of tree it has.\n     */\n    treeOptions?: ClosureTreeOptions\n\n    /**\n     * Checks if this table is a junction table of the closure table.\n     * This type is for tables that contain junction metadata of the closure tables.\n     */\n    isClosureJunction: boolean = false\n\n    /**\n     * Checks if entity's table has multiple primary columns.\n     */\n    hasMultiplePrimaryKeys: boolean = false\n\n    /**\n     * Indicates if this entity metadata has uuid generated columns.\n     */\n    hasUUIDGeneratedColumns: boolean = false\n\n    /**\n     * If this entity metadata is a child table of some table, it should have a discriminator value.\n     * Used to store a value in a discriminator column.\n     */\n    discriminatorValue?: string\n\n    /**\n     * Entity's column metadatas defined by user.\n     */\n    ownColumns: ColumnMetadata[] = []\n\n    /**\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\n     */\n    columns: ColumnMetadata[] = []\n\n    /**\n     * Ancestor columns used only in closure junction tables.\n     */\n    ancestorColumns: ColumnMetadata[] = []\n\n    /**\n     * Descendant columns used only in closure junction tables.\n     */\n    descendantColumns: ColumnMetadata[] = []\n\n    /**\n     * All columns except for virtual columns.\n     */\n    nonVirtualColumns: ColumnMetadata[] = []\n\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of owner entity.\n     */\n    ownerColumns: ColumnMetadata[] = []\n\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of inverse entity.\n     */\n    inverseColumns: ColumnMetadata[] = []\n\n    /**\n     * Gets the column with generated flag.\n     */\n    generatedColumns: ColumnMetadata[] = []\n\n    /**\n     * Gets the object id column used with mongodb database.\n     */\n    objectIdColumn?: ColumnMetadata\n\n    /**\n     * Gets entity column which contains a create date value.\n     */\n    createDateColumn?: ColumnMetadata\n\n    /**\n     * Gets entity column which contains an update date value.\n     */\n    updateDateColumn?: ColumnMetadata\n\n    /**\n     * Gets entity column which contains a delete date value.\n     */\n    deleteDateColumn?: ColumnMetadata\n\n    /**\n     * Gets entity column which contains an entity version.\n     */\n    versionColumn?: ColumnMetadata\n\n    /**\n     * Gets the discriminator column used to store entity identificator in single-table inheritance tables.\n     */\n    discriminatorColumn?: ColumnMetadata\n\n    /**\n     * Special column that stores tree level in tree entities.\n     */\n    treeLevelColumn?: ColumnMetadata\n\n    /**\n     * Nested set's left value column.\n     * Used only in tree entities with nested set pattern applied.\n     */\n    nestedSetLeftColumn?: ColumnMetadata\n\n    /**\n     * Nested set's right value column.\n     * Used only in tree entities with nested set pattern applied.\n     */\n    nestedSetRightColumn?: ColumnMetadata\n\n    /**\n     * Materialized path column.\n     * Used only in tree entities with materialized path pattern applied.\n     */\n    materializedPathColumn?: ColumnMetadata\n\n    /**\n     * Gets the primary columns.\n     */\n    primaryColumns: ColumnMetadata[] = []\n\n    /**\n     * Entity's relation metadatas.\n     */\n    ownRelations: RelationMetadata[] = []\n\n    /**\n     * Relations of the entity, including relations that are coming from the embeddeds of this entity.\n     */\n    relations: RelationMetadata[] = []\n\n    /**\n     * List of eager relations this metadata has.\n     */\n    eagerRelations: RelationMetadata[] = []\n\n    /**\n     * List of eager relations this metadata has.\n     */\n    lazyRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only one-to-one relations of the entity.\n     */\n    oneToOneRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only owner one-to-one relations of the entity.\n     */\n    ownerOneToOneRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only one-to-many relations of the entity.\n     */\n    oneToManyRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only many-to-one relations of the entity.\n     */\n    manyToOneRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only many-to-many relations of the entity.\n     */\n    manyToManyRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only owner many-to-many relations of the entity.\n     */\n    ownerManyToManyRelations: RelationMetadata[] = []\n\n    /**\n     * Gets only owner one-to-one and many-to-one relations.\n     */\n    relationsWithJoinColumns: RelationMetadata[] = []\n\n    /**\n     * Tree parent relation. Used only in tree-tables.\n     */\n    treeParentRelation?: RelationMetadata\n\n    /**\n     * Tree children relation. Used only in tree-tables.\n     */\n    treeChildrenRelation?: RelationMetadata\n\n    /**\n     * Entity's relation id metadatas.\n     */\n    relationIds: RelationIdMetadata[] = []\n\n    /**\n     * Entity's relation id metadatas.\n     */\n    relationCounts: RelationCountMetadata[] = []\n\n    /**\n     * Entity's foreign key metadatas.\n     */\n    foreignKeys: ForeignKeyMetadata[] = []\n\n    /**\n     * Entity's embedded metadatas.\n     */\n    embeddeds: EmbeddedMetadata[] = []\n\n    /**\n     * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.\n     */\n    allEmbeddeds: EmbeddedMetadata[] = []\n\n    /**\n     * Entity's own indices.\n     */\n    ownIndices: IndexMetadata[] = []\n\n    /**\n     * Entity's index metadatas.\n     */\n    indices: IndexMetadata[] = []\n\n    /**\n     * Entity's unique metadatas.\n     */\n    uniques: UniqueMetadata[] = []\n\n    /**\n     * Entity's own uniques.\n     */\n    ownUniques: UniqueMetadata[] = []\n\n    /**\n     * Entity's check metadatas.\n     */\n    checks: CheckMetadata[] = []\n\n    /**\n     * Entity's exclusion metadatas.\n     */\n    exclusions: ExclusionMetadata[] = []\n\n    /**\n     * Entity's own listener metadatas.\n     */\n    ownListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Entity listener metadatas.\n     */\n    listeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER LOAD\" type.\n     */\n    afterLoadListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"BEFORE INSERT\" type.\n     */\n    beforeInsertListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n    afterInsertListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"BEFORE UPDATE\" type.\n     */\n    beforeUpdateListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n    afterUpdateListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"BEFORE REMOVE\" type.\n     */\n    beforeRemoveListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"BEFORE SOFT REMOVE\" type.\n     */\n    beforeSoftRemoveListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"BEFORE RECOVER\" type.\n     */\n    beforeRecoverListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n    afterRemoveListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER SOFT REMOVE\" type.\n     */\n    afterSoftRemoveListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Listener metadatas with \"AFTER RECOVER\" type.\n     */\n    afterRecoverListeners: EntityListenerMetadata[] = []\n\n    /**\n     * Map of columns and relations of the entity.\n     *\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n     * This method will create following object:\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n     */\n    propertiesMap: ObjectLiteral\n\n    /**\n     * Table comment. Not supported by all database types.\n     */\n    comment?: string\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        connection: DataSource\n        inheritanceTree?: Function[]\n        inheritancePattern?: \"STI\" /*|\"CTI\"*/\n        tableTree?: TreeMetadataArgs\n        parentClosureEntityMetadata?: EntityMetadata\n        args: TableMetadataArgs\n    }) {\n        this.connection = options.connection\n        this.inheritanceTree = options.inheritanceTree || []\n        this.inheritancePattern = options.inheritancePattern\n        this.treeType = options.tableTree ? options.tableTree.type : undefined\n        this.treeOptions = options.tableTree\n            ? options.tableTree.options\n            : undefined\n        this.parentClosureEntityMetadata = options.parentClosureEntityMetadata!\n        this.tableMetadataArgs = options.args\n        this.target = this.tableMetadataArgs.target\n        this.tableType = this.tableMetadataArgs.type\n        this.expression = this.tableMetadataArgs.expression\n        this.withoutRowid = this.tableMetadataArgs.withoutRowid\n        this.dependsOn = this.tableMetadataArgs.dependsOn\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a new entity.\n     */\n    create(\n        queryRunner?: QueryRunner,\n        options?: { fromDeserializer?: boolean; pojo?: boolean },\n    ): any {\n        const pojo = options && options.pojo === true ? true : false\n        // if target is set to a function (e.g. class) that can be created then create it\n        let ret: any\n        if (typeof this.target === \"function\" && !pojo) {\n            if (!options?.fromDeserializer || this.isAlwaysUsingConstructor) {\n                ret = new (<any>this.target)()\n            } else {\n                ret = Object.create(this.target.prototype)\n            }\n        } else {\n            // otherwise simply return a new empty object\n            ret = {}\n        }\n\n        // add \"typename\" property\n        if (this.connection.options.typename) {\n            ret[this.connection.options.typename] = this.targetName\n        }\n\n        this.lazyRelations.forEach((relation) =>\n            this.connection.relationLoader.enableLazyLoad(\n                relation,\n                ret,\n                queryRunner,\n            ),\n        )\n        return ret\n    }\n\n    /**\n     * Checks if given entity has an id.\n     */\n    hasId(entity: ObjectLiteral): boolean {\n        if (!entity) return false\n\n        return this.primaryColumns.every((primaryColumn) => {\n            const value = primaryColumn.getEntityValue(entity)\n            return value !== null && value !== undefined && value !== \"\"\n        })\n    }\n\n    /**\n     * Checks if given entity / object contains ALL primary keys entity must have.\n     * Returns true if it contains all of them, false if at least one of them is not defined.\n     */\n    hasAllPrimaryKeys(entity: ObjectLiteral): boolean {\n        return this.primaryColumns.every((primaryColumn) => {\n            const value = primaryColumn.getEntityValue(entity)\n            return value !== null && value !== undefined\n        })\n    }\n\n    /**\n     * Ensures that given object is an entity id map.\n     * If given id is an object then it means its already id map.\n     * If given id isn't an object then it means its a value of the id column\n     * and it creates a new id map with this value and name of the primary column.\n     */\n    ensureEntityIdMap(id: any): ObjectLiteral {\n        if (ObjectUtils.isObject(id)) return id\n\n        if (this.hasMultiplePrimaryKeys)\n            throw new CannotCreateEntityIdMapError(this, id)\n\n        return this.primaryColumns[0].createValueMap(id)\n    }\n\n    /**\n     * Gets primary keys of the entity and returns them in a literal object.\n     * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\n     * For multiple primary keys it returns multiple keys in object.\n     * For primary keys inside embeds it returns complex object literal with keys in them.\n     */\n    getEntityIdMap(\n        entity: ObjectLiteral | undefined,\n    ): ObjectLiteral | undefined {\n        if (!entity) return undefined\n\n        return EntityMetadata.getValueMap(entity, this.primaryColumns, {\n            skipNulls: true,\n        })\n    }\n\n    /**\n     * Creates a \"mixed id map\".\n     * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\n     * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\n     * This is called mixed id map.\n     */\n    getEntityIdMixedMap(\n        entity: ObjectLiteral | undefined,\n    ): ObjectLiteral | undefined {\n        if (!entity) return entity\n\n        const idMap = this.getEntityIdMap(entity)\n        if (this.hasMultiplePrimaryKeys) {\n            return idMap\n        } else if (idMap) {\n            return this.primaryColumns[0].getEntityValue(idMap) // todo: what about parent primary column?\n        }\n\n        return idMap\n    }\n\n    /**\n     * Compares two different entities by their ids.\n     * Returns true if they match, false otherwise.\n     */\n    compareEntities(\n        firstEntity: ObjectLiteral,\n        secondEntity: ObjectLiteral,\n    ): boolean {\n        const firstEntityIdMap = this.getEntityIdMap(firstEntity)\n        if (!firstEntityIdMap) return false\n\n        const secondEntityIdMap = this.getEntityIdMap(secondEntity)\n        if (!secondEntityIdMap) return false\n\n        return OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap)\n    }\n\n    /**\n     * Finds column with a given property name.\n     */\n    findColumnWithPropertyName(\n        propertyName: string,\n    ): ColumnMetadata | undefined {\n        return this.columns.find(\n            (column) => column.propertyName === propertyName,\n        )\n    }\n\n    /**\n     * Finds column with a given database name.\n     */\n    findColumnWithDatabaseName(\n        databaseName: string,\n    ): ColumnMetadata | undefined {\n        return this.columns.find(\n            (column) => column.databaseName === databaseName,\n        )\n    }\n\n    /**\n     * Checks if there is a column or relationship with a given property path.\n     */\n    hasColumnWithPropertyPath(propertyPath: string): boolean {\n        const hasColumn = this.columns.some(\n            (column) => column.propertyPath === propertyPath,\n        )\n        return hasColumn || this.hasRelationWithPropertyPath(propertyPath)\n    }\n\n    /**\n     * Finds column with a given property path.\n     */\n    findColumnWithPropertyPath(\n        propertyPath: string,\n    ): ColumnMetadata | undefined {\n        const column = this.columns.find(\n            (column) => column.propertyPath === propertyPath,\n        )\n        if (column) return column\n\n        // in the case if column with property path was not found, try to find a relation with such property path\n        // if we find relation and it has a single join column then its the column user was seeking\n        const relation = this.relations.find(\n            (relation) => relation.propertyPath === propertyPath,\n        )\n        if (relation && relation.joinColumns.length === 1)\n            return relation.joinColumns[0]\n\n        return undefined\n    }\n\n    /**\n     * Finds column with a given property path.\n     * Does not search in relation unlike findColumnWithPropertyPath.\n     */\n    findColumnWithPropertyPathStrict(\n        propertyPath: string,\n    ): ColumnMetadata | undefined {\n        return this.columns.find(\n            (column) => column.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Finds columns with a given property path.\n     * Property path can match a relation, and relations can contain multiple columns.\n     */\n    findColumnsWithPropertyPath(propertyPath: string): ColumnMetadata[] {\n        const column = this.columns.find(\n            (column) => column.propertyPath === propertyPath,\n        )\n        if (column) return [column]\n\n        // in the case if column with property path was not found, try to find a relation with such property path\n        // if we find relation and it has a single join column then its the column user was seeking\n        const relation = this.findRelationWithPropertyPath(propertyPath)\n        if (relation && relation.joinColumns) return relation.joinColumns\n\n        return []\n    }\n\n    /**\n     * Checks if there is a relation with the given property path.\n     */\n    hasRelationWithPropertyPath(propertyPath: string): boolean {\n        return this.relations.some(\n            (relation) => relation.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Finds relation with the given property path.\n     */\n    findRelationWithPropertyPath(\n        propertyPath: string,\n    ): RelationMetadata | undefined {\n        return this.relations.find(\n            (relation) => relation.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Checks if there is an embedded with a given property path.\n     */\n    hasEmbeddedWithPropertyPath(propertyPath: string): boolean {\n        return this.allEmbeddeds.some(\n            (embedded) => embedded.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Finds embedded with a given property path.\n     */\n    findEmbeddedWithPropertyPath(\n        propertyPath: string,\n    ): EmbeddedMetadata | undefined {\n        return this.allEmbeddeds.find(\n            (embedded) => embedded.propertyPath === propertyPath,\n        )\n    }\n\n    /**\n     * Returns an array of databaseNames mapped from provided propertyPaths\n     */\n    mapPropertyPathsToColumns(propertyPaths: string[]) {\n        return propertyPaths.map((propertyPath) => {\n            const column = this.findColumnWithPropertyPath(propertyPath)\n            if (column == null) {\n                throw new EntityPropertyNotFoundError(propertyPath, this)\n            }\n            return column\n        })\n    }\n\n    /**\n     * Iterates through entity and finds and extracts all values from relations in the entity.\n     * If relation value is an array its being flattened.\n     */\n    extractRelationValuesFromEntity(\n        entity: ObjectLiteral,\n        relations: RelationMetadata[],\n    ): [RelationMetadata, any, EntityMetadata][] {\n        const relationsAndValues: [RelationMetadata, any, EntityMetadata][] = []\n        relations.forEach((relation) => {\n            const value = relation.getEntityValue(entity)\n            if (Array.isArray(value)) {\n                value.forEach((subValue) =>\n                    relationsAndValues.push([\n                        relation,\n                        subValue,\n                        EntityMetadata.getInverseEntityMetadata(\n                            subValue,\n                            relation,\n                        ),\n                    ]),\n                )\n            } else if (value) {\n                relationsAndValues.push([\n                    relation,\n                    value,\n                    EntityMetadata.getInverseEntityMetadata(value, relation),\n                ])\n            }\n        })\n        return relationsAndValues\n    }\n\n    /**\n     * In the case of SingleTableInheritance, find the correct metadata\n     * for a given value.\n     *\n     * @param value The value to find the metadata for.\n     * @returns The found metadata for the entity or the base metadata if no matching metadata\n     *          was found in the whole inheritance tree.\n     */\n    findInheritanceMetadata(value: any): EntityMetadata {\n        // Check for single table inheritance and find the correct metadata in that case.\n        // Goal is to use the correct discriminator as we could have a repository\n        // for an (abstract) base class and thus the target would not match.\n\n        if (\n            this.inheritancePattern === \"STI\" &&\n            this.childEntityMetadatas.length > 0\n        ) {\n            // There could be a column on the base class that can manually be set to override the type.\n            let manuallySetDiscriminatorValue: unknown\n            if (this.discriminatorColumn) {\n                manuallySetDiscriminatorValue =\n                    value[this.discriminatorColumn.propertyName]\n            }\n            return (\n                this.childEntityMetadatas.find(\n                    (meta) =>\n                        manuallySetDiscriminatorValue ===\n                            meta.discriminatorValue ||\n                        value.constructor === meta.target,\n                ) || this\n            )\n        }\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Static Methods\n    // -------------------------------------------------------------------------\n\n    private static getInverseEntityMetadata(\n        value: any,\n        relation: RelationMetadata,\n    ): EntityMetadata {\n        return relation.inverseEntityMetadata.findInheritanceMetadata(value)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Static Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a property paths for a given entity.\n     *\n     * @deprecated\n     */\n    static createPropertyPath(\n        metadata: EntityMetadata,\n        entity: ObjectLiteral,\n        prefix: string = \"\",\n    ) {\n        const paths: string[] = []\n        Object.keys(entity).forEach((key) => {\n            // check for function is needed in the cases when createPropertyPath used on values contain a function as a value\n            // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })\n            const parentPath = prefix ? prefix + \".\" + key : key\n            if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {\n                const subPaths = this.createPropertyPath(\n                    metadata,\n                    entity[key],\n                    parentPath,\n                )\n                paths.push(...subPaths)\n            } else {\n                const path = prefix ? prefix + \".\" + key : key\n                paths.push(path)\n            }\n        })\n        return paths\n    }\n\n    /**\n     * Finds difference between two entity id maps.\n     * Returns items that exist in the first array and absent in the second array.\n     */\n    static difference(\n        firstIdMaps: ObjectLiteral[],\n        secondIdMaps: ObjectLiteral[],\n    ): ObjectLiteral[] {\n        return firstIdMaps.filter((firstIdMap) => {\n            return !secondIdMaps.find((secondIdMap) =>\n                OrmUtils.compareIds(firstIdMap, secondIdMap),\n            )\n        })\n    }\n\n    /**\n     * Creates value map from the given values and columns.\n     * Examples of usages are primary columns map and join columns map.\n     */\n    static getValueMap(\n        entity: ObjectLiteral,\n        columns: ColumnMetadata[],\n        options?: { skipNulls?: boolean },\n    ): ObjectLiteral | undefined {\n        return columns.reduce((map, column) => {\n            const value = column.getEntityValueMap(entity, options)\n\n            // make sure that none of the values of the columns are not missing\n            if (map === undefined || value === null || value === undefined)\n                return undefined\n\n            return OrmUtils.mergeDeep(map, value)\n        }, {} as ObjectLiteral | undefined)\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Builder Methods\n    // ---------------------------------------------------------------------\n\n    build() {\n        const namingStrategy = this.connection.namingStrategy\n        const entityPrefix = this.connection.options.entityPrefix\n        const entitySkipConstructor =\n            this.connection.options.entitySkipConstructor\n\n        this.engine = this.tableMetadataArgs.engine\n        this.database =\n            this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata\n                ? this.parentEntityMetadata.database\n                : this.tableMetadataArgs.database\n        if (this.tableMetadataArgs.schema) {\n            this.schema = this.tableMetadataArgs.schema\n        } else if (\n            this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata\n        ) {\n            this.schema = this.parentEntityMetadata.schema\n        } else if (this.connection.options?.hasOwnProperty(\"schema\")) {\n            this.schema = (this.connection.options as any).schema\n        }\n        this.givenTableName =\n            this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata\n                ? this.parentEntityMetadata.givenTableName\n                : this.tableMetadataArgs.name\n        this.synchronize =\n            this.tableMetadataArgs.synchronize === false ? false : true\n        this.targetName =\n            typeof this.tableMetadataArgs.target === \"function\"\n                ? (this.tableMetadataArgs.target as any).name\n                : this.tableMetadataArgs.target\n        if (this.tableMetadataArgs.type === \"closure-junction\") {\n            this.tableNameWithoutPrefix =\n                namingStrategy.closureJunctionTableName(this.givenTableName!)\n        } else if (\n            this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata\n        ) {\n            this.tableNameWithoutPrefix = namingStrategy.tableName(\n                this.parentEntityMetadata.targetName,\n                this.parentEntityMetadata.givenTableName,\n            )\n        } else {\n            this.tableNameWithoutPrefix = namingStrategy.tableName(\n                this.targetName,\n                this.givenTableName,\n            )\n\n            if (\n                this.tableMetadataArgs.type === \"junction\" &&\n                this.connection.driver.maxAliasLength &&\n                this.connection.driver.maxAliasLength > 0 &&\n                this.tableNameWithoutPrefix.length >\n                    this.connection.driver.maxAliasLength\n            ) {\n                // note: we are not using DriverUtils.buildAlias here because we would like to avoid\n                // hashed table names. However, current algorithm also isn't perfect, but we cannot\n                // change it, since it's a big breaking change. Planned to 0.4.0\n                this.tableNameWithoutPrefix = shorten(\n                    this.tableNameWithoutPrefix,\n                    { separator: \"_\", segmentLength: 3 },\n                )\n            }\n        }\n        this.tableName = entityPrefix\n            ? namingStrategy.prefixTableName(\n                  entityPrefix,\n                  this.tableNameWithoutPrefix,\n              )\n            : this.tableNameWithoutPrefix\n        this.target = this.target ? this.target : this.tableName\n        this.name = this.targetName ? this.targetName : this.tableName\n        this.expression = this.tableMetadataArgs.expression\n        this.withoutRowid =\n            this.tableMetadataArgs.withoutRowid === true ? true : false\n        this.tablePath = this.connection.driver.buildTableName(\n            this.tableName,\n            this.schema,\n            this.database,\n        )\n        this.orderBy =\n            typeof this.tableMetadataArgs.orderBy === \"function\"\n                ? this.tableMetadataArgs.orderBy(this.propertiesMap)\n                : this.tableMetadataArgs.orderBy // todo: is propertiesMap available here? Looks like its not\n\n        if (entitySkipConstructor !== undefined) {\n            this.isAlwaysUsingConstructor = !entitySkipConstructor\n        }\n\n        this.isJunction =\n            this.tableMetadataArgs.type === \"closure-junction\" ||\n            this.tableMetadataArgs.type === \"junction\"\n        this.isClosureJunction =\n            this.tableMetadataArgs.type === \"closure-junction\"\n\n        this.comment = this.tableMetadataArgs.comment\n    }\n\n    /**\n     * Registers a new column in the entity and recomputes all depend properties.\n     */\n    registerColumn(column: ColumnMetadata) {\n        if (this.ownColumns.indexOf(column) !== -1) return\n\n        this.ownColumns.push(column)\n        this.columns = this.embeddeds.reduce(\n            (columns, embedded) => columns.concat(embedded.columnsFromTree),\n            this.ownColumns,\n        )\n        this.primaryColumns = this.columns.filter((column) => column.isPrimary)\n        this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1\n        this.hasUUIDGeneratedColumns =\n            this.columns.filter(\n                (column) =>\n                    column.isGenerated || column.generationStrategy === \"uuid\",\n            ).length > 0\n        this.propertiesMap = this.createPropertiesMap()\n        if (this.childEntityMetadatas)\n            this.childEntityMetadatas.forEach((entityMetadata) =>\n                entityMetadata.registerColumn(column),\n            )\n    }\n\n    /**\n     * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\n     * in a special format - { propertyName: propertyName }.\n     *\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n     * This method will create following object:\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n     */\n    createPropertiesMap(): { [name: string]: string | any } {\n        const map: { [name: string]: string | any } = {}\n        this.columns.forEach((column) =>\n            OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)),\n        )\n        this.relations.forEach((relation) =>\n            OrmUtils.mergeDeep(\n                map,\n                relation.createValueMap(relation.propertyPath),\n            ),\n        )\n        return map\n    }\n\n    /**\n     * Checks if entity has any column which rely on returning data,\n     * e.g. columns with auto generated value, DEFAULT values considered as dependant of returning data.\n     * For example, if we need to have RETURNING after INSERT (or we need returned id for DBs not supporting RETURNING),\n     * it means we cannot execute bulk inserts in some cases.\n     */\n    getInsertionReturningColumns(): ColumnMetadata[] {\n        return this.columns.filter((column) => {\n            return (\n                column.default !== undefined ||\n                column.asExpression !== undefined ||\n                column.isGenerated ||\n                column.isCreateDate ||\n                column.isUpdateDate ||\n                column.isDeleteDate ||\n                column.isVersion\n            )\n        })\n    }\n}\n"],"names":[],"mappings":";;;AAGA,OAAO,EAAE,4BAA4B,EAAE,MAAM,uCAAuC,CAAA;AAIpF,OAAO,EAAE,QAAQ,EAAE,MAAM,kBAAkB,CAAA;AAe3C,OAAO,EAAE,2BAA2B,EAAE,MAAM,sCAAsC,CAAA;AAClF,OAAO,EAAE,WAAW,EAAE,MAAM,qBAAqB,CAAA;AACjD,OAAO,EAAE,OAAO,EAAE,MAAM,qBAAqB,CAAA;;;;;;AAKvC,MAAO,cAAc;IA8evB,wEAAwE;IACxE,cAAc;IACd,wEAAwE;IAExE,YAAY,OAOX,CAAA;QAxfQ,IAAA,CAAA,cAAa,GAAG,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAA;QA+BrD;;WAEG,CACH,IAAA,CAAA,oBAAoB,GAAqB,EAAE,CAAA;QAE3C;;;;WAIG,CACH,IAAA,CAAA,eAAe,GAAe,EAAE,CAAA;QAEhC;;WAEG,CACH,IAAA,CAAA,SAAS,GAAc,SAAS,CAAA;QAiChC;;WAEG,CACH,IAAA,CAAA,YAAY,GAAa,KAAK,CAAA;QA8B9B;;WAEG,CACH,IAAA,CAAA,WAAW,GAAY,IAAI,CAAA;QA4B3B;;WAEG,CACH,IAAA,CAAA,uBAAuB,GAAY,KAAK,CAAA;QAExC;;;;;WAKG,CACH,IAAA,CAAA,UAAU,GAAY,KAAK,CAAA;QAE3B;;;WAGG,CACH,IAAA,CAAA,wBAAwB,GAAY,IAAI,CAAA;QAYxC;;;WAGG,CACH,IAAA,CAAA,iBAAiB,GAAY,KAAK,CAAA;QAElC;;WAEG,CACH,IAAA,CAAA,sBAAsB,GAAY,KAAK,CAAA;QAEvC;;WAEG,CACH,IAAA,CAAA,uBAAuB,GAAY,KAAK,CAAA;QAQxC;;WAEG,CACH,IAAA,CAAA,UAAU,GAAqB,EAAE,CAAA;QAEjC;;WAEG,CACH,IAAA,CAAA,OAAO,GAAqB,EAAE,CAAA;QAE9B;;WAEG,CACH,IAAA,CAAA,eAAe,GAAqB,EAAE,CAAA;QAEtC;;WAEG,CACH,IAAA,CAAA,iBAAiB,GAAqB,EAAE,CAAA;QAExC;;WAEG,CACH,IAAA,CAAA,iBAAiB,GAAqB,EAAE,CAAA;QAExC;;;WAGG,CACH,IAAA,CAAA,YAAY,GAAqB,EAAE,CAAA;QAEnC;;;WAGG,CACH,IAAA,CAAA,cAAc,GAAqB,EAAE,CAAA;QAErC;;WAEG,CACH,IAAA,CAAA,gBAAgB,GAAqB,EAAE,CAAA;QAuDvC;;WAEG,CACH,IAAA,CAAA,cAAc,GAAqB,EAAE,CAAA;QAErC;;WAEG,CACH,IAAA,CAAA,YAAY,GAAuB,EAAE,CAAA;QAErC;;WAEG,CACH,IAAA,CAAA,SAAS,GAAuB,EAAE,CAAA;QAElC;;WAEG,CACH,IAAA,CAAA,cAAc,GAAuB,EAAE,CAAA;QAEvC;;WAEG,CACH,IAAA,CAAA,aAAa,GAAuB,EAAE,CAAA;QAEtC;;WAEG,CACH,IAAA,CAAA,iBAAiB,GAAuB,EAAE,CAAA;QAE1C;;WAEG,CACH,IAAA,CAAA,sBAAsB,GAAuB,EAAE,CAAA;QAE/C;;WAEG,CACH,IAAA,CAAA,kBAAkB,GAAuB,EAAE,CAAA;QAE3C;;WAEG,CACH,IAAA,CAAA,kBAAkB,GAAuB,EAAE,CAAA;QAE3C;;WAEG,CACH,IAAA,CAAA,mBAAmB,GAAuB,EAAE,CAAA;QAE5C;;WAEG,CACH,IAAA,CAAA,wBAAwB,GAAuB,EAAE,CAAA;QAEjD;;WAEG,CACH,IAAA,CAAA,wBAAwB,GAAuB,EAAE,CAAA;QAYjD;;WAEG,CACH,IAAA,CAAA,WAAW,GAAyB,EAAE,CAAA;QAEtC;;WAEG,CACH,IAAA,CAAA,cAAc,GAA4B,EAAE,CAAA;QAE5C;;WAEG,CACH,IAAA,CAAA,WAAW,GAAyB,EAAE,CAAA;QAEtC;;WAEG,CACH,IAAA,CAAA,SAAS,GAAuB,EAAE,CAAA;QAElC;;WAEG,CACH,IAAA,CAAA,YAAY,GAAuB,EAAE,CAAA;QAErC;;WAEG,CACH,IAAA,CAAA,UAAU,GAAoB,EAAE,CAAA;QAEhC;;WAEG,CACH,IAAA,CAAA,OAAO,GAAoB,EAAE,CAAA;QAE7B;;WAEG,CACH,IAAA,CAAA,OAAO,GAAqB,EAAE,CAAA;QAE9B;;WAEG,CACH,IAAA,CAAA,UAAU,GAAqB,EAAE,CAAA;QAEjC;;WAEG,CACH,IAAA,CAAA,MAAM,GAAoB,EAAE,CAAA;QAE5B;;WAEG,CACH,IAAA,CAAA,UAAU,GAAwB,EAAE,CAAA;QAEpC;;WAEG,CACH,IAAA,CAAA,YAAY,GAA6B,EAAE,CAAA;QAE3C;;WAEG,CACH,IAAA,CAAA,SAAS,GAA6B,EAAE,CAAA;QAExC;;WAEG,CACH,IAAA,CAAA,kBAAkB,GAA6B,EAAE,CAAA;QAEjD;;WAEG,CACH,IAAA,CAAA,qBAAqB,GAA6B,EAAE,CAAA;QAEpD;;WAEG,CACH,IAAA,CAAA,oBAAoB,GAA6B,EAAE,CAAA;QAEnD;;WAEG,CACH,IAAA,CAAA,qBAAqB,GAA6B,EAAE,CAAA;QAEpD;;WAEG,CACH,IAAA,CAAA,oBAAoB,GAA6B,EAAE,CAAA;QAEnD;;WAEG,CACH,IAAA,CAAA,qBAAqB,GAA6B,EAAE,CAAA;QAEpD;;WAEG,CACH,IAAA,CAAA,yBAAyB,GAA6B,EAAE,CAAA;QAExD;;WAEG,CACH,IAAA,CAAA,sBAAsB,GAA6B,EAAE,CAAA;QAErD;;WAEG,CACH,IAAA,CAAA,oBAAoB,GAA6B,EAAE,CAAA;QAEnD;;WAEG,CACH,IAAA,CAAA,wBAAwB,GAA6B,EAAE,CAAA;QAEvD;;WAEG,CACH,IAAA,CAAA,qBAAqB,GAA6B,EAAE,CAAA;QA4BhD,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAA;QACpC,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,IAAI,EAAE,CAAA;QACpD,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAA;QACpD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAA;QACtE,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,SAAS,GAC9B,OAAO,CAAC,SAAS,CAAC,OAAO,GACzB,SAAS,CAAA;QACf,IAAI,CAAC,2BAA2B,GAAG,OAAO,CAAC,2BAA4B,CAAA;QACvE,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,IAAI,CAAA;QACrC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAA;QAC3C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAA;QAC5C,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAA;QACnD,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAA;QACvD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAA;IACrD,CAAC;IAED,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E;;OAEG,CACH,MAAM,CACF,WAAyB,EACzB,OAAwD,EAAA;QAExD,MAAM,IAAI,GAAG,OAAO,IAAI,OAAO,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAA;QAC5D,iFAAiF;QACjF,IAAI,GAAQ,CAAA;QACZ,IAAI,OAAO,IAAI,CAAC,MAAM,KAAK,UAAU,IAAI,CAAC,IAAI,EAAE,CAAC;YAC7C,IAAI,CAAC,OAAO,EAAE,gBAAgB,IAAI,IAAI,CAAC,wBAAwB,EAAE,CAAC;gBAC9D,GAAG,GAAG,IAAU,IAAI,CAAC,MAAO,EAAE,CAAA;YAClC,CAAC,MAAM,CAAC;gBACJ,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;YAC9C,CAAC;QACL,CAAC,MAAM,CAAC;YACJ,6CAA6C;YAC7C,GAAG,GAAG,CAAA,CAAE,CAAA;QACZ,CAAC;QAED,0BAA0B;QAC1B,IAAI,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;YACnC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,UAAU,CAAA;QAC3D,CAAC;QAED,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,CAClC,CADoC,GAChC,CAAC,UAAU,CAAC,cAAc,CAAC,cAAc,CACzC,QAAQ,EACR,GAAG,EACH,WAAW,CACd,CACJ,CAAA;QACD,OAAO,GAAG,CAAA;IACd,CAAC;IAED;;OAEG,CACH,KAAK,CAAC,MAAqB,EAAA;QACvB,IAAI,CAAC,MAAM,EAAE,OAAO,KAAK,CAAA;QAEzB,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,aAAa,EAAE,EAAE;YAC/C,MAAM,KAAK,GAAG,aAAa,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA;YAClD,OAAO,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,EAAE,CAAA;QAChE,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;;OAGG,CACH,iBAAiB,CAAC,MAAqB,EAAA;QACnC,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,aAAa,EAAE,EAAE;YAC/C,MAAM,KAAK,GAAG,aAAa,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA;YAClD,OAAO,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,CAAA;QAChD,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;;;;OAKG,CACH,iBAAiB,CAAC,EAAO,EAAA;QACrB,sKAAI,cAAW,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,OAAO,EAAE,CAAA;QAEvC,IAAI,IAAI,CAAC,sBAAsB,EAC3B,MAAM,wLAAI,+BAA4B,CAAC,IAAI,EAAE,EAAE,CAAC,CAAA;QAEpD,OAAO,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,EAAE,CAAC,CAAA;IACpD,CAAC;IAED;;;;;OAKG,CACH,cAAc,CACV,MAAiC,EAAA;QAEjC,IAAI,CAAC,MAAM,EAAE,OAAO,SAAS,CAAA;QAE7B,OAAO,cAAc,CAAC,WAAW,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc,EAAE;YAC3D,SAAS,EAAE,IAAI;SAClB,CAAC,CAAA;IACN,CAAC;IAED;;;;;OAKG,CACH,mBAAmB,CACf,MAAiC,EAAA;QAEjC,IAAI,CAAC,MAAM,EAAE,OAAO,MAAM,CAAA;QAE1B,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA;QACzC,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC9B,OAAO,KAAK,CAAA;QAChB,CAAC,MAAM,IAAI,KAAK,EAAE,CAAC;YACf,OAAO,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,CAAA,CAAC,0CAA0C;QAClG,CAAC;QAED,OAAO,KAAK,CAAA;IAChB,CAAC;IAED;;;OAGG,CACH,eAAe,CACX,WAA0B,EAC1B,YAA2B,EAAA;QAE3B,MAAM,gBAAgB,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QACzD,IAAI,CAAC,gBAAgB,EAAE,OAAO,KAAK,CAAA;QAEnC,MAAM,iBAAiB,GAAG,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,CAAA;QAC3D,IAAI,CAAC,iBAAiB,EAAE,OAAO,KAAK,CAAA;QAEpC,sKAAO,WAAQ,CAAC,UAAU,CAAC,gBAAgB,EAAE,iBAAiB,CAAC,CAAA;IACnE,CAAC;IAED;;OAEG,CACH,0BAA0B,CACtB,YAAoB,EAAA;QAEpB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CACpB,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,YAAY,KAAK,YAAY,CACnD,CAAA;IACL,CAAC;IAED;;OAEG,CACH,0BAA0B,CACtB,YAAoB,EAAA;QAEpB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CACpB,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,YAAY,KAAK,YAAY,CACnD,CAAA;IACL,CAAC;IAED;;OAEG,CACH,yBAAyB,CAAC,YAAoB,EAAA;QAC1C,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAC/B,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,YAAY,KAAK,YAAY,CACnD,CAAA;QACD,OAAO,SAAS,IAAI,IAAI,CAAC,2BAA2B,CAAC,YAAY,CAAC,CAAA;IACtE,CAAC;IAED;;OAEG,CACH,0BAA0B,CACtB,YAAoB,EAAA;QAEpB,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAC5B,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,YAAY,KAAK,YAAY,CACnD,CAAA;QACD,IAAI,MAAM,EAAE,OAAO,MAAM,CAAA;QAEzB,yGAAyG;QACzG,2FAA2F;QAC3F,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAChC,CAAC,QAAQ,EAAE,CAAG,CAAD,OAAS,CAAC,YAAY,KAAK,YAAY,CACvD,CAAA;QACD,IAAI,QAAQ,IAAI,QAAQ,CAAC,WAAW,CAAC,MAAM,KAAK,CAAC,EAC7C,OAAO,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAA;QAElC,OAAO,SAAS,CAAA;IACpB,CAAC;IAED;;;OAGG,CACH,gCAAgC,CAC5B,YAAoB,EAAA;QAEpB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CACpB,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,YAAY,KAAK,YAAY,CACnD,CAAA;IACL,CAAC;IAED;;;OAGG,CACH,2BAA2B,CAAC,YAAoB,EAAA;QAC5C,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAC5B,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,YAAY,KAAK,YAAY,CACnD,CAAA;QACD,IAAI,MAAM,EAAE,OAAO;YAAC,MAAM;SAAC,CAAA;QAE3B,yGAAyG;QACzG,2FAA2F;QAC3F,MAAM,QAAQ,GAAG,IAAI,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;QAChE,IAAI,QAAQ,IAAI,QAAQ,CAAC,WAAW,EAAE,OAAO,QAAQ,CAAC,WAAW,CAAA;QAEjE,OAAO,EAAE,CAAA;IACb,CAAC;IAED;;OAEG,CACH,2BAA2B,CAAC,YAAoB,EAAA;QAC5C,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CACtB,CAAC,QAAQ,EAAE,CAAG,CAAD,OAAS,CAAC,YAAY,KAAK,YAAY,CACvD,CAAA;IACL,CAAC;IAED;;OAEG,CACH,4BAA4B,CACxB,YAAoB,EAAA;QAEpB,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CACtB,CAAC,QAAQ,EAAE,CAAG,CAAD,OAAS,CAAC,YAAY,KAAK,YAAY,CACvD,CAAA;IACL,CAAC;IAED;;OAEG,CACH,2BAA2B,CAAC,YAAoB,EAAA;QAC5C,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CACzB,CAAC,QAAQ,EAAE,CAAG,CAAD,OAAS,CAAC,YAAY,KAAK,YAAY,CACvD,CAAA;IACL,CAAC;IAED;;OAEG,CACH,4BAA4B,CACxB,YAAoB,EAAA;QAEpB,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CACzB,CAAC,QAAQ,EAAE,CAAG,CAAD,OAAS,CAAC,YAAY,KAAK,YAAY,CACvD,CAAA;IACL,CAAC;IAED;;OAEG,CACH,yBAAyB,CAAC,aAAuB,EAAA;QAC7C,OAAO,aAAa,CAAC,GAAG,CAAC,CAAC,YAAY,EAAE,EAAE;YACtC,MAAM,MAAM,GAAG,IAAI,CAAC,0BAA0B,CAAC,YAAY,CAAC,CAAA;YAC5D,IAAI,MAAM,IAAI,IAAI,EAAE,CAAC;gBACjB,MAAM,uLAAI,8BAA2B,CAAC,YAAY,EAAE,IAAI,CAAC,CAAA;YAC7D,CAAC;YACD,OAAO,MAAM,CAAA;QACjB,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;;OAGG,CACH,+BAA+B,CAC3B,MAAqB,EACrB,SAA6B,EAAA;QAE7B,MAAM,kBAAkB,GAA8C,EAAE,CAAA;QACxE,SAAS,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;YAC3B,MAAM,KAAK,GAAG,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA;YAC7C,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;gBACvB,KAAK,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,CACrB,CADuB,iBACL,CAAC,IAAI,CAAC;wBACpB,QAAQ;wBACR,QAAQ;wBACR,cAAc,CAAC,wBAAwB,CACnC,QAAQ,EACR,QAAQ,CACX;qBACJ,CAAC,CACL,CAAA;YACL,CAAC,MAAM,IAAI,KAAK,EAAE,CAAC;gBACf,kBAAkB,CAAC,IAAI,CAAC;oBACpB,QAAQ;oBACR,KAAK;oBACL,cAAc,CAAC,wBAAwB,CAAC,KAAK,EAAE,QAAQ,CAAC;iBAC3D,CAAC,CAAA;YACN,CAAC;QACL,CAAC,CAAC,CAAA;QACF,OAAO,kBAAkB,CAAA;IAC7B,CAAC;IAED;;;;;;;OAOG,CACH,uBAAuB,CAAC,KAAU,EAAA;QAC9B,iFAAiF;QACjF,yEAAyE;QACzE,oEAAoE;QAEpE,IACI,IAAI,CAAC,kBAAkB,KAAK,KAAK,IACjC,IAAI,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,EACtC,CAAC;YACC,2FAA2F;YAC3F,IAAI,6BAAsC,CAAA;YAC1C,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;gBAC3B,6BAA6B,GACzB,KAAK,CAAC,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,CAAA;YACpD,CAAC;YACD,OAAO,AACH,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAC1B,CAAC,IAAI,EAAE,CACH,CADK,4BACwB,KACzB,IAAI,CAAC,kBAAkB,IAC3B,KAAK,CAAC,WAAW,KAAK,IAAI,CAAC,MAAM,CACxC,IAAI,IAAI,CACZ,CAAA;QACL,CAAC;QACD,OAAO,IAAI,CAAA;IACf,CAAC;IAED,4EAA4E;IAC5E,yBAAyB;IACzB,4EAA4E;IAEpE,MAAM,CAAC,wBAAwB,CACnC,KAAU,EACV,QAA0B,EAAA;QAE1B,OAAO,QAAQ,CAAC,qBAAqB,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAA;IACxE,CAAC;IAED,4EAA4E;IAC5E,wBAAwB;IACxB,4EAA4E;IAE5E;;;;OAIG,CACH,MAAM,CAAC,kBAAkB,CACrB,QAAwB,EACxB,MAAqB,EACrB,SAAiB,EAAE,EAAA;QAEnB,MAAM,KAAK,GAAa,EAAE,CAAA;QAC1B,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;YAChC,iHAAiH;YACjH,6DAA6D;YAC7D,MAAM,UAAU,GAAG,MAAM,CAAC,CAAC,CAAC,MAAM,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAA;YACpD,IAAI,QAAQ,CAAC,2BAA2B,CAAC,UAAU,CAAC,EAAE,CAAC;gBACnD,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CACpC,QAAQ,EACR,MAAM,CAAC,GAAG,CAAC,EACX,UAAU,CACb,CAAA;gBACD,KAAK,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,CAAA;YAC3B,CAAC,MAAM,CAAC;gBACJ,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,MAAM,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAA;gBAC9C,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;YACpB,CAAC;QACL,CAAC,CAAC,CAAA;QACF,OAAO,KAAK,CAAA;IAChB,CAAC;IAED;;;OAGG,CACH,MAAM,CAAC,UAAU,CACb,WAA4B,EAC5B,YAA6B,EAAA;QAE7B,OAAO,WAAW,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,EAAE;YACrC,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,WAAW,EAAE,EAAE,8JACtC,WAAQ,CAAC,UAAU,CAAC,UAAU,EAAE,WAAW,CAAC,CAC/C,CAAA;QACL,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;;OAGG,CACH,MAAM,CAAC,WAAW,CACd,MAAqB,EACrB,OAAyB,EACzB,OAAiC,EAAA;QAEjC,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,MAAM,EAAE,EAAE;YAClC,MAAM,KAAK,GAAG,MAAM,CAAC,iBAAiB,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA;YAEvD,mEAAmE;YACnE,IAAI,GAAG,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,EAC1D,OAAO,SAAS,CAAA;YAEpB,sKAAO,WAAQ,CAAC,SAAS,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;QACzC,CAAC,EAAE,CAAA,CAA+B,CAAC,CAAA;IACvC,CAAC;IAED,wEAAwE;IACxE,yBAAyB;IACzB,wEAAwE;IAExE,KAAK,GAAA;QACD,MAAM,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAA;QACrD,MAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,YAAY,CAAA;QACzD,MAAM,qBAAqB,GACvB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,qBAAqB,CAAA;QAEjD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAA;QAC3C,IAAI,CAAC,QAAQ,GACT,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,cAAc,IAC9C,IAAI,CAAC,oBAAoB,GACnB,IAAI,CAAC,oBAAoB,CAAC,QAAQ,GAClC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAA;QACzC,IAAI,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE,CAAC;YAChC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAA;QAC/C,CAAC,MAAM,IACH,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,cAAc,IAC9C,IAAI,CAAC,oBAAoB,EAC3B,CAAC;YACC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAA;QAClD,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,cAAc,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC3D,IAAI,CAAC,MAAM,GAAI,IAAI,CAAC,UAAU,CAAC,OAAe,CAAC,MAAM,CAAA;QACzD,CAAC;QACD,IAAI,CAAC,cAAc,GACf,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,cAAc,IAC9C,IAAI,CAAC,oBAAoB,GACnB,IAAI,CAAC,oBAAoB,CAAC,cAAc,GACxC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAA;QACrC,IAAI,CAAC,WAAW,GACZ,IAAI,CAAC,iBAAiB,CAAC,WAAW,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAA;QAC/D,IAAI,CAAC,UAAU,GACX,OAAO,IAAI,CAAC,iBAAiB,CAAC,MAAM,KAAK,UAAU,GAC5C,IAAI,CAAC,iBAAiB,CAAC,MAAc,CAAC,IAAI,GAC3C,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAA;QACvC,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,kBAAkB,EAAE,CAAC;YACrD,IAAI,CAAC,sBAAsB,GACvB,cAAc,CAAC,wBAAwB,CAAC,IAAI,CAAC,cAAe,CAAC,CAAA;QACrE,CAAC,MAAM,IACH,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,cAAc,IAC9C,IAAI,CAAC,oBAAoB,EAC3B,CAAC;YACC,IAAI,CAAC,sBAAsB,GAAG,cAAc,CAAC,SAAS,CAClD,IAAI,CAAC,oBAAoB,CAAC,UAAU,EACpC,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAC3C,CAAA;QACL,CAAC,MAAM,CAAC;YACJ,IAAI,CAAC,sBAAsB,GAAG,cAAc,CAAC,SAAS,CAClD,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,cAAc,CACtB,CAAA;YAED,IACI,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,UAAU,IAC1C,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,cAAc,IACrC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,cAAc,GAAG,CAAC,IACzC,IAAI,CAAC,sBAAsB,CAAC,MAAM,GAC9B,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,cAAc,EAC3C,CAAC;gBACC,oFAAoF;gBACpF,mFAAmF;gBACnF,gEAAgE;gBAChE,IAAI,CAAC,sBAAsB,yKAAG,UAAA,AAAO,EACjC,IAAI,CAAC,sBAAsB,EAC3B;oBAAE,SAAS,EAAE,GAAG;oBAAE,aAAa,EAAE,CAAC;gBAAA,CAAE,CACvC,CAAA;YACL,CAAC;QACL,CAAC;QACD,IAAI,CAAC,SAAS,GAAG,YAAY,GACvB,cAAc,CAAC,eAAe,CAC1B,YAAY,EACZ,IAAI,CAAC,sBAAsB,CAC9B,GACD,IAAI,CAAC,sBAAsB,CAAA;QACjC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAA;QACxD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAA;QAC9D,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAA;QACnD,IAAI,CAAC,YAAY,GACb,IAAI,CAAC,iBAAiB,CAAC,YAAY,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAA;QAC/D,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,cAAc,CAClD,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,MAAM,EACX,IAAI,CAAC,QAAQ,CAChB,CAAA;QACD,IAAI,CAAC,OAAO,GACR,OAAO,IAAI,CAAC,iBAAiB,CAAC,OAAO,KAAK,UAAU,GAC9C,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,GAClD,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAA,CAAC,4DAA4D;QAErG,IAAI,qBAAqB,KAAK,SAAS,EAAE,CAAC;YACtC,IAAI,CAAC,wBAAwB,GAAG,CAAC,qBAAqB,CAAA;QAC1D,CAAC;QAED,IAAI,CAAC,UAAU,GACX,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,kBAAkB,IAClD,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,UAAU,CAAA;QAC9C,IAAI,CAAC,iBAAiB,GAClB,IAAI,CAAC,iBAAiB,CAAC,IAAI,KAAK,kBAAkB,CAAA;QAEtD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAA;IACjD,CAAC;IAED;;OAEG,CACH,cAAc,CAAC,MAAsB,EAAA;QACjC,IAAI,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,OAAM;QAElD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QAC5B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAChC,CAAC,OAAO,EAAE,QAAQ,EAAE,CAAG,CAAD,MAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,eAAe,CAAC,EAC/D,IAAI,CAAC,UAAU,CAClB,CAAA;QACD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,SAAS,CAAC,CAAA;QACvE,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAA;QAC5D,IAAI,CAAC,uBAAuB,GACxB,IAAI,CAAC,OAAO,CAAC,MAAM,CACf,CAAC,MAAM,EAAE,CACL,CADO,KACD,CAAC,WAAW,IAAI,MAAM,CAAC,kBAAkB,KAAK,MAAM,CACjE,CAAC,MAAM,GAAG,CAAC,CAAA;QAChB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAA;QAC/C,IAAI,IAAI,CAAC,oBAAoB,EACzB,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,cAAc,EAAE,CAC/C,CADiD,aACnC,CAAC,cAAc,CAAC,MAAM,CAAC,CACxC,CAAA;IACT,CAAC;IAED;;;;;;;OAOG,CACH,mBAAmB,GAAA;QACf,MAAM,GAAG,GAAqC,CAAA,CAAE,CAAA;QAChD,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE,8JAC5B,WAAQ,CAAC,SAAS,CAAC,GAAG,EAAE,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CACtE,CAAA;QACD,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE,8JAChC,WAAQ,CAAC,SAAS,CACd,GAAG,EACH,QAAQ,CAAC,cAAc,CAAC,QAAQ,CAAC,YAAY,CAAC,CACjD,CACJ,CAAA;QACD,OAAO,GAAG,CAAA;IACd,CAAC;IAED;;;;;OAKG,CACH,4BAA4B,GAAA;QACxB,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE;YAClC,OAAO,AACH,MAAM,CAAC,OAAO,KAAK,SAAS,IAC5B,MAAM,CAAC,YAAY,KAAK,SAAS,IACjC,MAAM,CAAC,WAAW,IAClB,MAAM,CAAC,YAAY,IACnB,MAAM,CAAC,YAAY,IACnB,MAAM,CAAC,YAAY,IACnB,MAAM,CAAC,SAAS,CACnB,CAAA;QACL,CAAC,CAAC,CAAA;IACN,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 564, "column": 0}, "map": {"version":3,"file":"ColumnMetadata.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/metadata/ColumnMetadata.ts"],"sourceRoot":"..","sourcesContent":["import { ColumnType } from \"../driver/types/ColumnTypes\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\nimport { RelationMetadata } from \"./RelationMetadata\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { ColumnMetadataArgs } from \"../metadata-args/ColumnMetadataArgs\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { ValueTransformer } from \"../decorator/options/ValueTransformer\"\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\nimport { VirtualColumnOptions } from \"../decorator/options/VirtualColumnOptions\"\n\n/**\n * This metadata contains all information about entity's column.\n */\nexport class ColumnMetadata {\n    readonly \"@instanceof\" = Symbol.for(\"ColumnMetadata\")\n\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Target class where column decorator is used.\n     * This may not be always equal to entity metadata (for example embeds or inheritance cases).\n     */\n    target: Function | string\n\n    /**\n     * Entity metadata where this column metadata is.\n     *\n     * For example for @Column() name: string in Post, entityMetadata will be metadata of Post entity.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Embedded metadata where this column metadata is.\n     * If this column is not in embed then this property value is undefined.\n     */\n    embeddedMetadata?: EmbeddedMetadata\n\n    /**\n     * If column is a foreign key of some relation then this relation's metadata will be there.\n     * If this column does not have a foreign key then this property value is undefined.\n     */\n    relationMetadata?: RelationMetadata\n\n    /**\n     * Class's property name on which this column is applied.\n     */\n    propertyName: string\n\n    /**\n     * The database type of the column.\n     */\n    type: ColumnType\n\n    /**\n     * Type's length in the database.\n     */\n    length: string = \"\"\n\n    /**\n     * Type's display width in the database.\n     */\n    width?: number\n\n    /**\n     * Defines column character set.\n     */\n    charset?: string\n\n    /**\n     * Defines column collation.\n     */\n    collation?: string\n\n    /**\n     * Indicates if this column is a primary key.\n     */\n    isPrimary: boolean = false\n\n    /**\n     * Indicates if this column is generated (auto increment or generated other way).\n     */\n    isGenerated: boolean = false\n\n    /**\n     * Indicates if column can contain nulls or not.\n     */\n    isNullable: boolean = false\n\n    /**\n     * Indicates if column is selected by query builder or not.\n     */\n    isSelect: boolean = true\n\n    /**\n     * Indicates if column is inserted by default or not.\n     */\n    isInsert: boolean = true\n\n    /**\n     * Indicates if column allows updates or not.\n     */\n    isUpdate: boolean = true\n\n    /**\n     * Specifies generation strategy if this column will use auto increment.\n     */\n    generationStrategy?: \"uuid\" | \"increment\" | \"rowid\"\n\n    /**\n     * Identity column type. Supports only in Postgres 10+.\n     */\n    generatedIdentity?: \"ALWAYS\" | \"BY DEFAULT\"\n\n    /**\n     * Column comment.\n     * This feature is not supported by all databases.\n     */\n    comment?: string\n\n    /**\n     * Default database value.\n     */\n    default?:\n        | number\n        | boolean\n        | string\n        | null\n        | (number | boolean | string)[]\n        | Record<string, object>\n        | (() => string)\n\n    /**\n     * ON UPDATE trigger. Works only for MySQL.\n     */\n    onUpdate?: string\n\n    /**\n     * The precision for a decimal (exact numeric) column (applies only for decimal column),\n     * which is the maximum number of digits that are stored for the values.\n     */\n    precision?: number | null\n\n    /**\n     * The scale for a decimal (exact numeric) column (applies only for decimal column),\n     * which represents the number of digits to the right of the decimal point and must not be greater than precision.\n     */\n    scale?: number\n\n    /**\n     * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\n     * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n     */\n    zerofill: boolean = false\n\n    /**\n     * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.\n     */\n    unsigned: boolean = false\n\n    /**\n     * Array of possible enumerated values.\n     *\n     * `postgres` and `mysql` store enum values as strings but we want to keep support\n     * for numeric and heterogeneous based typescript enums, so we need (string|number)[]\n     */\n    enum?: (string | number)[]\n\n    /**\n     * Exact name of enum\n     */\n    enumName?: string\n\n    /**\n     * Generated column expression.\n     */\n    asExpression?: string\n\n    /**\n     * Generated column type.\n     */\n    generatedType?: \"VIRTUAL\" | \"STORED\"\n\n    /**\n     * Return type of HSTORE column.\n     * Returns value as string or as object.\n     */\n    hstoreType?: \"object\" | \"string\"\n\n    /**\n     * Indicates if this column is an array.\n     */\n    isArray: boolean = false\n\n    /**\n     * Gets full path to this column property (including column property name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just property name of the column.\n     */\n    propertyPath: string\n\n    /**\n     * Same as property path, but dots are replaced with '_'.\n     * Used in query builder statements.\n     */\n    propertyAliasName: string\n\n    /**\n     * Gets full path to this column database name (including column database name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just database name of the column.\n     */\n    databasePath: string\n\n    /**\n     * Complete column name in the database including its embedded prefixes.\n     */\n    databaseName: string\n\n    /**\n     * Database name in the database without embedded prefixes applied.\n     */\n    databaseNameWithoutPrefixes: string\n\n    /**\n     * Database name set by entity metadata builder, not yet passed naming strategy process and without embedded prefixes.\n     */\n    givenDatabaseName?: string\n\n    /**\n     * Indicates if column is virtual. Virtual columns are not mapped to the entity.\n     */\n    isVirtual: boolean = false\n\n    /**\n     * Indicates if column is a virtual property. Virtual properties are not mapped to the entity.\n     * This property is used in tandem the virtual column decorator.\n     * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.\n     */\n    isVirtualProperty: boolean = false\n\n    /**\n     * Query to be used to populate the column data. This query is used when generating the relational db script.\n     * The query function is called with the current entities alias either defined by the Entity Decorator or automatically\n     * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.\n     */\n    query?: (alias: string) => string\n\n    /**\n     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.\n     */\n    isDiscriminator: boolean = false\n\n    /**\n     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.\n     */\n    isTreeLevel: boolean = false\n\n    /**\n     * Indicates if this column contains an entity creation date.\n     */\n    isCreateDate: boolean = false\n\n    /**\n     * Indicates if this column contains an entity update date.\n     */\n    isUpdateDate: boolean = false\n\n    /**\n     * Indicates if this column contains an entity delete date.\n     */\n    isDeleteDate: boolean = false\n\n    /**\n     * Indicates if this column contains an entity version.\n     */\n    isVersion: boolean = false\n\n    /**\n     * Indicates if this column contains an object id.\n     */\n    isObjectId: boolean = false\n\n    /**\n     * If this column is foreign key then it references some other column,\n     * and this property will contain reference to this column.\n     */\n    referencedColumn: ColumnMetadata | undefined\n\n    /**\n     * If this column is primary key then this specifies the name for it.\n     */\n    primaryKeyConstraintName?: string\n\n    /**\n     * If this column is foreign key then this specifies the name for it.\n     */\n    foreignKeyConstraintName?: string\n\n    /**\n     * Specifies a value transformer that is to be used to (un)marshal\n     * this column when reading or writing to the database.\n     */\n    transformer?: ValueTransformer | ValueTransformer[]\n\n    /**\n     * Column type in the case if this column is in the closure table.\n     * Column can be ancestor or descendant in the closure tables.\n     */\n    closureType?: \"ancestor\" | \"descendant\"\n\n    /**\n     * Indicates if this column is nested set's left column.\n     * Used only in tree entities with nested-set type.\n     */\n    isNestedSetLeft: boolean = false\n\n    /**\n     * Indicates if this column is nested set's right column.\n     * Used only in tree entities with nested-set type.\n     */\n    isNestedSetRight: boolean = false\n\n    /**\n     * Indicates if this column is materialized path's path column.\n     * Used only in tree entities with materialized path type.\n     */\n    isMaterializedPath: boolean = false\n\n    /**\n     * Spatial Feature Type (Geometry, Point, Polygon, etc.)\n     */\n    spatialFeatureType?: string\n\n    /**\n     * SRID (Spatial Reference ID (EPSG code))\n     */\n    srid?: number\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        connection: DataSource\n        entityMetadata: EntityMetadata\n        embeddedMetadata?: EmbeddedMetadata\n        referencedColumn?: ColumnMetadata\n        args: ColumnMetadataArgs\n        closureType?: \"ancestor\" | \"descendant\"\n        nestedSetLeft?: boolean\n        nestedSetRight?: boolean\n        materializedPath?: boolean\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.embeddedMetadata = options.embeddedMetadata!\n        this.referencedColumn = options.referencedColumn\n        if (options.args.target) this.target = options.args.target\n        if (options.args.propertyName)\n            this.propertyName = options.args.propertyName\n        if (options.args.options.name)\n            this.givenDatabaseName = options.args.options.name\n        if (options.args.options.type) this.type = options.args.options.type\n        if (options.args.options.length)\n            this.length = options.args.options.length\n                ? options.args.options.length.toString()\n                : \"\"\n        if (options.args.options.width) this.width = options.args.options.width\n        if (options.args.options.charset)\n            this.charset = options.args.options.charset\n        if (options.args.options.collation)\n            this.collation = options.args.options.collation\n        if (options.args.options.primary)\n            this.isPrimary = options.args.options.primary\n        if (options.args.options.default === null)\n            // to make sure default: null is the same as nullable: true\n            this.isNullable = true\n        if (options.args.options.nullable !== undefined)\n            this.isNullable = options.args.options.nullable\n        if (options.args.options.select !== undefined)\n            this.isSelect = options.args.options.select\n        if (options.args.options.insert !== undefined)\n            this.isInsert = options.args.options.insert\n        if (options.args.options.update !== undefined)\n            this.isUpdate = options.args.options.update\n        if (options.args.options.readonly !== undefined)\n            this.isUpdate = !options.args.options.readonly\n        if (options.args.options.comment)\n            this.comment = options.args.options.comment\n        if (options.args.options.default !== undefined)\n            this.default = options.args.options.default\n        if (options.args.options.onUpdate)\n            this.onUpdate = options.args.options.onUpdate\n        if (options.args.options.generatedIdentity)\n            this.generatedIdentity = options.args.options.generatedIdentity\n        if (\n            options.args.options.scale !== null &&\n            options.args.options.scale !== undefined\n        )\n            this.scale = options.args.options.scale\n        if (options.args.options.zerofill) {\n            this.zerofill = options.args.options.zerofill\n            this.unsigned = true // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n        }\n        if (options.args.options.unsigned)\n            this.unsigned = options.args.options.unsigned\n        if (options.args.options.precision !== null)\n            this.precision = options.args.options.precision\n        if (options.args.options.enum) {\n            if (\n                ObjectUtils.isObject(options.args.options.enum) &&\n                !Array.isArray(options.args.options.enum)\n            ) {\n                this.enum = Object.keys(options.args.options.enum)\n                    // remove numeric keys - typescript numeric enum types generate them\n                    // From the documentation: “declaration merging” means that the compiler merges two separate declarations\n                    // declared with the same name into a single definition. This concept is often used to merge enum with namespace\n                    // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages\n                    // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise\n                    // generated SQL statements contains string representation of that function which leads into syntax error\n                    // at database side.\n                    .filter(\n                        (key) =>\n                            isNaN(+key) &&\n                            typeof (options.args.options.enum as ObjectLiteral)[\n                                key\n                            ] !== \"function\",\n                    )\n                    .map(\n                        (key) =>\n                            (options.args.options.enum as ObjectLiteral)[key],\n                    )\n            } else {\n                this.enum = options.args.options.enum\n            }\n        }\n        if (options.args.options.enumName) {\n            this.enumName = options.args.options.enumName\n        }\n        if (options.args.options.primaryKeyConstraintName) {\n            this.primaryKeyConstraintName =\n                options.args.options.primaryKeyConstraintName\n        }\n        if (options.args.options.foreignKeyConstraintName) {\n            this.foreignKeyConstraintName =\n                options.args.options.foreignKeyConstraintName\n        }\n        if (options.args.options.asExpression) {\n            this.asExpression = options.args.options.asExpression\n            this.generatedType = options.args.options.generatedType\n                ? options.args.options.generatedType\n                : \"VIRTUAL\"\n        }\n        if (options.args.options.hstoreType)\n            this.hstoreType = options.args.options.hstoreType\n        if (options.args.options.array)\n            this.isArray = options.args.options.array\n        if (options.args.mode) {\n            this.isVirtualProperty = options.args.mode === \"virtual-property\"\n            this.isVirtual = options.args.mode === \"virtual\"\n            this.isTreeLevel = options.args.mode === \"treeLevel\"\n            this.isCreateDate = options.args.mode === \"createDate\"\n            this.isUpdateDate = options.args.mode === \"updateDate\"\n            this.isDeleteDate = options.args.mode === \"deleteDate\"\n            this.isVersion = options.args.mode === \"version\"\n            this.isObjectId = options.args.mode === \"objectId\"\n        }\n        if (this.isVirtualProperty) {\n            this.isInsert = false\n            this.isUpdate = false\n        }\n        if (options.args.options.transformer)\n            this.transformer = options.args.options.transformer\n        if (options.args.options.spatialFeatureType)\n            this.spatialFeatureType = options.args.options.spatialFeatureType\n        if (options.args.options.srid !== undefined)\n            this.srid = options.args.options.srid\n        if ((options.args.options as VirtualColumnOptions).query)\n            this.query = (options.args.options as VirtualColumnOptions).query\n        if (this.isTreeLevel)\n            this.type = options.connection.driver.mappedDataTypes.treeLevel\n        if (this.isCreateDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.createDate\n            if (!this.default)\n                this.default = () =>\n                    options.connection.driver.mappedDataTypes.createDateDefault\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (\n                this.precision === undefined &&\n                options.args.options.precision === undefined &&\n                options.connection.driver.mappedDataTypes.createDatePrecision\n            )\n                this.precision =\n                    options.connection.driver.mappedDataTypes.createDatePrecision\n        }\n        if (this.isUpdateDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.updateDate\n            if (!this.default)\n                this.default = () =>\n                    options.connection.driver.mappedDataTypes.updateDateDefault\n            if (!this.onUpdate)\n                this.onUpdate =\n                    options.connection.driver.mappedDataTypes.updateDateDefault\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (\n                this.precision === undefined &&\n                options.args.options.precision === undefined &&\n                options.connection.driver.mappedDataTypes.updateDatePrecision\n            )\n                this.precision =\n                    options.connection.driver.mappedDataTypes.updateDatePrecision\n        }\n        if (this.isDeleteDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.deleteDate\n            if (!this.isNullable)\n                this.isNullable =\n                    options.connection.driver.mappedDataTypes.deleteDateNullable\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (\n                this.precision === undefined &&\n                options.args.options.precision === undefined &&\n                options.connection.driver.mappedDataTypes.deleteDatePrecision\n            )\n                this.precision =\n                    options.connection.driver.mappedDataTypes.deleteDatePrecision\n        }\n        if (this.isVersion)\n            this.type = options.connection.driver.mappedDataTypes.version\n        if (options.closureType) this.closureType = options.closureType\n        if (options.nestedSetLeft) this.isNestedSetLeft = options.nestedSetLeft\n        if (options.nestedSetRight)\n            this.isNestedSetRight = options.nestedSetRight\n        if (options.materializedPath)\n            this.isMaterializedPath = options.materializedPath\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Creates entity id map from the given entity ids array.\n     */\n    createValueMap(value: any, useDatabaseName = false) {\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                map: ObjectLiteral,\n            ): any => {\n                const propertyName = propertyNames.shift()\n                if (propertyName) {\n                    map[propertyName] = {}\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName])\n                    return map\n                }\n\n                // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n                if (\n                    (this.generationStrategy === \"increment\" ||\n                        this.generationStrategy === \"rowid\") &&\n                    this.type === \"bigint\" &&\n                    value !== null\n                )\n                    value = String(value)\n\n                map[useDatabaseName ? this.databaseName : this.propertyName] =\n                    value\n                return map\n            }\n            return extractEmbeddedColumnValue(propertyNames, {})\n        } else {\n            // no embeds - no problems. Simply return column property name and its value of the entity\n\n            // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n            if (\n                (this.generationStrategy === \"increment\" ||\n                    this.generationStrategy === \"rowid\") &&\n                this.type === \"bigint\" &&\n                value !== null\n            )\n                value = String(value)\n\n            return {\n                [useDatabaseName ? this.databaseName : this.propertyName]:\n                    value,\n            }\n        }\n    }\n\n    /**\n     * Extracts column value and returns its column name with this value in a literal object.\n     * If column is in embedded (or recursive embedded) it returns complex literal object.\n     *\n     * Examples what this method can return depend if this column is in embeds.\n     * { id: 1 } or { title: \"hello\" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }\n     */\n    getEntityValueMap(\n        entity: ObjectLiteral,\n        options?: { skipNulls?: boolean },\n    ): ObjectLiteral | undefined {\n        const returnNulls = false // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.\n\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n            const isEmbeddedArray = this.embeddedMetadata.isArray\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                value: ObjectLiteral,\n            ): ObjectLiteral => {\n                if (value === undefined) {\n                    return {}\n                }\n\n                const propertyName = propertyNames.shift()\n\n                if (propertyName) {\n                    const submap = extractEmbeddedColumnValue(\n                        propertyNames,\n                        value[propertyName],\n                    )\n                    if (Object.keys(submap).length > 0) {\n                        return { [propertyName]: submap }\n                    }\n                    return {}\n                }\n\n                if (isEmbeddedArray && Array.isArray(value)) {\n                    return value.map((v) => ({\n                        [this.propertyName]: v[this.propertyName],\n                    }))\n                }\n\n                if (\n                    value[this.propertyName] !== undefined &&\n                    (returnNulls === false || value[this.propertyName] !== null)\n                ) {\n                    return { [this.propertyName]: value[this.propertyName] }\n                }\n\n                return {}\n            }\n            const map = extractEmbeddedColumnValue(propertyNames, entity)\n\n            return Object.keys(map).length > 0 ? map : undefined\n        } else {\n            // no embeds - no problems. Simply return column property name and its value of the entity\n            /**\n             * Object.getOwnPropertyDescriptor checks if the relation is lazy, in which case value is a Promise\n             * DO NOT use `entity[\n                this.relationMetadata.propertyName] instanceof Promise`, which will invoke property getter and make unwanted DB request\n             * refer: https://github.com/typeorm/typeorm/pull/8676#issuecomment-1049906331\n             */\n            if (\n                this.relationMetadata &&\n                !Object.getOwnPropertyDescriptor(\n                    entity,\n                    this.relationMetadata.propertyName,\n                )?.get &&\n                entity[this.relationMetadata.propertyName] &&\n                ObjectUtils.isObject(entity[this.relationMetadata.propertyName])\n            ) {\n                if (this.relationMetadata.joinColumns.length > 1) {\n                    const map = this.relationMetadata.joinColumns.reduce(\n                        (map, joinColumn) => {\n                            const value =\n                                joinColumn.referencedColumn!.getEntityValueMap(\n                                    entity[this.relationMetadata!.propertyName],\n                                )\n                            if (value === undefined) return map\n                            return OrmUtils.mergeDeep(map, value)\n                        },\n                        {},\n                    )\n                    if (Object.keys(map).length > 0)\n                        return { [this.propertyName]: map }\n                } else {\n                    const value =\n                        this.relationMetadata.joinColumns[0].referencedColumn!.getEntityValue(\n                            entity[this.relationMetadata!.propertyName],\n                        )\n                    if (value) {\n                        return { [this.propertyName]: value }\n                    }\n                }\n\n                return undefined\n            } else {\n                if (\n                    entity[this.propertyName] !== undefined &&\n                    (returnNulls === false ||\n                        entity[this.propertyName] !== null)\n                ) {\n                    return { [this.propertyName]: entity[this.propertyName] }\n                }\n\n                return undefined\n            }\n        }\n    }\n\n    /**\n     * Extracts column value from the given entity.\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\n     */\n    getEntityValue(\n        entity: ObjectLiteral,\n        transform: boolean = false,\n    ): any | undefined {\n        if (entity === undefined || entity === null) return undefined\n\n        // extract column value from embeddeds of entity if column is in embedded\n        let value: any = undefined\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n            const isEmbeddedArray = this.embeddedMetadata.isArray\n\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                value: ObjectLiteral,\n            ): any => {\n                const propertyName = propertyNames.shift()\n                return propertyName && value\n                    ? extractEmbeddedColumnValue(\n                          propertyNames,\n                          value[propertyName],\n                      )\n                    : value\n            }\n\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n            const embeddedObject = extractEmbeddedColumnValue(\n                propertyNames,\n                entity,\n            )\n            if (embeddedObject) {\n                if (this.relationMetadata && this.referencedColumn) {\n                    const relatedEntity =\n                        this.relationMetadata.getEntityValue(embeddedObject)\n                    if (\n                        relatedEntity &&\n                        ObjectUtils.isObject(relatedEntity) &&\n                        !InstanceChecker.isFindOperator(relatedEntity) &&\n                        !Buffer.isBuffer(relatedEntity)\n                    ) {\n                        value =\n                            this.referencedColumn.getEntityValue(relatedEntity)\n                    } else if (\n                        embeddedObject[this.propertyName] &&\n                        ObjectUtils.isObject(\n                            embeddedObject[this.propertyName],\n                        ) &&\n                        !InstanceChecker.isFindOperator(\n                            embeddedObject[this.propertyName],\n                        ) &&\n                        !Buffer.isBuffer(embeddedObject[this.propertyName]) &&\n                        !(embeddedObject[this.propertyName] instanceof Date)\n                    ) {\n                        value = this.referencedColumn.getEntityValue(\n                            embeddedObject[this.propertyName],\n                        )\n                    } else {\n                        value = embeddedObject[this.propertyName]\n                    }\n                } else if (this.referencedColumn) {\n                    value = this.referencedColumn.getEntityValue(\n                        embeddedObject[this.propertyName],\n                    )\n                } else if (isEmbeddedArray && Array.isArray(embeddedObject)) {\n                    value = embeddedObject.map((o) => o[this.propertyName])\n                } else {\n                    value = embeddedObject[this.propertyName]\n                }\n            }\n        } else {\n            // no embeds - no problems. Simply return column name by property name of the entity\n            if (this.relationMetadata && this.referencedColumn) {\n                const relatedEntity =\n                    this.relationMetadata.getEntityValue(entity)\n                if (\n                    relatedEntity &&\n                    ObjectUtils.isObject(relatedEntity) &&\n                    !InstanceChecker.isFindOperator(relatedEntity) &&\n                    !(typeof relatedEntity === \"function\") &&\n                    !Buffer.isBuffer(relatedEntity)\n                ) {\n                    value = this.referencedColumn.getEntityValue(relatedEntity)\n                } else if (\n                    entity[this.propertyName] &&\n                    ObjectUtils.isObject(entity[this.propertyName]) &&\n                    !InstanceChecker.isFindOperator(\n                        entity[this.propertyName],\n                    ) &&\n                    !(typeof entity[this.propertyName] === \"function\") &&\n                    !Buffer.isBuffer(entity[this.propertyName]) &&\n                    !(entity[this.propertyName] instanceof Date)\n                ) {\n                    value = this.referencedColumn.getEntityValue(\n                        entity[this.propertyName],\n                    )\n                } else {\n                    value = entity[this.propertyName]\n                }\n            } else if (this.referencedColumn) {\n                value = this.referencedColumn.getEntityValue(\n                    entity[this.propertyName],\n                )\n            } else {\n                value = entity[this.propertyName]\n            }\n        }\n\n        if (transform && this.transformer)\n            value = ApplyValueTransformers.transformTo(this.transformer, value)\n\n        return value\n    }\n\n    /**\n     * Sets given entity's column value.\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n     */\n    setEntityValue(entity: ObjectLiteral, value: any): void {\n        if (this.embeddedMetadata) {\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const extractEmbeddedColumnValue = (\n                embeddedMetadatas: EmbeddedMetadata[],\n                map: ObjectLiteral,\n            ): any => {\n                // if (!object[embeddedMetadata.propertyName])\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                const embeddedMetadata = embeddedMetadatas.shift()\n                if (embeddedMetadata) {\n                    if (!map[embeddedMetadata.propertyName])\n                        map[embeddedMetadata.propertyName] =\n                            embeddedMetadata.create()\n\n                    extractEmbeddedColumnValue(\n                        embeddedMetadatas,\n                        map[embeddedMetadata.propertyName],\n                    )\n                    return map\n                }\n                map[this.propertyName] = value\n                return map\n            }\n            return extractEmbeddedColumnValue(\n                [...this.embeddedMetadata.embeddedMetadataTree],\n                entity,\n            )\n        } else {\n            // we write a deep object in this entity only if the column is virtual\n            // because if its not virtual it means the user defined a real column for this relation\n            // also we don't do it if column is inside a junction table\n            if (\n                !this.entityMetadata.isJunction &&\n                this.isVirtual &&\n                this.referencedColumn &&\n                this.referencedColumn.propertyName !== this.propertyName\n            ) {\n                if (!(this.propertyName in entity)) {\n                    entity[this.propertyName] = {}\n                }\n\n                entity[this.propertyName][this.referencedColumn.propertyName] =\n                    value\n            } else {\n                entity[this.propertyName] = value\n            }\n        }\n    }\n\n    /**\n     * Compares given entity's column value with a given value.\n     */\n    compareEntityValue(entity: any, valueToCompareWith: any) {\n        const columnValue = this.getEntityValue(entity)\n        if (typeof columnValue?.equals === \"function\") {\n            return columnValue.equals(valueToCompareWith)\n        }\n        return columnValue === valueToCompareWith\n    }\n\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n\n    build(connection: DataSource): this {\n        this.propertyPath = this.buildPropertyPath()\n        this.propertyAliasName = this.propertyPath.replace(\".\", \"_\")\n        this.databaseName = this.buildDatabaseName(connection)\n        this.databasePath = this.buildDatabasePath()\n        this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(\n            this.propertyName,\n            this.givenDatabaseName,\n            [],\n        )\n        return this\n    }\n\n    protected buildPropertyPath(): string {\n        let path = \"\"\n        if (\n            this.embeddedMetadata &&\n            this.embeddedMetadata.parentPropertyNames.length\n        )\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\"\n\n        path += this.propertyName\n\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        // also we don't do it if column is inside a junction table\n        if (\n            !this.entityMetadata.isJunction &&\n            this.isVirtual &&\n            this.referencedColumn &&\n            this.referencedColumn.propertyName !== this.propertyName\n        )\n            path += \".\" + this.referencedColumn.propertyName\n\n        return path\n    }\n\n    protected buildDatabasePath(): string {\n        let path = \"\"\n        if (\n            this.embeddedMetadata &&\n            this.embeddedMetadata.parentPropertyNames.length\n        )\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\"\n\n        path += this.databaseName\n\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        // also we don't do it if column is inside a junction table\n        if (\n            !this.entityMetadata.isJunction &&\n            this.isVirtual &&\n            this.referencedColumn &&\n            this.referencedColumn.databaseName !== this.databaseName\n        )\n            path += \".\" + this.referencedColumn.databaseName\n\n        return path\n    }\n\n    protected buildDatabaseName(connection: DataSource): string {\n        let propertyNames = this.embeddedMetadata\n            ? this.embeddedMetadata.parentPrefixes\n            : []\n        if (connection.driver.options.type === \"mongodb\")\n            // we don't need to include embedded name for the mongodb column names\n            propertyNames = []\n        return connection.namingStrategy.columnName(\n            this.propertyName,\n            this.givenDatabaseName,\n            propertyNames,\n        )\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1035, "column": 0}, "map": {"version":3,"file":"IndexMetadata.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/metadata/IndexMetadata.ts"],"sourceRoot":"..","sourcesContent":["import { EntityMetadata } from \"./EntityMetadata\"\nimport { IndexMetadataArgs } from \"../metadata-args/IndexMetadataArgs\"\nimport { NamingStrategyInterface } from \"../naming-strategy/NamingStrategyInterface\"\nimport { ColumnMetadata } from \"./ColumnMetadata\"\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\nimport { TypeORMError } from \"../error\"\n\n/**\n * Index metadata contains all information about table's index.\n */\nexport class IndexMetadata {\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the class to which this index is applied.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Embedded metadata if this index was applied on embedded.\n     */\n    embeddedMetadata?: EmbeddedMetadata\n\n    /**\n     * Indicates if this index must be unique.\n     */\n    isUnique: boolean = false\n\n    /**\n     * The SPATIAL modifier indexes the entire column and does not allow indexed columns to contain NULL values.\n     * Works only in MySQL.\n     */\n    isSpatial: boolean = false\n\n    /**\n     * The FULLTEXT modifier indexes the entire column and does not allow prefixing.\n     * Works only in MySQL.\n     */\n    isFulltext: boolean = false\n\n    /**\n     * NULL_FILTERED indexes are particularly useful for indexing sparse columns, where most rows contain a NULL value.\n     * In these cases, the NULL_FILTERED index can be considerably smaller and more efficient to maintain than\n     * a normal index that includes NULL values.\n     *\n     * Works only in Spanner.\n     */\n    isNullFiltered: boolean = false\n\n    /**\n     * Fulltext parser.\n     * Works only in MySQL.\n     */\n    parser?: string\n\n    /**\n     * Indicates if this index must synchronize with database index.\n     */\n    synchronize: boolean = true\n\n    /**\n     * If true, the index only references documents with the specified field.\n     * These indexes use less space but behave differently in some situations (particularly sorts).\n     * This option is only supported for mongodb database.\n     */\n    isSparse?: boolean\n\n    /**\n     * Builds the index in the background so that building an index an does not block other database activities.\n     * This option is only supported for mongodb database.\n     */\n    isBackground?: boolean\n\n    /**\n     * Builds the index using the concurrently option.\n     * This options is only supported for postgres database.\n     */\n    isConcurrent?: boolean\n\n    /**\n     * Specifies a time to live, in seconds.\n     * This option is only supported for mongodb database.\n     */\n    expireAfterSeconds?: number\n\n    /**\n     * Target class to which metadata is applied.\n     */\n    target?: Function | string\n\n    /**\n     * Indexed columns.\n     */\n    columns: ColumnMetadata[] = []\n\n    /**\n     * User specified index name.\n     */\n    givenName?: string\n\n    /**\n     * User specified column names.\n     */\n    givenColumnNames?:\n        | ((object?: any) => any[] | { [key: string]: number })\n        | string[]\n\n    /**\n     * Final index name.\n     * If index name was given by a user then it stores normalized (by naming strategy) givenName.\n     * If index name was not given then its generated.\n     */\n    name: string\n\n    /**\n     * Index filter condition.\n     */\n    where?: string\n\n    /**\n     * Map of column names with order set.\n     * Used only by MongoDB driver.\n     */\n    columnNamesWithOrderingMap: { [key: string]: number } = {}\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        embeddedMetadata?: EmbeddedMetadata\n        columns?: ColumnMetadata[]\n        args?: IndexMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.embeddedMetadata = options.embeddedMetadata\n        if (options.columns) this.columns = options.columns\n\n        if (options.args) {\n            this.target = options.args.target\n            if (\n                options.args.synchronize !== null &&\n                options.args.synchronize !== undefined\n            )\n                this.synchronize = options.args.synchronize\n            this.isUnique = !!options.args.unique\n            this.isSpatial = !!options.args.spatial\n            this.isFulltext = !!options.args.fulltext\n            this.isNullFiltered = !!options.args.nullFiltered\n            this.parser = options.args.parser\n            this.where = options.args.where\n            this.isSparse = options.args.sparse\n            this.isBackground = options.args.background\n            this.isConcurrent = options.args.concurrent\n            this.expireAfterSeconds = options.args.expireAfterSeconds\n            this.givenName = options.args.name\n            this.givenColumnNames = options.args.columns\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Build Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds some depend index properties.\n     * Must be called after all entity metadata's properties map, columns and relations are built.\n     */\n    build(namingStrategy: NamingStrategyInterface): this {\n        if (this.synchronize === false) {\n            this.name = this.givenName!\n            return this\n        }\n\n        const map: { [key: string]: number } = {}\n\n        // if columns already an array of string then simply return it\n        if (this.givenColumnNames) {\n            let columnPropertyPaths: string[] = []\n            if (Array.isArray(this.givenColumnNames)) {\n                columnPropertyPaths = this.givenColumnNames.map(\n                    (columnName) => {\n                        if (this.embeddedMetadata)\n                            return (\n                                this.embeddedMetadata.propertyPath +\n                                \".\" +\n                                columnName\n                            )\n\n                        return columnName.trim()\n                    },\n                )\n                columnPropertyPaths.forEach(\n                    (propertyPath) => (map[propertyPath] = 1),\n                )\n            } else {\n                // todo: indices in embeds are not implemented in this syntax. deprecate this syntax?\n                // if columns is a function that returns array of field names then execute it and get columns names from it\n                const columnsFnResult = this.givenColumnNames(\n                    this.entityMetadata.propertiesMap,\n                )\n                if (Array.isArray(columnsFnResult)) {\n                    columnPropertyPaths = columnsFnResult.map((i: any) =>\n                        String(i),\n                    )\n                    columnPropertyPaths.forEach((name) => (map[name] = 1))\n                } else {\n                    columnPropertyPaths = Object.keys(columnsFnResult).map(\n                        (i: any) => String(i),\n                    )\n                    Object.keys(columnsFnResult).forEach(\n                        (columnName) =>\n                            (map[columnName] = columnsFnResult[columnName]),\n                    )\n                }\n            }\n\n            this.columns = columnPropertyPaths\n                .map((propertyPath) => {\n                    const columnWithSameName = this.entityMetadata.columns.find(\n                        (column) => column.propertyPath === propertyPath,\n                    )\n                    if (columnWithSameName) {\n                        return [columnWithSameName]\n                    }\n                    const relationWithSameName =\n                        this.entityMetadata.relations.find(\n                            (relation) =>\n                                relation.isWithJoinColumn &&\n                                relation.propertyName === propertyPath,\n                        )\n                    if (relationWithSameName) {\n                        return relationWithSameName.joinColumns\n                    }\n                    const indexName = this.givenName\n                        ? '\"' + this.givenName + '\" '\n                        : \"\"\n                    const entityName = this.entityMetadata.targetName\n                    throw new TypeORMError(\n                        `Index ${indexName}contains column that is missing in the entity (${entityName}): ` +\n                            propertyPath,\n                    )\n                })\n                .reduce((a, b) => a.concat(b))\n        }\n\n        this.columnNamesWithOrderingMap = Object.keys(map).reduce(\n            (updatedMap, key) => {\n                const column = this.entityMetadata.columns.find(\n                    (column) => column.propertyPath === key,\n                )\n                if (column) updatedMap[column.databasePath] = map[key]\n\n                return updatedMap\n            },\n            {} as { [key: string]: number },\n        )\n\n        this.name = this.givenName\n            ? this.givenName\n            : namingStrategy.indexName(\n                  this.entityMetadata.tableName,\n                  this.columns.map((column) => column.databaseName),\n                  this.where,\n              )\n        return this\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1158, "column": 0}, "map": {"version":3,"file":"RelationMetadata.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/metadata/RelationMetadata.ts"],"sourceRoot":"..","sourcesContent":["import { RelationType } from \"./types/RelationTypes\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { ForeignKeyMetadata } from \"./ForeignKeyMetadata\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"./ColumnMetadata\"\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\nimport { RelationMetadataArgs } from \"../metadata-args/RelationMetadataArgs\"\nimport { DeferrableType } from \"./types/DeferrableType\"\nimport { OnUpdateType } from \"./types/OnUpdateType\"\nimport { OnDeleteType } from \"./types/OnDeleteType\"\nimport { PropertyTypeFactory } from \"./types/PropertyTypeInFunction\"\nimport { TypeORMError } from \"../error\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Contains all information about some entity's relation.\n */\nexport class RelationMetadata {\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the entity where this relation is placed.\n     *\n     * For example for @ManyToMany(type => Category) in Post, entityMetadata will be metadata of Post entity.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Entity metadata of the entity that is targeted by this relation.\n     *\n     * For example for @ManyToMany(type => Category) in Post, inverseEntityMetadata will be metadata of Category entity.\n     */\n    inverseEntityMetadata: EntityMetadata\n\n    /**\n     * Entity metadata of the junction table.\n     * Junction tables have their own entity metadata objects.\n     * Defined only for many-to-many relations.\n     */\n    junctionEntityMetadata?: EntityMetadata\n\n    /**\n     * Embedded metadata where this relation is.\n     * If this relation is not in embed then this property value is undefined.\n     */\n    embeddedMetadata?: EmbeddedMetadata\n\n    /**\n     * Relation type, e.g. is it one-to-one, one-to-many, many-to-one or many-to-many.\n     */\n    relationType: RelationType\n\n    /**\n     * Target entity to which this relation is applied.\n     * Target IS NOT equal to entityMetadata.target, because relation\n     *\n     * For example for @ManyToMany(type => Category) in Post, target will be Post.\n     * If @ManyToMany(type => Category) is in Counters which is embedded into Post, target will be Counters.\n     * If @ManyToMany(type => Category) is in abstract class BaseUser which Post extends, target will be BaseUser.\n     * Target can be string if its defined in entity schema instead of class.\n     */\n    target: Function | string\n\n    /**\n     * Target's property name to which relation decorator is applied.\n     */\n    propertyName: string\n\n    /**\n     * Gets full path to this column property (including relation name).\n     * Full path is relevant when column is used in embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters.likes\".\n     * If property is not in embeds then it returns just property name of the column.\n     */\n    propertyPath: string\n\n    /**\n     * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.\n     */\n    isTreeParent: boolean = false\n\n    /**\n     * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.\n     */\n    isTreeChildren: boolean = false\n\n    /**\n     * Indicates if this relation's column is a primary key.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     */\n    isPrimary: boolean = false\n\n    /**\n     * Indicates if this relation is lazily loaded.\n     */\n    isLazy: boolean = false\n\n    /**\n     * Indicates if this relation is eagerly loaded.\n     */\n    isEager: boolean = false\n\n    /**\n     * Indicates if persistence is enabled for the relation.\n     * By default its enabled, but if you want to avoid any changes in the relation to be reflected in the database you can disable it.\n     * If its disabled you can only change a relation from inverse side of a relation or using relation query builder functionality.\n     * This is useful for performance optimization since its disabling avoid multiple extra queries during entity save.\n     */\n    persistenceEnabled: boolean = true\n\n    /**\n     * When a parent is saved (with cascading but) without a child row that still exists in database, this will control what shall happen to them.\n     * delete will remove these rows from database. nullify will remove the relation key.\n     * skip will keep the relation intact. Removal of related item is only possible through its own repo.\n     */\n    orphanedRowAction?: \"nullify\" | \"delete\" | \"soft-delete\" | \"disable\"\n\n    /**\n     * If set to true then related objects are allowed to be inserted to the database.\n     */\n    isCascadeInsert: boolean = false\n\n    /**\n     * If set to true then related objects are allowed to be updated in the database.\n     */\n    isCascadeUpdate: boolean = false\n\n    /**\n     * If set to true then related objects are allowed to be remove from the database.\n     */\n    isCascadeRemove: boolean = false\n\n    /**\n     * If set to true then related objects are allowed to be soft-removed from the database.\n     */\n    isCascadeSoftRemove: boolean = false\n\n    /**\n     * If set to true then related objects are allowed to be recovered from the database.\n     */\n    isCascadeRecover: boolean = false\n\n    /**\n     * Indicates if relation column value can be nullable or not.\n     */\n    isNullable: boolean = true\n\n    /**\n     * What to do with a relation on deletion of the row containing a foreign key.\n     */\n    onDelete?: OnDeleteType\n\n    /**\n     * What to do with a relation on update of the row containing a foreign key.\n     */\n    onUpdate?: OnUpdateType\n\n    /**\n     * What to do with a relation on update of the row containing a foreign key.\n     */\n    deferrable?: DeferrableType\n\n    /**\n     * Indicates whether foreign key constraints will be created for join columns.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     * Defaults to true.\n     */\n    createForeignKeyConstraints: boolean = true\n\n    /**\n     * Gets the property's type to which this relation is applied.\n     *\n     * For example for @ManyToMany(type => Category) in Post, target will be Category.\n     */\n    type: Function | string\n\n    /**\n     * Indicates if this side is an owner of this relation.\n     */\n    isOwning: boolean = false\n\n    /**\n     * Checks if this relation's type is \"one-to-one\".\n     */\n    isOneToOne: boolean = false\n\n    /**\n     * Checks if this relation is owner side of the \"one-to-one\" relation.\n     * Owner side means this side of relation has a join column in the table.\n     */\n    isOneToOneOwner: boolean = false\n\n    /**\n     * Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).\n     */\n    isWithJoinColumn: boolean = false\n\n    /**\n     * Checks if this relation is NOT owner side of the \"one-to-one\" relation.\n     * NOT owner side means this side of relation does not have a join column in the table.\n     */\n    isOneToOneNotOwner: boolean = false\n\n    /**\n     * Checks if this relation's type is \"one-to-many\".\n     */\n    isOneToMany: boolean = false\n\n    /**\n     * Checks if this relation's type is \"many-to-one\".\n     */\n    isManyToOne: boolean = false\n\n    /**\n     * Checks if this relation's type is \"many-to-many\".\n     */\n    isManyToMany: boolean = false\n\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is owner side of the relationship.\n     * Owner side means this side of relation has a join table.\n     */\n    isManyToManyOwner: boolean = false\n\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is NOT owner side of the relationship.\n     * Not owner side means this side of relation does not have a join table.\n     */\n    isManyToManyNotOwner: boolean = false\n\n    /**\n     * Gets the property path of the inverse side of the relation.\n     */\n    inverseSidePropertyPath: string\n\n    /**\n     * Inverse side of the relation set by user.\n     *\n     * Inverse side set in the relation can be either string - property name of the column on inverse side,\n     * either can be a function that accepts a map of properties with the object and returns one of them.\n     * Second approach is used to achieve type-safety.\n     */\n    givenInverseSidePropertyFactory: PropertyTypeFactory<any>\n\n    /**\n     * Gets the relation metadata of the inverse side of this relation.\n     */\n    inverseRelation?: RelationMetadata\n\n    /**\n     * Join table name.\n     */\n    joinTableName: string\n\n    /**\n     * Foreign keys created for this relation.\n     */\n    foreignKeys: ForeignKeyMetadata[] = []\n\n    /**\n     * Join table columns.\n     * Join columns can be obtained only from owner side of the relation.\n     * From non-owner side of the relation join columns will be empty.\n     * If this relation is a many-to-one/one-to-one then it takes join columns from the current entity.\n     * If this relation is many-to-many then it takes all owner join columns from the junction entity.\n     */\n    joinColumns: ColumnMetadata[] = []\n\n    /**\n     * Inverse join table columns.\n     * Inverse join columns are supported only for many-to-many relations\n     * and can be obtained only from owner side of the relation.\n     * From non-owner side of the relation join columns will be undefined.\n     */\n    inverseJoinColumns: ColumnMetadata[] = []\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        embeddedMetadata?: EmbeddedMetadata\n        args: RelationMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.embeddedMetadata = options.embeddedMetadata!\n        const args = options.args\n        this.target = args.target\n        this.propertyName = args.propertyName\n        this.relationType = args.relationType\n\n        if (args.inverseSideProperty)\n            this.givenInverseSidePropertyFactory = args.inverseSideProperty\n\n        this.isLazy = args.isLazy || false\n        // this.isCascadeInsert = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"insert\") !== -1);\n        // this.isCascadeUpdate = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"update\") !== -1);\n        // this.isCascadeRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"remove\") !== -1);\n        // this.isCascadeSoftRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"soft-remove\") !== -1);\n        // this.isCascadeRecover = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"recover\") !== -1);\n        this.isCascadeInsert =\n            args.options.cascade === true ||\n            (Array.isArray(args.options.cascade) &&\n                args.options.cascade.indexOf(\"insert\") !== -1)\n        this.isCascadeUpdate =\n            args.options.cascade === true ||\n            (Array.isArray(args.options.cascade) &&\n                args.options.cascade.indexOf(\"update\") !== -1)\n        this.isCascadeRemove =\n            args.options.cascade === true ||\n            (Array.isArray(args.options.cascade) &&\n                args.options.cascade.indexOf(\"remove\") !== -1)\n        this.isCascadeSoftRemove =\n            args.options.cascade === true ||\n            (Array.isArray(args.options.cascade) &&\n                args.options.cascade.indexOf(\"soft-remove\") !== -1)\n        this.isCascadeRecover =\n            args.options.cascade === true ||\n            (Array.isArray(args.options.cascade) &&\n                args.options.cascade.indexOf(\"recover\") !== -1)\n        // this.isPrimary = args.options.primary || false;\n        this.isNullable =\n            args.options.nullable === false || this.isPrimary ? false : true\n        this.onDelete = args.options.onDelete\n        this.onUpdate = args.options.onUpdate\n        this.deferrable = args.options.deferrable\n        this.createForeignKeyConstraints =\n            args.options.createForeignKeyConstraints === false ? false : true\n        this.isEager = args.options.eager || false\n        this.persistenceEnabled =\n            args.options.persistence === false ? false : true\n        this.orphanedRowAction = args.options.orphanedRowAction || \"nullify\"\n        this.isTreeParent = args.isTreeParent || false\n        this.isTreeChildren = args.isTreeChildren || false\n\n        if (typeof args.type === \"function\") {\n            this.type =\n                typeof args.type === \"function\"\n                    ? (args.type as () => any)()\n                    : args.type\n        } else if (InstanceChecker.isEntitySchema(args.type)) {\n            this.type = args.type.options.name\n        } else if (\n            ObjectUtils.isObject(args.type) &&\n            typeof (args.type as any).name === \"string\"\n        ) {\n            this.type = (args.type as any).name\n        } else {\n            this.type = args.type as string | Function\n        }\n\n        this.isOneToOne = this.relationType === \"one-to-one\"\n        this.isOneToMany = this.relationType === \"one-to-many\"\n        this.isManyToOne = this.relationType === \"many-to-one\"\n        this.isManyToMany = this.relationType === \"many-to-many\"\n        this.isOneToOneNotOwner = this.isOneToOne ? true : false\n        this.isManyToManyNotOwner = this.isManyToMany ? true : false\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Creates join column ids map from the given related entity ids array.\n     */\n    getRelationIdMap(entity: ObjectLiteral): ObjectLiteral | undefined {\n        const joinColumns = this.isOwning\n            ? this.joinColumns\n            : this.inverseRelation!.joinColumns\n        const referencedColumns = joinColumns.map(\n            (joinColumn) => joinColumn.referencedColumn!,\n        )\n        // console.log(\"entity\", entity);\n        // console.log(\"referencedColumns\", referencedColumns);\n        return EntityMetadata.getValueMap(entity, referencedColumns)\n    }\n\n    /**\n     * Ensures that given object is an entity id map.\n     * If given id is an object then it means its already id map.\n     * If given id isn't an object then it means its a value of the id column\n     * and it creates a new id map with this value and name of the primary column.\n     */\n    ensureRelationIdMap(id: any): ObjectLiteral {\n        if (ObjectUtils.isObject(id)) return id\n\n        const joinColumns = this.isOwning\n            ? this.joinColumns\n            : this.inverseRelation!.joinColumns\n        const referencedColumns = joinColumns.map(\n            (joinColumn) => joinColumn.referencedColumn!,\n        )\n\n        if (referencedColumns.length > 1)\n            throw new TypeORMError(\n                `Cannot create relation id map for a single value because relation contains multiple referenced columns.`,\n            )\n\n        return referencedColumns[0].createValueMap(id)\n    }\n\n    /**\n     * Extracts column value from the given entity.\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\n     */\n    getEntityValue(\n        entity: ObjectLiteral,\n        getLazyRelationsPromiseValue: boolean = false,\n    ): any | undefined {\n        if (entity === null || entity === undefined) return undefined\n        // extract column value from embeddeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                value: ObjectLiteral,\n            ): any => {\n                const propertyName = propertyNames.shift()\n                if (propertyName) {\n                    if (value[propertyName]) {\n                        return extractEmbeddedColumnValue(\n                            propertyNames,\n                            value[propertyName],\n                        )\n                    }\n                    return undefined\n                }\n                return value\n            }\n\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n            const embeddedObject = extractEmbeddedColumnValue(\n                propertyNames,\n                entity,\n            )\n\n            if (this.isLazy) {\n                if (\n                    embeddedObject[\"__\" + this.propertyName + \"__\"] !==\n                    undefined\n                )\n                    return embeddedObject[\"__\" + this.propertyName + \"__\"]\n\n                if (getLazyRelationsPromiseValue === true)\n                    return embeddedObject[this.propertyName]\n\n                return undefined\n            }\n            return embeddedObject\n                ? embeddedObject[\n                      this.isLazy\n                          ? \"__\" + this.propertyName + \"__\"\n                          : this.propertyName\n                  ]\n                : undefined\n        } else {\n            // no embeds - no problems. Simply return column name by property name of the entity\n            if (this.isLazy) {\n                if (entity[\"__\" + this.propertyName + \"__\"] !== undefined)\n                    return entity[\"__\" + this.propertyName + \"__\"]\n\n                if (getLazyRelationsPromiseValue === true)\n                    return entity[this.propertyName]\n\n                return undefined\n            }\n            return entity[this.propertyName]\n        }\n    }\n\n    /**\n     * Sets given entity's relation's value.\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n     *\n     * If merge is set to true, it merges given value into currently\n     */\n    setEntityValue(entity: ObjectLiteral, value: any): void {\n        const propertyName = this.isLazy\n            ? \"__\" + this.propertyName + \"__\"\n            : this.propertyName\n\n        if (this.embeddedMetadata) {\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const extractEmbeddedColumnValue = (\n                embeddedMetadatas: EmbeddedMetadata[],\n                map: ObjectLiteral,\n            ): any => {\n                // if (!object[embeddedMetadata.propertyName])\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n\n                const embeddedMetadata = embeddedMetadatas.shift()\n                if (embeddedMetadata) {\n                    if (!map[embeddedMetadata.propertyName])\n                        map[embeddedMetadata.propertyName] =\n                            embeddedMetadata.create()\n\n                    extractEmbeddedColumnValue(\n                        embeddedMetadatas,\n                        map[embeddedMetadata.propertyName],\n                    )\n                    return map\n                }\n                map[propertyName] = value\n                return map\n            }\n            return extractEmbeddedColumnValue(\n                [...this.embeddedMetadata.embeddedMetadataTree],\n                entity,\n            )\n        } else {\n            entity[propertyName] = value\n        }\n    }\n\n    /**\n     * Creates entity id map from the given entity ids array.\n     */\n    createValueMap(value: any) {\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames]\n\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (\n                propertyNames: string[],\n                map: ObjectLiteral,\n            ): any => {\n                const propertyName = propertyNames.shift()\n                if (propertyName) {\n                    map[propertyName] = {}\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName])\n                    return map\n                }\n                map[this.propertyName] = value\n                return map\n            }\n            return extractEmbeddedColumnValue(propertyNames, {})\n        } else {\n            // no embeds - no problems. Simply return column property name and its value of the entity\n            return { [this.propertyName]: value }\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds some depend relation metadata properties.\n     * This builder method should be used only after embedded metadata tree was build.\n     */\n    build() {\n        this.propertyPath = this.buildPropertyPath()\n    }\n\n    /**\n     * Registers given foreign keys in the relation.\n     * This builder method should be used to register foreign key in the relation.\n     */\n    registerForeignKeys(...foreignKeys: ForeignKeyMetadata[]) {\n        this.foreignKeys.push(...foreignKeys)\n    }\n\n    /**\n     * Registers given join columns in the relation.\n     * This builder method should be used to register join column in the relation.\n     */\n    registerJoinColumns(\n        joinColumns: ColumnMetadata[] = [],\n        inverseJoinColumns: ColumnMetadata[] = [],\n    ) {\n        this.joinColumns = joinColumns\n        this.inverseJoinColumns = inverseJoinColumns\n        this.isOwning =\n            this.isManyToOne ||\n            ((this.isManyToMany || this.isOneToOne) &&\n                this.joinColumns.length > 0)\n        this.isOneToOneOwner = this.isOneToOne && this.isOwning\n        this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning\n        this.isManyToManyOwner = this.isManyToMany && this.isOwning\n        this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning\n        this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner\n    }\n\n    /**\n     * Registers a given junction entity metadata.\n     * This builder method can be called after junction entity metadata for the many-to-many relation was created.\n     */\n    registerJunctionEntityMetadata(junctionEntityMetadata: EntityMetadata) {\n        this.junctionEntityMetadata = junctionEntityMetadata\n        this.joinTableName = junctionEntityMetadata.tableName\n        if (this.inverseRelation) {\n            this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata\n            this.joinTableName = junctionEntityMetadata.tableName\n        }\n    }\n\n    /**\n     * Builds inverse side property path based on given inverse side property factory.\n     * This builder method should be used only after properties map of the inverse entity metadata was build.\n     */\n    buildInverseSidePropertyPath(): string {\n        if (this.givenInverseSidePropertyFactory) {\n            const ownerEntityPropertiesMap =\n                this.inverseEntityMetadata.propertiesMap\n            if (typeof this.givenInverseSidePropertyFactory === \"function\")\n                return this.givenInverseSidePropertyFactory(\n                    ownerEntityPropertiesMap,\n                )\n\n            if (typeof this.givenInverseSidePropertyFactory === \"string\")\n                return this.givenInverseSidePropertyFactory\n        } else if (\n            this.isTreeParent &&\n            this.entityMetadata.treeChildrenRelation\n        ) {\n            return this.entityMetadata.treeChildrenRelation.propertyName\n        } else if (\n            this.isTreeChildren &&\n            this.entityMetadata.treeParentRelation\n        ) {\n            return this.entityMetadata.treeParentRelation.propertyName\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Builds relation's property path based on its embedded tree.\n     */\n    buildPropertyPath(): string {\n        if (\n            !this.embeddedMetadata ||\n            !this.embeddedMetadata.parentPropertyNames.length\n        )\n            return this.propertyName\n\n        return (\n            this.embeddedMetadata.parentPropertyNames.join(\".\") +\n            \".\" +\n            this.propertyName\n        )\n    }\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAA;;AAUjD,OAAO,EAAE,YAAY,EAAE,MAAM,UAAU,CAAA;AACvC,OAAO,EAAE,WAAW,EAAE,MAAM,qBAAqB,CAAA;AACjD,OAAO,EAAE,eAAe,EAAE,MAAM,yBAAyB,CAAA;;;;;AAKnD,MAAO,gBAAgB;IAqQzB,wEAAwE;IACxE,cAAc;IACd,wEAAwE;IAExE,YAAY,OAIX,CAAA;QAhND;;WAEG,CACH,IAAA,CAAA,YAAY,GAAY,KAAK,CAAA;QAE7B;;WAEG,CACH,IAAA,CAAA,cAAc,GAAY,KAAK,CAAA;QAE/B;;;WAGG,CACH,IAAA,CAAA,SAAS,GAAY,KAAK,CAAA;QAE1B;;WAEG,CACH,IAAA,CAAA,MAAM,GAAY,KAAK,CAAA;QAEvB;;WAEG,CACH,IAAA,CAAA,OAAO,GAAY,KAAK,CAAA;QAExB;;;;;WAKG,CACH,IAAA,CAAA,kBAAkB,GAAY,IAAI,CAAA;QASlC;;WAEG,CACH,IAAA,CAAA,eAAe,GAAY,KAAK,CAAA;QAEhC;;WAEG,CACH,IAAA,CAAA,eAAe,GAAY,KAAK,CAAA;QAEhC;;WAEG,CACH,IAAA,CAAA,eAAe,GAAY,KAAK,CAAA;QAEhC;;WAEG,CACH,IAAA,CAAA,mBAAmB,GAAY,KAAK,CAAA;QAEpC;;WAEG,CACH,IAAA,CAAA,gBAAgB,GAAY,KAAK,CAAA;QAEjC;;WAEG,CACH,IAAA,CAAA,UAAU,GAAY,IAAI,CAAA;QAiB1B;;;;WAIG,CACH,IAAA,CAAA,2BAA2B,GAAY,IAAI,CAAA;QAS3C;;WAEG,CACH,IAAA,CAAA,QAAQ,GAAY,KAAK,CAAA;QAEzB;;WAEG,CACH,IAAA,CAAA,UAAU,GAAY,KAAK,CAAA;QAE3B;;;WAGG,CACH,IAAA,CAAA,eAAe,GAAY,KAAK,CAAA;QAEhC;;WAEG,CACH,IAAA,CAAA,gBAAgB,GAAY,KAAK,CAAA;QAEjC;;;WAGG,CACH,IAAA,CAAA,kBAAkB,GAAY,KAAK,CAAA;QAEnC;;WAEG,CACH,IAAA,CAAA,WAAW,GAAY,KAAK,CAAA;QAE5B;;WAEG,CACH,IAAA,CAAA,WAAW,GAAY,KAAK,CAAA;QAE5B;;WAEG,CACH,IAAA,CAAA,YAAY,GAAY,KAAK,CAAA;QAE7B;;;WAGG,CACH,IAAA,CAAA,iBAAiB,GAAY,KAAK,CAAA;QAElC;;;WAGG,CACH,IAAA,CAAA,oBAAoB,GAAY,KAAK,CAAA;QA0BrC;;WAEG,CACH,IAAA,CAAA,WAAW,GAAyB,EAAE,CAAA;QAEtC;;;;;;WAMG,CACH,IAAA,CAAA,WAAW,GAAqB,EAAE,CAAA;QAElC;;;;;WAKG,CACH,IAAA,CAAA,kBAAkB,GAAqB,EAAE,CAAA;QAWrC,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAA;QAC5C,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,gBAAiB,CAAA;QACjD,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAA;QACzB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAA;QACzB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAA;QACrC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAA;QAErC,IAAI,IAAI,CAAC,mBAAmB,EACxB,IAAI,CAAC,+BAA+B,GAAG,IAAI,CAAC,mBAAmB,CAAA;QAEnE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,IAAI,KAAK,CAAA;QAClC,oJAAoJ;QACpJ,oJAAoJ;QACpJ,oJAAoJ;QACpJ,6JAA6J;QAC7J,sJAAsJ;QACtJ,IAAI,CAAC,eAAe,GAChB,IAAI,CAAC,OAAO,CAAC,OAAO,KAAK,IAAI,IAC5B,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAChC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;QACtD,IAAI,CAAC,eAAe,GAChB,IAAI,CAAC,OAAO,CAAC,OAAO,KAAK,IAAI,IAC5B,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAChC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;QACtD,IAAI,CAAC,eAAe,GAChB,IAAI,CAAC,OAAO,CAAC,OAAO,KAAK,IAAI,IAC5B,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAChC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;QACtD,IAAI,CAAC,mBAAmB,GACpB,IAAI,CAAC,OAAO,CAAC,OAAO,KAAK,IAAI,IAC5B,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAChC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;QAC3D,IAAI,CAAC,gBAAgB,GACjB,IAAI,CAAC,OAAO,CAAC,OAAO,KAAK,IAAI,IAC5B,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAChC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;QACvD,kDAAkD;QAClD,IAAI,CAAC,UAAU,GACX,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK,KAAK,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAA;QACpE,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAA;QACrC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAA;QACrC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,CAAA;QACzC,IAAI,CAAC,2BAA2B,GAC5B,IAAI,CAAC,OAAO,CAAC,2BAA2B,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAA;QACrE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI,KAAK,CAAA;QAC1C,IAAI,CAAC,kBAAkB,GACnB,IAAI,CAAC,OAAO,CAAC,WAAW,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAA;QACrD,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,OAAO,CAAC,iBAAiB,IAAI,SAAS,CAAA;QACpE,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,IAAI,KAAK,CAAA;QAC9C,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,IAAI,KAAK,CAAA;QAElD,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE,CAAC;YAClC,IAAI,CAAC,IAAI,GACL,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU,GACxB,IAAI,CAAC,IAAkB,EAAE,GAC1B,IAAI,CAAC,IAAI,CAAA;QACvB,CAAC,MAAM,0KAAI,kBAAe,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;YACnD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAA;QACtC,CAAC,MAAM,sKACH,cAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,IAC/B,OAAQ,IAAI,CAAC,IAAY,CAAC,IAAI,KAAK,QAAQ,EAC7C,CAAC;YACC,IAAI,CAAC,IAAI,GAAI,IAAI,CAAC,IAAY,CAAC,IAAI,CAAA;QACvC,CAAC,MAAM,CAAC;YACJ,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAyB,CAAA;QAC9C,CAAC;QAED,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,YAAY,KAAK,YAAY,CAAA;QACpD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,YAAY,KAAK,aAAa,CAAA;QACtD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,YAAY,KAAK,aAAa,CAAA;QACtD,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,KAAK,cAAc,CAAA;QACxD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAA;QACxD,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAA;IAChE,CAAC;IAED,wEAAwE;IACxE,iBAAiB;IACjB,wEAAwE;IAExE;;OAEG,CACH,gBAAgB,CAAC,MAAqB,EAAA;QAClC,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,GAC3B,IAAI,CAAC,WAAW,GAChB,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAA;QACvC,MAAM,iBAAiB,GAAG,WAAW,CAAC,GAAG,CACrC,CAAC,UAAU,EAAE,CAAG,CAAD,SAAW,CAAC,gBAAiB,CAC/C,CAAA;QACD,iCAAiC;QACjC,uDAAuD;QACvD,gLAAO,iBAAc,CAAC,WAAW,CAAC,MAAM,EAAE,iBAAiB,CAAC,CAAA;IAChE,CAAC;IAED;;;;;OAKG,CACH,mBAAmB,CAAC,EAAO,EAAA;QACvB,sKAAI,cAAW,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,OAAO,EAAE,CAAA;QAEvC,MAAM,WAAW,GAAG,IAAI,CAAC,QAAQ,GAC3B,IAAI,CAAC,WAAW,GAChB,IAAI,CAAC,eAAgB,CAAC,WAAW,CAAA;QACvC,MAAM,iBAAiB,GAAG,WAAW,CAAC,GAAG,CACrC,CAAC,UAAU,EAAE,CAAG,CAAD,SAAW,CAAC,gBAAiB,CAC/C,CAAA;QAED,IAAI,iBAAiB,CAAC,MAAM,GAAG,CAAC,EAC5B,MAAM,wKAAI,eAAY,CAClB,CAAA,uGAAA,CAAyG,CAC5G,CAAA;QAEL,OAAO,iBAAiB,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,EAAE,CAAC,CAAA;IAClD,CAAC;IAED;;;OAGG,CACH,cAAc,CACV,MAAqB,EACrB,+BAAwC,KAAK,EAAA;QAE7C,IAAI,MAAM,KAAK,IAAI,IAAI,MAAM,KAAK,SAAS,EAAE,OAAO,SAAS,CAAA;QAC7D,yEAAyE;QACzE,IAAI,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACxB,yGAAyG;YACzG,uEAAuE;YAEvE,0HAA0H;YAC1H,MAAM,aAAa,GAAG,CAAC;mBAAG,IAAI,CAAC,gBAAgB,CAAC,mBAAmB;aAAC,CAAA;YAEpE,oHAAoH;YACpH,uHAAuH;YACvH,MAAM,0BAA0B,GAAG,CAC/B,aAAuB,EACvB,KAAoB,EACjB,EAAE;gBACL,MAAM,YAAY,GAAG,aAAa,CAAC,KAAK,EAAE,CAAA;gBAC1C,IAAI,YAAY,EAAE,CAAC;oBACf,IAAI,KAAK,CAAC,YAAY,CAAC,EAAE,CAAC;wBACtB,OAAO,0BAA0B,CAC7B,aAAa,EACb,KAAK,CAAC,YAAY,CAAC,CACtB,CAAA;oBACL,CAAC;oBACD,OAAO,SAAS,CAAA;gBACpB,CAAC;gBACD,OAAO,KAAK,CAAA;YAChB,CAAC,CAAA;YAED,+GAA+G;YAC/G,MAAM,cAAc,GAAG,0BAA0B,CAC7C,aAAa,EACb,MAAM,CACT,CAAA;YAED,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;gBACd,IACI,cAAc,CAAC,IAAI,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,KAC/C,SAAS,EAET,OAAO,cAAc,CAAC,IAAI,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,CAAA;gBAE1D,IAAI,4BAA4B,KAAK,IAAI,EACrC,OAAO,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,CAAA;gBAE5C,OAAO,SAAS,CAAA;YACpB,CAAC;YACD,OAAO,cAAc,GACf,cAAc,CACV,IAAI,CAAC,MAAM,GACL,IAAI,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,GAC/B,IAAI,CAAC,YAAY,CAC1B,GACD,SAAS,CAAA;QACnB,CAAC,MAAM,CAAC;YACJ,oFAAoF;YACpF,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;gBACd,IAAI,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,KAAK,SAAS,EACrD,OAAO,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,CAAA;gBAElD,IAAI,4BAA4B,KAAK,IAAI,EACrC,OAAO,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAA;gBAEpC,OAAO,SAAS,CAAA;YACpB,CAAC;YACD,OAAO,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAA;QACpC,CAAC;IACL,CAAC;IAED;;;;;OAKG,CACH,cAAc,CAAC,MAAqB,EAAE,KAAU,EAAA;QAC5C,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,GAC1B,IAAI,GAAG,IAAI,CAAC,YAAY,GAAG,IAAI,GAC/B,IAAI,CAAC,YAAY,CAAA;QAEvB,IAAI,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACxB,0HAA0H;YAC1H,MAAM,0BAA0B,GAAG,CAC/B,iBAAqC,EACrC,GAAkB,EACf,EAAE;gBACL,8CAA8C;gBAC9C,yEAAyE;gBAEzE,MAAM,gBAAgB,GAAG,iBAAiB,CAAC,KAAK,EAAE,CAAA;gBAClD,IAAI,gBAAgB,EAAE,CAAC;oBACnB,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC,YAAY,CAAC,EACnC,GAAG,CAAC,gBAAgB,CAAC,YAAY,CAAC,GAC9B,gBAAgB,CAAC,MAAM,EAAE,CAAA;oBAEjC,0BAA0B,CACtB,iBAAiB,EACjB,GAAG,CAAC,gBAAgB,CAAC,YAAY,CAAC,CACrC,CAAA;oBACD,OAAO,GAAG,CAAA;gBACd,CAAC;gBACD,GAAG,CAAC,YAAY,CAAC,GAAG,KAAK,CAAA;gBACzB,OAAO,GAAG,CAAA;YACd,CAAC,CAAA;YACD,OAAO,0BAA0B,CAC7B,CAAC;mBAAG,IAAI,CAAC,gBAAgB,CAAC,oBAAoB;aAAC,EAC/C,MAAM,CACT,CAAA;QACL,CAAC,MAAM,CAAC;YACJ,MAAM,CAAC,YAAY,CAAC,GAAG,KAAK,CAAA;QAChC,CAAC;IACL,CAAC;IAED;;OAEG,CACH,cAAc,CAAC,KAAU,EAAA;QACrB,sEAAsE;QACtE,IAAI,IAAI,CAAC,gBAAgB,EAAE,CAAC;YACxB,yGAAyG;YACzG,0FAA0F;YAC1F,8DAA8D;YAE9D,0HAA0H;YAC1H,MAAM,aAAa,GAAG,CAAC;mBAAG,IAAI,CAAC,gBAAgB,CAAC,mBAAmB;aAAC,CAAA;YAEpE,6FAA6F;YAC7F,kFAAkF;YAClF,gFAAgF;YAChF,4HAA4H;YAC5H,2CAA2C;YAC3C,MAAM,0BAA0B,GAAG,CAC/B,aAAuB,EACvB,GAAkB,EACf,EAAE;gBACL,MAAM,YAAY,GAAG,aAAa,CAAC,KAAK,EAAE,CAAA;gBAC1C,IAAI,YAAY,EAAE,CAAC;oBACf,GAAG,CAAC,YAAY,CAAC,GAAG,CAAA,CAAE,CAAA;oBACtB,0BAA0B,CAAC,aAAa,EAAE,GAAG,CAAC,YAAY,CAAC,CAAC,CAAA;oBAC5D,OAAO,GAAG,CAAA;gBACd,CAAC;gBACD,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,KAAK,CAAA;gBAC9B,OAAO,GAAG,CAAA;YACd,CAAC,CAAA;YACD,OAAO,0BAA0B,CAAC,aAAa,EAAE,CAAA,CAAE,CAAC,CAAA;QACxD,CAAC,MAAM,CAAC;YACJ,0FAA0F;YAC1F,OAAO;gBAAE,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,KAAK;YAAA,CAAE,CAAA;QACzC,CAAC;IACL,CAAC;IAED,wEAAwE;IACxE,kBAAkB;IAClB,wEAAwE;IAExE;;;OAGG,CACH,KAAK,GAAA;QACD,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAA;IAChD,CAAC;IAED;;;OAGG,CACH,mBAAmB,CAAC,GAAG,WAAiC,EAAA;QACpD,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,CAAA;IACzC,CAAC;IAED;;;OAGG,CACH,mBAAmB,CACf,cAAgC,EAAE,EAClC,qBAAuC,EAAE,EAAA;QAEzC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAA;QAC9B,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAA;QAC5C,IAAI,CAAC,QAAQ,GACT,IAAI,CAAC,WAAW,IACf,CAAC,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,UAAU,CAAC,IACnC,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;QACpC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAA;QACvD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,UAAU,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAA;QAC3D,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,QAAQ,CAAA;QAC3D,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,YAAY,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAA;QAC/D,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,eAAe,CAAA;IACpE,CAAC;IAED;;;OAGG,CACH,8BAA8B,CAAC,sBAAsC,EAAA;QACjE,IAAI,CAAC,sBAAsB,GAAG,sBAAsB,CAAA;QACpD,IAAI,CAAC,aAAa,GAAG,sBAAsB,CAAC,SAAS,CAAA;QACrD,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,IAAI,CAAC,eAAe,CAAC,sBAAsB,GAAG,sBAAsB,CAAA;YACpE,IAAI,CAAC,aAAa,GAAG,sBAAsB,CAAC,SAAS,CAAA;QACzD,CAAC;IACL,CAAC;IAED;;;OAGG,CACH,4BAA4B,GAAA;QACxB,IAAI,IAAI,CAAC,+BAA+B,EAAE,CAAC;YACvC,MAAM,wBAAwB,GAC1B,IAAI,CAAC,qBAAqB,CAAC,aAAa,CAAA;YAC5C,IAAI,OAAO,IAAI,CAAC,+BAA+B,KAAK,UAAU,EAC1D,OAAO,IAAI,CAAC,+BAA+B,CACvC,wBAAwB,CAC3B,CAAA;YAEL,IAAI,OAAO,IAAI,CAAC,+BAA+B,KAAK,QAAQ,EACxD,OAAO,IAAI,CAAC,+BAA+B,CAAA;QACnD,CAAC,MAAM,IACH,IAAI,CAAC,YAAY,IACjB,IAAI,CAAC,cAAc,CAAC,oBAAoB,EAC1C,CAAC;YACC,OAAO,IAAI,CAAC,cAAc,CAAC,oBAAoB,CAAC,YAAY,CAAA;QAChE,CAAC,MAAM,IACH,IAAI,CAAC,cAAc,IACnB,IAAI,CAAC,cAAc,CAAC,kBAAkB,EACxC,CAAC;YACC,OAAO,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,YAAY,CAAA;QAC9D,CAAC;QAED,OAAO,EAAE,CAAA;IACb,CAAC;IAED;;OAEG,CACH,iBAAiB,GAAA;QACb,IACI,CAAC,IAAI,CAAC,gBAAgB,IACtB,CAAC,IAAI,CAAC,gBAAgB,CAAC,mBAAmB,CAAC,MAAM,EAEjD,OAAO,IAAI,CAAC,YAAY,CAAA;QAE5B,OAAO,AACH,IAAI,CAAC,gBAAgB,CAAC,mBAAmB,CAAC,IAAI,CAAC,GAAG,CAAC,GACnD,GAAG,GACH,IAAI,CAAC,YAAY,CACpB,CAAA;IACL,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 1512, "column": 0}, "map": {"version":3,"file":"EmbeddedMetadata.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/metadata/EmbeddedMetadata.ts"],"sourceRoot":"..","sourcesContent":["import { ColumnMetadata } from \"./ColumnMetadata\"\nimport { RelationMetadata } from \"./RelationMetadata\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { EmbeddedMetadataArgs } from \"../metadata-args/EmbeddedMetadataArgs\"\nimport { RelationIdMetadata } from \"./RelationIdMetadata\"\nimport { RelationCountMetadata } from \"./RelationCountMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { EntityListenerMetadata } from \"./EntityListenerMetadata\"\nimport { IndexMetadata } from \"./IndexMetadata\"\nimport { UniqueMetadata } from \"./UniqueMetadata\"\nimport { TypeORMError } from \"../error\"\n\n/**\n * Contains all information about entity's embedded property.\n */\nexport class EmbeddedMetadata {\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata where this embedded is.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Parent embedded in the case if this embedded inside other embedded.\n     */\n    parentEmbeddedMetadata?: EmbeddedMetadata\n\n    /**\n     * Embedded target type.\n     */\n    type: Function | string\n\n    /**\n     * Property name on which this embedded is attached.\n     */\n    propertyName: string\n\n    /**\n     * Gets full path to this embedded property (including embedded property name).\n     * Full path is relevant when embedded is used inside other embeds (one or multiple nested).\n     * For example it will return \"counters.subcounters\".\n     */\n    propertyPath: string\n\n    /**\n     * Columns inside this embed.\n     */\n    columns: ColumnMetadata[] = []\n\n    /**\n     * Relations inside this embed.\n     */\n    relations: RelationMetadata[] = []\n\n    /**\n     * Entity listeners inside this embed.\n     */\n    listeners: EntityListenerMetadata[] = []\n\n    /**\n     * Indices applied to the embed columns.\n     */\n    indices: IndexMetadata[] = []\n\n    /**\n     * Uniques applied to the embed columns.\n     */\n    uniques: UniqueMetadata[] = []\n\n    /**\n     * Relation ids inside this embed.\n     */\n    relationIds: RelationIdMetadata[] = []\n\n    /**\n     * Relation counts inside this embed.\n     */\n    relationCounts: RelationCountMetadata[] = []\n\n    /**\n     * Nested embeddable in this embeddable (which has current embedded as parent embedded).\n     */\n    embeddeds: EmbeddedMetadata[] = []\n\n    /**\n     * Indicates if the entity should be instantiated using the constructor\n     * or via allocating a new object via `Object.create()`.\n     */\n    isAlwaysUsingConstructor: boolean = true\n\n    /**\n     * Indicates if this embedded is in array mode.\n     *\n     * This option works only in mongodb.\n     */\n    isArray: boolean = false\n\n    /**\n     * Prefix of the embedded, used instead of propertyName.\n     * If set to empty string or false, then prefix is not set at all.\n     */\n    customPrefix: string | boolean | undefined\n\n    /**\n     * Gets the prefix of the columns.\n     * By default its a property name of the class where this prefix is.\n     * But if custom prefix is set then it takes its value as a prefix.\n     * However if custom prefix is set to empty string or false, then prefix to column is not applied at all.\n     */\n    prefix: string\n\n    /**\n     * Returns array of property names of current embed and all its parent embeds.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * we need to get value of \"id\" column from the post real entity object.\n     * this method will return [\"data\", \"information\", \"counters\"]\n     */\n    parentPropertyNames: string[] = []\n\n    /**\n     * Returns array of prefixes of current embed and all its parent embeds.\n     */\n    parentPrefixes: string[] = []\n\n    /**\n     * Returns embed metadatas from all levels of the parent tree.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]\n     */\n    embeddedMetadataTree: EmbeddedMetadata[] = []\n\n    /**\n     * Embed metadatas from all levels of the parent tree.\n     *\n     * example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\n     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]\n     */\n    columnsFromTree: ColumnMetadata[] = []\n\n    /**\n     * Relations of this embed and all relations from its child embeds.\n     */\n    relationsFromTree: RelationMetadata[] = []\n\n    /**\n     * Relations of this embed and all relations from its child embeds.\n     */\n    listenersFromTree: EntityListenerMetadata[] = []\n\n    /**\n     * Indices of this embed and all indices from its child embeds.\n     */\n    indicesFromTree: IndexMetadata[] = []\n\n    /**\n     * Uniques of this embed and all uniques from its child embeds.\n     */\n    uniquesFromTree: UniqueMetadata[] = []\n\n    /**\n     * Relation ids of this embed and all relation ids from its child embeds.\n     */\n    relationIdsFromTree: RelationIdMetadata[] = []\n\n    /**\n     * Relation counts of this embed and all relation counts from its child embeds.\n     */\n    relationCountsFromTree: RelationCountMetadata[] = []\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        args: EmbeddedMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.type = options.args.type()\n        this.propertyName = options.args.propertyName\n        this.customPrefix = options.args.prefix\n        this.isArray = options.args.isArray\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Creates a new embedded object.\n     */\n    create(options?: { fromDeserializer?: boolean }): any {\n        if (!(typeof this.type === \"function\")) {\n            return {}\n        }\n\n        if (options?.fromDeserializer || !this.isAlwaysUsingConstructor) {\n            return Object.create(this.type.prototype)\n        } else {\n            return new (this.type as any)()\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n\n    build(connection: DataSource): this {\n        this.embeddeds.forEach((embedded) => embedded.build(connection))\n        this.prefix = this.buildPrefix(connection)\n        this.parentPropertyNames = this.buildParentPropertyNames()\n        this.parentPrefixes = this.buildParentPrefixes()\n        this.propertyPath = this.parentPropertyNames.join(\".\")\n        this.embeddedMetadataTree = this.buildEmbeddedMetadataTree()\n        this.columnsFromTree = this.buildColumnsFromTree()\n        this.relationsFromTree = this.buildRelationsFromTree()\n        this.listenersFromTree = this.buildListenersFromTree()\n        this.indicesFromTree = this.buildIndicesFromTree()\n        this.uniquesFromTree = this.buildUniquesFromTree()\n        this.relationIdsFromTree = this.buildRelationIdsFromTree()\n        this.relationCountsFromTree = this.buildRelationCountsFromTree()\n\n        if (connection.options.entitySkipConstructor) {\n            this.isAlwaysUsingConstructor =\n                !connection.options.entitySkipConstructor\n        }\n\n        return this\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    protected buildPartialPrefix(): string[] {\n        // if prefix option was not set or explicitly set to true - default prefix\n        if (this.customPrefix === undefined || this.customPrefix === true) {\n            return [this.propertyName]\n        }\n\n        // if prefix option was set to empty string or explicity set to false - disable prefix\n        if (this.customPrefix === \"\" || this.customPrefix === false) {\n            return []\n        }\n\n        // use custom prefix\n        if (typeof this.customPrefix === \"string\") {\n            return [this.customPrefix]\n        }\n\n        throw new TypeORMError(\n            `Invalid prefix option given for ${this.entityMetadata.targetName}#${this.propertyName}`,\n        )\n    }\n\n    protected buildPrefix(connection: DataSource): string {\n        if (connection.driver.options.type === \"mongodb\")\n            return this.propertyName\n\n        const prefixes: string[] = []\n        if (this.parentEmbeddedMetadata)\n            prefixes.push(this.parentEmbeddedMetadata.buildPrefix(connection))\n\n        prefixes.push(...this.buildPartialPrefix())\n\n        return prefixes.join(\"_\") // todo: use naming strategy instead of \"_\"  !!!\n    }\n\n    protected buildParentPropertyNames(): string[] {\n        return this.parentEmbeddedMetadata\n            ? this.parentEmbeddedMetadata\n                  .buildParentPropertyNames()\n                  .concat(this.propertyName)\n            : [this.propertyName]\n    }\n\n    protected buildParentPrefixes(): string[] {\n        return this.parentEmbeddedMetadata\n            ? this.parentEmbeddedMetadata\n                  .buildParentPrefixes()\n                  .concat(this.buildPartialPrefix())\n            : this.buildPartialPrefix()\n    }\n\n    protected buildEmbeddedMetadataTree(): EmbeddedMetadata[] {\n        return this.parentEmbeddedMetadata\n            ? this.parentEmbeddedMetadata\n                  .buildEmbeddedMetadataTree()\n                  .concat(this)\n            : [this]\n    }\n\n    protected buildColumnsFromTree(): ColumnMetadata[] {\n        return this.embeddeds.reduce(\n            (columns, embedded) =>\n                columns.concat(embedded.buildColumnsFromTree()),\n            this.columns,\n        )\n    }\n\n    protected buildRelationsFromTree(): RelationMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildRelationsFromTree()),\n            this.relations,\n        )\n    }\n\n    protected buildListenersFromTree(): EntityListenerMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildListenersFromTree()),\n            this.listeners,\n        )\n    }\n\n    protected buildIndicesFromTree(): IndexMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildIndicesFromTree()),\n            this.indices,\n        )\n    }\n\n    protected buildUniquesFromTree(): UniqueMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildUniquesFromTree()),\n            this.uniques,\n        )\n    }\n\n    protected buildRelationIdsFromTree(): RelationIdMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildRelationIdsFromTree()),\n            this.relationIds,\n        )\n    }\n\n    protected buildRelationCountsFromTree(): RelationCountMetadata[] {\n        return this.embeddeds.reduce(\n            (relations, embedded) =>\n                relations.concat(embedded.buildRelationCountsFromTree()),\n            this.relationCounts,\n        )\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1709, "column": 0}, "map": {"version":3,"file":"RelationIdMetadata.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/metadata/RelationIdMetadata.ts"],"sourceRoot":"..","sourcesContent":["import { RelationIdMetadataArgs } from \"../metadata-args/RelationIdMetadataArgs\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { RelationMetadata } from \"./RelationMetadata\"\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { TypeORMError } from \"../error\"\n\n/**\n * Contains all information about entity's relation count.\n */\nexport class RelationIdMetadata {\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata where this column metadata is.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Relation from which ids will be extracted.\n     */\n    relation: RelationMetadata\n\n    /**\n     * Relation name which need to count.\n     */\n    relationNameOrFactory: string | ((object: any) => any)\n\n    /**\n     * Target class to which metadata is applied.\n     */\n    target: Function | string\n\n    /**\n     * Target's property name to which this metadata is applied.\n     */\n    propertyName: string\n\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias?: string\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    queryBuilderFactory?: (\n        qb: SelectQueryBuilder<any>,\n    ) => SelectQueryBuilder<any>\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        args: RelationIdMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.target = options.args.target\n        this.propertyName = options.args.propertyName\n        this.relationNameOrFactory = options.args.relation\n        this.alias = options.args.alias\n        this.queryBuilderFactory = options.args.queryBuilderFactory\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Sets relation id value from the given entity.\n     *\n     * todo: make it to work in embeds as well.\n     */\n    setValue(entity: ObjectLiteral) {\n        const inverseEntity = this.relation.getEntityValue(entity)\n\n        if (Array.isArray(inverseEntity)) {\n            entity[this.propertyName] = inverseEntity\n                .map((item) => {\n                    return this.relation.inverseEntityMetadata.getEntityIdMixedMap(\n                        item,\n                    )\n                })\n                .filter((item) => item !== null && item !== undefined)\n        } else {\n            const value =\n                this.relation.inverseEntityMetadata.getEntityIdMixedMap(\n                    inverseEntity,\n                )\n            if (value !== undefined) entity[this.propertyName] = value\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Builder Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds some depend relation id properties.\n     * This builder method should be used only after entity metadata, its properties map and all relations are build.\n     */\n    build() {\n        const propertyPath =\n            typeof this.relationNameOrFactory === \"function\"\n                ? this.relationNameOrFactory(this.entityMetadata.propertiesMap)\n                : this.relationNameOrFactory\n        const relation =\n            this.entityMetadata.findRelationWithPropertyPath(propertyPath)\n        if (!relation)\n            throw new TypeORMError(\n                `Cannot find relation ${propertyPath}. Wrong relation specified for @RelationId decorator.`,\n            )\n\n        this.relation = relation\n    }\n}\n"],"names":[],"mappings":";;;;AAKA,OAAO,EAAE,YAAY,EAAE,MAAM,UAAU,CAAA;;AAKjC,MAAO,kBAAkB;IA0C3B,wEAAwE;IACxE,cAAc;IACd,wEAAwE;IAExE,YAAY,OAGX,CAAA;QACG,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAA;QAC5C,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,MAAM,CAAA;QACjC,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC,YAAY,CAAA;QAC7C,IAAI,CAAC,qBAAqB,GAAG,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAA;QAClD,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAA;QAC/B,IAAI,CAAC,mBAAmB,GAAG,OAAO,CAAC,IAAI,CAAC,mBAAmB,CAAA;IAC/D,CAAC;IAED,wEAAwE;IACxE,iBAAiB;IACjB,wEAAwE;IAExE;;;;OAIG,CACH,QAAQ,CAAC,MAAqB,EAAA;QAC1B,MAAM,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA;QAE1D,IAAI,KAAK,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE,CAAC;YAC/B,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,aAAa,CACpC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;gBACV,OAAO,IAAI,CAAC,QAAQ,CAAC,qBAAqB,CAAC,mBAAmB,CAC1D,IAAI,CACP,CAAA;YACL,CAAC,CAAC,CACD,MAAM,CAAC,CAAC,IAAI,EAAE,CAAG,CAAD,GAAK,KAAK,IAAI,IAAI,IAAI,KAAK,SAAS,CAAC,CAAA;QAC9D,CAAC,MAAM,CAAC;YACJ,MAAM,KAAK,GACP,IAAI,CAAC,QAAQ,CAAC,qBAAqB,CAAC,mBAAmB,CACnD,aAAa,CAChB,CAAA;YACL,IAAI,KAAK,KAAK,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,KAAK,CAAA;QAC9D,CAAC;IACL,CAAC;IAED,wEAAwE;IACxE,yBAAyB;IACzB,wEAAwE;IAExE;;;OAGG,CACH,KAAK,GAAA;QACD,MAAM,YAAY,GACd,OAAO,IAAI,CAAC,qBAAqB,KAAK,UAAU,GAC1C,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,GAC7D,IAAI,CAAC,qBAAqB,CAAA;QACpC,MAAM,QAAQ,GACV,IAAI,CAAC,cAAc,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;QAClE,IAAI,CAAC,QAAQ,EACT,MAAM,wKAAI,eAAY,CAClB,CAAA,qBAAA,EAAwB,YAAY,CAAA,qDAAA,CAAuD,CAC9F,CAAA;QAEL,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAA;IAC5B,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 1764, "column": 0}, "map": {"version":3,"file":"RelationCountMetadata.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/metadata/RelationCountMetadata.ts"],"sourceRoot":"..","sourcesContent":["import { RelationCountMetadataArgs } from \"../metadata-args/RelationCountMetadataArgs\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { RelationMetadata } from \"./RelationMetadata\"\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\"\nimport { TypeORMError } from \"../error\"\n\n/**\n * Contains all information about entity's relation count.\n */\nexport class RelationCountMetadata {\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata where this column metadata is.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Relation which needs to be counted.\n     */\n    relation: RelationMetadata\n\n    /**\n     * Relation name which need to count.\n     */\n    relationNameOrFactory: string | ((object: any) => any)\n\n    /**\n     * Target class to which metadata is applied.\n     */\n    target: Function | string\n\n    /**\n     * Target's property name to which this metadata is applied.\n     */\n    propertyName: string\n\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias?: string\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    queryBuilderFactory?: (\n        qb: SelectQueryBuilder<any>,\n    ) => SelectQueryBuilder<any>\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        args: RelationCountMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.target = options.args.target\n        this.propertyName = options.args.propertyName\n        this.relationNameOrFactory = options.args.relation\n        this.alias = options.args.alias\n        this.queryBuilderFactory = options.args.queryBuilderFactory\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Builder Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds some depend relation count metadata properties.\n     * This builder method should be used only after entity metadata, its properties map and all relations are build.\n     */\n    build() {\n        const propertyPath =\n            typeof this.relationNameOrFactory === \"function\"\n                ? this.relationNameOrFactory(this.entityMetadata.propertiesMap)\n                : this.relationNameOrFactory\n        const relation =\n            this.entityMetadata.findRelationWithPropertyPath(propertyPath)\n        if (!relation)\n            throw new TypeORMError(\n                `Cannot find relation ${propertyPath}. Wrong relation specified for @RelationCount decorator.`,\n            )\n\n        this.relation = relation\n    }\n}\n"],"names":[],"mappings":";;;;AAIA,OAAO,EAAE,YAAY,EAAE,MAAM,UAAU,CAAA;;AAKjC,MAAO,qBAAqB;IA0C9B,wEAAwE;IACxE,cAAc;IACd,wEAAwE;IAExE,YAAY,OAGX,CAAA;QACG,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAA;QAC5C,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,MAAM,CAAA;QACjC,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC,YAAY,CAAA;QAC7C,IAAI,CAAC,qBAAqB,GAAG,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAA;QAClD,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAA;QAC/B,IAAI,CAAC,mBAAmB,GAAG,OAAO,CAAC,IAAI,CAAC,mBAAmB,CAAA;IAC/D,CAAC;IAED,wEAAwE;IACxE,yBAAyB;IACzB,wEAAwE;IAExE;;;OAGG,CACH,KAAK,GAAA;QACD,MAAM,YAAY,GACd,OAAO,IAAI,CAAC,qBAAqB,KAAK,UAAU,GAC1C,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,GAC7D,IAAI,CAAC,qBAAqB,CAAA;QACpC,MAAM,QAAQ,GACV,IAAI,CAAC,cAAc,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;QAClE,IAAI,CAAC,QAAQ,EACT,MAAM,wKAAI,eAAY,CAClB,CAAA,qBAAA,EAAwB,YAAY,CAAA,wDAAA,CAA0D,CACjG,CAAA;QAEL,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAA;IAC5B,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 1801, "column": 0}, "map": {"version":3,"file":"EventListenerTypes.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/metadata/browser/src/metadata/types/EventListenerTypes.ts"],"sourceRoot":"../..","sourcesContent":["/**\n * All types that entity listener can be.\n */\nexport type EventListenerType =\n    | \"after-load\"\n    | \"before-insert\"\n    | \"after-insert\"\n    | \"before-update\"\n    | \"after-update\"\n    | \"before-remove\"\n    | \"after-remove\"\n    | \"before-soft-remove\"\n    | \"after-soft-remove\"\n    | \"before-recover\"\n    | \"after-recover\"\n\n/**\n * Provides a constants for each entity listener type.\n */\nexport class EventListenerTypes {\n    static AFTER_LOAD = \"after-load\" as const\n    static BEFORE_INSERT = \"before-insert\" as const\n    static AFTER_INSERT = \"after-insert\" as const\n    static BEFORE_UPDATE = \"before-update\" as const\n    static AFTER_UPDATE = \"after-update\" as const\n    static BEFORE_REMOVE = \"before-remove\" as const\n    static AFTER_REMOVE = \"after-remove\" as const\n    static BEFORE_SOFT_REMOVE = \"before-soft-remove\" as const\n    static AFTER_SOFT_REMOVE = \"after-soft-remove\" as const\n    static BEFORE_RECOVER = \"before-recover\" as const\n    static AFTER_RECOVER = \"after-recover\" as const\n}\n"],"names":[],"mappings":"AAgBA;;GAEG;;;AACG,MAAO,kBAAkB;;AACpB,mBAAA,UAAU,GAAG,YAAqB,CAAA;AAClC,mBAAA,aAAa,GAAG,eAAwB,CAAA;AACxC,mBAAA,YAAY,GAAG,cAAuB,CAAA;AACtC,mBAAA,aAAa,GAAG,eAAwB,CAAA;AACxC,mBAAA,YAAY,GAAG,cAAuB,CAAA;AACtC,mBAAA,aAAa,GAAG,eAAwB,CAAA;AACxC,mBAAA,YAAY,GAAG,cAAuB,CAAA;AACtC,mBAAA,kBAAkB,GAAG,oBAA6B,CAAA;AAClD,mBAAA,iBAAiB,GAAG,mBAA4B,CAAA;AAChD,mBAAA,cAAc,GAAG,gBAAyB,CAAA;AAC1C,mBAAA,aAAa,GAAG,eAAwB,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1825, "column": 0}, "map": {"version":3,"file":"ForeignKeyMetadata.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/metadata/ForeignKeyMetadata.ts"],"sourceRoot":"..","sourcesContent":["import { ColumnMetadata } from \"./ColumnMetadata\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { NamingStrategyInterface } from \"../naming-strategy/NamingStrategyInterface\"\nimport { DeferrableType } from \"./types/DeferrableType\"\nimport { OnDeleteType } from \"./types/OnDeleteType\"\nimport { OnUpdateType } from \"./types/OnUpdateType\"\n\n/**\n * Contains all information about entity's foreign key.\n */\nexport class ForeignKeyMetadata {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Entity metadata where this foreign key is.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Entity metadata which this foreign key references.\n     */\n    referencedEntityMetadata: EntityMetadata\n\n    /**\n     * Array of columns of this foreign key.\n     */\n    columns: ColumnMetadata[] = []\n\n    /**\n     * Array of referenced columns.\n     */\n    referencedColumns: ColumnMetadata[] = []\n\n    /**\n     * What to do with a relation on deletion of the row containing a foreign key.\n     */\n    onDelete?: OnDeleteType\n\n    /**\n     * What to do with a relation on update of the row containing a foreign key.\n     */\n    onUpdate?: OnUpdateType\n\n    /**\n     * When to check the constraints of a foreign key.\n     */\n    deferrable?: DeferrableType\n\n    /**\n     * Gets the table name to which this foreign key is referenced.\n     */\n    referencedTablePath: string\n\n    /**\n     * Gets foreign key name.\n     * If unique constraint name was given by a user then it stores givenName.\n     * If unique constraint name was not given then its generated.\n     */\n    name: string\n\n    /**\n     * Gets array of column names.\n     */\n    columnNames: string[] = []\n\n    /**\n     * Gets array of referenced column names.\n     */\n    referencedColumnNames: string[] = []\n\n    /**\n     * User specified unique constraint name.\n     */\n    givenName?: string\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        referencedEntityMetadata: EntityMetadata\n        namingStrategy?: NamingStrategyInterface\n        columns: ColumnMetadata[]\n        referencedColumns: ColumnMetadata[]\n        onDelete?: OnDeleteType\n        onUpdate?: OnUpdateType\n        deferrable?: DeferrableType\n        name?: string\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.referencedEntityMetadata = options.referencedEntityMetadata\n        this.columns = options.columns\n        this.referencedColumns = options.referencedColumns\n        this.onDelete = options.onDelete || \"NO ACTION\"\n        this.onUpdate = options.onUpdate || \"NO ACTION\"\n        this.deferrable = options.deferrable\n        this.givenName = options.name\n        if (options.namingStrategy) this.build(options.namingStrategy)\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds some depend foreign key properties.\n     * Must be called after all entity metadatas and their columns are built.\n     */\n    build(namingStrategy: NamingStrategyInterface) {\n        this.columnNames = this.columns.map((column) => column.databaseName)\n        this.referencedColumnNames = this.referencedColumns.map(\n            (column) => column.databaseName,\n        )\n        this.referencedTablePath = this.referencedEntityMetadata.tablePath\n        this.name = this.givenName\n            ? this.givenName\n            : namingStrategy.foreignKeyName(\n                  this.entityMetadata.tableName,\n                  this.columnNames,\n                  this.referencedEntityMetadata.tableName,\n                  this.referencedColumnNames,\n              )\n    }\n}\n"],"names":[],"mappings":"AAOA;;GAEG;;;AACG,MAAO,kBAAkB;IAmE3B,wEAAwE;IACxE,cAAc;IACd,wEAAwE;IAExE,YAAY,OAUX,CAAA;QAlED;;WAEG,CACH,IAAA,CAAA,OAAO,GAAqB,EAAE,CAAA;QAE9B;;WAEG,CACH,IAAA,CAAA,iBAAiB,GAAqB,EAAE,CAAA;QA6BxC;;WAEG,CACH,IAAA,CAAA,WAAW,GAAa,EAAE,CAAA;QAE1B;;WAEG,CACH,IAAA,CAAA,qBAAqB,GAAa,EAAE,CAAA;QAsBhC,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAA;QAC5C,IAAI,CAAC,wBAAwB,GAAG,OAAO,CAAC,wBAAwB,CAAA;QAChE,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAA;QAC9B,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,iBAAiB,CAAA;QAClD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,WAAW,CAAA;QAC/C,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,WAAW,CAAA;QAC/C,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAA;QACpC,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,IAAI,CAAA;QAC7B,IAAI,OAAO,CAAC,cAAc,EAAE,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,CAAA;IAClE,CAAC;IAED,wEAAwE;IACxE,iBAAiB;IACjB,wEAAwE;IAExE;;;OAGG,CACH,KAAK,CAAC,cAAuC,EAAA;QACzC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,YAAY,CAAC,CAAA;QACpE,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CACnD,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,YAAY,CAClC,CAAA;QACD,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,wBAAwB,CAAC,SAAS,CAAA;QAClE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,SAAS,GACpB,IAAI,CAAC,SAAS,GACd,cAAc,CAAC,cAAc,CACzB,IAAI,CAAC,cAAc,CAAC,SAAS,EAC7B,IAAI,CAAC,WAAW,EAChB,IAAI,CAAC,wBAAwB,CAAC,SAAS,EACvC,IAAI,CAAC,qBAAqB,CAC7B,CAAA;IACX,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 1876, "column": 0}, "map": {"version":3,"file":"UniqueMetadata.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/metadata/UniqueMetadata.ts"],"sourceRoot":"..","sourcesContent":["import { EmbeddedMetadata } from \"./EmbeddedMetadata\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { NamingStrategyInterface } from \"../naming-strategy/NamingStrategyInterface\"\nimport { ColumnMetadata } from \"./ColumnMetadata\"\nimport { UniqueMetadataArgs } from \"../metadata-args/UniqueMetadataArgs\"\nimport { TypeORMError } from \"../error\"\nimport { DeferrableType } from \"./types/DeferrableType\"\n\n/**\n * Unique metadata contains all information about table's unique constraints.\n */\nexport class UniqueMetadata {\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the class to which this unique constraint is applied.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Embedded metadata if this unique was applied on embedded.\n     */\n    embeddedMetadata?: EmbeddedMetadata\n\n    /**\n     * Target class to which metadata is applied.\n     */\n    target?: Function | string\n\n    /**\n     * Unique columns.\n     */\n    columns: ColumnMetadata[] = []\n\n    /**\n     * Indicate if unique constraints can be deferred.\n     */\n    deferrable?: DeferrableType\n\n    /**\n     * User specified unique constraint name.\n     */\n    givenName?: string\n\n    /**\n     * User specified column names.\n     */\n    givenColumnNames?:\n        | ((object?: any) => any[] | { [key: string]: number })\n        | string[]\n\n    /**\n     * Final unique constraint name.\n     * If unique constraint name was given by a user then it stores normalized (by naming strategy) givenName.\n     * If unique constraint name was not given then its generated.\n     */\n    name: string\n\n    /**\n     * Map of column names with order set.\n     * Used only by MongoDB driver.\n     */\n    columnNamesWithOrderingMap: { [key: string]: number } = {}\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        embeddedMetadata?: EmbeddedMetadata\n        columns?: ColumnMetadata[]\n        args?: UniqueMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.embeddedMetadata = options.embeddedMetadata\n        if (options.columns) this.columns = options.columns\n\n        if (options.args) {\n            this.target = options.args.target\n            this.givenName = options.args.name\n            this.givenColumnNames = options.args.columns\n            this.deferrable = options.args.deferrable\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Build Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds some depend unique constraint properties.\n     * Must be called after all entity metadata's properties map, columns and relations are built.\n     */\n    build(namingStrategy: NamingStrategyInterface): this {\n        const map: { [key: string]: number } = {}\n\n        // if columns already an array of string then simply return it\n        if (this.givenColumnNames) {\n            let columnPropertyPaths: string[] = []\n            if (Array.isArray(this.givenColumnNames)) {\n                columnPropertyPaths = this.givenColumnNames.map(\n                    (columnName) => {\n                        if (this.embeddedMetadata)\n                            return (\n                                this.embeddedMetadata.propertyPath +\n                                \".\" +\n                                columnName\n                            )\n\n                        return columnName.trim()\n                    },\n                )\n                columnPropertyPaths.forEach(\n                    (propertyPath) => (map[propertyPath] = 1),\n                )\n            } else {\n                // if columns is a function that returns array of field names then execute it and get columns names from it\n                const columnsFnResult = this.givenColumnNames(\n                    this.entityMetadata.propertiesMap,\n                )\n                if (Array.isArray(columnsFnResult)) {\n                    columnPropertyPaths = columnsFnResult.map((i: any) =>\n                        String(i),\n                    )\n                    columnPropertyPaths.forEach((name) => (map[name] = 1))\n                } else {\n                    columnPropertyPaths = Object.keys(columnsFnResult).map(\n                        (i: any) => String(i),\n                    )\n                    Object.keys(columnsFnResult).forEach(\n                        (columnName) =>\n                            (map[columnName] = columnsFnResult[columnName]),\n                    )\n                }\n            }\n\n            this.columns = columnPropertyPaths\n                .map((propertyName) => {\n                    const columnWithSameName = this.entityMetadata.columns.find(\n                        (column) => column.propertyPath === propertyName,\n                    )\n                    if (columnWithSameName) {\n                        return [columnWithSameName]\n                    }\n                    const relationWithSameName =\n                        this.entityMetadata.relations.find(\n                            (relation) =>\n                                relation.isWithJoinColumn &&\n                                relation.propertyName === propertyName,\n                        )\n                    if (relationWithSameName) {\n                        return relationWithSameName.joinColumns\n                    }\n                    const indexName = this.givenName\n                        ? '\"' + this.givenName + '\" '\n                        : \"\"\n                    const entityName = this.entityMetadata.targetName\n                    throw new TypeORMError(\n                        `Unique constraint ${indexName}contains column that is missing in the entity (${entityName}): ` +\n                            propertyName,\n                    )\n                })\n                .reduce((a, b) => a.concat(b))\n        }\n\n        this.columnNamesWithOrderingMap = Object.keys(map).reduce(\n            (updatedMap, key) => {\n                const column = this.entityMetadata.columns.find(\n                    (column) => column.propertyPath === key,\n                )\n                if (column) updatedMap[column.databasePath] = map[key]\n\n                return updatedMap\n            },\n            {} as { [key: string]: number },\n        )\n\n        this.name = this.givenName\n            ? this.givenName\n            : namingStrategy.uniqueConstraintName(\n                  this.entityMetadata.tableName,\n                  this.columns.map((column) => column.databaseName),\n              )\n        return this\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1963, "column": 0}, "map": {"version":3,"file":"EntityListenerMetadata.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/metadata/EntityListenerMetadata.ts"],"sourceRoot":"..","sourcesContent":["import { EventListenerType } from \"./types/EventListenerTypes\"\nimport { EntityListenerMetadataArgs } from \"../metadata-args/EntityListenerMetadataArgs\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { EntityMetadata } from \"./EntityMetadata\"\nimport { EmbeddedMetadata } from \"./EmbeddedMetadata\"\n\n/**\n * This metadata contains all information about entity's listeners.\n */\nexport class EntityListenerMetadata {\n    // ---------------------------------------------------------------------\n    // Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the listener.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Embedded metadata of the listener, in the case if listener is in embedded.\n     */\n    embeddedMetadata?: EmbeddedMetadata\n\n    /**\n     * Target class to which metadata is applied.\n     * This can be different then entityMetadata.target in the case if listener is in the embedded.\n     */\n    target: Function | string\n\n    /**\n     * Target's property name to which this metadata is applied.\n     */\n    propertyName: string\n\n    /**\n     * The type of the listener.\n     */\n    type: EventListenerType\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        embeddedMetadata?: EmbeddedMetadata\n        args: EntityListenerMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n        this.embeddedMetadata = options.embeddedMetadata\n        this.target = options.args.target\n        this.propertyName = options.args.propertyName\n        this.type = options.args.type\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Checks if entity listener is allowed to be executed on the given entity.\n     */\n    isAllowed(entity: ObjectLiteral) {\n        // todo: create in entity metadata method like isInherited?\n        return (\n            this.entityMetadata.target === entity.constructor || // todo: .constructor won't work for entity schemas, but there are no entity listeners in schemas since there are no objects, right?\n            (typeof this.entityMetadata.target === \"function\" &&\n                entity.constructor.prototype instanceof\n                    this.entityMetadata.target)\n        ) // todo: also need to implement entity schema inheritance\n    }\n\n    /**\n     * Executes listener method of the given entity.\n     */\n    execute(entity: ObjectLiteral) {\n        // Check if the Embedded Metadata does not exist\n        if (!this.embeddedMetadata) {\n            // Get the Entity's Method\n            const entityMethod = entity[this.propertyName]\n\n            // Check if the Entity Method does not exist\n            if (!entityMethod)\n                throw new Error(\n                    `Entity listener method \"${this.propertyName}\" does not exist in entity \"${entity.constructor.name}\".`,\n                )\n\n            // Check if the Entity Method is not a function\n            if (typeof entityMethod !== \"function\")\n                throw new Error(\n                    `Entity listener method \"${this.propertyName}\" in entity \"${\n                        entity.constructor.name\n                    }\" must be a function but got \"${typeof entityMethod}\".`,\n                )\n\n            // Call and return the Entity Method\n            return entityMethod.call(entity)\n        }\n\n        // Call the Embedded Method\n        this.callEntityEmbeddedMethod(\n            entity,\n            this.embeddedMetadata.propertyPath.split(\".\"),\n        )\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Calls embedded entity listener method no matter how nested it is.\n     */\n    protected callEntityEmbeddedMethod(\n        entity: ObjectLiteral,\n        propertyPaths: string[],\n    ): void {\n        const propertyPath = propertyPaths.shift()\n        if (!propertyPath || !entity[propertyPath]) return\n\n        if (propertyPaths.length === 0) {\n            if (Array.isArray(entity[propertyPath])) {\n                entity[propertyPath].map((embedded: ObjectLiteral) =>\n                    embedded[this.propertyName](),\n                )\n            } else {\n                entity[propertyPath][this.propertyName]()\n            }\n        } else {\n            if (entity[propertyPath])\n                this.callEntityEmbeddedMethod(\n                    entity[propertyPath],\n                    propertyPaths,\n                )\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2030, "column": 0}, "map": {"version":3,"file":"CheckMetadata.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/metadata/CheckMetadata.ts"],"sourceRoot":"..","sourcesContent":["import { EntityMetadata } from \"./EntityMetadata\"\nimport { NamingStrategyInterface } from \"../naming-strategy/NamingStrategyInterface\"\nimport { CheckMetadataArgs } from \"../metadata-args/CheckMetadataArgs\"\n\n/**\n * Check metadata contains all information about table's check constraints.\n */\nexport class CheckMetadata {\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the class to which this check constraint is applied.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Target class to which metadata is applied.\n     */\n    target?: Function | string\n\n    /**\n     * Check expression.\n     */\n    expression: string\n\n    /**\n     * User specified check constraint name.\n     */\n    givenName?: string\n\n    /**\n     * Final check constraint name.\n     * If check constraint name was given by a user then it stores normalized (by naming strategy) givenName.\n     * If check constraint name was not given then its generated.\n     */\n    name: string\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        args?: CheckMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n\n        if (options.args) {\n            this.target = options.args.target\n            this.expression = options.args.expression\n            this.givenName = options.args.name\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Build Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds some depend check constraint properties.\n     * Must be called after all entity metadata's properties map, columns and relations are built.\n     */\n    build(namingStrategy: NamingStrategyInterface): this {\n        this.name = this.givenName\n            ? this.givenName\n            : namingStrategy.checkConstraintName(\n                  this.entityMetadata.tableName,\n                  this.expression,\n              )\n        return this\n    }\n}\n"],"names":[],"mappings":"AAIA;;GAEG;;;AACG,MAAO,aAAa;IAgCtB,wEAAwE;IACxE,cAAc;IACd,wEAAwE;IAExE,YAAY,OAGX,CAAA;QACG,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAA;QAE5C,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,MAAM,CAAA;YACjC,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,IAAI,CAAC,UAAU,CAAA;YACzC,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAA;QACtC,CAAC;IACL,CAAC;IAED,wEAAwE;IACxE,uBAAuB;IACvB,wEAAwE;IAExE;;;OAGG,CACH,KAAK,CAAC,cAAuC,EAAA;QACzC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,SAAS,GACpB,IAAI,CAAC,SAAS,GACd,cAAc,CAAC,mBAAmB,CAC9B,IAAI,CAAC,cAAc,CAAC,SAAS,EAC7B,IAAI,CAAC,UAAU,CAClB,CAAA;QACP,OAAO,IAAI,CAAA;IACf,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 2064, "column": 0}, "map": {"version":3,"file":"ExclusionMetadata.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/metadata/ExclusionMetadata.ts"],"sourceRoot":"..","sourcesContent":["import { EntityMetadata } from \"./EntityMetadata\"\nimport { NamingStrategyInterface } from \"../naming-strategy/NamingStrategyInterface\"\nimport { ExclusionMetadataArgs } from \"../metadata-args/ExclusionMetadataArgs\"\n\n/**\n * Exclusion metadata contains all information about table's exclusion constraints.\n */\nexport class ExclusionMetadata {\n    // ---------------------------------------------------------------------\n    // Public Properties\n    // ---------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the class to which this exclusion constraint is applied.\n     */\n    entityMetadata: EntityMetadata\n\n    /**\n     * Target class to which metadata is applied.\n     */\n    target?: Function | string\n\n    /**\n     * Exclusion expression.\n     */\n    expression: string\n\n    /**\n     * User specified exclusion constraint name.\n     */\n    givenName?: string\n\n    /**\n     * Final exclusion constraint name.\n     * If exclusion constraint name was given by a user then it stores normalized (by naming strategy) givenName.\n     * If exclusion constraint name was not given then its generated.\n     */\n    name: string\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        entityMetadata: EntityMetadata\n        args?: ExclusionMetadataArgs\n    }) {\n        this.entityMetadata = options.entityMetadata\n\n        if (options.args) {\n            this.target = options.args.target\n            this.expression = options.args.expression\n            this.givenName = options.args.name\n        }\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Build Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds some depend exclusion constraint properties.\n     * Must be called after all entity metadata's properties map, columns and relations are built.\n     */\n    build(namingStrategy: NamingStrategyInterface): this {\n        this.name = this.givenName\n            ? this.givenName\n            : namingStrategy.exclusionConstraintName(\n                  this.entityMetadata.tableName,\n                  this.expression,\n              )\n        return this\n    }\n}\n"],"names":[],"mappings":"AAIA;;GAEG;;;AACG,MAAO,iBAAiB;IAgC1B,wEAAwE;IACxE,cAAc;IACd,wEAAwE;IAExE,YAAY,OAGX,CAAA;QACG,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAA;QAE5C,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,MAAM,CAAA;YACjC,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,IAAI,CAAC,UAAU,CAAA;YACzC,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAA;QACtC,CAAC;IACL,CAAC;IAED,wEAAwE;IACxE,uBAAuB;IACvB,wEAAwE;IAExE;;;OAGG,CACH,KAAK,CAAC,cAAuC,EAAA;QACzC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,SAAS,GACpB,IAAI,CAAC,SAAS,GACd,cAAc,CAAC,uBAAuB,CAClC,IAAI,CAAC,cAAc,CAAC,SAAS,EAC7B,IAAI,CAAC,UAAU,CAClB,CAAA;QACP,OAAO,IAAI,CAAA;IACf,CAAC;CACJ","ignoreList":[0]}}]
}