{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"SubjectTopologicalSorter.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/persistence/SubjectTopologicalSorter.ts"],"sourceRoot":"..","sourcesContent":["import { Subject } from \"./Subject\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { TypeORMError } from \"../error\"\n\n/**\n * Orders insert or remove subjects in proper order (using topological sorting)\n * to make sure insert or remove operations are executed in a proper order.\n */\nexport class SubjectTopologicalSorter {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Insert subjects needs to be sorted.\n     */\n    subjects: Subject[]\n\n    /**\n     * Unique list of entity metadatas of this subject.\n     */\n    metadatas: EntityMetadata[]\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(subjects: Subject[]) {\n        this.subjects = [...subjects] // copy subjects to prevent changing of sent array\n        this.metadatas = this.getUniqueMetadatas(this.subjects)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sorts (orders) subjects in their topological order.\n     */\n    sort(direction: \"insert\" | \"delete\"): Subject[] {\n        // if there are no metadatas it probably mean there is no subjects... we don't have to do anything here\n        if (!this.metadatas.length) return this.subjects\n\n        const sortedSubjects: Subject[] = []\n\n        // first if we sort for deletion all junction subjects\n        // junction subjects are subjects without entity and database entity set\n        if (direction === \"delete\") {\n            const junctionSubjects = this.subjects.filter(\n                (subject) => !subject.entity && !subject.databaseEntity,\n            )\n            sortedSubjects.push(...junctionSubjects)\n            this.removeAlreadySorted(junctionSubjects)\n        }\n\n        // next we always insert entities with non-nullable relations, sort them first\n        const nonNullableDependencies = this.getNonNullableDependencies()\n        let sortedNonNullableEntityTargets = this.toposort(\n            nonNullableDependencies,\n        )\n        if (direction === \"insert\")\n            sortedNonNullableEntityTargets =\n                sortedNonNullableEntityTargets.reverse()\n\n        // so we have a sorted entity targets\n        // go thought each of them and find all subjects with sorted entity target\n        // add those sorted targets and remove them from original array of targets\n        sortedNonNullableEntityTargets.forEach((sortedEntityTarget) => {\n            const entityTargetSubjects = this.subjects.filter(\n                (subject) =>\n                    subject.metadata.targetName === sortedEntityTarget ||\n                    subject.metadata.inheritanceTree.some(\n                        (s) => s.name === sortedEntityTarget,\n                    ),\n            )\n            sortedSubjects.push(...entityTargetSubjects)\n            this.removeAlreadySorted(entityTargetSubjects)\n        })\n\n        // next sort all other entities\n        // same process as in above but with other entities\n        const otherDependencies: string[][] = this.getDependencies()\n        let sortedOtherEntityTargets = this.toposort(otherDependencies)\n        if (direction === \"insert\")\n            sortedOtherEntityTargets = sortedOtherEntityTargets.reverse()\n\n        sortedOtherEntityTargets.forEach((sortedEntityTarget) => {\n            const entityTargetSubjects = this.subjects.filter(\n                (subject) => subject.metadata.targetName === sortedEntityTarget,\n            )\n            sortedSubjects.push(...entityTargetSubjects)\n            this.removeAlreadySorted(entityTargetSubjects)\n        })\n\n        // if we have something left in the subjects add them as well\n        sortedSubjects.push(...this.subjects)\n        return sortedSubjects\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Removes already sorted subjects from this.subjects list of subjects.\n     */\n    protected removeAlreadySorted(subjects: Subject[]) {\n        subjects.forEach((subject) => {\n            this.subjects.splice(this.subjects.indexOf(subject), 1)\n        })\n    }\n\n    /**\n     * Extracts all unique metadatas from the given subjects.\n     */\n    protected getUniqueMetadatas(subjects: Subject[]) {\n        const metadatas: EntityMetadata[] = []\n        subjects.forEach((subject) => {\n            if (metadatas.indexOf(subject.metadata) === -1)\n                metadatas.push(subject.metadata)\n        })\n        return metadatas\n    }\n\n    /**\n     * Gets dependency tree for all entity metadatas with non-nullable relations.\n     * We need to execute insertions first for entities which non-nullable relations.\n     */\n    protected getNonNullableDependencies(): string[][] {\n        return this.metadatas.reduce((dependencies, metadata) => {\n            metadata.relationsWithJoinColumns.forEach((relation) => {\n                if (relation.isNullable) return\n\n                dependencies.push([\n                    metadata.targetName,\n                    relation.inverseEntityMetadata.targetName,\n                ])\n            })\n            return dependencies\n        }, [] as string[][])\n    }\n\n    /**\n     * Gets dependency tree for all entity metadatas with non-nullable relations.\n     * We need to execute insertions first for entities which non-nullable relations.\n     */\n    protected getDependencies(): string[][] {\n        return this.metadatas.reduce((dependencies, metadata) => {\n            metadata.relationsWithJoinColumns.forEach((relation) => {\n                // if relation is self-referenced we skip it\n                if (relation.inverseEntityMetadata === metadata) return\n\n                dependencies.push([\n                    metadata.targetName,\n                    relation.inverseEntityMetadata.targetName,\n                ])\n            })\n            return dependencies\n        }, [] as string[][])\n    }\n\n    /**\n     * Sorts given graph using topological sorting algorithm.\n     *\n     * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.\n     */\n    protected toposort(edges: any[][]) {\n        function uniqueNodes(arr: any[]) {\n            const res = []\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const edge: any = arr[i]\n                if (res.indexOf(edge[0]) < 0) res.push(edge[0])\n                if (res.indexOf(edge[1]) < 0) res.push(edge[1])\n            }\n            return res\n        }\n\n        const nodes = uniqueNodes(edges)\n        let cursor = nodes.length,\n            sorted = new Array(cursor),\n            visited: any = {},\n            i = cursor\n\n        while (i--) {\n            if (!visited[i]) visit(nodes[i], i, [])\n        }\n\n        function visit(node: any, i: number, predecessors: any[]) {\n            if (predecessors.indexOf(node) >= 0) {\n                throw new TypeORMError(\n                    \"Cyclic dependency: \" + JSON.stringify(node),\n                ) // todo: better error\n            }\n\n            if (!~nodes.indexOf(node)) {\n                throw new TypeORMError(\n                    \"Found unknown node. Make sure to provided all involved nodes. Unknown node: \" +\n                        JSON.stringify(node),\n                )\n            }\n\n            if (visited[i]) return\n            visited[i] = true\n\n            // outgoing edges\n            const outgoing = edges.filter(function (edge) {\n                return edge[0] === node\n            })\n            if ((i = outgoing.length)) {\n                const preds = predecessors.concat(node)\n                do {\n                    const child = outgoing[--i][1]\n                    visit(child, nodes.indexOf(child), preds)\n                } while (i)\n            }\n\n            sorted[--cursor] = node\n        }\n\n        return sorted\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"file":"SubjectChangedColumnsComputer.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/persistence/SubjectChangedColumnsComputer.ts"],"sourceRoot":"..","sourcesContent":["import { Subject } from \"./Subject\"\nimport { DateUtils } from \"../util/DateUtils\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\n\n/**\n * Finds what columns are changed in the subject entities.\n */\nexport class SubjectChangedColumnsComputer {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Finds what columns are changed in the subject entities.\n     */\n    compute(subjects: Subject[]) {\n        subjects.forEach((subject) => {\n            this.computeDiffColumns(subject)\n            this.computeDiffRelationalColumns(subjects, subject)\n        })\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Differentiate columns from the updated entity and entity stored in the database.\n     */\n    protected computeDiffColumns(subject: Subject): void {\n        // if there is no persisted entity then nothing to compute changed in it\n        if (!subject.entity) return\n\n        subject.metadata.columns.forEach((column) => {\n            // ignore special columns\n            if (\n                column.isVirtual ||\n                column.isDiscriminator // ||\n                // column.isUpdateDate ||\n                // column.isVersion ||\n                // column.isCreateDate\n            )\n                return\n\n            const changeMap = subject.changeMaps.find(\n                (changeMap) => changeMap.column === column,\n            )\n            if (changeMap) {\n                subject.changeMaps.splice(\n                    subject.changeMaps.indexOf(changeMap),\n                    1,\n                )\n            }\n\n            // get user provided value - column value from the user provided persisted entity\n            const entityValue = column.getEntityValue(subject.entity!)\n\n            // we don't perform operation over undefined properties (but we DO need null properties!)\n            if (entityValue === undefined) return\n\n            // if there is no database entity then all columns are treated as new, e.g. changed\n            if (subject.databaseEntity) {\n                // skip transform database value for json / jsonb for comparison later on\n                const shouldTransformDatabaseEntity =\n                    column.type !== \"json\" && column.type !== \"jsonb\"\n\n                // get database value of the column\n                let databaseValue = column.getEntityValue(\n                    subject.databaseEntity,\n                    shouldTransformDatabaseEntity,\n                )\n\n                // filter out \"relational columns\" only in the case if there is a relation object in entity\n                if (column.relationMetadata) {\n                    const value = column.relationMetadata.getEntityValue(\n                        subject.entity!,\n                    )\n                    if (value !== null && value !== undefined) return\n                }\n                let normalizedValue = entityValue\n                // normalize special values to make proper comparision\n                if (entityValue !== null) {\n                    switch (column.type) {\n                        case \"date\":\n                            normalizedValue = column.isArray\n                                ? entityValue.map((date: Date) =>\n                                      DateUtils.mixedDateToDateString(date),\n                                  )\n                                : DateUtils.mixedDateToDateString(entityValue)\n                            databaseValue = column.isArray\n                                ? databaseValue.map((date: Date) =>\n                                      DateUtils.mixedDateToDateString(date),\n                                  )\n                                : DateUtils.mixedDateToDateString(databaseValue)\n                            break\n\n                        case \"time\":\n                        case \"time with time zone\":\n                        case \"time without time zone\":\n                        case \"timetz\":\n                            normalizedValue = column.isArray\n                                ? entityValue.map((date: Date) =>\n                                      DateUtils.mixedDateToTimeString(date),\n                                  )\n                                : DateUtils.mixedDateToTimeString(entityValue)\n                            databaseValue = column.isArray\n                                ? databaseValue.map((date: Date) =>\n                                      DateUtils.mixedDateToTimeString(date),\n                                  )\n                                : DateUtils.mixedDateToTimeString(databaseValue)\n                            break\n\n                        case \"datetime\":\n                        case \"datetime2\":\n                        case Date:\n                        case \"timestamp\":\n                        case \"timestamp without time zone\":\n                        case \"timestamp with time zone\":\n                        case \"timestamp with local time zone\":\n                        case \"timestamptz\":\n                            normalizedValue = column.isArray\n                                ? entityValue.map((date: Date) =>\n                                      DateUtils.mixedDateToUtcDatetimeString(\n                                          date,\n                                      ),\n                                  )\n                                : DateUtils.mixedDateToUtcDatetimeString(\n                                      entityValue,\n                                  )\n\n                            databaseValue = column.isArray\n                                ? databaseValue.map((date: Date) =>\n                                      DateUtils.mixedDateToUtcDatetimeString(\n                                          date,\n                                      ),\n                                  )\n                                : DateUtils.mixedDateToUtcDatetimeString(\n                                      databaseValue,\n                                  )\n\n                            break\n\n                        case \"json\":\n                        case \"jsonb\":\n                            // JSON.stringify doesn't work because postgresql sorts jsonb before save.\n                            // If you try to save json '[{\"messages\": \"\", \"attribute Key\": \"\", \"level\":\"\"}] ' as jsonb,\n                            // then postgresql will save it as '[{\"level\": \"\", \"message\":\"\", \"attributeKey\": \"\"}]'\n                            if (\n                                OrmUtils.deepCompare(entityValue, databaseValue)\n                            )\n                                return\n                            break\n\n                        case \"simple-array\":\n                            normalizedValue =\n                                DateUtils.simpleArrayToString(entityValue)\n                            databaseValue =\n                                DateUtils.simpleArrayToString(databaseValue)\n                            break\n                        case \"simple-enum\":\n                            normalizedValue =\n                                DateUtils.simpleEnumToString(entityValue)\n                            databaseValue =\n                                DateUtils.simpleEnumToString(databaseValue)\n                            break\n                        case \"simple-json\":\n                            normalizedValue =\n                                DateUtils.simpleJsonToString(entityValue)\n                            databaseValue =\n                                DateUtils.simpleJsonToString(databaseValue)\n                            break\n                    }\n\n                    if (column.transformer) {\n                        normalizedValue = ApplyValueTransformers.transformTo(\n                            column.transformer,\n                            entityValue,\n                        )\n                    }\n                }\n\n                // if value is not changed - then do nothing\n                if (column.isArray) {\n                    if (OrmUtils.deepCompare(normalizedValue, databaseValue))\n                        return\n                } else if (\n                    Buffer.isBuffer(normalizedValue) &&\n                    Buffer.isBuffer(databaseValue)\n                ) {\n                    if (normalizedValue.equals(databaseValue)) {\n                        return\n                    }\n                } else {\n                    if (normalizedValue === databaseValue) return\n                }\n            }\n\n            if (!subject.diffColumns.includes(column))\n                subject.diffColumns.push(column)\n\n            subject.changeMaps.push({\n                column: column,\n                value: entityValue,\n            })\n        })\n    }\n\n    /**\n     * Difference columns of the owning one-to-one and many-to-one columns.\n     */\n    protected computeDiffRelationalColumns(\n        allSubjects: Subject[],\n        subject: Subject,\n    ): void {\n        // if there is no persisted entity then nothing to compute changed in it\n        if (!subject.entity) return\n\n        subject.metadata.relationsWithJoinColumns.forEach((relation) => {\n            // get the related entity from the persisted entity\n            let relatedEntity = relation.getEntityValue(subject.entity!)\n\n            // we don't perform operation over undefined properties (but we DO need null properties!)\n            if (relatedEntity === undefined) return\n\n            // if there is no database entity then all relational columns are treated as new, e.g. changed\n            if (subject.databaseEntity) {\n                // here we cover two scenarios:\n                // 1. related entity can be another entity which is natural way\n                // 2. related entity can be just an entity id\n                // if relation entity is just a relation id set (for example post.tag = 1)\n                // then we create an id map from it to make a proper comparision\n                let relatedEntityRelationIdMap: ObjectLiteral = relatedEntity\n                if (\n                    relatedEntityRelationIdMap !== null &&\n                    ObjectUtils.isObject(relatedEntityRelationIdMap)\n                )\n                    relatedEntityRelationIdMap = relation.getRelationIdMap(\n                        relatedEntityRelationIdMap,\n                    )!\n\n                // get database related entity. Since loadRelationIds are used on databaseEntity\n                // related entity will contain only its relation ids\n                const databaseRelatedEntityRelationIdMap =\n                    relation.getEntityValue(subject.databaseEntity)\n\n                // if relation ids are equal then we don't need to update anything\n                const areRelatedIdsEqual = OrmUtils.compareIds(\n                    relatedEntityRelationIdMap,\n                    databaseRelatedEntityRelationIdMap,\n                )\n                if (areRelatedIdsEqual) {\n                    return\n                } else {\n                    subject.diffRelations.push(relation)\n                }\n            }\n\n            // if there is an inserted subject for the related entity of the persisted entity then use it as related entity\n            // this code is used for related entities without ids to be properly inserted (and then updated if needed)\n            const valueSubject = allSubjects.find(\n                (subject) =>\n                    subject.mustBeInserted && subject.entity === relatedEntity,\n            )\n            if (valueSubject) relatedEntity = valueSubject\n\n            // find if there is already a relation to be changed\n            const changeMap = subject.changeMaps.find(\n                (changeMap) => changeMap.relation === relation,\n            )\n            if (changeMap) {\n                // and update its value if it was found\n                changeMap.value = relatedEntity\n            } else {\n                // if it wasn't found add a new relation for change\n                subject.changeMaps.push({\n                    relation: relation,\n                    value: relatedEntity,\n                })\n            }\n        })\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"file":"NestedSetSubjectExecutor.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/persistence/browser/src/persistence/tree/NestedSetSubjectExecutor.ts"],"sourceRoot":"../..","sourcesContent":["import { Subject } from \"../Subject\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { NestedSetMultipleRootError } from \"../../error/NestedSetMultipleRootError\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\n\nclass NestedSetIds {\n    left: number\n    right: number\n}\n\n/**\n * Executes subject operations for nested set tree entities.\n */\nexport class NestedSetSubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const tableName = this.getTableName(subject.metadata.tablePath)\n        const leftColumnName = escape(\n            subject.metadata.nestedSetLeftColumn!.databaseName,\n        )\n        const rightColumnName = escape(\n            subject.metadata.nestedSetRightColumn!.databaseName,\n        )\n\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet\n                ? subject.parentSubject.insertedValueSet\n                : subject.parentSubject.entity\n        const parentId = subject.metadata.getEntityIdMap(parent)\n\n        let parentNsRight: number | undefined = undefined\n        if (parentId) {\n            parentNsRight = await this.queryRunner.manager\n                .createQueryBuilder()\n                .select(\n                    subject.metadata.targetName +\n                        \".\" +\n                        subject.metadata.nestedSetRightColumn!.propertyPath,\n                    \"right\",\n                )\n                .from(subject.metadata.target, subject.metadata.targetName)\n                .whereInIds(parentId)\n                .getRawOne()\n                .then((result) => {\n                    const value: any = result ? result[\"right\"] : undefined\n                    // CockroachDB returns numeric types as string\n                    return typeof value === \"string\" ? parseInt(value) : value\n                })\n        }\n\n        if (parentNsRight !== undefined) {\n            await this.queryRunner.query(\n                `UPDATE ${tableName} SET ` +\n                    `${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,` +\n                    `${rightColumnName} = ${rightColumnName} + 2 ` +\n                    `WHERE ${rightColumnName} >= ${parentNsRight}`,\n            )\n\n            OrmUtils.mergeDeep(\n                subject.insertedValueSet,\n                subject.metadata.nestedSetLeftColumn!.createValueMap(\n                    parentNsRight,\n                ),\n                subject.metadata.nestedSetRightColumn!.createValueMap(\n                    parentNsRight + 1,\n                ),\n            )\n        } else {\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent)\n\n            // Validate if a root entity already exits and throw an exception\n            if (!isUniqueRoot) throw new NestedSetMultipleRootError()\n\n            OrmUtils.mergeDeep(\n                subject.insertedValueSet,\n                subject.metadata.nestedSetLeftColumn!.createValueMap(1),\n                subject.metadata.nestedSetRightColumn!.createValueMap(2),\n            )\n        }\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.entity\n\n        let entity = subject.databaseEntity // if entity was attached via parent\n        if (!entity && parent)\n            // if entity was attached via children\n            entity = subject.metadata\n                .treeChildrenRelation!.getEntityValue(parent)\n                .find((child: any) => {\n                    return Object.entries(subject.identifier!).every(\n                        ([key, value]) => child[key] === value,\n                    )\n                })\n\n        // Exit if the parent or the entity where never set\n        if (entity === undefined || parent === undefined) {\n            return\n        }\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(\n            entity!,\n        )\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent)\n        const parentId = subject.metadata.getEntityIdMap(parent)\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\n            return\n        }\n\n        if (parent) {\n            const escape = (alias: string) =>\n                this.queryRunner.connection.driver.escape(alias)\n            const tableName = this.getTableName(subject.metadata.tablePath)\n            const leftColumnName = escape(\n                subject.metadata.nestedSetLeftColumn!.databaseName,\n            )\n            const rightColumnName = escape(\n                subject.metadata.nestedSetRightColumn!.databaseName,\n            )\n\n            const entityId = subject.metadata.getEntityIdMap(entity)\n\n            let entityNs: NestedSetIds | undefined = undefined\n            if (entityId) {\n                entityNs = (\n                    await this.getNestedSetIds(subject.metadata, entityId)\n                )[0]\n            }\n\n            let parentNs: NestedSetIds | undefined = undefined\n            if (parentId) {\n                parentNs = (\n                    await this.getNestedSetIds(subject.metadata, parentId)\n                )[0]\n            }\n\n            if (entityNs !== undefined && parentNs !== undefined) {\n                const isMovingUp = parentNs.left > entityNs.left\n                const treeSize = entityNs.right - entityNs.left + 1\n\n                let entitySize: number\n                if (isMovingUp) {\n                    entitySize = parentNs.left - entityNs.right\n                } else {\n                    entitySize = parentNs.right - entityNs.left\n                }\n\n                // Moved entity logic\n                const updateLeftSide =\n                    `WHEN ${leftColumnName} >= ${entityNs.left} AND ` +\n                    `${leftColumnName} < ${entityNs.right} ` +\n                    `THEN ${leftColumnName} + ${entitySize} `\n\n                const updateRightSide =\n                    `WHEN ${rightColumnName} > ${entityNs.left} AND ` +\n                    `${rightColumnName} <= ${entityNs.right} ` +\n                    `THEN ${rightColumnName} + ${entitySize} `\n\n                // Update the surrounding entities\n                if (isMovingUp) {\n                    await this.queryRunner.query(\n                        `UPDATE ${tableName} ` +\n                            `SET ${leftColumnName} = CASE ` +\n                            `WHEN ${leftColumnName} > ${entityNs.right} AND ` +\n                            `${leftColumnName} <= ${parentNs.left} ` +\n                            `THEN ${leftColumnName} - ${treeSize} ` +\n                            updateLeftSide +\n                            `ELSE ${leftColumnName} ` +\n                            `END, ` +\n                            `${rightColumnName} = CASE ` +\n                            `WHEN ${rightColumnName} > ${entityNs.right} AND ` +\n                            `${rightColumnName} < ${parentNs.left} ` +\n                            `THEN ${rightColumnName} - ${treeSize} ` +\n                            updateRightSide +\n                            `ELSE ${rightColumnName} ` +\n                            `END`,\n                    )\n                } else {\n                    await this.queryRunner.query(\n                        `UPDATE ${tableName} ` +\n                            `SET ${leftColumnName} = CASE ` +\n                            `WHEN ${leftColumnName} < ${entityNs.left} AND ` +\n                            `${leftColumnName} > ${parentNs.right} ` +\n                            `THEN ${leftColumnName} + ${treeSize} ` +\n                            updateLeftSide +\n                            `ELSE ${leftColumnName} ` +\n                            `END, ` +\n                            `${rightColumnName} = CASE ` +\n                            `WHEN ${rightColumnName} < ${entityNs.left} AND ` +\n                            `${rightColumnName} >= ${parentNs.right} ` +\n                            `THEN ${rightColumnName} + ${treeSize} ` +\n                            updateRightSide +\n                            `ELSE ${rightColumnName} ` +\n                            `END`,\n                    )\n                }\n            }\n        } else {\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent)\n\n            // Validate if a root entity already exits and throw an exception\n            if (!isUniqueRoot) throw new NestedSetMultipleRootError()\n        }\n    }\n\n    /**\n     * Executes operations when subject is being removed.\n     */\n    async remove(subjects: Subject | Subject[]): Promise<void> {\n        if (!Array.isArray(subjects)) subjects = [subjects]\n\n        const metadata = subjects[0].metadata\n\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const tableName = this.getTableName(metadata.tablePath)\n        const leftColumnName = escape(\n            metadata.nestedSetLeftColumn!.databaseName,\n        )\n        const rightColumnName = escape(\n            metadata.nestedSetRightColumn!.databaseName,\n        )\n\n        const entitiesIds: ObjectLiteral[] = []\n        for (const subject of subjects) {\n            const entityId = metadata.getEntityIdMap(subject.entity)\n\n            if (entityId) {\n                entitiesIds.push(entityId)\n            }\n        }\n\n        const entitiesNs = await this.getNestedSetIds(metadata, entitiesIds)\n\n        for (const entity of entitiesNs) {\n            const treeSize = entity.right - entity.left + 1\n\n            await this.queryRunner.query(\n                `UPDATE ${tableName} ` +\n                    `SET ${leftColumnName} = CASE ` +\n                    `WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ` +\n                    `ELSE ${leftColumnName} ` +\n                    `END, ` +\n                    `${rightColumnName} = CASE ` +\n                    `WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ` +\n                    `ELSE ${rightColumnName} ` +\n                    `END`,\n            )\n        }\n    }\n\n    /**\n     * Get the nested set ids for a given entity\n     */\n    protected getNestedSetIds(\n        metadata: EntityMetadata,\n        ids: ObjectLiteral | ObjectLiteral[],\n    ): Promise<NestedSetIds[]> {\n        const select = {\n            left: `${metadata.targetName}.${\n                metadata.nestedSetLeftColumn!.propertyPath\n            }`,\n            right: `${metadata.targetName}.${\n                metadata.nestedSetRightColumn!.propertyPath\n            }`,\n        }\n\n        const queryBuilder = this.queryRunner.manager.createQueryBuilder()\n\n        Object.entries(select).forEach(([key, value]) => {\n            queryBuilder.addSelect(value, key)\n        })\n\n        return queryBuilder\n            .from(metadata.target, metadata.targetName)\n            .whereInIds(ids)\n            .orderBy(select.right, \"DESC\")\n            .getRawMany()\n            .then((results) => {\n                const data: NestedSetIds[] = []\n\n                for (const result of results) {\n                    const entry: any = {}\n                    for (const key of Object.keys(select)) {\n                        const value = result ? result[key] : undefined\n\n                        // CockroachDB returns numeric types as string\n                        entry[key] =\n                            typeof value === \"string\" ? parseInt(value) : value\n                    }\n                    data.push(entry)\n                }\n\n                return data\n            })\n    }\n\n    private async isUniqueRootEntity(\n        subject: Subject,\n        parent: any,\n    ): Promise<boolean> {\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const tableName = this.getTableName(subject.metadata.tablePath)\n        const parameters: any[] = []\n        const whereCondition = subject.metadata\n            .treeParentRelation!.joinColumns.map((column) => {\n                const columnName = escape(column.databaseName)\n                const parameter = column.getEntityValue(parent)\n\n                if (parameter == null) {\n                    return `${columnName} IS NULL`\n                }\n\n                parameters.push(parameter)\n                const parameterName =\n                    this.queryRunner.connection.driver.createParameter(\n                        \"entity_\" + column.databaseName,\n                        parameters.length - 1,\n                    )\n                return `${columnName} = ${parameterName}`\n            })\n            .join(\" AND \")\n\n        const countAlias = \"count\"\n        const result = await this.queryRunner.query(\n            `SELECT COUNT(1) AS ${escape(\n                countAlias,\n            )} FROM ${tableName} WHERE ${whereCondition}`,\n            parameters,\n            true,\n        )\n\n        return parseInt(result.records[0][countAlias]) === 0\n    }\n\n    /**\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath\n            .split(\".\")\n            .map((i) => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                return i === \"\"\n                    ? i\n                    : this.queryRunner.connection.driver.escape(i)\n            })\n            .join(\".\")\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 535, "column": 0}, "map": {"version":3,"file":"ClosureSubjectExecutor.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/persistence/browser/src/persistence/tree/ClosureSubjectExecutor.ts"],"sourceRoot":"../..","sourcesContent":["import { Subject } from \"../Subject\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { CannotAttachTreeChildrenEntityError } from \"../../error/CannotAttachTreeChildrenEntityError\"\nimport { DeleteQueryBuilder } from \"../../query-builder/DeleteQueryBuilder\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\n\n/**\n * Executes subject operations for closure entities.\n */\nexport class ClosureSubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n        // create values to be inserted into the closure junction\n        const closureJunctionInsertMap: ObjectLiteral = {}\n        subject.metadata.closureJunctionTable.ancestorColumns.forEach(\n            (column) => {\n                closureJunctionInsertMap[column.databaseName] =\n                    subject.identifier\n            },\n        )\n        subject.metadata.closureJunctionTable.descendantColumns.forEach(\n            (column) => {\n                closureJunctionInsertMap[column.databaseName] =\n                    subject.identifier\n            },\n        )\n\n        // insert values into the closure junction table\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .insert()\n            .into(subject.metadata.closureJunctionTable.tablePath)\n            .values(closureJunctionInsertMap)\n            .updateEntity(false)\n            .callListeners(false)\n            .execute()\n\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet\n                ? subject.parentSubject.insertedValueSet\n                : subject.parentSubject.entity\n\n        if (parent) {\n            const escape = (alias: string) =>\n                this.queryRunner.connection.driver.escape(alias)\n            const tableName = this.getTableName(\n                subject.metadata.closureJunctionTable.tablePath,\n            )\n            const queryParams: any[] = []\n\n            const ancestorColumnNames =\n                subject.metadata.closureJunctionTable.ancestorColumns.map(\n                    (column) => {\n                        return escape(column.databaseName)\n                    },\n                )\n            const descendantColumnNames =\n                subject.metadata.closureJunctionTable.descendantColumns.map(\n                    (column) => {\n                        return escape(column.databaseName)\n                    },\n                )\n            const childEntityIds1 = subject.metadata.primaryColumns.map(\n                (column) => {\n                    queryParams.push(\n                        column.getEntityValue(\n                            subject.insertedValueSet\n                                ? subject.insertedValueSet\n                                : subject.entity!,\n                        ),\n                    )\n                    return this.queryRunner.connection.driver.createParameter(\n                        \"child_entity_\" + column.databaseName,\n                        queryParams.length - 1,\n                    )\n                },\n            )\n\n            const whereCondition =\n                subject.metadata.closureJunctionTable.descendantColumns.map(\n                    (column) => {\n                        const columnName = escape(column.databaseName)\n                        const parentId =\n                            column.referencedColumn!.getEntityValue(parent)\n\n                        if (!parentId)\n                            throw new CannotAttachTreeChildrenEntityError(\n                                subject.metadata.name,\n                            )\n\n                        queryParams.push(parentId)\n                        const parameterName =\n                            this.queryRunner.connection.driver.createParameter(\n                                \"parent_entity_\" +\n                                    column.referencedColumn!.databaseName,\n                                queryParams.length - 1,\n                            )\n                        return `${columnName} = ${parameterName}`\n                    },\n                )\n\n            await this.queryRunner.query(\n                `INSERT INTO ${tableName} (${[\n                    ...ancestorColumnNames,\n                    ...descendantColumnNames,\n                ].join(\", \")}) ` +\n                    `SELECT ${ancestorColumnNames.join(\n                        \", \",\n                    )}, ${childEntityIds1.join(\n                        \", \",\n                    )} FROM ${tableName} WHERE ${whereCondition.join(\" AND \")}`,\n                queryParams,\n            )\n        }\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.entity\n\n        let entity = subject.databaseEntity // if entity was attached via parent\n        if (!entity && parent)\n            // if entity was attached via children\n            entity = subject.metadata\n                .treeChildrenRelation!.getEntityValue(parent)\n                .find((child: any) => {\n                    return Object.entries(subject.identifier!).every(\n                        ([key, value]) => child[key] === value,\n                    )\n                })\n\n        // Exit if the parent or the entity where never set\n        if (entity === undefined || parent === undefined) {\n            return\n        }\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(\n            entity!,\n        )\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent)\n        const parentId = subject.metadata.getEntityIdMap(parent)\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\n            return\n        }\n\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const closureTable = subject.metadata.closureJunctionTable\n\n        const ancestorColumnNames = closureTable.ancestorColumns.map(\n            (column) => {\n                return escape(column.databaseName)\n            },\n        )\n\n        const descendantColumnNames = closureTable.descendantColumns.map(\n            (column) => {\n                return escape(column.databaseName)\n            },\n        )\n\n        // Delete logic\n        const createSubQuery = (qb: DeleteQueryBuilder<any>, alias: string) => {\n            const subAlias = `sub${alias}`\n\n            const subSelect = qb\n                .createQueryBuilder()\n                .select(descendantColumnNames.join(\", \"))\n                .from(closureTable.tablePath, subAlias)\n\n            // Create where conditions e.g. (WHERE \"subdescendant\".\"id_ancestor\" = :value_id)\n            for (const column of closureTable.ancestorColumns) {\n                subSelect.andWhere(\n                    `${escape(subAlias)}.${escape(\n                        column.databaseName,\n                    )} = :value_${column.referencedColumn!.databaseName}`,\n                )\n            }\n\n            return qb\n                .createQueryBuilder()\n                .select(descendantColumnNames.join(\", \"))\n                .from(`(${subSelect.getQuery()})`, alias)\n                .setParameters(subSelect.getParameters())\n                .getQuery()\n        }\n\n        const parameters: ObjectLiteral = {}\n        for (const column of subject.metadata.primaryColumns) {\n            parameters[`value_${column.databaseName}`] =\n                entity![column.databaseName]\n        }\n\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .delete()\n            .from(closureTable.tablePath)\n            .where(\n                (qb) =>\n                    `(${descendantColumnNames.join(\", \")}) IN (${createSubQuery(\n                        qb,\n                        \"descendant\",\n                    )})`,\n            )\n            .andWhere(\n                (qb) =>\n                    `(${ancestorColumnNames.join(\n                        \", \",\n                    )}) NOT IN (${createSubQuery(qb, \"ancestor\")})`,\n            )\n            .setParameters(parameters)\n            .execute()\n\n        /**\n         * Only insert new parent if it exits\n         *\n         * This only happens if the entity doesn't become a root entity\n         */\n        if (parent) {\n            // Insert logic\n            const queryParams: any[] = []\n\n            const tableName = this.getTableName(closureTable.tablePath)\n            const superAlias = escape(\"supertree\")\n            const subAlias = escape(\"subtree\")\n\n            const select = [\n                ...ancestorColumnNames.map(\n                    (columnName) => `${superAlias}.${columnName}`,\n                ),\n                ...descendantColumnNames.map(\n                    (columnName) => `${subAlias}.${columnName}`,\n                ),\n            ]\n\n            const entityWhereCondition =\n                subject.metadata.closureJunctionTable.ancestorColumns.map(\n                    (column) => {\n                        const columnName = escape(column.databaseName)\n                        const entityId =\n                            column.referencedColumn!.getEntityValue(entity!)\n\n                        queryParams.push(entityId)\n                        const parameterName =\n                            this.queryRunner.connection.driver.createParameter(\n                                \"entity_\" +\n                                    column.referencedColumn!.databaseName,\n                                queryParams.length - 1,\n                            )\n                        return `${subAlias}.${columnName} = ${parameterName}`\n                    },\n                )\n\n            const parentWhereCondition =\n                subject.metadata.closureJunctionTable.descendantColumns.map(\n                    (column) => {\n                        const columnName = escape(column.databaseName)\n                        const parentId =\n                            column.referencedColumn!.getEntityValue(parent)\n\n                        if (!parentId)\n                            throw new CannotAttachTreeChildrenEntityError(\n                                subject.metadata.name,\n                            )\n\n                        queryParams.push(parentId)\n                        const parameterName =\n                            this.queryRunner.connection.driver.createParameter(\n                                \"parent_entity_\" +\n                                    column.referencedColumn!.databaseName,\n                                queryParams.length - 1,\n                            )\n                        return `${superAlias}.${columnName} = ${parameterName}`\n                    },\n                )\n\n            await this.queryRunner.query(\n                `INSERT INTO ${tableName} (${[\n                    ...ancestorColumnNames,\n                    ...descendantColumnNames,\n                ].join(\", \")}) ` +\n                    `SELECT ${select.join(\", \")} ` +\n                    `FROM ${tableName} AS ${superAlias}, ${tableName} AS ${subAlias} ` +\n                    `WHERE ${[\n                        ...entityWhereCondition,\n                        ...parentWhereCondition,\n                    ].join(\" AND \")}`,\n                queryParams,\n            )\n        }\n    }\n\n    /**\n     * Executes operations when subject is being removed.\n     */\n    async remove(subjects: Subject | Subject[]): Promise<void> {\n        // Only mssql need to execute deletes for the juntion table as it doesn't support multi cascade paths.\n        if (!(this.queryRunner.connection.driver.options.type === \"mssql\")) {\n            return\n        }\n\n        if (!Array.isArray(subjects)) subjects = [subjects]\n\n        const escape = (alias: string) =>\n            this.queryRunner.connection.driver.escape(alias)\n        const identifiers = subjects.map((subject) => subject.identifier)\n        const closureTable = subjects[0].metadata.closureJunctionTable\n\n        const generateWheres = (columns: ColumnMetadata[]) => {\n            return columns\n                .map((column) => {\n                    const data = identifiers.map(\n                        (identifier) =>\n                            identifier![column.referencedColumn!.databaseName],\n                    )\n                    return `${escape(column.databaseName)} IN (${data.join(\n                        \", \",\n                    )})`\n                })\n                .join(\" AND \")\n        }\n\n        const ancestorWhere = generateWheres(closureTable.ancestorColumns)\n        const descendantWhere = generateWheres(closureTable.descendantColumns)\n\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .delete()\n            .from(closureTable.tablePath)\n            .where(ancestorWhere)\n            .orWhere(descendantWhere)\n            .execute()\n    }\n\n    /**\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath\n            .split(\".\")\n            .map((i) => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                return i === \"\"\n                    ? i\n                    : this.queryRunner.connection.driver.escape(i)\n            })\n            .join(\".\")\n    }\n}\n"],"names":[],"mappings":";;;AAGA,OAAO,EAAE,mCAAmC,EAAE,MAAM,iDAAiD,CAAA;AAErG,OAAO,EAAE,QAAQ,EAAE,MAAM,qBAAqB,CAAA;;;AAMxC,MAAO,sBAAsB;IAC/B,4EAA4E;IAC5E,cAAc;IACd,4EAA4E;IAE5E,YAAsB,WAAwB,CAAA;QAAxB,IAAA,CAAA,WAAW,GAAX,WAAW,CAAa;IAAG,CAAC;IAElD,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E;;OAEG,CACH,KAAK,CAAC,MAAM,CAAC,OAAgB,EAAA;QACzB,yDAAyD;QACzD,MAAM,wBAAwB,GAAkB,CAAA,CAAE,CAAA;QAClD,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAAC,eAAe,CAAC,OAAO,CACzD,CAAC,MAAM,EAAE,EAAE;YACP,wBAAwB,CAAC,MAAM,CAAC,YAAY,CAAC,GACzC,OAAO,CAAC,UAAU,CAAA;QAC1B,CAAC,CACJ,CAAA;QACD,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAAC,iBAAiB,CAAC,OAAO,CAC3D,CAAC,MAAM,EAAE,EAAE;YACP,wBAAwB,CAAC,MAAM,CAAC,YAAY,CAAC,GACzC,OAAO,CAAC,UAAU,CAAA;QAC1B,CAAC,CACJ,CAAA;QAED,gDAAgD;QAChD,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CACzB,kBAAkB,EAAE,CACpB,MAAM,EAAE,CACR,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAAC,SAAS,CAAC,CACrD,MAAM,CAAC,wBAAwB,CAAC,CAChC,YAAY,CAAC,KAAK,CAAC,CACnB,aAAa,CAAC,KAAK,CAAC,CACpB,OAAO,EAAE,CAAA;QAEd,IAAI,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,kBAAmB,CAAC,cAAc,CAC5D,OAAO,CAAC,MAAO,CAClB,CAAA,CAAC,oCAAoC;QACtC,IAAI,CAAC,MAAM,IAAI,OAAO,CAAC,aAAa,IAAI,OAAO,CAAC,aAAa,CAAC,MAAM,EAChE,sCAAsC;QACtC,MAAM,GAAG,OAAO,CAAC,aAAa,CAAC,gBAAgB,GACzC,OAAO,CAAC,aAAa,CAAC,gBAAgB,GACtC,OAAO,CAAC,aAAa,CAAC,MAAM,CAAA;QAEtC,IAAI,MAAM,EAAE,CAAC;YACT,MAAM,MAAM,GAAG,CAAC,KAAa,EAAE,CAC3B,CAD6B,GACzB,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA;YACpD,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAC/B,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAAC,SAAS,CAClD,CAAA;YACD,MAAM,WAAW,GAAU,EAAE,CAAA;YAE7B,MAAM,mBAAmB,GACrB,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAAC,eAAe,CAAC,GAAG,CACrD,CAAC,MAAM,EAAE,EAAE;gBACP,OAAO,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA;YACtC,CAAC,CACJ,CAAA;YACL,MAAM,qBAAqB,GACvB,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAAC,iBAAiB,CAAC,GAAG,CACvD,CAAC,MAAM,EAAE,EAAE;gBACP,OAAO,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA;YACtC,CAAC,CACJ,CAAA;YACL,MAAM,eAAe,GAAG,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,GAAG,CACvD,CAAC,MAAM,EAAE,EAAE;gBACP,WAAW,CAAC,IAAI,CACZ,MAAM,CAAC,cAAc,CACjB,OAAO,CAAC,gBAAgB,GAClB,OAAO,CAAC,gBAAgB,GACxB,OAAO,CAAC,MAAO,CACxB,CACJ,CAAA;gBACD,OAAO,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CACrD,eAAe,GAAG,MAAM,CAAC,YAAY,EACrC,WAAW,CAAC,MAAM,GAAG,CAAC,CACzB,CAAA;YACL,CAAC,CACJ,CAAA;YAED,MAAM,cAAc,GAChB,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAAC,iBAAiB,CAAC,GAAG,CACvD,CAAC,MAAM,EAAE,EAAE;gBACP,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA;gBAC9C,MAAM,QAAQ,GACV,MAAM,CAAC,gBAAiB,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA;gBAEnD,IAAI,CAAC,QAAQ,EACT,MAAM,+LAAI,sCAAmC,CACzC,OAAO,CAAC,QAAQ,CAAC,IAAI,CACxB,CAAA;gBAEL,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;gBAC1B,MAAM,aAAa,GACf,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAC9C,gBAAgB,GACZ,MAAM,CAAC,gBAAiB,CAAC,YAAY,EACzC,WAAW,CAAC,MAAM,GAAG,CAAC,CACzB,CAAA;gBACL,OAAO,GAAG,UAAU,CAAA,GAAA,EAAM,aAAa,EAAE,CAAA;YAC7C,CAAC,CACJ,CAAA;YAEL,MAAM,IAAI,CAAC,WAAW,CAAC,KAAK,CACxB,CAAA,YAAA,EAAe,SAAS,CAAA,EAAA,EAAK;mBACtB,mBAAmB;mBACnB,qBAAqB;aAC3B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,EAAA,CAAI,GACZ,CAAA,OAAA,EAAU,mBAAmB,CAAC,IAAI,CAC9B,IAAI,CACP,CAAA,EAAA,EAAK,eAAe,CAAC,IAAI,CACtB,IAAI,CACP,CAAA,MAAA,EAAS,SAAS,CAAA,OAAA,EAAU,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,EAC/D,WAAW,CACd,CAAA;QACL,CAAC;IACL,CAAC;IAED;;OAEG,CACH,KAAK,CAAC,MAAM,CAAC,OAAgB,EAAA;QACzB,IAAI,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,kBAAmB,CAAC,cAAc,CAC5D,OAAO,CAAC,MAAO,CAClB,CAAA,CAAC,oCAAoC;QACtC,IAAI,CAAC,MAAM,IAAI,OAAO,CAAC,aAAa,IAAI,OAAO,CAAC,aAAa,CAAC,MAAM,EAChE,sCAAsC;QACtC,MAAM,GAAG,OAAO,CAAC,aAAa,CAAC,MAAM,CAAA;QAEzC,IAAI,MAAM,GAAG,OAAO,CAAC,cAAc,CAAA,CAAC,oCAAoC;QACxE,IAAI,CAAC,MAAM,IAAI,MAAM,EACjB,sCAAsC;QACtC,MAAM,GAAG,OAAO,CAAC,QAAQ,CACpB,oBAAqB,CAAC,cAAc,CAAC,MAAM,CAAC,CAC5C,IAAI,CAAC,CAAC,KAAU,EAAE,EAAE;YACjB,OAAO,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,UAAW,CAAC,CAAC,KAAK,CAC5C,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,CAAG,CAAD,IAAM,CAAC,GAAG,CAAC,KAAK,KAAK,CACzC,CAAA;QACL,CAAC,CAAC,CAAA;QAEV,mDAAmD;QACnD,IAAI,MAAM,KAAK,SAAS,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;YAC/C,OAAM;QACV,CAAC;QAED,MAAM,SAAS,GAAG,OAAO,CAAC,QAAQ,CAAC,kBAAmB,CAAC,cAAc,CACjE,MAAO,CACV,CAAA;QACD,MAAM,WAAW,GAAG,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,SAAS,CAAC,CAAA;QAC9D,MAAM,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA;QAExD,+CAA+C;QAC/C,mKAAI,WAAQ,CAAC,UAAU,CAAC,WAAW,EAAE,QAAQ,CAAC,EAAE,CAAC;YAC7C,OAAM;QACV,CAAC;QAED,MAAM,MAAM,GAAG,CAAC,KAAa,EAAE,CAC3B,CAD6B,GACzB,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA;QACpD,MAAM,YAAY,GAAG,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAAA;QAE1D,MAAM,mBAAmB,GAAG,YAAY,CAAC,eAAe,CAAC,GAAG,CACxD,CAAC,MAAM,EAAE,EAAE;YACP,OAAO,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA;QACtC,CAAC,CACJ,CAAA;QAED,MAAM,qBAAqB,GAAG,YAAY,CAAC,iBAAiB,CAAC,GAAG,CAC5D,CAAC,MAAM,EAAE,EAAE;YACP,OAAO,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA;QACtC,CAAC,CACJ,CAAA;QAED,eAAe;QACf,MAAM,cAAc,GAAG,CAAC,EAA2B,EAAE,KAAa,EAAE,EAAE;YAClE,MAAM,QAAQ,GAAG,CAAA,GAAA,EAAM,KAAK,EAAE,CAAA;YAE9B,MAAM,SAAS,GAAG,EAAE,CACf,kBAAkB,EAAE,CACpB,MAAM,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CACxC,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAA;YAE3C,iFAAiF;YACjF,KAAK,MAAM,MAAM,IAAI,YAAY,CAAC,eAAe,CAAE,CAAC;gBAChD,SAAS,CAAC,QAAQ,CACd,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAA,CAAA,EAAI,MAAM,CACzB,MAAM,CAAC,YAAY,CACtB,CAAA,UAAA,EAAa,MAAM,CAAC,gBAAiB,CAAC,YAAY,EAAE,CACxD,CAAA;YACL,CAAC;YAED,OAAO,EAAE,CACJ,kBAAkB,EAAE,CACpB,MAAM,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CACxC,IAAI,CAAC,CAAA,CAAA,EAAI,SAAS,CAAC,QAAQ,EAAE,CAAA,CAAA,CAAG,EAAE,KAAK,CAAC,CACxC,aAAa,CAAC,SAAS,CAAC,aAAa,EAAE,CAAC,CACxC,QAAQ,EAAE,CAAA;QACnB,CAAC,CAAA;QAED,MAAM,UAAU,GAAkB,CAAA,CAAE,CAAA;QACpC,KAAK,MAAM,MAAM,IAAI,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAE,CAAC;YACnD,UAAU,CAAC,CAAA,MAAA,EAAS,MAAM,CAAC,YAAY,EAAE,CAAC,GACtC,MAAO,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA;QACpC,CAAC;QAED,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CACzB,kBAAkB,EAAE,CACpB,MAAM,EAAE,CACR,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAC5B,KAAK,CACF,CAAC,EAAE,EAAE,CACD,CADG,AACH,CAAA,EAAI,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,MAAA,EAAS,cAAc,CACvD,EAAE,EACF,YAAY,CACf,CAAA,CAAA,CAAG,CACX,CACA,QAAQ,CACL,CAAC,EAAE,EAAE,CACD,CADG,AACH,CAAA,EAAI,mBAAmB,CAAC,IAAI,CACxB,IAAI,CACP,CAAA,UAAA,EAAa,cAAc,CAAC,EAAE,EAAE,UAAU,CAAC,CAAA,CAAA,CAAG,CACtD,CACA,aAAa,CAAC,UAAU,CAAC,CACzB,OAAO,EAAE,CAAA;QAEd;;;;WAIG,CACH,IAAI,MAAM,EAAE,CAAC;YACT,eAAe;YACf,MAAM,WAAW,GAAU,EAAE,CAAA;YAE7B,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,SAAS,CAAC,CAAA;YAC3D,MAAM,UAAU,GAAG,MAAM,CAAC,WAAW,CAAC,CAAA;YACtC,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAS,CAAC,CAAA;YAElC,MAAM,MAAM,GAAG;mBACR,mBAAmB,CAAC,GAAG,CACtB,CAAC,UAAU,EAAE,CAAG,CAAD,EAAI,UAAU,CAAA,CAAA,EAAI,UAAU,EAAE,CAChD;mBACE,qBAAqB,CAAC,GAAG,CACxB,CAAC,UAAU,EAAE,CAAG,CAAD,EAAI,QAAQ,CAAA,CAAA,EAAI,UAAU,EAAE,CAC9C;aACJ,CAAA;YAED,MAAM,oBAAoB,GACtB,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAAC,eAAe,CAAC,GAAG,CACrD,CAAC,MAAM,EAAE,EAAE;gBACP,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA;gBAC9C,MAAM,QAAQ,GACV,MAAM,CAAC,gBAAiB,CAAC,cAAc,CAAC,MAAO,CAAC,CAAA;gBAEpD,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;gBAC1B,MAAM,aAAa,GACf,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAC9C,SAAS,GACL,MAAM,CAAC,gBAAiB,CAAC,YAAY,EACzC,WAAW,CAAC,MAAM,GAAG,CAAC,CACzB,CAAA;gBACL,OAAO,GAAG,QAAQ,CAAA,CAAA,EAAI,UAAU,CAAA,GAAA,EAAM,aAAa,EAAE,CAAA;YACzD,CAAC,CACJ,CAAA;YAEL,MAAM,oBAAoB,GACtB,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAAC,iBAAiB,CAAC,GAAG,CACvD,CAAC,MAAM,EAAE,EAAE;gBACP,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA;gBAC9C,MAAM,QAAQ,GACV,MAAM,CAAC,gBAAiB,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA;gBAEnD,IAAI,CAAC,QAAQ,EACT,MAAM,+LAAI,sCAAmC,CACzC,OAAO,CAAC,QAAQ,CAAC,IAAI,CACxB,CAAA;gBAEL,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;gBAC1B,MAAM,aAAa,GACf,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAC9C,gBAAgB,GACZ,MAAM,CAAC,gBAAiB,CAAC,YAAY,EACzC,WAAW,CAAC,MAAM,GAAG,CAAC,CACzB,CAAA;gBACL,OAAO,GAAG,UAAU,CAAA,CAAA,EAAI,UAAU,CAAA,GAAA,EAAM,aAAa,EAAE,CAAA;YAC3D,CAAC,CACJ,CAAA;YAEL,MAAM,IAAI,CAAC,WAAW,CAAC,KAAK,CACxB,CAAA,YAAA,EAAe,SAAS,CAAA,EAAA,EAAK;mBACtB,mBAAmB;mBACnB,qBAAqB;aAC3B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,EAAA,CAAI,GACZ,CAAA,OAAA,EAAU,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,CAAA,CAAG,GAC9B,CAAA,KAAA,EAAQ,SAAS,CAAA,IAAA,EAAO,UAAU,CAAA,EAAA,EAAK,SAAS,CAAA,IAAA,EAAO,QAAQ,CAAA,CAAA,CAAG,GAClE,CAAA,MAAA,EAAS;mBACF,oBAAoB;mBACpB,oBAAoB;aAC1B,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,EACrB,WAAW,CACd,CAAA;QACL,CAAC;IACL,CAAC;IAED;;OAEG,CACH,KAAK,CAAC,MAAM,CAAC,QAA6B,EAAA;QACtC,sGAAsG;QACtG,IAAI,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,OAAO,CAAC,EAAE,CAAC;YACjE,OAAM;QACV,CAAC;QAED,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,QAAQ,GAAG;YAAC,QAAQ;SAAC,CAAA;QAEnD,MAAM,MAAM,GAAG,CAAC,KAAa,EAAE,CAC3B,CAD6B,GACzB,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA;QACpD,MAAM,WAAW,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,UAAU,CAAC,CAAA;QACjE,MAAM,YAAY,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,oBAAoB,CAAA;QAE9D,MAAM,cAAc,GAAG,CAAC,OAAyB,EAAE,EAAE;YACjD,OAAO,OAAO,CACT,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE;gBACZ,MAAM,IAAI,GAAG,WAAW,CAAC,GAAG,CACxB,CAAC,UAAU,EAAE,CACT,CADW,SACA,CAAC,MAAM,CAAC,gBAAiB,CAAC,YAAY,CAAC,CACzD,CAAA;gBACD,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA,KAAA,EAAQ,IAAI,CAAC,IAAI,CAClD,IAAI,CACP,CAAA,CAAA,CAAG,CAAA;YACR,CAAC,CAAC,CACD,IAAI,CAAC,OAAO,CAAC,CAAA;QACtB,CAAC,CAAA;QAED,MAAM,aAAa,GAAG,cAAc,CAAC,YAAY,CAAC,eAAe,CAAC,CAAA;QAClE,MAAM,eAAe,GAAG,cAAc,CAAC,YAAY,CAAC,iBAAiB,CAAC,CAAA;QAEtE,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CACzB,kBAAkB,EAAE,CACpB,MAAM,EAAE,CACR,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAC5B,KAAK,CAAC,aAAa,CAAC,CACpB,OAAO,CAAC,eAAe,CAAC,CACxB,OAAO,EAAE,CAAA;IAClB,CAAC;IAED;;;OAGG,CACO,YAAY,CAAC,SAAiB,EAAA;QACpC,OAAO,SAAS,CACX,KAAK,CAAC,GAAG,CAAC,CACV,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;YACP,sMAAsM;YACtM,OAAO,CAAC,KAAK,EAAE,GACT,CAAC,GACD,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA;QACtD,CAAC,CAAC,CACD,IAAI,CAAC,GAAG,CAAC,CAAA;IAClB,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 718, "column": 0}, "map": {"version":3,"file":"MaterializedPathSubjectExecutor.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/persistence/browser/src/persistence/tree/MaterializedPathSubjectExecutor.ts"],"sourceRoot":"../..","sourcesContent":["import { Subject } from \"../Subject\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { Brackets } from \"../../query-builder/Brackets\"\n\n/**\n * Executes subject operations for materialized-path tree entities.\n */\nexport class MaterializedPathSubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected queryRunner: QueryRunner) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject: Subject): Promise<void> {\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet\n                ? subject.parentSubject.insertedValueSet\n                : subject.parentSubject.entity\n\n        const parentId = subject.metadata.getEntityIdMap(parent)\n\n        let parentPath: string = \"\"\n        if (parentId) {\n            parentPath = await this.getEntityPath(subject, parentId)\n        }\n\n        const insertedEntityId = subject.metadata\n            .treeParentRelation!.joinColumns.map((joinColumn) => {\n                return joinColumn.referencedColumn!.getEntityValue(\n                    subject.insertedValueSet!,\n                )\n            })\n            .join(\"_\")\n\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .update(subject.metadata.target)\n            .set({\n                [subject.metadata.materializedPathColumn!.propertyPath]:\n                    parentPath + insertedEntityId + \".\",\n            } as any)\n            .where(subject.identifier!)\n            .execute()\n    }\n\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject: Subject): Promise<void> {\n        let newParent = subject.metadata.treeParentRelation!.getEntityValue(\n            subject.entity!,\n        ) // if entity was attached via parent\n        if (!newParent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            newParent = subject.parentSubject.entity\n\n        let entity = subject.databaseEntity // if entity was attached via parent\n        if (!entity && newParent)\n            // if entity was attached via children\n            entity = subject.metadata\n                .treeChildrenRelation!.getEntityValue(newParent)\n                .find((child: any) => {\n                    return Object.entries(subject.identifier!).every(\n                        ([key, value]) => child[key] === value,\n                    )\n                })\n\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(\n            entity!,\n        )\n        const oldParentId = this.getEntityParentReferencedColumnMap(\n            subject,\n            oldParent,\n        )\n        const newParentId = this.getEntityParentReferencedColumnMap(\n            subject,\n            newParent,\n        )\n\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, newParentId)) {\n            return\n        }\n\n        let newParentPath: string = \"\"\n        if (newParentId) {\n            newParentPath = await this.getEntityPath(subject, newParentId)\n        }\n\n        let oldParentPath: string = \"\"\n        if (oldParentId) {\n            oldParentPath =\n                (await this.getEntityPath(subject, oldParentId)) || \"\"\n        }\n\n        const entityPath = subject.metadata\n            .treeParentRelation!.joinColumns.map((joinColumn) => {\n                return joinColumn.referencedColumn!.getEntityValue(entity!)\n            })\n            .join(\"_\")\n\n        const propertyPath =\n            subject.metadata.materializedPathColumn!.propertyPath\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .update(subject.metadata.target)\n            .set({\n                [propertyPath]: () =>\n                    `REPLACE(${this.queryRunner.connection.driver.escape(\n                        propertyPath,\n                    )}, '${oldParentPath}${entityPath}.', '${newParentPath}${entityPath}.')`,\n            } as any)\n            .where(`${propertyPath} LIKE :path`, {\n                path: `${oldParentPath}${entityPath}.%`,\n            })\n            .execute()\n    }\n\n    private getEntityParentReferencedColumnMap(\n        subject: Subject,\n        entity: ObjectLiteral | undefined,\n    ): ObjectLiteral | undefined {\n        if (!entity) return undefined\n        return EntityMetadata.getValueMap(\n            entity,\n            subject.metadata\n                .treeParentRelation!.joinColumns.map(\n                    (column) => column.referencedColumn,\n                )\n                .filter((v) => v != null) as ColumnMetadata[],\n            { skipNulls: true },\n        )\n    }\n\n    private getEntityPath(\n        subject: Subject,\n        id: ObjectLiteral,\n    ): Promise<string> {\n        const metadata = subject.metadata\n        const normalized = (Array.isArray(id) ? id : [id]).map((id) =>\n            metadata.ensureEntityIdMap(id),\n        )\n        return this.queryRunner.manager\n            .createQueryBuilder()\n            .select(\n                subject.metadata.targetName +\n                    \".\" +\n                    subject.metadata.materializedPathColumn!.propertyPath,\n                \"path\",\n            )\n            .from(subject.metadata.target, subject.metadata.targetName)\n            .where(\n                new Brackets((qb) => {\n                    for (const data of normalized) {\n                        qb.orWhere(new Brackets((qb) => qb.where(data)))\n                    }\n                }),\n            )\n            .getRawOne()\n            .then((result) => (result ? result[\"path\"] : \"\"))\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 815, "column": 0}, "map": {"version":3,"file":"SubjectExecutor.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/persistence/SubjectExecutor.ts"],"sourceRoot":"..","sourcesContent":["import { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { Subject } from \"./Subject\"\nimport { SubjectTopologicalSorter } from \"./SubjectTopologicalSorter\"\nimport { SubjectChangedColumnsComputer } from \"./SubjectChangedColumnsComputer\"\nimport { SubjectWithoutIdentifierError } from \"../error/SubjectWithoutIdentifierError\"\nimport { SubjectRemovedAndUpdatedError } from \"../error/SubjectRemovedAndUpdatedError\"\nimport { MongoEntityManager } from \"../entity-manager/MongoEntityManager\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { SaveOptions } from \"../repository/SaveOptions\"\nimport { RemoveOptions } from \"../repository/RemoveOptions\"\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\"\nimport { NestedSetSubjectExecutor } from \"./tree/NestedSetSubjectExecutor\"\nimport { ClosureSubjectExecutor } from \"./tree/ClosureSubjectExecutor\"\nimport { MaterializedPathSubjectExecutor } from \"./tree/MaterializedPathSubjectExecutor\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { UpdateResult } from \"../query-builder/result/UpdateResult\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\nexport class SubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\n     */\n    hasExecutableOperations: boolean = false\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryRunner used to execute all queries with a given subjects.\n     */\n    protected queryRunner: QueryRunner\n\n    /**\n     * Persistence options.\n     */\n    protected options?: SaveOptions & RemoveOptions\n\n    /**\n     * All subjects that needs to be operated.\n     */\n    protected allSubjects: Subject[]\n\n    /**\n     * Subjects that must be inserted.\n     */\n    protected insertSubjects: Subject[] = []\n\n    /**\n     * Subjects that must be updated.\n     */\n    protected updateSubjects: Subject[] = []\n\n    /**\n     * Subjects that must be removed.\n     */\n    protected removeSubjects: Subject[] = []\n\n    /**\n     * Subjects that must be soft-removed.\n     */\n    protected softRemoveSubjects: Subject[] = []\n\n    /**\n     * Subjects that must be recovered.\n     */\n    protected recoverSubjects: Subject[] = []\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        queryRunner: QueryRunner,\n        subjects: Subject[],\n        options?: SaveOptions & RemoveOptions,\n    ) {\n        this.queryRunner = queryRunner\n        this.allSubjects = subjects\n        this.options = options\n        this.validate()\n        this.recompute()\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes all operations over given array of subjects.\n     * Executes queries using given query runner.\n     */\n    async execute(): Promise<void> {\n        // console.time(\"SubjectExecutor.execute\");\n\n        // broadcast \"before\" events before we start insert / update / remove operations\n        let broadcasterResult: BroadcasterResult | undefined = undefined\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastBeforeEventsForAll\");\n            broadcasterResult = this.broadcastBeforeEventsForAll()\n            if (broadcasterResult.promises.length > 0)\n                await Promise.all(broadcasterResult.promises)\n            // console.timeEnd(\".broadcastBeforeEventsForAll\");\n        }\n\n        // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\n        // recompute only in the case if any listener or subscriber was really executed\n        if (broadcasterResult && broadcasterResult.count > 0) {\n            // console.time(\".recompute\");\n            this.insertSubjects.forEach((subject) => subject.recompute())\n            this.updateSubjects.forEach((subject) => subject.recompute())\n            this.removeSubjects.forEach((subject) => subject.recompute())\n            this.softRemoveSubjects.forEach((subject) => subject.recompute())\n            this.recoverSubjects.forEach((subject) => subject.recompute())\n            this.recompute()\n            // console.timeEnd(\".recompute\");\n        }\n\n        // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\n\n        // console.timeEnd(\"prepare\");\n\n        // execute all insert operations\n        // console.time(\".insertion\");\n        this.insertSubjects = new SubjectTopologicalSorter(\n            this.insertSubjects,\n        ).sort(\"insert\")\n        await this.executeInsertOperations()\n        // console.timeEnd(\".insertion\");\n\n        // recompute update operations since insertion can create updation operations for the\n        // properties it wasn't able to handle on its own (referenced columns)\n        this.updateSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeUpdated,\n        )\n\n        // execute update operations\n        // console.time(\".updation\");\n        await this.executeUpdateOperations()\n        // console.timeEnd(\".updation\");\n\n        // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\n        // console.time(\".removal\");\n        this.removeSubjects = new SubjectTopologicalSorter(\n            this.removeSubjects,\n        ).sort(\"delete\")\n        await this.executeRemoveOperations()\n        // console.timeEnd(\".removal\");\n\n        // recompute soft-remove operations\n        this.softRemoveSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeSoftRemoved,\n        )\n\n        // execute soft-remove operations\n        await this.executeSoftRemoveOperations()\n\n        // recompute recover operations\n        this.recoverSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeRecovered,\n        )\n\n        // execute recover operations\n        await this.executeRecoverOperations()\n\n        // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n        // console.time(\".updateSpecialColumnsInPersistedEntities\");\n        this.updateSpecialColumnsInPersistedEntities()\n        // console.timeEnd(\".updateSpecialColumnsInPersistedEntities\");\n\n        // finally broadcast \"after\" events after we finish insert / update / remove operations\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastAfterEventsForAll\");\n            broadcasterResult = this.broadcastAfterEventsForAll()\n            if (broadcasterResult.promises.length > 0)\n                await Promise.all(broadcasterResult.promises)\n            // console.timeEnd(\".broadcastAfterEventsForAll\");\n        }\n        // console.timeEnd(\"SubjectExecutor.execute\");\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validates all given subjects.\n     */\n    protected validate() {\n        this.allSubjects.forEach((subject) => {\n            if (subject.mustBeUpdated && subject.mustBeRemoved)\n                throw new SubjectRemovedAndUpdatedError(subject)\n        })\n    }\n\n    /**\n     * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\n     */\n    protected recompute(): void {\n        new SubjectChangedColumnsComputer().compute(this.allSubjects)\n        this.insertSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeInserted,\n        )\n        this.updateSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeUpdated,\n        )\n        this.removeSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeRemoved,\n        )\n        this.softRemoveSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeSoftRemoved,\n        )\n        this.recoverSubjects = this.allSubjects.filter(\n            (subject) => subject.mustBeRecovered,\n        )\n        this.hasExecutableOperations =\n            this.insertSubjects.length > 0 ||\n            this.updateSubjects.length > 0 ||\n            this.removeSubjects.length > 0 ||\n            this.softRemoveSubjects.length > 0 ||\n            this.recoverSubjects.length > 0\n    }\n\n    /**\n     * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\", \"BEFORE_SOFT_REMOVE\", \"BEFORE_RECOVER\" events for all given subjects.\n     */\n    protected broadcastBeforeEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult()\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeInsertEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                ),\n            )\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.diffColumns,\n                    subject.diffRelations,\n                ),\n            )\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.identifier,\n                ),\n            )\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeSoftRemoveEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.identifier,\n                ),\n            )\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastBeforeRecoverEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.identifier,\n                ),\n            )\n        return result\n    }\n\n    /**\n     * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\", \"AFTER_SOFT_REMOVE\", \"AFTER_RECOVER\" events for all given subjects.\n     * Returns void if there wasn't any listener or subscriber executed.\n     * Note: this method has a performance-optimized code organization.\n     */\n    protected broadcastAfterEventsForAll(): BroadcasterResult {\n        const result = new BroadcasterResult()\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterInsertEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.identifier,\n                ),\n            )\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterUpdateEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.diffColumns,\n                    subject.diffRelations,\n                ),\n            )\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterRemoveEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.identifier,\n                ),\n            )\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterSoftRemoveEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.identifier,\n                ),\n            )\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach((subject) =>\n                this.queryRunner.broadcaster.broadcastAfterRecoverEvent(\n                    result,\n                    subject.metadata,\n                    subject.entity!,\n                    subject.databaseEntity,\n                    subject.identifier,\n                ),\n            )\n        return result\n    }\n\n    /**\n     * Executes insert operations.\n     */\n    protected async executeInsertOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedInsertSubjects, groupedInsertSubjectKeys] =\n            this.groupBulkSubjects(this.insertSubjects, \"insert\")\n\n        // then we run insertion in the sequential order which is important since we have an ordered subjects\n        for (const groupName of groupedInsertSubjectKeys) {\n            const subjects = groupedInsertSubjects[groupName]\n\n            // we must separately insert entities which does not have any values to insert\n            // because its not possible to insert multiple entities with only default values in bulk\n            const bulkInsertMaps: ObjectLiteral[] = []\n            const bulkInsertSubjects: Subject[] = []\n            const singleInsertSubjects: Subject[] = []\n            if (this.queryRunner.connection.driver.options.type === \"mongodb\") {\n                subjects.forEach((subject) => {\n                    if (subject.metadata.createDateColumn && subject.entity) {\n                        subject.entity[\n                            subject.metadata.createDateColumn.databaseName\n                        ] = new Date()\n                    }\n\n                    if (subject.metadata.updateDateColumn && subject.entity) {\n                        subject.entity[\n                            subject.metadata.updateDateColumn.databaseName\n                        ] = new Date()\n                    }\n\n                    subject.createValueSetAndPopChangeMap()\n\n                    bulkInsertSubjects.push(subject)\n                    bulkInsertMaps.push(subject.entity!)\n                })\n            } else if (\n                this.queryRunner.connection.driver.options.type === \"oracle\"\n            ) {\n                subjects.forEach((subject) => {\n                    singleInsertSubjects.push(subject)\n                })\n            } else {\n                subjects.forEach((subject) => {\n                    // we do not insert in bulk in following cases:\n                    // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows\n                    // - when entity is a tree table, since tree tables require extra operation per each inserted row\n                    // - when oracle is used, since oracle's bulk insertion is very bad\n                    if (\n                        subject.changeMaps.length === 0 ||\n                        subject.metadata.treeType ||\n                        this.queryRunner.connection.driver.options.type ===\n                            \"oracle\" ||\n                        this.queryRunner.connection.driver.options.type ===\n                            \"sap\"\n                    ) {\n                        singleInsertSubjects.push(subject)\n                    } else {\n                        bulkInsertSubjects.push(subject)\n                        bulkInsertMaps.push(\n                            subject.createValueSetAndPopChangeMap(),\n                        )\n                    }\n                })\n            }\n\n            // for mongodb we have a bit different insertion logic\n            if (\n                InstanceChecker.isMongoEntityManager(this.queryRunner.manager)\n            ) {\n                const insertResult = await this.queryRunner.manager.insert(\n                    subjects[0].metadata.target,\n                    bulkInsertMaps,\n                )\n                subjects.forEach((subject, index) => {\n                    subject.identifier = insertResult.identifiers[index]\n                    subject.generatedMap = insertResult.generatedMaps[index]\n                    subject.insertedValueSet = bulkInsertMaps[index]\n                })\n            } else {\n                // here we execute our insertion query\n                // we need to enable entity updation because we DO need to have updated insertedMap\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                if (bulkInsertMaps.length > 0) {\n                    const insertResult = await this.queryRunner.manager\n                        .createQueryBuilder()\n                        .insert()\n                        .into(subjects[0].metadata.target)\n                        .values(bulkInsertMaps)\n                        .updateEntity(\n                            this.options && this.options.reload === false\n                                ? false\n                                : true,\n                        )\n                        .callListeners(false)\n                        .execute()\n\n                    bulkInsertSubjects.forEach((subject, index) => {\n                        subject.identifier = insertResult.identifiers[index]\n                        subject.generatedMap = insertResult.generatedMaps[index]\n                        subject.insertedValueSet = bulkInsertMaps[index]\n                    })\n                }\n\n                // insert subjects which must be inserted in separate requests (all default values)\n                if (singleInsertSubjects.length > 0) {\n                    for (const subject of singleInsertSubjects) {\n                        subject.insertedValueSet =\n                            subject.createValueSetAndPopChangeMap() // important to have because query builder sets inserted values into it\n\n                        // for nested set we execute additional queries\n                        if (subject.metadata.treeType === \"nested-set\")\n                            await new NestedSetSubjectExecutor(\n                                this.queryRunner,\n                            ).insert(subject)\n\n                        await this.queryRunner.manager\n                            .createQueryBuilder()\n                            .insert()\n                            .into(subject.metadata.target)\n                            .values(subject.insertedValueSet)\n                            .updateEntity(\n                                this.options && this.options.reload === false\n                                    ? false\n                                    : true,\n                            )\n                            .callListeners(false)\n                            .execute()\n                            .then((insertResult) => {\n                                subject.identifier = insertResult.identifiers[0]\n                                subject.generatedMap =\n                                    insertResult.generatedMaps[0]\n                            })\n\n                        // for tree tables we execute additional queries\n                        if (subject.metadata.treeType === \"closure-table\") {\n                            await new ClosureSubjectExecutor(\n                                this.queryRunner,\n                            ).insert(subject)\n                        } else if (\n                            subject.metadata.treeType === \"materialized-path\"\n                        ) {\n                            await new MaterializedPathSubjectExecutor(\n                                this.queryRunner,\n                            ).insert(subject)\n                        }\n                    }\n                }\n            }\n\n            subjects.forEach((subject) => {\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(\n                            subject.generatedMap!,\n                        )\n                        if (value !== undefined && value !== null) {\n                            const preparedValue =\n                                this.queryRunner.connection.driver.prepareHydratedValue(\n                                    value,\n                                    column,\n                                )\n                            column.setEntityValue(\n                                subject.generatedMap!,\n                                preparedValue,\n                            )\n                        }\n                    })\n                }\n            })\n        }\n    }\n\n    /**\n     * Updates all given subjects in the database.\n     */\n    protected async executeUpdateOperations(): Promise<void> {\n        const updateSubject = async (subject: Subject) => {\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject)\n\n            // for mongodb we have a bit different updation logic\n            if (\n                InstanceChecker.isMongoEntityManager(this.queryRunner.manager)\n            ) {\n                const partialEntity = this.cloneMongoSubjectEntity(subject)\n                if (\n                    subject.metadata.objectIdColumn &&\n                    subject.metadata.objectIdColumn.propertyName\n                ) {\n                    delete partialEntity[\n                        subject.metadata.objectIdColumn.propertyName\n                    ]\n                }\n\n                if (\n                    subject.metadata.createDateColumn &&\n                    subject.metadata.createDateColumn.propertyName\n                ) {\n                    delete partialEntity[\n                        subject.metadata.createDateColumn.propertyName\n                    ]\n                }\n\n                if (\n                    subject.metadata.updateDateColumn &&\n                    subject.metadata.updateDateColumn.propertyName\n                ) {\n                    partialEntity[\n                        subject.metadata.updateDateColumn.propertyName\n                    ] = new Date()\n                }\n\n                const manager = this.queryRunner.manager as MongoEntityManager\n\n                await manager.update(\n                    subject.metadata.target,\n                    subject.identifier,\n                    partialEntity,\n                )\n            } else {\n                const updateMap: ObjectLiteral =\n                    subject.createValueSetAndPopChangeMap()\n\n                // for tree tables we execute additional queries\n                switch (subject.metadata.treeType) {\n                    case \"nested-set\":\n                        await new NestedSetSubjectExecutor(\n                            this.queryRunner,\n                        ).update(subject)\n                        break\n\n                    case \"closure-table\":\n                        await new ClosureSubjectExecutor(\n                            this.queryRunner,\n                        ).update(subject)\n                        break\n\n                    case \"materialized-path\":\n                        await new MaterializedPathSubjectExecutor(\n                            this.queryRunner,\n                        ).update(subject)\n                        break\n                }\n\n                // here we execute our updation query\n                // we need to enable entity updation because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const updateQueryBuilder = this.queryRunner.manager\n                    .createQueryBuilder()\n                    .update(subject.metadata.target)\n                    .set(updateMap)\n                    .updateEntity(\n                        this.options && this.options.reload === false\n                            ? false\n                            : true,\n                    )\n                    .callListeners(false)\n\n                if (subject.entity) {\n                    updateQueryBuilder.whereEntity(subject.identifier)\n                } else {\n                    // in this case identifier is just conditions object to update by\n                    updateQueryBuilder.where(subject.identifier)\n                }\n\n                const updateResult = await updateQueryBuilder.execute()\n                const updateGeneratedMap = updateResult.generatedMaps[0]\n                if (updateGeneratedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(updateGeneratedMap!)\n                        if (value !== undefined && value !== null) {\n                            const preparedValue =\n                                this.queryRunner.connection.driver.prepareHydratedValue(\n                                    value,\n                                    column,\n                                )\n                            column.setEntityValue(\n                                updateGeneratedMap!,\n                                preparedValue,\n                            )\n                        }\n                    })\n                    if (!subject.generatedMap) {\n                        subject.generatedMap = {}\n                    }\n                    Object.assign(subject.generatedMap, updateGeneratedMap)\n                }\n            }\n        }\n\n        // Nested sets need to be updated one by one\n        // Split array in two, one with nested set subjects and the other with the remaining subjects\n        const nestedSetSubjects: Subject[] = []\n        const remainingSubjects: Subject[] = []\n\n        for (const subject of this.updateSubjects) {\n            if (subject.metadata.treeType === \"nested-set\") {\n                nestedSetSubjects.push(subject)\n            } else {\n                remainingSubjects.push(subject)\n            }\n        }\n\n        // Run nested set updates one by one\n        const nestedSetPromise = new Promise<void>(async (ok, fail) => {\n            for (const subject of nestedSetSubjects) {\n                try {\n                    await updateSubject(subject)\n                } catch (error) {\n                    fail(error)\n                }\n            }\n            ok()\n        })\n\n        // Run all remaining subjects in parallel\n        await Promise.all([\n            ...remainingSubjects.map(updateSubject),\n            nestedSetPromise,\n        ])\n    }\n\n    /**\n     * Removes all given subjects from the database.\n     *\n     * todo: we need to apply topological sort here as well\n     */\n    protected async executeRemoveOperations(): Promise<void> {\n        // group insertion subjects to make bulk insertions\n        const [groupedRemoveSubjects, groupedRemoveSubjectKeys] =\n            this.groupBulkSubjects(this.removeSubjects, \"delete\")\n\n        for (const groupName of groupedRemoveSubjectKeys) {\n            const subjects = groupedRemoveSubjects[groupName]\n            const deleteMaps = subjects.map((subject) => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject)\n\n                return subject.identifier\n            })\n\n            // for mongodb we have a bit different updation logic\n            if (\n                InstanceChecker.isMongoEntityManager(this.queryRunner.manager)\n            ) {\n                const manager = this.queryRunner.manager as MongoEntityManager\n                await manager.delete(subjects[0].metadata.target, deleteMaps)\n            } else {\n                // for tree tables we execute additional queries\n                switch (subjects[0].metadata.treeType) {\n                    case \"nested-set\":\n                        await new NestedSetSubjectExecutor(\n                            this.queryRunner,\n                        ).remove(subjects)\n                        break\n\n                    case \"closure-table\":\n                        await new ClosureSubjectExecutor(\n                            this.queryRunner,\n                        ).remove(subjects)\n                        break\n                }\n\n                // here we execute our deletion query\n                // we don't need to specify entities and set update entity to true since the only thing query builder\n                // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n                // also, we disable listeners because we call them on our own in persistence layer\n                await this.queryRunner.manager\n                    .createQueryBuilder()\n                    .delete()\n                    .from(subjects[0].metadata.target)\n                    .where(deleteMaps)\n                    .callListeners(false)\n                    .execute()\n            }\n        }\n    }\n\n    private cloneMongoSubjectEntity(subject: Subject): ObjectLiteral {\n        const target: ObjectLiteral = {}\n\n        if (subject.entity) {\n            for (const column of subject.metadata.columns) {\n                OrmUtils.mergeDeep(\n                    target,\n                    column.getEntityValueMap(subject.entity),\n                )\n            }\n        }\n\n        return target\n    }\n\n    /**\n     * Soft-removes all given subjects in the database.\n     */\n    protected async executeSoftRemoveOperations(): Promise<void> {\n        await Promise.all(\n            this.softRemoveSubjects.map(async (subject) => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject)\n\n                let updateResult: UpdateResult\n\n                // for mongodb we have a bit different updation logic\n                if (\n                    InstanceChecker.isMongoEntityManager(\n                        this.queryRunner.manager,\n                    )\n                ) {\n                    const partialEntity = this.cloneMongoSubjectEntity(subject)\n                    if (\n                        subject.metadata.objectIdColumn &&\n                        subject.metadata.objectIdColumn.propertyName\n                    ) {\n                        delete partialEntity[\n                            subject.metadata.objectIdColumn.propertyName\n                        ]\n                    }\n\n                    if (\n                        subject.metadata.createDateColumn &&\n                        subject.metadata.createDateColumn.propertyName\n                    ) {\n                        delete partialEntity[\n                            subject.metadata.createDateColumn.propertyName\n                        ]\n                    }\n\n                    if (\n                        subject.metadata.updateDateColumn &&\n                        subject.metadata.updateDateColumn.propertyName\n                    ) {\n                        partialEntity[\n                            subject.metadata.updateDateColumn.propertyName\n                        ] = new Date()\n                    }\n\n                    if (\n                        subject.metadata.deleteDateColumn &&\n                        subject.metadata.deleteDateColumn.propertyName\n                    ) {\n                        partialEntity[\n                            subject.metadata.deleteDateColumn.propertyName\n                        ] = new Date()\n                    }\n\n                    const manager = this.queryRunner\n                        .manager as MongoEntityManager\n\n                    updateResult = await manager.update(\n                        subject.metadata.target,\n                        subject.identifier,\n                        partialEntity,\n                    )\n                } else {\n                    // here we execute our soft-deletion query\n                    // we need to enable entity soft-deletion because we update a subject identifier\n                    // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                    // also, we disable listeners because we call them on our own in persistence layer\n                    const softDeleteQueryBuilder = this.queryRunner.manager\n                        .createQueryBuilder()\n                        .softDelete()\n                        .from(subject.metadata.target)\n                        .updateEntity(\n                            this.options && this.options.reload === false\n                                ? false\n                                : true,\n                        )\n                        .callListeners(false)\n\n                    if (subject.entity) {\n                        softDeleteQueryBuilder.whereEntity(subject.identifier)\n                    } else {\n                        // in this case identifier is just conditions object to update by\n                        softDeleteQueryBuilder.where(subject.identifier)\n                    }\n\n                    updateResult = await softDeleteQueryBuilder.execute()\n                }\n\n                subject.generatedMap = updateResult.generatedMaps[0]\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(\n                            subject.generatedMap!,\n                        )\n                        if (value !== undefined && value !== null) {\n                            const preparedValue =\n                                this.queryRunner.connection.driver.prepareHydratedValue(\n                                    value,\n                                    column,\n                                )\n                            column.setEntityValue(\n                                subject.generatedMap!,\n                                preparedValue,\n                            )\n                        }\n                    })\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }),\n        )\n    }\n\n    /**\n     * Recovers all given subjects in the database.\n     */\n    protected async executeRecoverOperations(): Promise<void> {\n        await Promise.all(\n            this.recoverSubjects.map(async (subject) => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject)\n\n                let updateResult: UpdateResult\n\n                // for mongodb we have a bit different updation logic\n                if (\n                    InstanceChecker.isMongoEntityManager(\n                        this.queryRunner.manager,\n                    )\n                ) {\n                    const partialEntity = this.cloneMongoSubjectEntity(subject)\n                    if (\n                        subject.metadata.objectIdColumn &&\n                        subject.metadata.objectIdColumn.propertyName\n                    ) {\n                        delete partialEntity[\n                            subject.metadata.objectIdColumn.propertyName\n                        ]\n                    }\n\n                    if (\n                        subject.metadata.createDateColumn &&\n                        subject.metadata.createDateColumn.propertyName\n                    ) {\n                        delete partialEntity[\n                            subject.metadata.createDateColumn.propertyName\n                        ]\n                    }\n\n                    if (\n                        subject.metadata.updateDateColumn &&\n                        subject.metadata.updateDateColumn.propertyName\n                    ) {\n                        partialEntity[\n                            subject.metadata.updateDateColumn.propertyName\n                        ] = new Date()\n                    }\n\n                    if (\n                        subject.metadata.deleteDateColumn &&\n                        subject.metadata.deleteDateColumn.propertyName\n                    ) {\n                        partialEntity[\n                            subject.metadata.deleteDateColumn.propertyName\n                        ] = null\n                    }\n\n                    const manager = this.queryRunner\n                        .manager as MongoEntityManager\n\n                    updateResult = await manager.update(\n                        subject.metadata.target,\n                        subject.identifier,\n                        partialEntity,\n                    )\n                } else {\n                    // here we execute our restory query\n                    // we need to enable entity restory because we update a subject identifier\n                    // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                    // also, we disable listeners because we call them on our own in persistence layer\n                    const softDeleteQueryBuilder = this.queryRunner.manager\n                        .createQueryBuilder()\n                        .restore()\n                        .from(subject.metadata.target)\n                        .updateEntity(\n                            this.options && this.options.reload === false\n                                ? false\n                                : true,\n                        )\n                        .callListeners(false)\n\n                    if (subject.entity) {\n                        softDeleteQueryBuilder.whereEntity(subject.identifier)\n                    } else {\n                        // in this case identifier is just conditions object to update by\n                        softDeleteQueryBuilder.where(subject.identifier)\n                    }\n\n                    updateResult = await softDeleteQueryBuilder.execute()\n                }\n\n                subject.generatedMap = updateResult.generatedMaps[0]\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(\n                            subject.generatedMap!,\n                        )\n                        if (value !== undefined && value !== null) {\n                            const preparedValue =\n                                this.queryRunner.connection.driver.prepareHydratedValue(\n                                    value,\n                                    column,\n                                )\n                            column.setEntityValue(\n                                subject.generatedMap!,\n                                preparedValue,\n                            )\n                        }\n                    })\n                }\n\n                // experiments, remove probably, need to implement tree tables children removal\n                // if (subject.updatedRelationMaps.length > 0) {\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n                //         if (!updatedRelation.relation.isTreeParent) return;\n                //         if (!updatedRelation.value !== null) return;\n                //\n                //         if (subject.metadata.treeType === \"closure-table\") {\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n                //         }\n                //     }));\n                // }\n            }),\n        )\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInPersistedEntities(): void {\n        // update inserted entity properties\n        if (this.insertSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(\n                this.insertSubjects,\n            )\n\n        // update updated entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(\n                this.updateSubjects,\n            )\n\n        // update soft-removed entity properties\n        if (this.softRemoveSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(\n                this.softRemoveSubjects,\n            )\n\n        // update recovered entity properties\n        if (this.recoverSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(\n                this.recoverSubjects,\n            )\n\n        // remove ids from the entities that were removed\n        if (this.removeSubjects.length) {\n            this.removeSubjects.forEach((subject) => {\n                if (!subject.entity) return\n\n                subject.metadata.primaryColumns.forEach((primaryColumn) => {\n                    primaryColumn.setEntityValue(subject.entity!, undefined)\n                })\n            })\n        }\n\n        // other post-persist updations\n        this.allSubjects.forEach((subject) => {\n            if (!subject.entity) return\n\n            subject.metadata.relationIds.forEach((relationId) => {\n                relationId.setValue(subject.entity!)\n            })\n\n            // mongo _id remove\n            if (\n                InstanceChecker.isMongoEntityManager(this.queryRunner.manager)\n            ) {\n                if (\n                    subject.metadata.objectIdColumn &&\n                    subject.metadata.objectIdColumn.databaseName &&\n                    subject.metadata.objectIdColumn.databaseName !==\n                        subject.metadata.objectIdColumn.propertyName\n                ) {\n                    delete subject.entity[\n                        subject.metadata.objectIdColumn.databaseName\n                    ]\n                }\n            }\n        })\n    }\n\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    protected updateSpecialColumnsInInsertedAndUpdatedEntities(\n        subjects: Subject[],\n    ): void {\n        subjects.forEach((subject) => {\n            if (!subject.entity) return\n\n            // set values to \"null\" for nullable columns that did not have values\n            subject.metadata.columns.forEach((column) => {\n                // if table inheritance is used make sure this column is not child's column\n                if (\n                    subject.metadata.childEntityMetadatas.length > 0 &&\n                    subject.metadata.childEntityMetadatas\n                        .map((metadata) => metadata.target)\n                        .indexOf(column.target) !== -1\n                )\n                    return\n\n                // entities does not have virtual columns\n                if (column.isVirtual) return\n\n                // if column is deletedAt\n                if (column.isDeleteDate) return\n\n                // update nullable columns\n                if (column.isNullable) {\n                    const columnValue = column.getEntityValue(subject.entity!)\n                    if (columnValue === undefined)\n                        column.setEntityValue(subject.entity!, null)\n                }\n\n                // update relational columns\n                if (subject.updatedRelationMaps.length > 0) {\n                    subject.updatedRelationMaps.forEach(\n                        (updatedRelationMap) => {\n                            updatedRelationMap.relation.joinColumns.forEach(\n                                (column) => {\n                                    if (column.isVirtual === true) return\n\n                                    column.setEntityValue(\n                                        subject.entity!,\n                                        ObjectUtils.isObject(\n                                            updatedRelationMap.value,\n                                        )\n                                            ? column.referencedColumn!.getEntityValue(\n                                                  updatedRelationMap.value,\n                                              )\n                                            : updatedRelationMap.value,\n                                    )\n                                },\n                            )\n                        },\n                    )\n                }\n            })\n\n            // merge into entity all generated values returned by a database\n            if (subject.generatedMap)\n                this.queryRunner.manager.merge(\n                    subject.metadata.target as any,\n                    subject.entity,\n                    subject.generatedMap,\n                )\n        })\n    }\n\n    /**\n     * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\n     * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\n     * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\n     * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\n     * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\n     * That's why we only support bulking in junction tables for those drivers.\n     *\n     * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\n     * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\n     */\n    protected groupBulkSubjects(\n        subjects: Subject[],\n        type: \"insert\" | \"delete\",\n    ): [{ [key: string]: Subject[] }, string[]] {\n        const group: { [key: string]: Subject[] } = {}\n        const keys: string[] = []\n        const hasReturningDependColumns = subjects.some((subject) => {\n            return subject.metadata.getInsertionReturningColumns().length > 0\n        })\n        const groupingAllowed =\n            type === \"delete\" ||\n            this.queryRunner.connection.driver.isReturningSqlSupported(\n                \"insert\",\n            ) ||\n            hasReturningDependColumns === false\n\n        subjects.forEach((subject, index) => {\n            const key =\n                groupingAllowed || subject.metadata.isJunction\n                    ? subject.metadata.name\n                    : subject.metadata.name + \"_\" + index\n            if (!group[key]) {\n                group[key] = [subject]\n                keys.push(key)\n            } else {\n                group[key].push(subject)\n            }\n        })\n\n        return [group, keys]\n    }\n}\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAA;AACrE,OAAO,EAAE,6BAA6B,EAAE,MAAM,iCAAiC,CAAA;AAC/E,OAAO,EAAE,6BAA6B,EAAE,MAAM,wCAAwC,CAAA;AACtF,OAAO,EAAE,6BAA6B,EAAE,MAAM,wCAAwC,CAAA;AAKtF,OAAO,EAAE,iBAAiB,EAAE,MAAM,iCAAiC,CAAA;AACnE,OAAO,EAAE,wBAAwB,EAAE,MAAM,iCAAiC,CAAA;AAC1E,OAAO,EAAE,sBAAsB,EAAE,MAAM,+BAA+B,CAAA;AACtE,OAAO,EAAE,+BAA+B,EAAE,MAAM,wCAAwC,CAAA;AACxF,OAAO,EAAE,QAAQ,EAAE,MAAM,kBAAkB,CAAA;AAE3C,OAAO,EAAE,WAAW,EAAE,MAAM,qBAAqB,CAAA;AACjD,OAAO,EAAE,eAAe,EAAE,MAAM,yBAAyB,CAAA;;;;;;;;;;;;AAMnD,MAAO,eAAe;IAsDxB,4EAA4E;IAC5E,cAAc;IACd,4EAA4E;IAE5E,YACI,WAAwB,EACxB,QAAmB,EACnB,OAAqC,CAAA;QA5DzC,4EAA4E;QAC5E,oBAAoB;QACpB,4EAA4E;QAE5E;;WAEG,CACH,IAAA,CAAA,uBAAuB,GAAY,KAAK,CAAA;QAqBxC;;WAEG,CACO,IAAA,CAAA,cAAc,GAAc,EAAE,CAAA;QAExC;;WAEG,CACO,IAAA,CAAA,cAAc,GAAc,EAAE,CAAA;QAExC;;WAEG,CACO,IAAA,CAAA,cAAc,GAAc,EAAE,CAAA;QAExC;;WAEG,CACO,IAAA,CAAA,kBAAkB,GAAc,EAAE,CAAA;QAE5C;;WAEG,CACO,IAAA,CAAA,eAAe,GAAc,EAAE,CAAA;QAWrC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAA;QAC9B,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAA;QAC3B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAA;QACtB,IAAI,CAAC,QAAQ,EAAE,CAAA;QACf,IAAI,CAAC,SAAS,EAAE,CAAA;IACpB,CAAC;IAED,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E;;;OAGG,CACH,KAAK,CAAC,OAAO,GAAA;QACT,2CAA2C;QAE3C,gFAAgF;QAChF,IAAI,iBAAiB,GAAkC,SAAS,CAAA;QAChE,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,SAAS,KAAK,KAAK,EAAE,CAAC;YACpD,gDAAgD;YAChD,iBAAiB,GAAG,IAAI,CAAC,2BAA2B,EAAE,CAAA;YACtD,IAAI,iBAAiB,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EACrC,MAAM,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAA;QACjD,mDAAmD;QACvD,CAAC;QAED,sIAAsI;QACtI,+EAA+E;QAC/E,IAAI,iBAAiB,IAAI,iBAAiB,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC;YACnD,8BAA8B;YAC9B,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,SAAS,EAAE,CAAC,CAAA;YAC7D,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,SAAS,EAAE,CAAC,CAAA;YAC7D,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,SAAS,EAAE,CAAC,CAAA;YAC7D,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,SAAS,EAAE,CAAC,CAAA;YACjE,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,SAAS,EAAE,CAAC,CAAA;YAC9D,IAAI,CAAC,SAAS,EAAE,CAAA;QAChB,iCAAiC;QACrC,CAAC;QAED,6GAA6G;QAE7G,8BAA8B;QAE9B,gCAAgC;QAChC,8BAA8B;QAC9B,IAAI,CAAC,cAAc,GAAG,0LAAI,2BAAwB,CAC9C,IAAI,CAAC,cAAc,CACtB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;QAChB,MAAM,IAAI,CAAC,uBAAuB,EAAE,CAAA;QACpC,iCAAiC;QAEjC,qFAAqF;QACrF,sEAAsE;QACtE,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CACzC,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,aAAa,CACrC,CAAA;QAED,4BAA4B;QAC5B,6BAA6B;QAC7B,MAAM,IAAI,CAAC,uBAAuB,EAAE,CAAA;QACpC,gCAAgC;QAEhC,yHAAyH;QACzH,4BAA4B;QAC5B,IAAI,CAAC,cAAc,GAAG,0LAAI,2BAAwB,CAC9C,IAAI,CAAC,cAAc,CACtB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;QAChB,MAAM,IAAI,CAAC,uBAAuB,EAAE,CAAA;QACpC,+BAA+B;QAE/B,mCAAmC;QACnC,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAC7C,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,iBAAiB,CACzC,CAAA;QAED,iCAAiC;QACjC,MAAM,IAAI,CAAC,2BAA2B,EAAE,CAAA;QAExC,+BAA+B;QAC/B,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAC1C,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,eAAe,CACvC,CAAA;QAED,6BAA6B;QAC7B,MAAM,IAAI,CAAC,wBAAwB,EAAE,CAAA;QAErC,6GAA6G;QAC7G,4DAA4D;QAC5D,IAAI,CAAC,uCAAuC,EAAE,CAAA;QAC9C,+DAA+D;QAE/D,uFAAuF;QACvF,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,SAAS,KAAK,KAAK,EAAE,CAAC;YACpD,+CAA+C;YAC/C,iBAAiB,GAAG,IAAI,CAAC,0BAA0B,EAAE,CAAA;YACrD,IAAI,iBAAiB,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EACrC,MAAM,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAA;QACjD,kDAAkD;QACtD,CAAC;IACD,8CAA8C;IAClD,CAAC;IAED,4EAA4E;IAC5E,oBAAoB;IACpB,4EAA4E;IAE5E;;OAEG,CACO,QAAQ,GAAA;QACd,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YACjC,IAAI,OAAO,CAAC,aAAa,IAAI,OAAO,CAAC,aAAa,EAC9C,MAAM,yLAAI,gCAA6B,CAAC,OAAO,CAAC,CAAA;QACxD,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;OAEG,CACO,SAAS,GAAA;QACf,+LAAI,gCAA6B,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;QAC7D,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CACzC,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,cAAc,CACtC,CAAA;QACD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CACzC,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,aAAa,CACrC,CAAA;QACD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CACzC,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,aAAa,CACrC,CAAA;QACD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAC7C,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,iBAAiB,CACzC,CAAA;QACD,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAC1C,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,eAAe,CACvC,CAAA;QACD,IAAI,CAAC,uBAAuB,GACxB,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,IAC9B,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,IAC9B,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,IAC9B,IAAI,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,IAClC,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAA;IACvC,CAAC;IAED;;OAEG,CACO,2BAA2B,GAAA;QACjC,MAAM,MAAM,GAAG,kLAAI,oBAAiB,EAAE,CAAA;QACtC,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAC1B,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAClC,CADoC,GAChC,CAAC,WAAW,CAAC,WAAW,CAAC,0BAA0B,CACnD,MAAM,EACN,OAAO,CAAC,QAAQ,EAChB,OAAO,CAAC,MAAO,CAClB,CACJ,CAAA;QACL,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAC1B,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAClC,CADoC,GAChC,CAAC,WAAW,CAAC,WAAW,CAAC,0BAA0B,CACnD,MAAM,EACN,OAAO,CAAC,QAAQ,EAChB,OAAO,CAAC,MAAO,EACf,OAAO,CAAC,cAAc,EACtB,OAAO,CAAC,WAAW,EACnB,OAAO,CAAC,aAAa,CACxB,CACJ,CAAA;QACL,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAC1B,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAClC,CADoC,GAChC,CAAC,WAAW,CAAC,WAAW,CAAC,0BAA0B,CACnD,MAAM,EACN,OAAO,CAAC,QAAQ,EAChB,OAAO,CAAC,MAAO,EACf,OAAO,CAAC,cAAc,EACtB,OAAO,CAAC,UAAU,CACrB,CACJ,CAAA;QACL,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAC9B,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CACtC,CADwC,GACpC,CAAC,WAAW,CAAC,WAAW,CAAC,8BAA8B,CACvD,MAAM,EACN,OAAO,CAAC,QAAQ,EAChB,OAAO,CAAC,MAAO,EACf,OAAO,CAAC,cAAc,EACtB,OAAO,CAAC,UAAU,CACrB,CACJ,CAAA;QACL,IAAI,IAAI,CAAC,eAAe,CAAC,MAAM,EAC3B,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CACnC,CADqC,GACjC,CAAC,WAAW,CAAC,WAAW,CAAC,2BAA2B,CACpD,MAAM,EACN,OAAO,CAAC,QAAQ,EAChB,OAAO,CAAC,MAAO,EACf,OAAO,CAAC,cAAc,EACtB,OAAO,CAAC,UAAU,CACrB,CACJ,CAAA;QACL,OAAO,MAAM,CAAA;IACjB,CAAC;IAED;;;;OAIG,CACO,0BAA0B,GAAA;QAChC,MAAM,MAAM,GAAG,kLAAI,oBAAiB,EAAE,CAAA;QACtC,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAC1B,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAClC,CADoC,GAChC,CAAC,WAAW,CAAC,WAAW,CAAC,yBAAyB,CAClD,MAAM,EACN,OAAO,CAAC,QAAQ,EAChB,OAAO,CAAC,MAAO,EACf,OAAO,CAAC,UAAU,CACrB,CACJ,CAAA;QACL,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAC1B,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAClC,CADoC,GAChC,CAAC,WAAW,CAAC,WAAW,CAAC,yBAAyB,CAClD,MAAM,EACN,OAAO,CAAC,QAAQ,EAChB,OAAO,CAAC,MAAO,EACf,OAAO,CAAC,cAAc,EACtB,OAAO,CAAC,WAAW,EACnB,OAAO,CAAC,aAAa,CACxB,CACJ,CAAA;QACL,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAC1B,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAClC,CADoC,GAChC,CAAC,WAAW,CAAC,WAAW,CAAC,yBAAyB,CAClD,MAAM,EACN,OAAO,CAAC,QAAQ,EAChB,OAAO,CAAC,MAAO,EACf,OAAO,CAAC,cAAc,EACtB,OAAO,CAAC,UAAU,CACrB,CACJ,CAAA;QACL,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAC9B,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CACtC,CADwC,GACpC,CAAC,WAAW,CAAC,WAAW,CAAC,6BAA6B,CACtD,MAAM,EACN,OAAO,CAAC,QAAQ,EAChB,OAAO,CAAC,MAAO,EACf,OAAO,CAAC,cAAc,EACtB,OAAO,CAAC,UAAU,CACrB,CACJ,CAAA;QACL,IAAI,IAAI,CAAC,eAAe,CAAC,MAAM,EAC3B,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CACnC,CADqC,GACjC,CAAC,WAAW,CAAC,WAAW,CAAC,0BAA0B,CACnD,MAAM,EACN,OAAO,CAAC,QAAQ,EAChB,OAAO,CAAC,MAAO,EACf,OAAO,CAAC,cAAc,EACtB,OAAO,CAAC,UAAU,CACrB,CACJ,CAAA;QACL,OAAO,MAAM,CAAA;IACjB,CAAC;IAED;;OAEG,CACO,KAAK,CAAC,uBAAuB,GAAA;QACnC,mDAAmD;QACnD,MAAM,CAAC,qBAAqB,EAAE,wBAAwB,CAAC,GACnD,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAA;QAEzD,qGAAqG;QACrG,KAAK,MAAM,SAAS,IAAI,wBAAwB,CAAE,CAAC;YAC/C,MAAM,QAAQ,GAAG,qBAAqB,CAAC,SAAS,CAAC,CAAA;YAEjD,8EAA8E;YAC9E,wFAAwF;YACxF,MAAM,cAAc,GAAoB,EAAE,CAAA;YAC1C,MAAM,kBAAkB,GAAc,EAAE,CAAA;YACxC,MAAM,oBAAoB,GAAc,EAAE,CAAA;YAC1C,IAAI,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;gBAChE,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;oBACzB,IAAI,OAAO,CAAC,QAAQ,CAAC,gBAAgB,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;wBACtD,OAAO,CAAC,MAAM,CACV,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CACjD,GAAG,IAAI,IAAI,EAAE,CAAA;oBAClB,CAAC;oBAED,IAAI,OAAO,CAAC,QAAQ,CAAC,gBAAgB,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;wBACtD,OAAO,CAAC,MAAM,CACV,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CACjD,GAAG,IAAI,IAAI,EAAE,CAAA;oBAClB,CAAC;oBAED,OAAO,CAAC,6BAA6B,EAAE,CAAA;oBAEvC,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;oBAChC,cAAc,CAAC,IAAI,CAAC,OAAO,CAAC,MAAO,CAAC,CAAA;gBACxC,CAAC,CAAC,CAAA;YACN,CAAC,MAAM,IACH,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,QAAQ,EAC9D,CAAC;gBACC,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;oBACzB,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;gBACtC,CAAC,CAAC,CAAA;YACN,CAAC,MAAM,CAAC;gBACJ,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;oBACzB,+CAA+C;oBAC/C,6IAA6I;oBAC7I,iGAAiG;oBACjG,mEAAmE;oBACnE,IACI,OAAO,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,IAC/B,OAAO,CAAC,QAAQ,CAAC,QAAQ,IACzB,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAC3C,QAAQ,IACZ,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAC3C,KAAK,EACX,CAAC;wBACC,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;oBACtC,CAAC,MAAM,CAAC;wBACJ,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;wBAChC,cAAc,CAAC,IAAI,CACf,OAAO,CAAC,6BAA6B,EAAE,CAC1C,CAAA;oBACL,CAAC;gBACL,CAAC,CAAC,CAAA;YACN,CAAC;YAED,sDAAsD;YACtD,0KACI,kBAAe,CAAC,oBAAoB,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,EAChE,CAAC;gBACC,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,MAAM,CACtD,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,EAC3B,cAAc,CACjB,CAAA;gBACD,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE;oBAChC,OAAO,CAAC,UAAU,GAAG,YAAY,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;oBACpD,OAAO,CAAC,YAAY,GAAG,YAAY,CAAC,aAAa,CAAC,KAAK,CAAC,CAAA;oBACxD,OAAO,CAAC,gBAAgB,GAAG,cAAc,CAAC,KAAK,CAAC,CAAA;gBACpD,CAAC,CAAC,CAAA;YACN,CAAC,MAAM,CAAC;gBACJ,sCAAsC;gBACtC,mFAAmF;gBACnF,yGAAyG;gBACzG,kFAAkF;gBAClF,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBAC5B,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CAC9C,kBAAkB,EAAE,CACpB,MAAM,EAAE,CACR,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CACjC,MAAM,CAAC,cAAc,CAAC,CACtB,YAAY,CACT,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,KAAK,GACvC,KAAK,GACL,IAAI,CACb,CACA,aAAa,CAAC,KAAK,CAAC,CACpB,OAAO,EAAE,CAAA;oBAEd,kBAAkB,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE;wBAC1C,OAAO,CAAC,UAAU,GAAG,YAAY,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;wBACpD,OAAO,CAAC,YAAY,GAAG,YAAY,CAAC,aAAa,CAAC,KAAK,CAAC,CAAA;wBACxD,OAAO,CAAC,gBAAgB,GAAG,cAAc,CAAC,KAAK,CAAC,CAAA;oBACpD,CAAC,CAAC,CAAA;gBACN,CAAC;gBAED,mFAAmF;gBACnF,IAAI,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBAClC,KAAK,MAAM,OAAO,IAAI,oBAAoB,CAAE,CAAC;wBACzC,OAAO,CAAC,gBAAgB,GACpB,OAAO,CAAC,6BAA6B,EAAE,CAAA,CAAC,uEAAuE;wBAEnH,+CAA+C;wBAC/C,IAAI,OAAO,CAAC,QAAQ,CAAC,QAAQ,KAAK,YAAY,EAC1C,MAAM,kMAAI,2BAAwB,CAC9B,IAAI,CAAC,WAAW,CACnB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAA;wBAErB,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CACzB,kBAAkB,EAAE,CACpB,MAAM,EAAE,CACR,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CAC7B,MAAM,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAChC,YAAY,CACT,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,KAAK,GACvC,KAAK,GACL,IAAI,CACb,CACA,aAAa,CAAC,KAAK,CAAC,CACpB,OAAO,EAAE,CACT,IAAI,CAAC,CAAC,YAAY,EAAE,EAAE;4BACnB,OAAO,CAAC,UAAU,GAAG,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC,CAAA;4BAChD,OAAO,CAAC,YAAY,GAChB,YAAY,CAAC,aAAa,CAAC,CAAC,CAAC,CAAA;wBACrC,CAAC,CAAC,CAAA;wBAEN,gDAAgD;wBAChD,IAAI,OAAO,CAAC,QAAQ,CAAC,QAAQ,KAAK,eAAe,EAAE,CAAC;4BAChD,MAAM,gMAAI,yBAAsB,CAC5B,IAAI,CAAC,WAAW,CACnB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAA;wBACrB,CAAC,MAAM,IACH,OAAO,CAAC,QAAQ,CAAC,QAAQ,KAAK,mBAAmB,EACnD,CAAC;4BACC,MAAM,yMAAI,kCAA+B,CACrC,IAAI,CAAC,WAAW,CACnB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAA;wBACrB,CAAC;oBACL,CAAC;gBACL,CAAC;YACL,CAAC;YAED,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gBACzB,IAAI,OAAO,CAAC,YAAY,EAAE,CAAC;oBACvB,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;wBACxC,MAAM,KAAK,GAAG,MAAM,CAAC,cAAc,CAC/B,OAAO,CAAC,YAAa,CACxB,CAAA;wBACD,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;4BACxC,MAAM,aAAa,GACf,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,oBAAoB,CACnD,KAAK,EACL,MAAM,CACT,CAAA;4BACL,MAAM,CAAC,cAAc,CACjB,OAAO,CAAC,YAAa,EACrB,aAAa,CAChB,CAAA;wBACL,CAAC;oBACL,CAAC,CAAC,CAAA;gBACN,CAAC;YACL,CAAC,CAAC,CAAA;QACN,CAAC;IACL,CAAC;IAED;;OAEG,CACO,KAAK,CAAC,uBAAuB,GAAA;QACnC,MAAM,aAAa,GAAG,KAAK,EAAE,OAAgB,EAAE,EAAE;YAC7C,IAAI,CAAC,OAAO,CAAC,UAAU,EACnB,MAAM,yLAAI,gCAA6B,CAAC,OAAO,CAAC,CAAA;YAEpD,qDAAqD;YACrD,0KACI,kBAAe,CAAC,oBAAoB,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,EAChE,CAAC;gBACC,MAAM,aAAa,GAAG,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAA;gBAC3D,IACI,OAAO,CAAC,QAAQ,CAAC,cAAc,IAC/B,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,EAC9C,CAAC;oBACC,OAAO,aAAa,CAChB,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,CAC/C,CAAA;gBACL,CAAC;gBAED,IACI,OAAO,CAAC,QAAQ,CAAC,gBAAgB,IACjC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,EAChD,CAAC;oBACC,OAAO,aAAa,CAChB,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CACjD,CAAA;gBACL,CAAC;gBAED,IACI,OAAO,CAAC,QAAQ,CAAC,gBAAgB,IACjC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,EAChD,CAAC;oBACC,aAAa,CACT,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CACjD,GAAG,IAAI,IAAI,EAAE,CAAA;gBAClB,CAAC;gBAED,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,OAA6B,CAAA;gBAE9D,MAAM,OAAO,CAAC,MAAM,CAChB,OAAO,CAAC,QAAQ,CAAC,MAAM,EACvB,OAAO,CAAC,UAAU,EAClB,aAAa,CAChB,CAAA;YACL,CAAC,MAAM,CAAC;gBACJ,MAAM,SAAS,GACX,OAAO,CAAC,6BAA6B,EAAE,CAAA;gBAE3C,gDAAgD;gBAChD,OAAQ,OAAO,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;oBAChC,KAAK,YAAY;wBACb,MAAM,kMAAI,2BAAwB,CAC9B,IAAI,CAAC,WAAW,CACnB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAA;wBACjB,MAAK;oBAET,KAAK,eAAe;wBAChB,MAAM,gMAAI,yBAAsB,CAC5B,IAAI,CAAC,WAAW,CACnB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAA;wBACjB,MAAK;oBAET,KAAK,mBAAmB;wBACpB,MAAM,yMAAI,kCAA+B,CACrC,IAAI,CAAC,WAAW,CACnB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAA;wBACjB,MAAK;gBACb,CAAC;gBAED,qCAAqC;gBACrC,2EAA2E;gBAC3E,yGAAyG;gBACzG,kFAAkF;gBAClF,MAAM,kBAAkB,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAC9C,kBAAkB,EAAE,CACpB,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CAC/B,GAAG,CAAC,SAAS,CAAC,CACd,YAAY,CACT,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,KAAK,GACvC,KAAK,GACL,IAAI,CACb,CACA,aAAa,CAAC,KAAK,CAAC,CAAA;gBAEzB,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;oBACjB,kBAAkB,CAAC,WAAW,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA;gBACtD,CAAC,MAAM,CAAC;oBACJ,iEAAiE;oBACjE,kBAAkB,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA;gBAChD,CAAC;gBAED,MAAM,YAAY,GAAG,MAAM,kBAAkB,CAAC,OAAO,EAAE,CAAA;gBACvD,MAAM,kBAAkB,GAAG,YAAY,CAAC,aAAa,CAAC,CAAC,CAAC,CAAA;gBACxD,IAAI,kBAAkB,EAAE,CAAC;oBACrB,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;wBACxC,MAAM,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,kBAAmB,CAAC,CAAA;wBACxD,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;4BACxC,MAAM,aAAa,GACf,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,oBAAoB,CACnD,KAAK,EACL,MAAM,CACT,CAAA;4BACL,MAAM,CAAC,cAAc,CACjB,kBAAmB,EACnB,aAAa,CAChB,CAAA;wBACL,CAAC;oBACL,CAAC,CAAC,CAAA;oBACF,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;wBACxB,OAAO,CAAC,YAAY,GAAG,CAAA,CAAE,CAAA;oBAC7B,CAAC;oBACD,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,YAAY,EAAE,kBAAkB,CAAC,CAAA;gBAC3D,CAAC;YACL,CAAC;QACL,CAAC,CAAA;QAED,4CAA4C;QAC5C,6FAA6F;QAC7F,MAAM,iBAAiB,GAAc,EAAE,CAAA;QACvC,MAAM,iBAAiB,GAAc,EAAE,CAAA;QAEvC,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,cAAc,CAAE,CAAC;YACxC,IAAI,OAAO,CAAC,QAAQ,CAAC,QAAQ,KAAK,YAAY,EAAE,CAAC;gBAC7C,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;YACnC,CAAC,MAAM,CAAC;gBACJ,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;YACnC,CAAC;QACL,CAAC;QAED,oCAAoC;QACpC,MAAM,gBAAgB,GAAG,IAAI,OAAO,CAAO,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE;YAC1D,KAAK,MAAM,OAAO,IAAI,iBAAiB,CAAE,CAAC;gBACtC,IAAI,CAAC;oBACD,MAAM,aAAa,CAAC,OAAO,CAAC,CAAA;gBAChC,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;oBACb,IAAI,CAAC,KAAK,CAAC,CAAA;gBACf,CAAC;YACL,CAAC;YACD,EAAE,EAAE,CAAA;QACR,CAAC,CAAC,CAAA;QAEF,yCAAyC;QACzC,MAAM,OAAO,CAAC,GAAG,CAAC;eACX,iBAAiB,CAAC,GAAG,CAAC,aAAa,CAAC;YACvC,gBAAgB;SACnB,CAAC,CAAA;IACN,CAAC;IAED;;;;OAIG,CACO,KAAK,CAAC,uBAAuB,GAAA;QACnC,mDAAmD;QACnD,MAAM,CAAC,qBAAqB,EAAE,wBAAwB,CAAC,GACnD,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAA;QAEzD,KAAK,MAAM,SAAS,IAAI,wBAAwB,CAAE,CAAC;YAC/C,MAAM,QAAQ,GAAG,qBAAqB,CAAC,SAAS,CAAC,CAAA;YACjD,MAAM,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE;gBACxC,IAAI,CAAC,OAAO,CAAC,UAAU,EACnB,MAAM,yLAAI,gCAA6B,CAAC,OAAO,CAAC,CAAA;gBAEpD,OAAO,OAAO,CAAC,UAAU,CAAA;YAC7B,CAAC,CAAC,CAAA;YAEF,qDAAqD;YACrD,0KACI,kBAAe,CAAC,oBAAoB,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,EAChE,CAAC;gBACC,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,OAA6B,CAAA;gBAC9D,MAAM,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,EAAE,UAAU,CAAC,CAAA;YACjE,CAAC,MAAM,CAAC;gBACJ,gDAAgD;gBAChD,OAAQ,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;oBACpC,KAAK,YAAY;wBACb,MAAM,kMAAI,2BAAwB,CAC9B,IAAI,CAAC,WAAW,CACnB,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;wBAClB,MAAK;oBAET,KAAK,eAAe;wBAChB,MAAM,gMAAI,yBAAsB,CAC5B,IAAI,CAAC,WAAW,CACnB,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;wBAClB,MAAK;gBACb,CAAC;gBAED,qCAAqC;gBACrC,qGAAqG;gBACrG,uGAAuG;gBACvG,kFAAkF;gBAClF,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CACzB,kBAAkB,EAAE,CACpB,MAAM,EAAE,CACR,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CACjC,KAAK,CAAC,UAAU,CAAC,CACjB,aAAa,CAAC,KAAK,CAAC,CACpB,OAAO,EAAE,CAAA;YAClB,CAAC;QACL,CAAC;IACL,CAAC;IAEO,uBAAuB,CAAC,OAAgB,EAAA;QAC5C,MAAM,MAAM,GAAkB,CAAA,CAAE,CAAA;QAEhC,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;YACjB,KAAK,MAAM,MAAM,IAAI,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAE,CAAC;+KAC5C,WAAQ,CAAC,SAAS,CACd,MAAM,EACN,MAAM,CAAC,iBAAiB,CAAC,OAAO,CAAC,MAAM,CAAC,CAC3C,CAAA;YACL,CAAC;QACL,CAAC;QAED,OAAO,MAAM,CAAA;IACjB,CAAC;IAED;;OAEG,CACO,KAAK,CAAC,2BAA2B,GAAA;QACvC,MAAM,OAAO,CAAC,GAAG,CACb,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE;YAC1C,IAAI,CAAC,OAAO,CAAC,UAAU,EACnB,MAAM,yLAAI,gCAA6B,CAAC,OAAO,CAAC,CAAA;YAEpD,IAAI,YAA0B,CAAA;YAE9B,qDAAqD;YACrD,0KACI,kBAAe,CAAC,oBAAoB,CAChC,IAAI,CAAC,WAAW,CAAC,OAAO,CAC3B,EACH,CAAC;gBACC,MAAM,aAAa,GAAG,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAA;gBAC3D,IACI,OAAO,CAAC,QAAQ,CAAC,cAAc,IAC/B,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,EAC9C,CAAC;oBACC,OAAO,aAAa,CAChB,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,CAC/C,CAAA;gBACL,CAAC;gBAED,IACI,OAAO,CAAC,QAAQ,CAAC,gBAAgB,IACjC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,EAChD,CAAC;oBACC,OAAO,aAAa,CAChB,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CACjD,CAAA;gBACL,CAAC;gBAED,IACI,OAAO,CAAC,QAAQ,CAAC,gBAAgB,IACjC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,EAChD,CAAC;oBACC,aAAa,CACT,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CACjD,GAAG,IAAI,IAAI,EAAE,CAAA;gBAClB,CAAC;gBAED,IACI,OAAO,CAAC,QAAQ,CAAC,gBAAgB,IACjC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,EAChD,CAAC;oBACC,aAAa,CACT,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CACjD,GAAG,IAAI,IAAI,EAAE,CAAA;gBAClB,CAAC;gBAED,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAC3B,OAA6B,CAAA;gBAElC,YAAY,GAAG,MAAM,OAAO,CAAC,MAAM,CAC/B,OAAO,CAAC,QAAQ,CAAC,MAAM,EACvB,OAAO,CAAC,UAAU,EAClB,aAAa,CAChB,CAAA;YACL,CAAC,MAAM,CAAC;gBACJ,0CAA0C;gBAC1C,gFAAgF;gBAChF,yGAAyG;gBACzG,kFAAkF;gBAClF,MAAM,sBAAsB,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAClD,kBAAkB,EAAE,CACpB,UAAU,EAAE,CACZ,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CAC7B,YAAY,CACT,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,KAAK,GACvC,KAAK,GACL,IAAI,CACb,CACA,aAAa,CAAC,KAAK,CAAC,CAAA;gBAEzB,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;oBACjB,sBAAsB,CAAC,WAAW,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA;gBAC1D,CAAC,MAAM,CAAC;oBACJ,iEAAiE;oBACjE,sBAAsB,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA;gBACpD,CAAC;gBAED,YAAY,GAAG,MAAM,sBAAsB,CAAC,OAAO,EAAE,CAAA;YACzD,CAAC;YAED,OAAO,CAAC,YAAY,GAAG,YAAY,CAAC,aAAa,CAAC,CAAC,CAAC,CAAA;YACpD,IAAI,OAAO,CAAC,YAAY,EAAE,CAAC;gBACvB,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;oBACxC,MAAM,KAAK,GAAG,MAAM,CAAC,cAAc,CAC/B,OAAO,CAAC,YAAa,CACxB,CAAA;oBACD,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;wBACxC,MAAM,aAAa,GACf,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,oBAAoB,CACnD,KAAK,EACL,MAAM,CACT,CAAA;wBACL,MAAM,CAAC,cAAc,CACjB,OAAO,CAAC,YAAa,EACrB,aAAa,CAChB,CAAA;oBACL,CAAC;gBACL,CAAC,CAAC,CAAA;YACN,CAAC;QAED,+EAA+E;QAC/E,gDAAgD;QAChD,mFAAmF;QACnF,8DAA8D;QAC9D,uDAAuD;QACvD,EAAE;QACF,+DAA+D;QAC/D,4FAA4F;QAC5F,YAAY;QACZ,WAAW;QACX,IAAI;QACR,CAAC,CAAC,CACL,CAAA;IACL,CAAC;IAED;;OAEG,CACO,KAAK,CAAC,wBAAwB,GAAA;QACpC,MAAM,OAAO,CAAC,GAAG,CACb,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE;YACvC,IAAI,CAAC,OAAO,CAAC,UAAU,EACnB,MAAM,yLAAI,gCAA6B,CAAC,OAAO,CAAC,CAAA;YAEpD,IAAI,YAA0B,CAAA;YAE9B,qDAAqD;YACrD,0KACI,kBAAe,CAAC,oBAAoB,CAChC,IAAI,CAAC,WAAW,CAAC,OAAO,CAC3B,EACH,CAAC;gBACC,MAAM,aAAa,GAAG,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAA;gBAC3D,IACI,OAAO,CAAC,QAAQ,CAAC,cAAc,IAC/B,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,EAC9C,CAAC;oBACC,OAAO,aAAa,CAChB,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,CAC/C,CAAA;gBACL,CAAC;gBAED,IACI,OAAO,CAAC,QAAQ,CAAC,gBAAgB,IACjC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,EAChD,CAAC;oBACC,OAAO,aAAa,CAChB,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CACjD,CAAA;gBACL,CAAC;gBAED,IACI,OAAO,CAAC,QAAQ,CAAC,gBAAgB,IACjC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,EAChD,CAAC;oBACC,aAAa,CACT,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CACjD,GAAG,IAAI,IAAI,EAAE,CAAA;gBAClB,CAAC;gBAED,IACI,OAAO,CAAC,QAAQ,CAAC,gBAAgB,IACjC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,EAChD,CAAC;oBACC,aAAa,CACT,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CACjD,GAAG,IAAI,CAAA;gBACZ,CAAC;gBAED,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAC3B,OAA6B,CAAA;gBAElC,YAAY,GAAG,MAAM,OAAO,CAAC,MAAM,CAC/B,OAAO,CAAC,QAAQ,CAAC,MAAM,EACvB,OAAO,CAAC,UAAU,EAClB,aAAa,CAChB,CAAA;YACL,CAAC,MAAM,CAAC;gBACJ,oCAAoC;gBACpC,0EAA0E;gBAC1E,yGAAyG;gBACzG,kFAAkF;gBAClF,MAAM,sBAAsB,GAAG,IAAI,CAAC,WAAW,CAAC,OAAO,CAClD,kBAAkB,EAAE,CACpB,OAAO,EAAE,CACT,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,CAC7B,YAAY,CACT,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,KAAK,GACvC,KAAK,GACL,IAAI,CACb,CACA,aAAa,CAAC,KAAK,CAAC,CAAA;gBAEzB,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;oBACjB,sBAAsB,CAAC,WAAW,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA;gBAC1D,CAAC,MAAM,CAAC;oBACJ,iEAAiE;oBACjE,sBAAsB,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA;gBACpD,CAAC;gBAED,YAAY,GAAG,MAAM,sBAAsB,CAAC,OAAO,EAAE,CAAA;YACzD,CAAC;YAED,OAAO,CAAC,YAAY,GAAG,YAAY,CAAC,aAAa,CAAC,CAAC,CAAC,CAAA;YACpD,IAAI,OAAO,CAAC,YAAY,EAAE,CAAC;gBACvB,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;oBACxC,MAAM,KAAK,GAAG,MAAM,CAAC,cAAc,CAC/B,OAAO,CAAC,YAAa,CACxB,CAAA;oBACD,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI,EAAE,CAAC;wBACxC,MAAM,aAAa,GACf,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,oBAAoB,CACnD,KAAK,EACL,MAAM,CACT,CAAA;wBACL,MAAM,CAAC,cAAc,CACjB,OAAO,CAAC,YAAa,EACrB,aAAa,CAChB,CAAA;oBACL,CAAC;gBACL,CAAC,CAAC,CAAA;YACN,CAAC;QAED,+EAA+E;QAC/E,gDAAgD;QAChD,mFAAmF;QACnF,8DAA8D;QAC9D,uDAAuD;QACvD,EAAE;QACF,+DAA+D;QAC/D,4FAA4F;QAC5F,YAAY;QACZ,WAAW;QACX,IAAI;QACR,CAAC,CAAC,CACL,CAAA;IACL,CAAC;IAED;;;OAGG,CACO,uCAAuC,GAAA;QAC7C,oCAAoC;QACpC,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAC1B,IAAI,CAAC,gDAAgD,CACjD,IAAI,CAAC,cAAc,CACtB,CAAA;QAEL,mCAAmC;QACnC,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAC1B,IAAI,CAAC,gDAAgD,CACjD,IAAI,CAAC,cAAc,CACtB,CAAA;QAEL,wCAAwC;QACxC,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,EAC9B,IAAI,CAAC,gDAAgD,CACjD,IAAI,CAAC,kBAAkB,CAC1B,CAAA;QAEL,qCAAqC;QACrC,IAAI,IAAI,CAAC,eAAe,CAAC,MAAM,EAC3B,IAAI,CAAC,gDAAgD,CACjD,IAAI,CAAC,eAAe,CACvB,CAAA;QAEL,iDAAiD;QACjD,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,CAAC;YAC7B,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gBACpC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,OAAM;gBAE3B,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,aAAa,EAAE,EAAE;oBACtD,aAAa,CAAC,cAAc,CAAC,OAAO,CAAC,MAAO,EAAE,SAAS,CAAC,CAAA;gBAC5D,CAAC,CAAC,CAAA;YACN,CAAC,CAAC,CAAA;QACN,CAAC;QAED,+BAA+B;QAC/B,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YACjC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,OAAM;YAE3B,OAAO,CAAC,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,EAAE;gBAChD,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAO,CAAC,CAAA;YACxC,CAAC,CAAC,CAAA;YAEF,mBAAmB;YACnB,0KACI,kBAAe,CAAC,oBAAoB,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,EAChE,CAAC;gBACC,IACI,OAAO,CAAC,QAAQ,CAAC,cAAc,IAC/B,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,IAC5C,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,KACxC,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,EAClD,CAAC;oBACC,OAAO,OAAO,CAAC,MAAM,CACjB,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,CAC/C,CAAA;gBACL,CAAC;YACL,CAAC;QACL,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;;OAGG,CACO,gDAAgD,CACtD,QAAmB,EAAA;QAEnB,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YACzB,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,OAAM;YAE3B,qEAAqE;YACrE,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;gBACxC,2EAA2E;gBAC3E,IACI,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,IAChD,OAAO,CAAC,QAAQ,CAAC,oBAAoB,CAChC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAG,CAAD,OAAS,CAAC,MAAM,CAAC,CAClC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAElC,OAAM;gBAEV,yCAAyC;gBACzC,IAAI,MAAM,CAAC,SAAS,EAAE,OAAM;gBAE5B,yBAAyB;gBACzB,IAAI,MAAM,CAAC,YAAY,EAAE,OAAM;gBAE/B,0BAA0B;gBAC1B,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC;oBACpB,MAAM,WAAW,GAAG,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,MAAO,CAAC,CAAA;oBAC1D,IAAI,WAAW,KAAK,SAAS,EACzB,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,MAAO,EAAE,IAAI,CAAC,CAAA;gBACpD,CAAC;gBAED,4BAA4B;gBAC5B,IAAI,OAAO,CAAC,mBAAmB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBACzC,OAAO,CAAC,mBAAmB,CAAC,OAAO,CAC/B,CAAC,kBAAkB,EAAE,EAAE;wBACnB,kBAAkB,CAAC,QAAQ,CAAC,WAAW,CAAC,OAAO,CAC3C,CAAC,MAAM,EAAE,EAAE;4BACP,IAAI,MAAM,CAAC,SAAS,KAAK,IAAI,EAAE,OAAM;4BAErC,MAAM,CAAC,cAAc,CACjB,OAAO,CAAC,MAAO,oKACf,cAAW,CAAC,QAAQ,CAChB,kBAAkB,CAAC,KAAK,CAC3B,GACK,MAAM,CAAC,gBAAiB,CAAC,cAAc,CACnC,kBAAkB,CAAC,KAAK,CAC3B,GACD,kBAAkB,CAAC,KAAK,CACjC,CAAA;wBACL,CAAC,CACJ,CAAA;oBACL,CAAC,CACJ,CAAA;gBACL,CAAC;YACL,CAAC,CAAC,CAAA;YAEF,gEAAgE;YAChE,IAAI,OAAO,CAAC,YAAY,EACpB,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAC1B,OAAO,CAAC,QAAQ,CAAC,MAAa,EAC9B,OAAO,CAAC,MAAM,EACd,OAAO,CAAC,YAAY,CACvB,CAAA;QACT,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;;;;;;;;;OAUG,CACO,iBAAiB,CACvB,QAAmB,EACnB,IAAyB,EAAA;QAEzB,MAAM,KAAK,GAAiC,CAAA,CAAE,CAAA;QAC9C,MAAM,IAAI,GAAa,EAAE,CAAA;QACzB,MAAM,yBAAyB,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE;YACxD,OAAO,OAAO,CAAC,QAAQ,CAAC,4BAA4B,EAAE,CAAC,MAAM,GAAG,CAAC,CAAA;QACrE,CAAC,CAAC,CAAA;QACF,MAAM,eAAe,GACjB,IAAI,KAAK,QAAQ,IACjB,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAC,uBAAuB,CACtD,QAAQ,CACX,IACD,yBAAyB,KAAK,KAAK,CAAA;QAEvC,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE;YAChC,MAAM,GAAG,GACL,eAAe,IAAI,OAAO,CAAC,QAAQ,CAAC,UAAU,GACxC,OAAO,CAAC,QAAQ,CAAC,IAAI,GACrB,OAAO,CAAC,QAAQ,CAAC,IAAI,GAAG,GAAG,GAAG,KAAK,CAAA;YAC7C,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC;gBACd,KAAK,CAAC,GAAG,CAAC,GAAG;oBAAC,OAAO;iBAAC,CAAA;gBACtB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;YAClB,CAAC,MAAM,CAAC;gBACJ,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;YAC5B,CAAC;QACL,CAAC,CAAC,CAAA;QAEF,OAAO;YAAC,KAAK;YAAE,IAAI;SAAC,CAAA;IACxB,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 1442, "column": 0}, "map": {"version":3,"file":"Subject.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/persistence/Subject.ts"],"sourceRoot":"..","sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { SubjectChangeMap } from \"./SubjectChangeMap\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Subject is a subject of persistence.\n * It holds information about each entity that needs to be persisted:\n * - what entity should be persisted\n * - what is database representation of the persisted entity\n * - what entity metadata of the persisted entity\n * - what is allowed to with persisted entity (insert/update/remove)\n *\n * Having this collection of subjects we can perform database queries.\n */\nexport class Subject {\n    readonly \"@instanceof\" = Symbol.for(\"Subject\")\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the subject entity.\n     */\n    metadata: EntityMetadata\n\n    /**\n     * Subject identifier.\n     * This identifier is not limited to table entity primary columns.\n     * This can be entity id or ids as well as some unique entity properties, like name or title.\n     * Insert / Update / Remove operation will be executed by a given identifier.\n     */\n    identifier: ObjectLiteral | undefined = undefined\n\n    /**\n     * Copy of entity but with relational ids fulfilled.\n     */\n    entityWithFulfilledIds: ObjectLiteral | undefined = undefined\n\n    /**\n     * If subject was created by cascades this property will contain subject\n     * from where this subject was created.\n     */\n    parentSubject?: Subject\n\n    /**\n     * Gets entity sent to the persistence (e.g. changed entity).\n     * If entity is not set then this subject is created only for the entity loaded from the database,\n     * or this subject is used for the junction operation (junction operations are relying only on identifier).\n     */\n    entity?: ObjectLiteral\n\n    /**\n     * Database entity.\n     * THIS IS NOT RAW ENTITY DATA, its a real entity.\n     */\n    databaseEntity?: ObjectLiteral\n\n    /**\n     * Indicates if database entity was loaded.\n     * No matter if it was found or not, it indicates the fact of loading.\n     */\n    databaseEntityLoaded: boolean = false\n\n    /**\n     * Changes needs to be applied in the database for the given subject.\n     */\n    changeMaps: SubjectChangeMap[] = []\n\n    /**\n     * Generated values returned by a database (for example generated id or default values).\n     * Used in insert and update operations.\n     * Has entity-like structure (not just column database name and values).\n     */\n    generatedMap?: ObjectLiteral\n\n    /**\n     * Inserted values with updated values of special and default columns.\n     * Has entity-like structure (not just column database name and values).\n     */\n    insertedValueSet?: ObjectLiteral\n\n    /**\n     * Indicates if this subject can be inserted into the database.\n     * This means that this subject either is newly persisted, either can be inserted by cascades.\n     */\n    canBeInserted: boolean = false\n\n    /**\n     * Indicates if this subject can be updated in the database.\n     * This means that this subject either was persisted, either can be updated by cascades.\n     */\n    canBeUpdated: boolean = false\n\n    /**\n     * Indicates if this subject MUST be removed from the database.\n     * This means that this subject either was removed, either was removed by cascades.\n     */\n    mustBeRemoved: boolean = false\n\n    /**\n     * Indicates if this subject can be soft-removed from the database.\n     * This means that this subject either was soft-removed, either was soft-removed by cascades.\n     */\n    canBeSoftRemoved: boolean = false\n\n    /**\n     * Indicates if this subject can be recovered from the database.\n     * This means that this subject either was recovered, either was recovered by cascades.\n     */\n    canBeRecovered: boolean = false\n\n    /**\n     * Relations updated by the change maps.\n     */\n    updatedRelationMaps: {\n        relation: RelationMetadata\n        value: ObjectLiteral\n    }[] = []\n\n    /**\n     * List of updated columns\n     */\n    diffColumns: ColumnMetadata[] = []\n\n    /**\n     * List of updated relations\n     */\n    diffRelations: RelationMetadata[] = []\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(options: {\n        metadata: EntityMetadata\n        parentSubject?: Subject\n        entity?: ObjectLiteral\n        canBeInserted?: boolean\n        canBeUpdated?: boolean\n        mustBeRemoved?: boolean\n        canBeSoftRemoved?: boolean\n        canBeRecovered?: boolean\n        identifier?: ObjectLiteral\n        changeMaps?: SubjectChangeMap[]\n    }) {\n        this.metadata = options.metadata\n        this.entity = options.entity\n        this.parentSubject = options.parentSubject\n        if (options.canBeInserted !== undefined)\n            this.canBeInserted = options.canBeInserted\n        if (options.canBeUpdated !== undefined)\n            this.canBeUpdated = options.canBeUpdated\n        if (options.mustBeRemoved !== undefined)\n            this.mustBeRemoved = options.mustBeRemoved\n        if (options.canBeSoftRemoved !== undefined)\n            this.canBeSoftRemoved = options.canBeSoftRemoved\n        if (options.canBeRecovered !== undefined)\n            this.canBeRecovered = options.canBeRecovered\n        if (options.identifier !== undefined)\n            this.identifier = options.identifier\n        if (options.changeMaps !== undefined)\n            this.changeMaps.push(...options.changeMaps)\n\n        this.recompute()\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Checks if this subject must be inserted into the database.\n     * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)\n     * and if it does not have database entity set.\n     */\n    get mustBeInserted() {\n        return this.canBeInserted && !this.databaseEntity\n    }\n\n    /**\n     * Checks if this subject must be updated into the database.\n     * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get mustBeUpdated() {\n        return (\n            this.canBeUpdated &&\n            this.identifier &&\n            (this.databaseEntityLoaded === false ||\n                (this.databaseEntityLoaded && this.databaseEntity)) &&\n            // ((this.entity && this.databaseEntity) || (!this.entity && !this.databaseEntity)) &&\n            // ensure there are one or more changes for updatable columns\n            this.changeMaps.some(\n                (change) => !change.column || change.column.isUpdate,\n            )\n        )\n    }\n\n    /**\n     * Checks if this subject must be soft-removed into the database.\n     * Subject can be updated in the database if it is allowed to be soft-removed (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get mustBeSoftRemoved() {\n        return (\n            this.canBeSoftRemoved &&\n            this.identifier &&\n            (this.databaseEntityLoaded === false ||\n                (this.databaseEntityLoaded && this.databaseEntity))\n        )\n    }\n\n    /**\n     * Checks if this subject must be recovered into the database.\n     * Subject can be updated in the database if it is allowed to be recovered (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get mustBeRecovered() {\n        return (\n            this.canBeRecovered &&\n            this.identifier &&\n            (this.databaseEntityLoaded === false ||\n                (this.databaseEntityLoaded && this.databaseEntity))\n        )\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a value set needs to be inserted / updated in the database.\n     * Value set is based on the entity and change maps of the subject.\n     * Important note: this method pops data from this subject's change maps.\n     */\n    createValueSetAndPopChangeMap(): ObjectLiteral {\n        const changeMapsWithoutValues: SubjectChangeMap[] = []\n        const changeSet = this.changeMaps.reduce((updateMap, changeMap) => {\n            let value = changeMap.value\n            if (InstanceChecker.isSubject(value)) {\n                // referenced columns can refer on values both which were just inserted and which were present in the model\n                // if entity was just inserted valueSets must contain all values from the entity and values just inserted in the database\n                // so, here we check if we have a value set then we simply use it as value to get our reference column values\n                // otherwise simply use an entity which cannot be just inserted at the moment and have all necessary data\n                value = value.insertedValueSet\n                    ? value.insertedValueSet\n                    : value.entity\n            }\n            // value = changeMap.valueFactory ? changeMap.valueFactory(value) : changeMap.column.createValueMap(value);\n\n            let valueMap: ObjectLiteral | undefined\n            if (this.metadata.isJunction && changeMap.column) {\n                valueMap = changeMap.column.createValueMap(\n                    changeMap.column.referencedColumn!.getEntityValue(value),\n                )\n            } else if (changeMap.column) {\n                valueMap = changeMap.column.createValueMap(value)\n            } else if (changeMap.relation) {\n                // value can be a related object, for example: post.question = { id: 1 }\n                // or value can be a null or direct relation id, e.g. post.question = 1\n                // if its a direction relation id then we just set it to the valueMap,\n                // however if its an object then we need to extract its relation id map and set it to the valueMap\n                if (ObjectUtils.isObject(value) && !Buffer.isBuffer(value)) {\n                    // get relation id, e.g. referenced column name and its value,\n                    // for example: { id: 1 } which then will be set to relation, e.g. post.category = { id: 1 }\n                    const relationId =\n                        changeMap.relation!.getRelationIdMap(value)\n\n                    // but relation id can be empty, for example in the case when you insert a new post with category\n                    // and both post and category are newly inserted objects (by cascades) and in this case category will not have id\n                    // this means we need to insert post without question id and update post's questionId once question be inserted\n                    // that's why we create a new changeMap operation for future updation of the post entity\n                    if (relationId === undefined) {\n                        changeMapsWithoutValues.push(changeMap)\n                        this.canBeUpdated = true\n                        return updateMap\n                    }\n                    valueMap = changeMap.relation!.createValueMap(relationId)\n                    this.updatedRelationMaps.push({\n                        relation: changeMap.relation,\n                        value: relationId,\n                    })\n                } else {\n                    // value can be \"null\" or direct relation id here\n                    valueMap = changeMap.relation!.createValueMap(value)\n                    this.updatedRelationMaps.push({\n                        relation: changeMap.relation,\n                        value: value,\n                    })\n                }\n            }\n\n            OrmUtils.mergeDeep(updateMap, valueMap)\n            return updateMap\n        }, {} as ObjectLiteral)\n        this.changeMaps = changeMapsWithoutValues\n        return changeSet\n    }\n\n    /**\n     * Recomputes entityWithFulfilledIds and identifier when entity changes.\n     */\n    recompute(): void {\n        if (this.entity) {\n            this.entityWithFulfilledIds = Object.assign({}, this.entity)\n            if (this.parentSubject) {\n                this.metadata.primaryColumns.forEach((primaryColumn) => {\n                    if (\n                        primaryColumn.relationMetadata &&\n                        primaryColumn.relationMetadata.inverseEntityMetadata ===\n                            this.parentSubject!.metadata\n                    ) {\n                        const value =\n                            primaryColumn.referencedColumn!.getEntityValue(\n                                this.parentSubject!.entity!,\n                            )\n                        primaryColumn.setEntityValue(\n                            this.entityWithFulfilledIds!,\n                            value,\n                        )\n                    }\n                })\n            }\n            this.identifier = this.metadata.getEntityIdMap(\n                this.entityWithFulfilledIds,\n            )\n        } else if (this.databaseEntity) {\n            this.identifier = this.metadata.getEntityIdMap(this.databaseEntity)\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1635, "column": 0}, "map": {"version":3,"file":"OneToManySubjectBuilder.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/persistence/browser/src/persistence/subject-builder/OneToManySubjectBuilder.ts"],"sourceRoot":"../..","sourcesContent":["import { Subject } from \"../Subject\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\n\n/**\n * Builds operations needs to be executed for one-to-many relations of the given subjects.\n *\n * by example: post contains one-to-many relation with category in the property called \"categories\", e.g.\n *             @OneToMany(type => Category, category => category.post) categories: Category[]\n *             If user adds categories into the post and saves post we need to bind them.\n *             This operation requires updation of category table since its owner of the relation and contains a join column.\n *\n * note: this class shares lot of things with OneToOneInverseSideOperationBuilder, so when you change this class\n *       make sure to reflect changes there as well.\n */\nexport class OneToManySubjectBuilder {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected subjects: Subject[]) {}\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds all required operations.\n     */\n    build(): void {\n        this.subjects.forEach((subject) => {\n            subject.metadata.oneToManyRelations.forEach((relation) => {\n                // skip relations for which persistence is disabled\n                if (relation.persistenceEnabled === false) return\n\n                this.buildForSubjectRelation(subject, relation)\n            })\n        })\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds operations for a given subject and relation.\n     *\n     * by example: subject is \"post\" entity we are saving here and relation is \"categories\" inside it here.\n     */\n    protected buildForSubjectRelation(\n        subject: Subject,\n        relation: RelationMetadata,\n    ) {\n        // prepare objects (relation id maps) for the database entity\n        // by example: since subject is a post, we are expecting to get all post's categories saved in the database here,\n        //             particularly their relation ids, e.g. category ids stored in the database\n\n        // in most cases relatedEntityDatabaseValues will contain only the entity key properties.\n        // this is because subject.databaseEntity contains relations with loaded relation ids only.\n        // however if the entity uses the afterLoad hook to calculate any properties, the fetched \"key object\" might include ADDITIONAL properties.\n        // to handle such situations, we pass the data to relation.inverseEntityMetadata.getEntityIdMap to extract the key without any other properties.\n\n        let relatedEntityDatabaseRelationIds: ObjectLiteral[] = []\n        if (subject.databaseEntity) {\n            // related entities in the database can exist only if this entity (post) is saved\n            const relatedEntityDatabaseRelation: ObjectLiteral[] | undefined =\n                relation.getEntityValue(subject.databaseEntity)\n            if (relatedEntityDatabaseRelation) {\n                relatedEntityDatabaseRelationIds =\n                    relatedEntityDatabaseRelation.map(\n                        (entity) =>\n                            relation.inverseEntityMetadata.getEntityIdMap(\n                                entity,\n                            )!,\n                    )\n            }\n        }\n\n        // get related entities of persisted entity\n        // by example: get categories from the passed to persist post entity\n        let relatedEntities: ObjectLiteral[] = relation.getEntityValue(\n            subject.entity!,\n        )\n        if (relatedEntities === null)\n            // we treat relations set to null as removed, so we don't skip it\n            relatedEntities = [] as ObjectLiteral[]\n        if (relatedEntities === undefined)\n            // if relation is undefined then nothing to update\n            return\n\n        // extract only relation ids from the related entities, since we only need them for comparison\n        // by example: extract from categories only relation ids (category id, or let's say category title, depend on join column options)\n        const relatedPersistedEntityRelationIds: ObjectLiteral[] = []\n        relatedEntities.forEach((relatedEntity) => {\n            // by example: relatedEntity is a category here\n            let relationIdMap =\n                relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity) // by example: relationIdMap is category.id map here, e.g. { id: ... }\n\n            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n            let relatedEntitySubject = this.subjects.find((subject) => {\n                return subject.entity === relatedEntity\n            })\n\n            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n            if (relatedEntitySubject)\n                relationIdMap = relatedEntitySubject.identifier\n\n            // if relationIdMap is undefined then it means user binds object which is not saved in the database yet\n            // by example: if post contains categories which does not have ids yet (because they are new)\n            //             it means they are always newly inserted and relation update operation always must be created for them\n            //             it does not make sense to perform difference operation for them for both add and remove actions\n            if (!relationIdMap) {\n                // we decided to remove this error because it brings complications when saving object with non-saved entities\n                // if (!relatedEntitySubject)\n                //     throw new TypeORMError(`One-to-many relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n                //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +\n                //         `Please setup cascade insertion or save entities before binding it.`);\n                if (!relatedEntitySubject) return\n\n                // okay, so related subject exist and its marked for insertion, then add a new change map\n                // by example: this will tell category to insert into its post relation our post we are working with\n                //             relatedEntitySubject is newly inserted CategorySubject\n                //             relation.inverseRelation is ManyToOne relation inside Category\n                //             subject is Post needs to be inserted into Category\n                relatedEntitySubject.changeMaps.push({\n                    relation: relation.inverseRelation!,\n                    value: subject,\n                })\n\n                return\n            }\n\n            // check if this binding really exist in the database\n            // by example: find our category if its already bind in the database\n            const relationIdInDatabaseSubjectRelation =\n                relatedEntityDatabaseRelationIds.find(\n                    (relatedDatabaseEntityRelationId) => {\n                        return OrmUtils.compareIds(\n                            relationIdMap,\n                            relatedDatabaseEntityRelationId,\n                        )\n                    },\n                )\n\n            // if relationIdMap DOES NOT exist in the subject's relation in the database it means its a new relation and we need to \"bind\" them\n            // by example: this will tell category to insert into its post relation our post we are working with\n            //             relatedEntitySubject is newly inserted CategorySubject\n            //             relation.inverseRelation is ManyToOne relation inside Category\n            //             subject is Post needs to be inserted into Category\n            if (!relationIdInDatabaseSubjectRelation) {\n                // if there is no relatedEntitySubject then it means \"category\" wasn't persisted,\n                // but since we are going to update \"category\" table (since its an owning side of relation with join column)\n                // we create a new subject here:\n                if (!relatedEntitySubject) {\n                    relatedEntitySubject = new Subject({\n                        metadata: relation.inverseEntityMetadata,\n                        parentSubject: subject,\n                        canBeUpdated: true,\n                        identifier: relationIdMap,\n                    })\n                    this.subjects.push(relatedEntitySubject)\n                }\n\n                relatedEntitySubject.changeMaps.push({\n                    relation: relation.inverseRelation!,\n                    value: subject,\n                })\n            }\n\n            // if related entity has relation id then we add it to the list of relation ids\n            // this list will be used later to compare with database relation ids to find a difference\n            // what exist in this array and does not exist in the database are newly inserted relations\n            // what does not exist in this array, but exist in the database are removed relations\n            // removed relations are set to null from inverse side of relation\n            relatedPersistedEntityRelationIds.push(relationIdMap)\n        })\n\n        // find what related entities were added and what were removed based on difference between what we save and what database has\n        if (relation.inverseRelation?.orphanedRowAction !== \"disable\") {\n            EntityMetadata.difference(\n                relatedEntityDatabaseRelationIds,\n                relatedPersistedEntityRelationIds,\n            ).forEach((removedRelatedEntityRelationId) => {\n                // by example: removedRelatedEntityRelationId is category that was bind in the database before, but now its unbind\n\n                // todo: probably we can improve this in the future by finding entity with column those values,\n                // todo: maybe it was already in persistence process. This is possible due to unique requirements of join columns\n                // we create a new subject which operations will be executed in subject operation executor\n                const removedRelatedEntitySubject = new Subject({\n                    metadata: relation.inverseEntityMetadata,\n                    parentSubject: subject,\n                    identifier: removedRelatedEntityRelationId,\n                })\n\n                if (\n                    !relation.inverseRelation ||\n                    relation.inverseRelation.orphanedRowAction === \"nullify\"\n                ) {\n                    removedRelatedEntitySubject.canBeUpdated = true\n                    removedRelatedEntitySubject.changeMaps = [\n                        {\n                            relation: relation.inverseRelation!,\n                            value: null,\n                        },\n                    ]\n                } else if (\n                    relation.inverseRelation.orphanedRowAction === \"delete\"\n                ) {\n                    removedRelatedEntitySubject.mustBeRemoved = true\n                } else if (\n                    relation.inverseRelation.orphanedRowAction === \"soft-delete\"\n                ) {\n                    removedRelatedEntitySubject.canBeSoftRemoved = true\n                }\n\n                this.subjects.push(removedRelatedEntitySubject)\n            })\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1800, "column": 0}, "map": {"version":3,"file":"OneToOneInverseSideSubjectBuilder.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/persistence/browser/src/persistence/subject-builder/OneToOneInverseSideSubjectBuilder.ts"],"sourceRoot":"../..","sourcesContent":["import { Subject } from \"../Subject\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\n\n/**\n * Builds operations needs to be executed for one-to-one non-owner relations of the given subjects.\n *\n * by example: post contains one-to-one non-owner relation with category in the property called \"category\", e.g.\n *             @OneToOne(type => Category, category => category.post) category: Category\n *             If user sets a category into the post and saves post we need to bind them.\n *             This operation requires updation of category table since its owner of the relation and contains a join column.\n *\n * note: this class shares lot of things with OneToManyUpdateBuilder, so when you change this class\n *       make sure to reflect changes there as well.\n */\nexport class OneToOneInverseSideSubjectBuilder {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected subjects: Subject[]) {}\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds all required operations.\n     */\n    build(): void {\n        this.subjects.forEach((subject) => {\n            subject.metadata.oneToOneRelations.forEach((relation) => {\n                // we don't need owning relations, this operation is only for inverse side of one-to-one relations\n                // skip relations for which persistence is disabled\n                if (relation.isOwning || relation.persistenceEnabled === false)\n                    return\n\n                this.buildForSubjectRelation(subject, relation)\n            })\n        })\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds operations for a given subject and relation.\n     *\n     * by example: subject is \"post\" entity we are saving here and relation is \"category\" inside it here.\n     */\n    protected buildForSubjectRelation(\n        subject: Subject,\n        relation: RelationMetadata,\n    ) {\n        // prepare objects (relation id map) for the database entity\n        // note: subject.databaseEntity contains relation with loaded relation id only (id map)\n        // by example: since subject is a post, we are expecting to get post's category saved in the database here,\n        //             particularly its relation id, e.g. category id stored in the database\n        let relatedEntityDatabaseRelationId: ObjectLiteral | undefined =\n            undefined\n        if (subject.databaseEntity)\n            // related entity in the database can exist only if this entity (post) is saved\n            relatedEntityDatabaseRelationId = relation.getEntityValue(\n                subject.databaseEntity,\n            )\n\n        // get related entities of persisted entity\n        // by example: get category from the passed to persist post entity\n        const relatedEntity: ObjectLiteral | null = relation.getEntityValue(\n            subject.entity!,\n        ) // by example: relatedEntity is a category here\n        if (relatedEntity === undefined)\n            // if relation is undefined then nothing to update\n            return\n\n        // if related entity is null then we need to check if there a bind in the database and unset it\n        // if there is no bind in the entity then we don't need to do anything\n        // by example: if post.category = null and category has this post in the database then we unset it\n        if (relatedEntity === null) {\n            // it makes sense to update database only there is a previously set value in the database\n            if (relatedEntityDatabaseRelationId) {\n                // todo: probably we can improve this in the future by finding entity with column those values,\n                // todo: maybe it was already in persistence process. This is possible due to unique requirements of join columns\n                // we create a new subject which operations will be executed in subject operation executor\n\n                const removedRelatedEntitySubject = new Subject({\n                    metadata: relation.inverseEntityMetadata,\n                    parentSubject: subject,\n                    canBeUpdated: true,\n                    identifier: relatedEntityDatabaseRelationId,\n                    changeMaps: [\n                        {\n                            relation: relation.inverseRelation!,\n                            value: null,\n                        },\n                    ],\n                })\n                this.subjects.push(removedRelatedEntitySubject)\n            }\n\n            return\n        } // else means entity is bind in the database\n\n        // extract only relation id from the related entities, since we only need it for comparison\n        // by example: extract from category only relation id (category id, or let's say category title, depend on join column options)\n        let relationIdMap =\n            relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity) // by example: relationIdMap is category.id map here, e.g. { id: ... }\n\n        // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n        let relatedEntitySubject = this.subjects.find((operateSubject) => {\n            return (\n                !!operateSubject.entity &&\n                operateSubject.entity === relatedEntity\n            )\n        })\n\n        // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n        if (relatedEntitySubject)\n            relationIdMap = relatedEntitySubject.identifier\n\n        // if relationIdMap is undefined then it means user binds object which is not saved in the database yet\n        // by example: if post contains category which does not have id(s) yet (because its a new category)\n        //             it means its always newly inserted and relation update operation always must be created for it\n        //             it does not make sense to perform difference operation for it for both add and remove actions\n        if (!relationIdMap) {\n            // we decided to remove this error because it brings complications when saving object with non-saved entities\n            // if related entity does not have a subject then it means user tries to bind entity which wasn't saved\n            // in this persistence because he didn't pass this entity for save or he did not set cascades\n            // but without entity being inserted we cannot bind it in the relation operation, so we throw an exception here\n            // if (!relatedEntitySubject)\n            //     throw new TypeORMError(`One-to-one inverse relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n            //         `entity which does not exist in the database yet, thus cannot be bind in the database. ` +\n            //         `Please setup cascade insertion or save entity before binding it.`);\n            if (!relatedEntitySubject) return\n\n            // okay, so related subject exist and its marked for insertion, then add a new change map\n            // by example: this will tell category to insert into its post relation our post we are working with\n            //             relatedEntitySubject is newly inserted CategorySubject\n            //             relation.inverseRelation is OneToOne owner relation inside Category\n            //             subject is Post needs to be inserted into Category\n            relatedEntitySubject.changeMaps.push({\n                relation: relation.inverseRelation!,\n                value: subject,\n            })\n        }\n\n        // check if this binding really exist in the database\n        // by example: find our post if its already bind to category in the database and its not equal to what user tries to set\n        const areRelatedIdEqualWithDatabase =\n            relatedEntityDatabaseRelationId &&\n            OrmUtils.compareIds(relationIdMap, relatedEntityDatabaseRelationId)\n\n        // if they aren't equal it means its a new relation and we need to \"bind\" them\n        // by example: this will tell category to insert into its post relation our post we are working with\n        //             relatedEntitySubject is newly inserted CategorySubject\n        //             relation.inverseRelation is ManyToOne relation inside Category\n        //             subject is Post needs to be inserted into Category\n        if (!areRelatedIdEqualWithDatabase) {\n            // if there is no relatedEntitySubject then it means \"category\" wasn't persisted,\n            // but since we are going to update \"category\" table (since its an owning side of relation with join column)\n            // we create a new subject here:\n            if (!relatedEntitySubject) {\n                relatedEntitySubject = new Subject({\n                    metadata: relation.inverseEntityMetadata,\n                    canBeUpdated: true,\n                    identifier: relationIdMap,\n                })\n                this.subjects.push(relatedEntitySubject)\n            }\n\n            relatedEntitySubject.changeMaps.push({\n                relation: relation.inverseRelation!,\n                value: subject,\n            })\n        }\n    }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAA;AACpC,OAAO,EAAE,QAAQ,EAAE,MAAM,qBAAqB,CAAA;;;AAexC,MAAO,iCAAiC;IAC1C,wEAAwE;IACxE,cAAc;IACd,wEAAwE;IAExE,YAAsB,QAAmB,CAAA;QAAnB,IAAA,CAAA,QAAQ,GAAR,QAAQ,CAAW;IAAG,CAAC;IAE7C,wEAAwE;IACxE,iBAAiB;IACjB,wEAAwE;IAExE;;OAEG,CACH,KAAK,GAAA;QACD,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YAC9B,OAAO,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;gBACpD,kGAAkG;gBAClG,mDAAmD;gBACnD,IAAI,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,kBAAkB,KAAK,KAAK,EAC1D,OAAM;gBAEV,IAAI,CAAC,uBAAuB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAA;YACnD,CAAC,CAAC,CAAA;QACN,CAAC,CAAC,CAAA;IACN,CAAC;IAED,wEAAwE;IACxE,oBAAoB;IACpB,wEAAwE;IAExE;;;;OAIG,CACO,uBAAuB,CAC7B,OAAgB,EAChB,QAA0B,EAAA;QAE1B,4DAA4D;QAC5D,uFAAuF;QACvF,2GAA2G;QAC3G,oFAAoF;QACpF,IAAI,+BAA+B,GAC/B,SAAS,CAAA;QACb,IAAI,OAAO,CAAC,cAAc,EACtB,+EAA+E;QAC/E,+BAA+B,GAAG,QAAQ,CAAC,cAAc,CACrD,OAAO,CAAC,cAAc,CACzB,CAAA;QAEL,2CAA2C;QAC3C,kEAAkE;QAClE,MAAM,aAAa,GAAyB,QAAQ,CAAC,cAAc,CAC/D,OAAO,CAAC,MAAO,CAClB,CAAA,CAAC,+CAA+C;QACjD,IAAI,aAAa,KAAK,SAAS,EAC3B,kDAAkD;QAClD,OAAM;QAEV,+FAA+F;QAC/F,sEAAsE;QACtE,kGAAkG;QAClG,IAAI,aAAa,KAAK,IAAI,EAAE,CAAC;YACzB,yFAAyF;YACzF,IAAI,+BAA+B,EAAE,CAAC;gBAClC,+FAA+F;gBAC/F,iHAAiH;gBACjH,0FAA0F;gBAE1F,MAAM,2BAA2B,GAAG,yKAAI,UAAO,CAAC;oBAC5C,QAAQ,EAAE,QAAQ,CAAC,qBAAqB;oBACxC,aAAa,EAAE,OAAO;oBACtB,YAAY,EAAE,IAAI;oBAClB,UAAU,EAAE,+BAA+B;oBAC3C,UAAU,EAAE;wBACR;4BACI,QAAQ,EAAE,QAAQ,CAAC,eAAgB;4BACnC,KAAK,EAAE,IAAI;yBACd;qBACJ;iBACJ,CAAC,CAAA;gBACF,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,2BAA2B,CAAC,CAAA;YACnD,CAAC;YAED,OAAM;QACV,CAAC,CAAC,4CAA4C;QAE9C,2FAA2F;QAC3F,+HAA+H;QAC/H,IAAI,aAAa,GACb,QAAQ,CAAC,qBAAsB,CAAC,cAAc,CAAC,aAAa,CAAC,CAAA,CAAC,sEAAsE;QAExI,kGAAkG;QAClG,IAAI,oBAAoB,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,cAAc,EAAE,EAAE;YAC7D,OAAO,AACH,CAAC,CAAC,cAAc,CAAC,MAAM,IACvB,cAAc,CAAC,MAAM,KAAK,aAAa,CAC1C,CAAA;QACL,CAAC,CAAC,CAAA;QAEF,6HAA6H;QAC7H,IAAI,oBAAoB,EACpB,aAAa,GAAG,oBAAoB,CAAC,UAAU,CAAA;QAEnD,uGAAuG;QACvG,mGAAmG;QACnG,6GAA6G;QAC7G,4GAA4G;QAC5G,IAAI,CAAC,aAAa,EAAE,CAAC;YACjB,6GAA6G;YAC7G,uGAAuG;YACvG,6FAA6F;YAC7F,+GAA+G;YAC/G,6BAA6B;YAC7B,kIAAkI;YAClI,qGAAqG;YACrG,+EAA+E;YAC/E,IAAI,CAAC,oBAAoB,EAAE,OAAM;YAEjC,yFAAyF;YACzF,oGAAoG;YACpG,qEAAqE;YACrE,kFAAkF;YAClF,iEAAiE;YACjE,oBAAoB,CAAC,UAAU,CAAC,IAAI,CAAC;gBACjC,QAAQ,EAAE,QAAQ,CAAC,eAAgB;gBACnC,KAAK,EAAE,OAAO;aACjB,CAAC,CAAA;QACN,CAAC;QAED,qDAAqD;QACrD,wHAAwH;QACxH,MAAM,6BAA6B,GAC/B,+BAA+B,mKAC/B,WAAQ,CAAC,UAAU,CAAC,aAAa,EAAE,+BAA+B,CAAC,CAAA;QAEvE,8EAA8E;QAC9E,oGAAoG;QACpG,qEAAqE;QACrE,6EAA6E;QAC7E,iEAAiE;QACjE,IAAI,CAAC,6BAA6B,EAAE,CAAC;YACjC,iFAAiF;YACjF,4GAA4G;YAC5G,gCAAgC;YAChC,IAAI,CAAC,oBAAoB,EAAE,CAAC;gBACxB,oBAAoB,GAAG,yKAAI,UAAO,CAAC;oBAC/B,QAAQ,EAAE,QAAQ,CAAC,qBAAqB;oBACxC,YAAY,EAAE,IAAI;oBAClB,UAAU,EAAE,aAAa;iBAC5B,CAAC,CAAA;gBACF,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAA;YAC5C,CAAC;YAED,oBAAoB,CAAC,UAAU,CAAC,IAAI,CAAC;gBACjC,QAAQ,EAAE,QAAQ,CAAC,eAAgB;gBACnC,KAAK,EAAE,OAAO;aACjB,CAAC,CAAA;QACN,CAAC;IACL,CAAC;CACJ","ignoreList":[0]}},
    {"offset": {"line": 1940, "column": 0}, "map": {"version":3,"file":"ManyToManySubjectBuilder.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/persistence/browser/src/persistence/subject-builder/ManyToManySubjectBuilder.ts"],"sourceRoot":"../..","sourcesContent":["import { Subject } from \"../Subject\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\n\n/**\n * Builds operations needs to be executed for many-to-many relations of the given subjects.\n *\n * by example: post contains owner many-to-many relation with categories in the property called \"categories\", e.g.\n *             @ManyToMany(type => Category, category => category.posts) categories: Category[]\n *             If user adds categories into the post and saves post we need to bind them.\n *             This operation requires updation of junction table.\n */\nexport class ManyToManySubjectBuilder {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected subjects: Subject[]) {}\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds operations for any changes in the many-to-many relations of the subjects.\n     */\n    build(): void {\n        this.subjects.forEach((subject) => {\n            // if subject doesn't have entity then no need to find something that should be inserted or removed\n            if (!subject.entity) return\n\n            // go through all persistence enabled many-to-many relations and build subject operations for them\n            subject.metadata.manyToManyRelations.forEach((relation) => {\n                // skip relations for which persistence is disabled\n                if (relation.persistenceEnabled === false) return\n\n                this.buildForSubjectRelation(subject, relation)\n            })\n        })\n    }\n\n    /**\n     * Builds operations for removal of all many-to-many records of all many-to-many relations of the given subject.\n     */\n    buildForAllRemoval(subject: Subject) {\n        // if subject does not have a database entity then it means it does not exist in the database\n        // if it does not exist in the database then we don't have anything for deletion\n        if (!subject.databaseEntity) return\n\n        // go through all persistence enabled many-to-many relations and build subject operations for them\n        subject.metadata.manyToManyRelations.forEach((relation) => {\n            // skip relations for which persistence is disabled\n            if (relation.persistenceEnabled === false) return\n\n            // get all related entities (actually related entity relation ids) bind to this subject entity\n            // by example: returns category ids of the post we are currently working with (subject.entity is post)\n            const relatedEntityRelationIdsInDatabase: ObjectLiteral[] =\n                relation.getEntityValue(subject.databaseEntity!)\n\n            // go through all related entities and create a new junction subject for each row in junction table\n            relatedEntityRelationIdsInDatabase.forEach((relationId) => {\n                const junctionSubject = new Subject({\n                    metadata: relation.junctionEntityMetadata!,\n                    parentSubject: subject,\n                    mustBeRemoved: true,\n                    identifier: this.buildJunctionIdentifier(\n                        subject,\n                        relation,\n                        relationId,\n                    ),\n                })\n\n                // we use unshift because we need to perform those operations before post deletion is performed\n                // but post deletion was already added as an subject\n                // this is temporary solution, later we need to implement proper sorting of subjects before their removal\n                this.subjects.push(junctionSubject)\n            })\n        })\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds operations for a given subject and relation.\n     *\n     * by example: subject is \"post\" entity we are saving here and relation is \"categories\" inside it here.\n     */\n    protected buildForSubjectRelation(\n        subject: Subject,\n        relation: RelationMetadata,\n    ) {\n        // load from db all relation ids of inverse entities that are \"bind\" to the subject's entity\n        // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)\n        let databaseRelatedEntityIds: ObjectLiteral[] = []\n\n        // if subject don't have database entity it means all related entities in persisted subject are new and must be bind\n        // and we don't need to remove something that is not exist\n        if (subject.databaseEntity) {\n            const databaseRelatedEntityValue = relation.getEntityValue(\n                subject.databaseEntity,\n            )\n            if (databaseRelatedEntityValue) {\n                databaseRelatedEntityIds = databaseRelatedEntityValue.map(\n                    (e: any) =>\n                        relation.inverseEntityMetadata.getEntityIdMap(e),\n                )\n            }\n        }\n\n        // extract entity's relation value\n        // by example: categories inside our post (subject.entity is post)\n        let relatedEntities: ObjectLiteral[] = relation.getEntityValue(\n            subject.entity!,\n        )\n        if (relatedEntities === null)\n            // if value set to null its equal if we set it to empty array - all items must be removed from the database\n            relatedEntities = []\n        if (!Array.isArray(relatedEntities)) return\n\n        // from all related entities find only those which aren't found in the db - for them we will create operation subjects\n        relatedEntities.forEach((relatedEntity) => {\n            // by example: relatedEntity is category from categories saved with post\n\n            // todo: check how it will work for entities which are saved by cascades, but aren't saved in the database yet\n\n            // extract only relation id from the related entities, since we only need it for comparison\n            // by example: extract from category only relation id (category id, or let's say category title, depend on join column options)\n            let relatedEntityRelationIdMap =\n                relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)\n\n            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n            const relatedEntitySubject = this.subjects.find((subject) => {\n                return subject.entity === relatedEntity\n            })\n\n            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n            if (relatedEntitySubject)\n                relatedEntityRelationIdMap = relatedEntitySubject.identifier\n\n            // if related entity relation id map is empty it means related entity is newly persisted\n            if (!relatedEntityRelationIdMap) {\n                // we decided to remove this error because it brings complications when saving object with non-saved entities\n                // if related entity does not have a subject then it means user tries to bind entity which wasn't saved\n                // in this persistence because he didn't pass this entity for save or he did not set cascades\n                // but without entity being inserted we cannot bind it in the relation operation, so we throw an exception here\n                // we decided to remove this error because it brings complications when saving object with non-saved entities\n                // if (!relatedEntitySubject)\n                //     throw new TypeORMError(`Many-to-many relation \"${relation.entityMetadata.name}.${relation.propertyPath}\" contains ` +\n                //         `entities which do not exist in the database yet, thus they cannot be bind in the database. ` +\n                //         `Please setup cascade insertion or save entities before binding it.`);\n                if (!relatedEntitySubject) return\n            }\n\n            // try to find related entity in the database\n            // by example: find post's category in the database post's categories\n            const relatedEntityExistInDatabase = databaseRelatedEntityIds.find(\n                (databaseRelatedEntityRelationId) => {\n                    return OrmUtils.compareIds(\n                        databaseRelatedEntityRelationId,\n                        relatedEntityRelationIdMap,\n                    )\n                },\n            )\n\n            // if entity is found then don't do anything - it means binding in junction table already exist, we don't need to add anything\n            if (relatedEntityExistInDatabase) return\n\n            const ownerValue = relation.isOwning\n                ? subject\n                : relatedEntitySubject || relatedEntity // by example: ownerEntityMap is post from subject here\n            const inverseValue = relation.isOwning\n                ? relatedEntitySubject || relatedEntity\n                : subject // by example: inverseEntityMap is category from categories array here\n\n            // create a new subject for insert operation of junction rows\n            const junctionSubject = new Subject({\n                metadata: relation.junctionEntityMetadata!,\n                parentSubject: subject,\n                canBeInserted: true,\n            })\n            this.subjects.push(junctionSubject)\n\n            relation.junctionEntityMetadata!.ownerColumns.forEach((column) => {\n                junctionSubject.changeMaps.push({\n                    column: column,\n                    value: ownerValue,\n                    // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(ownerEntityMap),\n                })\n            })\n\n            relation.junctionEntityMetadata!.inverseColumns.forEach(\n                (column) => {\n                    junctionSubject.changeMaps.push({\n                        column: column,\n                        value: inverseValue,\n                        // valueFactory: (value) => column.referencedColumn!.getEntityValue(value) // column.referencedColumn!.getEntityValue(inverseEntityMap),\n                    })\n                },\n            )\n        })\n\n        // get all inverse entities relation ids that are \"bind\" to the currently persisted entity\n        const changedInverseEntityRelationIds: ObjectLiteral[] = []\n        relatedEntities.forEach((relatedEntity) => {\n            // relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)\n            let relatedEntityRelationIdMap =\n                relation.inverseEntityMetadata!.getEntityIdMap(relatedEntity)\n\n            // try to find a subject of this related entity, maybe it was loaded or was marked for persistence\n            const relatedEntitySubject = this.subjects.find((subject) => {\n                return subject.entity === relatedEntity\n            })\n\n            // if subject with entity was found take subject identifier as relation id map since it may contain extra properties resolved\n            if (relatedEntitySubject)\n                relatedEntityRelationIdMap = relatedEntitySubject.identifier\n\n            if (\n                relatedEntityRelationIdMap !== undefined &&\n                relatedEntityRelationIdMap !== null\n            )\n                changedInverseEntityRelationIds.push(relatedEntityRelationIdMap)\n        })\n\n        // now from all entities in the persisted entity find only those which aren't found in the db\n        const removedJunctionEntityIds = databaseRelatedEntityIds.filter(\n            (existRelationId) => {\n                return !changedInverseEntityRelationIds.find(\n                    (changedRelationId) => {\n                        return OrmUtils.compareIds(\n                            changedRelationId,\n                            existRelationId,\n                        )\n                    },\n                )\n            },\n        )\n\n        // finally create a new junction remove operations for missing related entities\n        removedJunctionEntityIds.forEach((removedEntityRelationId) => {\n            const junctionSubject = new Subject({\n                metadata: relation.junctionEntityMetadata!,\n                parentSubject: subject,\n                mustBeRemoved: true,\n                identifier: this.buildJunctionIdentifier(\n                    subject,\n                    relation,\n                    removedEntityRelationId,\n                ),\n            })\n            this.subjects.push(junctionSubject)\n        })\n    }\n\n    /**\n     * Creates identifiers for junction table.\n     * Example: { postId: 1, categoryId: 2 }\n     */\n    protected buildJunctionIdentifier(\n        subject: Subject,\n        relation: RelationMetadata,\n        relationId: ObjectLiteral,\n    ) {\n        const ownerEntityMap = relation.isOwning ? subject.entity! : relationId\n        const inverseEntityMap = relation.isOwning\n            ? relationId\n            : subject.entity!\n\n        const identifier: ObjectLiteral = {}\n        relation.junctionEntityMetadata!.ownerColumns.forEach((column) => {\n            OrmUtils.mergeDeep(\n                identifier,\n                column.createValueMap(\n                    column.referencedColumn!.getEntityValue(ownerEntityMap),\n                ),\n            )\n        })\n        relation.junctionEntityMetadata!.inverseColumns.forEach((column) => {\n            OrmUtils.mergeDeep(\n                identifier,\n                column.createValueMap(\n                    column.referencedColumn!.getEntityValue(inverseEntityMap),\n                ),\n            )\n        })\n        return identifier\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2131, "column": 0}, "map": {"version":3,"file":"SubjectDatabaseEntityLoader.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/persistence/SubjectDatabaseEntityLoader.ts"],"sourceRoot":"..","sourcesContent":["import { Subject } from \"./Subject\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { FindManyOptions } from \"../find-options/FindManyOptions\"\nimport { MongoRepository } from \"../repository/MongoRepository\"\nimport { OrmUtils } from \"../util/OrmUtils\"\n\n/**\n * Loads database entities for all operate subjects which do not have database entity set.\n * All entities that we load database entities for are marked as updated or inserted.\n * To understand which of them really needs to be inserted or updated we need to load\n * their original representations from the database.\n */\nexport class SubjectDatabaseEntityLoader {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(\n        protected queryRunner: QueryRunner,\n        protected subjects: Subject[],\n    ) {}\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Loads database entities for all subjects.\n     *\n     * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.\n     * This option is used for deletion.\n     */\n    async load(\n        operationType: \"save\" | \"remove\" | \"soft-remove\" | \"recover\",\n    ): Promise<void> {\n        // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n        // go through the groups and perform loading of database entities of each subject in the group\n        const promises = this.groupByEntityTargets().map(\n            async (subjectGroup) => {\n                // prepare entity ids of the subjects we need to load\n                const allIds: ObjectLiteral[] = []\n                const allSubjects: Subject[] = []\n                subjectGroup.subjects.forEach((subject) => {\n                    // we don't load if subject already has a database entity loaded\n                    if (subject.databaseEntity || !subject.identifier) return\n\n                    allIds.push(subject.identifier)\n                    allSubjects.push(subject)\n                })\n\n                // if there no ids found (means all entities are new and have generated ids) - then nothing to load there\n                if (!allIds.length) return\n\n                const loadRelationPropertyPaths: string[] = []\n\n                // for the save, soft-remove and recover operation\n                // extract all property paths of the relations we need to load relation ids for\n                // this is for optimization purpose - this way we don't load relation ids for entities\n                // whose relations are undefined, and since they are undefined its really pointless to\n                // load something for them, since undefined properties are skipped by the orm\n                if (\n                    operationType === \"save\" ||\n                    operationType === \"soft-remove\" ||\n                    operationType === \"recover\"\n                ) {\n                    subjectGroup.subjects.forEach((subject) => {\n                        // gets all relation property paths that exist in the persisted entity.\n                        subject.metadata.relations.forEach((relation) => {\n                            const value = relation.getEntityValue(\n                                subject.entityWithFulfilledIds!,\n                            )\n                            if (value === undefined) return\n\n                            if (\n                                loadRelationPropertyPaths.indexOf(\n                                    relation.propertyPath,\n                                ) === -1\n                            )\n                                loadRelationPropertyPaths.push(\n                                    relation.propertyPath,\n                                )\n                        })\n                    })\n                } else {\n                    // remove\n\n                    // for remove operation\n                    // we only need to load junction relation ids since only they are removed by cascades\n                    loadRelationPropertyPaths.push(\n                        ...subjectGroup.subjects[0].metadata.manyToManyRelations.map(\n                            (relation) => relation.propertyPath,\n                        ),\n                    )\n                }\n\n                const findOptions: FindManyOptions<any> = {\n                    loadEagerRelations: false,\n                    loadRelationIds: {\n                        relations: loadRelationPropertyPaths,\n                        disableMixedMap: true,\n                    },\n                    // the soft-deleted entities should be included in the loaded entities for recover operation\n                    withDeleted: true,\n                }\n\n                // load database entities for all given ids\n                let entities: any[] = []\n                if (\n                    this.queryRunner.connection.driver.options.type ===\n                    \"mongodb\"\n                ) {\n                    const mongoRepo =\n                        this.queryRunner.manager.getRepository<ObjectLiteral>(\n                            subjectGroup.target,\n                        ) as MongoRepository<ObjectLiteral>\n                    entities = await mongoRepo.findByIds(allIds, findOptions)\n                } else {\n                    entities = await this.queryRunner.manager\n                        .getRepository<ObjectLiteral>(subjectGroup.target)\n                        .createQueryBuilder()\n                        .setFindOptions(findOptions)\n                        .whereInIds(allIds)\n                        .getMany()\n                }\n\n                // Now when we have entities we need to find subject of each entity\n                // and insert that entity into database entity of the found subjects.\n                // A single entity can be applied to many subjects as there might be duplicates.\n                // This will likely result in the same row being updated multiple times during a transaction.\n                entities.forEach((entity) => {\n                    const entityId =\n                        allSubjects[0].metadata.getEntityIdMap(entity)\n                    allSubjects.forEach((subject) => {\n                        if (subject.databaseEntity) return\n                        if (OrmUtils.compareIds(subject.identifier, entityId))\n                            subject.databaseEntity = entity\n                    })\n                })\n\n                // this way we tell what subjects we tried to load database entities of\n                for (const subject of allSubjects) {\n                    subject.databaseEntityLoaded = true\n                }\n            },\n        )\n\n        await Promise.all(promises)\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Groups given Subject objects into groups separated by entity targets.\n     */\n    protected groupByEntityTargets(): {\n        target: Function | string\n        subjects: Subject[]\n    }[] {\n        return this.subjects.reduce((groups, operatedEntity) => {\n            let group = groups.find(\n                (group) => group.target === operatedEntity.metadata.target,\n            )\n            if (!group) {\n                group = { target: operatedEntity.metadata.target, subjects: [] }\n                groups.push(group)\n            }\n            group.subjects.push(operatedEntity)\n            return groups\n        }, [] as { target: Function | string; subjects: Subject[] }[])\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2249, "column": 0}, "map": {"version":3,"file":"CascadesSubjectBuilder.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/persistence/browser/src/persistence/subject-builder/CascadesSubjectBuilder.ts"],"sourceRoot":"../..","sourcesContent":["import { Subject } from \"../Subject\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\n\n/**\n * Finds all cascade operations of the given subject and cascade operations of the found cascaded subjects,\n * e.g. builds a cascade tree and creates a subjects for them.\n */\nexport class CascadesSubjectBuilder {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(protected allSubjects: Subject[]) {}\n\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds a cascade subjects tree and pushes them in into the given array of subjects.\n     */\n    build(\n        subject: Subject,\n        operationType: \"save\" | \"remove\" | \"soft-remove\" | \"recover\",\n    ) {\n        subject.metadata\n            .extractRelationValuesFromEntity(\n                subject.entity!,\n                subject.metadata.relations,\n            ) // todo: we can create EntityMetadata.cascadeRelations\n            .forEach(([relation, relationEntity, relationEntityMetadata]) => {\n                // we need only defined values and insert, update, soft-remove or recover cascades of the relation should be set\n                if (\n                    relationEntity === undefined ||\n                    relationEntity === null ||\n                    (!relation.isCascadeInsert &&\n                        !relation.isCascadeUpdate &&\n                        !relation.isCascadeSoftRemove &&\n                        !relation.isCascadeRecover)\n                )\n                    return\n\n                // if relation entity is just a relation id set (for example post.tag = 1)\n                // then we don't really need to check cascades since there is no object to insert or update\n                if (!ObjectUtils.isObject(relationEntity)) return\n\n                // if we already has this entity in list of operated subjects then skip it to avoid recursion\n                const alreadyExistRelationEntitySubject =\n                    this.findByPersistEntityLike(\n                        relationEntityMetadata.target,\n                        relationEntity,\n                    )\n                if (alreadyExistRelationEntitySubject) {\n                    if (\n                        alreadyExistRelationEntitySubject.canBeInserted ===\n                        false\n                    )\n                        // if its not marked for insertion yet\n                        alreadyExistRelationEntitySubject.canBeInserted =\n                            relation.isCascadeInsert === true &&\n                            operationType === \"save\"\n                    if (\n                        alreadyExistRelationEntitySubject.canBeUpdated === false\n                    )\n                        // if its not marked for update yet\n                        alreadyExistRelationEntitySubject.canBeUpdated =\n                            relation.isCascadeUpdate === true &&\n                            operationType === \"save\"\n                    if (\n                        alreadyExistRelationEntitySubject.canBeSoftRemoved ===\n                        false\n                    )\n                        // if its not marked for removal yet\n                        alreadyExistRelationEntitySubject.canBeSoftRemoved =\n                            relation.isCascadeSoftRemove === true &&\n                            operationType === \"soft-remove\"\n                    if (\n                        alreadyExistRelationEntitySubject.canBeRecovered ===\n                        false\n                    )\n                        // if its not marked for recovery yet\n                        alreadyExistRelationEntitySubject.canBeRecovered =\n                            relation.isCascadeRecover === true &&\n                            operationType === \"recover\"\n                    return\n                }\n\n                // mark subject with what we can do with it\n                // and add to the array of subjects to load only if there is no same entity there already\n                const relationEntitySubject = new Subject({\n                    metadata: relationEntityMetadata,\n                    parentSubject: subject,\n                    entity: relationEntity,\n                    canBeInserted:\n                        relation.isCascadeInsert === true &&\n                        operationType === \"save\",\n                    canBeUpdated:\n                        relation.isCascadeUpdate === true &&\n                        operationType === \"save\",\n                    canBeSoftRemoved:\n                        relation.isCascadeSoftRemove === true &&\n                        operationType === \"soft-remove\",\n                    canBeRecovered:\n                        relation.isCascadeRecover === true &&\n                        operationType === \"recover\",\n                })\n                this.allSubjects.push(relationEntitySubject)\n\n                // go recursively and find other entities we need to insert/update\n                this.build(relationEntitySubject, operationType)\n            })\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Finds subject where entity like given subject's entity.\n     * Comparison made by entity id.\n     */\n    protected findByPersistEntityLike(\n        entityTarget: Function | string,\n        entity: ObjectLiteral,\n    ): Subject | undefined {\n        return this.allSubjects.find((subject) => {\n            if (!subject.entity) return false\n\n            if (subject.entity === entity) return true\n\n            return (\n                subject.metadata.target === entityTarget &&\n                subject.metadata.compareEntities(\n                    subject.entityWithFulfilledIds!,\n                    entity,\n                )\n            )\n        })\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2325, "column": 0}, "map": {"version":3,"file":"EntityPersistExecutor.js","sources":["turbopack:///[project]/node_modules/typeorm/browser/browser/src/persistence/EntityPersistExecutor.ts"],"sourceRoot":"..","sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { SaveOptions } from \"../repository/SaveOptions\"\nimport { RemoveOptions } from \"../repository/RemoveOptions\"\nimport { MustBeEntityError } from \"../error/MustBeEntityError\"\nimport { SubjectExecutor } from \"./SubjectExecutor\"\nimport { CannotDetermineEntityError } from \"../error/CannotDetermineEntityError\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { Subject } from \"./Subject\"\nimport { OneToManySubjectBuilder } from \"./subject-builder/OneToManySubjectBuilder\"\nimport { OneToOneInverseSideSubjectBuilder } from \"./subject-builder/OneToOneInverseSideSubjectBuilder\"\nimport { ManyToManySubjectBuilder } from \"./subject-builder/ManyToManySubjectBuilder\"\nimport { SubjectDatabaseEntityLoader } from \"./SubjectDatabaseEntityLoader\"\nimport { CascadesSubjectBuilder } from \"./subject-builder/CascadesSubjectBuilder\"\nimport { OrmUtils } from \"../util/OrmUtils\"\n\n/**\n * Persists a single entity or multiple entities - saves or removes them.\n */\nexport class EntityPersistExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        protected queryRunner: QueryRunner | undefined,\n        protected mode: \"save\" | \"remove\" | \"soft-remove\" | \"recover\",\n        protected target: Function | string | undefined,\n        protected entity: ObjectLiteral | ObjectLiteral[],\n        protected options?: SaveOptions & RemoveOptions,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Executes persistence operation ob given entity or entities.\n     */\n    async execute(): Promise<void> {\n        // check if entity we are going to save is valid and is an object\n        if (!this.entity || typeof this.entity !== \"object\")\n            return Promise.reject(new MustBeEntityError(this.mode, this.entity))\n\n        // we MUST call \"fake\" resolve here to make sure all properties of lazily loaded relations are resolved\n        await Promise.resolve()\n\n        // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n        // if its not defined we create a new query runner - single connection where we'll execute all our operations\n        const queryRunner =\n            this.queryRunner || this.connection.createQueryRunner()\n\n        // save data in the query runner - this is useful functionality to share data from outside of the world\n        // with third classes - like subscribers and listener methods\n        const oldQueryRunnerData = queryRunner.data\n        if (this.options && this.options.data) {\n            queryRunner.data = this.options.data\n        }\n\n        try {\n            // collect all operate subjects\n            const entities: ObjectLiteral[] = Array.isArray(this.entity)\n                ? this.entity\n                : [this.entity]\n            const entitiesInChunks =\n                this.options && this.options.chunk && this.options.chunk > 0\n                    ? OrmUtils.chunk(entities, this.options.chunk)\n                    : [entities]\n\n            // console.time(\"building subject executors...\");\n            const executors = await Promise.all(\n                entitiesInChunks.map(async (entities) => {\n                    const subjects: Subject[] = []\n\n                    // create subjects for all entities we received for the persistence\n                    entities.forEach((entity) => {\n                        const entityTarget = this.target\n                            ? this.target\n                            : entity.constructor\n                        if (entityTarget === Object)\n                            throw new CannotDetermineEntityError(this.mode)\n\n                        const metadata = this.connection\n                            .getMetadata(entityTarget)\n                            .findInheritanceMetadata(entity)\n\n                        subjects.push(\n                            new Subject({\n                                metadata,\n                                entity: entity,\n                                canBeInserted: this.mode === \"save\",\n                                canBeUpdated: this.mode === \"save\",\n                                mustBeRemoved: this.mode === \"remove\",\n                                canBeSoftRemoved: this.mode === \"soft-remove\",\n                                canBeRecovered: this.mode === \"recover\",\n                            }),\n                        )\n                    })\n\n                    // console.time(\"building cascades...\");\n                    // go through each entity with metadata and create subjects and subjects by cascades for them\n                    const cascadesSubjectBuilder = new CascadesSubjectBuilder(\n                        subjects,\n                    )\n                    subjects.forEach((subject) => {\n                        // next step we build list of subjects we will operate with\n                        // these subjects are subjects that we need to insert or update alongside with main persisted entity\n                        cascadesSubjectBuilder.build(subject, this.mode)\n                    })\n                    // console.timeEnd(\"building cascades...\");\n\n                    // load database entities for all subjects we have\n                    // next step is to load database entities for all operate subjects\n                    // console.time(\"loading...\");\n                    await new SubjectDatabaseEntityLoader(\n                        queryRunner,\n                        subjects,\n                    ).load(this.mode)\n                    // console.timeEnd(\"loading...\");\n\n                    // console.time(\"other subjects...\");\n                    // build all related subjects and change maps\n                    if (\n                        this.mode === \"save\" ||\n                        this.mode === \"soft-remove\" ||\n                        this.mode === \"recover\"\n                    ) {\n                        new OneToManySubjectBuilder(subjects).build()\n                        new OneToOneInverseSideSubjectBuilder(subjects).build()\n                        new ManyToManySubjectBuilder(subjects).build()\n                    } else {\n                        subjects.forEach((subject) => {\n                            if (subject.mustBeRemoved) {\n                                new ManyToManySubjectBuilder(\n                                    subjects,\n                                ).buildForAllRemoval(subject)\n                            }\n                        })\n                    }\n                    // console.timeEnd(\"other subjects...\");\n                    // console.timeEnd(\"building subjects...\");\n                    // console.log(\"subjects\", subjects);\n\n                    // create a subject executor\n                    return new SubjectExecutor(\n                        queryRunner,\n                        subjects,\n                        this.options,\n                    )\n                }),\n            )\n            // console.timeEnd(\"building subject executors...\");\n\n            // make sure we have at least one executable operation before we create a transaction and proceed\n            // if we don't have operations it means we don't really need to update or remove something\n            const executorsWithExecutableOperations = executors.filter(\n                (executor) => executor.hasExecutableOperations,\n            )\n            if (executorsWithExecutableOperations.length === 0) return\n\n            // start execute queries in a transaction\n            // if transaction is already opened in this query runner then we don't touch it\n            // if its not opened yet then we open it here, and once we finish - we close it\n            let isTransactionStartedByUs = false\n            try {\n                // open transaction if its not opened yet\n                if (!queryRunner.isTransactionActive) {\n                    if (\n                        this.connection.driver.transactionSupport !== \"none\" &&\n                        (!this.options || this.options.transaction !== false)\n                    ) {\n                        // start transaction until it was not explicitly disabled\n                        isTransactionStartedByUs = true\n                        await queryRunner.startTransaction()\n                    }\n                }\n\n                // execute all persistence operations for all entities we have\n                // console.time(\"executing subject executors...\");\n                for (const executor of executorsWithExecutableOperations) {\n                    await executor.execute()\n                }\n                // console.timeEnd(\"executing subject executors...\");\n\n                // commit transaction if it was started by us\n                // console.time(\"commit\");\n                if (isTransactionStartedByUs === true)\n                    await queryRunner.commitTransaction()\n                // console.timeEnd(\"commit\");\n            } catch (error) {\n                // rollback transaction if it was started by us\n                if (isTransactionStartedByUs) {\n                    try {\n                        await queryRunner.rollbackTransaction()\n                    } catch (rollbackError) {}\n                }\n                throw error\n            }\n        } finally {\n            queryRunner.data = oldQueryRunnerData\n\n            // release query runner only if its created by us\n            if (!this.queryRunner) await queryRunner.release()\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}