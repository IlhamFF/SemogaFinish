(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["chunks/node_modules_typeorm_browser_metadata_d59433ab._.js", {

"[project]/node_modules/typeorm/browser/metadata/EntityMetadata.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "EntityMetadata": (()=>EntityMetadata)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$CannotCreateEntityIdMapError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/CannotCreateEntityIdMapError.js [middleware-edge] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$OrmUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/util/OrmUtils.js [middleware-edge] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$EntityPropertyNotFoundError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/EntityPropertyNotFoundError.js [middleware-edge] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ObjectUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/util/ObjectUtils.js [middleware-edge] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$StringUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/util/StringUtils.js [middleware-edge] (ecmascript)");
;
;
;
;
;
class EntityMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("EntityMetadata");
        /**
         * Children entity metadatas. Used in inheritance patterns.
         */ this.childEntityMetadatas = [];
        /**
         * All "inheritance tree" from a target entity.
         * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].
         * It also contains child entities for single table inheritance.
         */ this.inheritanceTree = [];
        /**
         * Table type. Tables can be closure, junction, etc.
         */ this.tableType = "regular";
        /**
         * Enables Sqlite "WITHOUT ROWID" modifier for the "CREATE TABLE" statement
         */ this.withoutRowid = false;
        /**
         * Indicates if schema will be synchronized for this entity or not.
         */ this.synchronize = true;
        /**
         * Checks if there any non-nullable column exist in this entity.
         */ this.hasNonNullableRelations = false;
        /**
         * Indicates if this entity metadata of a junction table, or not.
         * Junction table is a table created by many-to-many relationship.
         *
         * Its also possible to understand if entity is junction via tableType.
         */ this.isJunction = false;
        /**
         * Indicates if the entity should be instantiated using the constructor
         * or via allocating a new object via `Object.create()`.
         */ this.isAlwaysUsingConstructor = true;
        /**
         * Checks if this table is a junction table of the closure table.
         * This type is for tables that contain junction metadata of the closure tables.
         */ this.isClosureJunction = false;
        /**
         * Checks if entity's table has multiple primary columns.
         */ this.hasMultiplePrimaryKeys = false;
        /**
         * Indicates if this entity metadata has uuid generated columns.
         */ this.hasUUIDGeneratedColumns = false;
        /**
         * Entity's column metadatas defined by user.
         */ this.ownColumns = [];
        /**
         * Columns of the entity, including columns that are coming from the embeddeds of this entity.
         */ this.columns = [];
        /**
         * Ancestor columns used only in closure junction tables.
         */ this.ancestorColumns = [];
        /**
         * Descendant columns used only in closure junction tables.
         */ this.descendantColumns = [];
        /**
         * All columns except for virtual columns.
         */ this.nonVirtualColumns = [];
        /**
         * In the case if this entity metadata is junction table's entity metadata,
         * this will contain all referenced columns of owner entity.
         */ this.ownerColumns = [];
        /**
         * In the case if this entity metadata is junction table's entity metadata,
         * this will contain all referenced columns of inverse entity.
         */ this.inverseColumns = [];
        /**
         * Gets the column with generated flag.
         */ this.generatedColumns = [];
        /**
         * Gets the primary columns.
         */ this.primaryColumns = [];
        /**
         * Entity's relation metadatas.
         */ this.ownRelations = [];
        /**
         * Relations of the entity, including relations that are coming from the embeddeds of this entity.
         */ this.relations = [];
        /**
         * List of eager relations this metadata has.
         */ this.eagerRelations = [];
        /**
         * List of eager relations this metadata has.
         */ this.lazyRelations = [];
        /**
         * Gets only one-to-one relations of the entity.
         */ this.oneToOneRelations = [];
        /**
         * Gets only owner one-to-one relations of the entity.
         */ this.ownerOneToOneRelations = [];
        /**
         * Gets only one-to-many relations of the entity.
         */ this.oneToManyRelations = [];
        /**
         * Gets only many-to-one relations of the entity.
         */ this.manyToOneRelations = [];
        /**
         * Gets only many-to-many relations of the entity.
         */ this.manyToManyRelations = [];
        /**
         * Gets only owner many-to-many relations of the entity.
         */ this.ownerManyToManyRelations = [];
        /**
         * Gets only owner one-to-one and many-to-one relations.
         */ this.relationsWithJoinColumns = [];
        /**
         * Entity's relation id metadatas.
         */ this.relationIds = [];
        /**
         * Entity's relation id metadatas.
         */ this.relationCounts = [];
        /**
         * Entity's foreign key metadatas.
         */ this.foreignKeys = [];
        /**
         * Entity's embedded metadatas.
         */ this.embeddeds = [];
        /**
         * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.
         */ this.allEmbeddeds = [];
        /**
         * Entity's own indices.
         */ this.ownIndices = [];
        /**
         * Entity's index metadatas.
         */ this.indices = [];
        /**
         * Entity's unique metadatas.
         */ this.uniques = [];
        /**
         * Entity's own uniques.
         */ this.ownUniques = [];
        /**
         * Entity's check metadatas.
         */ this.checks = [];
        /**
         * Entity's exclusion metadatas.
         */ this.exclusions = [];
        /**
         * Entity's own listener metadatas.
         */ this.ownListeners = [];
        /**
         * Entity listener metadatas.
         */ this.listeners = [];
        /**
         * Listener metadatas with "AFTER LOAD" type.
         */ this.afterLoadListeners = [];
        /**
         * Listener metadatas with "BEFORE INSERT" type.
         */ this.beforeInsertListeners = [];
        /**
         * Listener metadatas with "AFTER INSERT" type.
         */ this.afterInsertListeners = [];
        /**
         * Listener metadatas with "BEFORE UPDATE" type.
         */ this.beforeUpdateListeners = [];
        /**
         * Listener metadatas with "AFTER UPDATE" type.
         */ this.afterUpdateListeners = [];
        /**
         * Listener metadatas with "BEFORE REMOVE" type.
         */ this.beforeRemoveListeners = [];
        /**
         * Listener metadatas with "BEFORE SOFT REMOVE" type.
         */ this.beforeSoftRemoveListeners = [];
        /**
         * Listener metadatas with "BEFORE RECOVER" type.
         */ this.beforeRecoverListeners = [];
        /**
         * Listener metadatas with "AFTER REMOVE" type.
         */ this.afterRemoveListeners = [];
        /**
         * Listener metadatas with "AFTER SOFT REMOVE" type.
         */ this.afterSoftRemoveListeners = [];
        /**
         * Listener metadatas with "AFTER RECOVER" type.
         */ this.afterRecoverListeners = [];
        this.connection = options.connection;
        this.inheritanceTree = options.inheritanceTree || [];
        this.inheritancePattern = options.inheritancePattern;
        this.treeType = options.tableTree ? options.tableTree.type : undefined;
        this.treeOptions = options.tableTree ? options.tableTree.options : undefined;
        this.parentClosureEntityMetadata = options.parentClosureEntityMetadata;
        this.tableMetadataArgs = options.args;
        this.target = this.tableMetadataArgs.target;
        this.tableType = this.tableMetadataArgs.type;
        this.expression = this.tableMetadataArgs.expression;
        this.withoutRowid = this.tableMetadataArgs.withoutRowid;
        this.dependsOn = this.tableMetadataArgs.dependsOn;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a new entity.
     */ create(queryRunner, options) {
        const pojo = options && options.pojo === true ? true : false;
        // if target is set to a function (e.g. class) that can be created then create it
        let ret;
        if (typeof this.target === "function" && !pojo) {
            if (!options?.fromDeserializer || this.isAlwaysUsingConstructor) {
                ret = new this.target();
            } else {
                ret = Object.create(this.target.prototype);
            }
        } else {
            // otherwise simply return a new empty object
            ret = {};
        }
        // add "typename" property
        if (this.connection.options.typename) {
            ret[this.connection.options.typename] = this.targetName;
        }
        this.lazyRelations.forEach((relation)=>this.connection.relationLoader.enableLazyLoad(relation, ret, queryRunner));
        return ret;
    }
    /**
     * Checks if given entity has an id.
     */ hasId(entity) {
        if (!entity) return false;
        return this.primaryColumns.every((primaryColumn)=>{
            const value = primaryColumn.getEntityValue(entity);
            return value !== null && value !== undefined && value !== "";
        });
    }
    /**
     * Checks if given entity / object contains ALL primary keys entity must have.
     * Returns true if it contains all of them, false if at least one of them is not defined.
     */ hasAllPrimaryKeys(entity) {
        return this.primaryColumns.every((primaryColumn)=>{
            const value = primaryColumn.getEntityValue(entity);
            return value !== null && value !== undefined;
        });
    }
    /**
     * Ensures that given object is an entity id map.
     * If given id is an object then it means its already id map.
     * If given id isn't an object then it means its a value of the id column
     * and it creates a new id map with this value and name of the primary column.
     */ ensureEntityIdMap(id) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ObjectUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["ObjectUtils"].isObject(id)) return id;
        if (this.hasMultiplePrimaryKeys) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$CannotCreateEntityIdMapError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["CannotCreateEntityIdMapError"](this, id);
        return this.primaryColumns[0].createValueMap(id);
    }
    /**
     * Gets primary keys of the entity and returns them in a literal object.
     * For example, for Post{ id: 1, title: "hello" } where id is primary it will return { id: 1 }
     * For multiple primary keys it returns multiple keys in object.
     * For primary keys inside embeds it returns complex object literal with keys in them.
     */ getEntityIdMap(entity) {
        if (!entity) return undefined;
        return EntityMetadata.getValueMap(entity, this.primaryColumns, {
            skipNulls: true
        });
    }
    /**
     * Creates a "mixed id map".
     * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.
     * But if entity has a single primary key then it will return just value of the id column of the entity, just value.
     * This is called mixed id map.
     */ getEntityIdMixedMap(entity) {
        if (!entity) return entity;
        const idMap = this.getEntityIdMap(entity);
        if (this.hasMultiplePrimaryKeys) {
            return idMap;
        } else if (idMap) {
            return this.primaryColumns[0].getEntityValue(idMap); // todo: what about parent primary column?
        }
        return idMap;
    }
    /**
     * Compares two different entities by their ids.
     * Returns true if they match, false otherwise.
     */ compareEntities(firstEntity, secondEntity) {
        const firstEntityIdMap = this.getEntityIdMap(firstEntity);
        if (!firstEntityIdMap) return false;
        const secondEntityIdMap = this.getEntityIdMap(secondEntity);
        if (!secondEntityIdMap) return false;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$OrmUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["OrmUtils"].compareIds(firstEntityIdMap, secondEntityIdMap);
    }
    /**
     * Finds column with a given property name.
     */ findColumnWithPropertyName(propertyName) {
        return this.columns.find((column)=>column.propertyName === propertyName);
    }
    /**
     * Finds column with a given database name.
     */ findColumnWithDatabaseName(databaseName) {
        return this.columns.find((column)=>column.databaseName === databaseName);
    }
    /**
     * Checks if there is a column or relationship with a given property path.
     */ hasColumnWithPropertyPath(propertyPath) {
        const hasColumn = this.columns.some((column)=>column.propertyPath === propertyPath);
        return hasColumn || this.hasRelationWithPropertyPath(propertyPath);
    }
    /**
     * Finds column with a given property path.
     */ findColumnWithPropertyPath(propertyPath) {
        const column = this.columns.find((column)=>column.propertyPath === propertyPath);
        if (column) return column;
        // in the case if column with property path was not found, try to find a relation with such property path
        // if we find relation and it has a single join column then its the column user was seeking
        const relation = this.relations.find((relation)=>relation.propertyPath === propertyPath);
        if (relation && relation.joinColumns.length === 1) return relation.joinColumns[0];
        return undefined;
    }
    /**
     * Finds column with a given property path.
     * Does not search in relation unlike findColumnWithPropertyPath.
     */ findColumnWithPropertyPathStrict(propertyPath) {
        return this.columns.find((column)=>column.propertyPath === propertyPath);
    }
    /**
     * Finds columns with a given property path.
     * Property path can match a relation, and relations can contain multiple columns.
     */ findColumnsWithPropertyPath(propertyPath) {
        const column = this.columns.find((column)=>column.propertyPath === propertyPath);
        if (column) return [
            column
        ];
        // in the case if column with property path was not found, try to find a relation with such property path
        // if we find relation and it has a single join column then its the column user was seeking
        const relation = this.findRelationWithPropertyPath(propertyPath);
        if (relation && relation.joinColumns) return relation.joinColumns;
        return [];
    }
    /**
     * Checks if there is a relation with the given property path.
     */ hasRelationWithPropertyPath(propertyPath) {
        return this.relations.some((relation)=>relation.propertyPath === propertyPath);
    }
    /**
     * Finds relation with the given property path.
     */ findRelationWithPropertyPath(propertyPath) {
        return this.relations.find((relation)=>relation.propertyPath === propertyPath);
    }
    /**
     * Checks if there is an embedded with a given property path.
     */ hasEmbeddedWithPropertyPath(propertyPath) {
        return this.allEmbeddeds.some((embedded)=>embedded.propertyPath === propertyPath);
    }
    /**
     * Finds embedded with a given property path.
     */ findEmbeddedWithPropertyPath(propertyPath) {
        return this.allEmbeddeds.find((embedded)=>embedded.propertyPath === propertyPath);
    }
    /**
     * Returns an array of databaseNames mapped from provided propertyPaths
     */ mapPropertyPathsToColumns(propertyPaths) {
        return propertyPaths.map((propertyPath)=>{
            const column = this.findColumnWithPropertyPath(propertyPath);
            if (column == null) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$EntityPropertyNotFoundError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["EntityPropertyNotFoundError"](propertyPath, this);
            }
            return column;
        });
    }
    /**
     * Iterates through entity and finds and extracts all values from relations in the entity.
     * If relation value is an array its being flattened.
     */ extractRelationValuesFromEntity(entity, relations) {
        const relationsAndValues = [];
        relations.forEach((relation)=>{
            const value = relation.getEntityValue(entity);
            if (Array.isArray(value)) {
                value.forEach((subValue)=>relationsAndValues.push([
                        relation,
                        subValue,
                        EntityMetadata.getInverseEntityMetadata(subValue, relation)
                    ]));
            } else if (value) {
                relationsAndValues.push([
                    relation,
                    value,
                    EntityMetadata.getInverseEntityMetadata(value, relation)
                ]);
            }
        });
        return relationsAndValues;
    }
    /**
     * In the case of SingleTableInheritance, find the correct metadata
     * for a given value.
     *
     * @param value The value to find the metadata for.
     * @returns The found metadata for the entity or the base metadata if no matching metadata
     *          was found in the whole inheritance tree.
     */ findInheritanceMetadata(value) {
        // Check for single table inheritance and find the correct metadata in that case.
        // Goal is to use the correct discriminator as we could have a repository
        // for an (abstract) base class and thus the target would not match.
        if (this.inheritancePattern === "STI" && this.childEntityMetadatas.length > 0) {
            // There could be a column on the base class that can manually be set to override the type.
            let manuallySetDiscriminatorValue;
            if (this.discriminatorColumn) {
                manuallySetDiscriminatorValue = value[this.discriminatorColumn.propertyName];
            }
            return this.childEntityMetadatas.find((meta)=>manuallySetDiscriminatorValue === meta.discriminatorValue || value.constructor === meta.target) || this;
        }
        return this;
    }
    // -------------------------------------------------------------------------
    // Private Static Methods
    // -------------------------------------------------------------------------
    static getInverseEntityMetadata(value, relation) {
        return relation.inverseEntityMetadata.findInheritanceMetadata(value);
    }
    // -------------------------------------------------------------------------
    // Public Static Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a property paths for a given entity.
     *
     * @deprecated
     */ static createPropertyPath(metadata, entity, prefix = "") {
        const paths = [];
        Object.keys(entity).forEach((key)=>{
            // check for function is needed in the cases when createPropertyPath used on values contain a function as a value
            // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })
            const parentPath = prefix ? prefix + "." + key : key;
            if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {
                const subPaths = this.createPropertyPath(metadata, entity[key], parentPath);
                paths.push(...subPaths);
            } else {
                const path = prefix ? prefix + "." + key : key;
                paths.push(path);
            }
        });
        return paths;
    }
    /**
     * Finds difference between two entity id maps.
     * Returns items that exist in the first array and absent in the second array.
     */ static difference(firstIdMaps, secondIdMaps) {
        return firstIdMaps.filter((firstIdMap)=>{
            return !secondIdMaps.find((secondIdMap)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$OrmUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["OrmUtils"].compareIds(firstIdMap, secondIdMap));
        });
    }
    /**
     * Creates value map from the given values and columns.
     * Examples of usages are primary columns map and join columns map.
     */ static getValueMap(entity, columns, options) {
        return columns.reduce((map, column)=>{
            const value = column.getEntityValueMap(entity, options);
            // make sure that none of the values of the columns are not missing
            if (map === undefined || value === null || value === undefined) return undefined;
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$OrmUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["OrmUtils"].mergeDeep(map, value);
        }, {});
    }
    // ---------------------------------------------------------------------
    // Public Builder Methods
    // ---------------------------------------------------------------------
    build() {
        const namingStrategy = this.connection.namingStrategy;
        const entityPrefix = this.connection.options.entityPrefix;
        const entitySkipConstructor = this.connection.options.entitySkipConstructor;
        this.engine = this.tableMetadataArgs.engine;
        this.database = this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata ? this.parentEntityMetadata.database : this.tableMetadataArgs.database;
        if (this.tableMetadataArgs.schema) {
            this.schema = this.tableMetadataArgs.schema;
        } else if (this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata) {
            this.schema = this.parentEntityMetadata.schema;
        } else if (this.connection.options?.hasOwnProperty("schema")) {
            this.schema = this.connection.options.schema;
        }
        this.givenTableName = this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata ? this.parentEntityMetadata.givenTableName : this.tableMetadataArgs.name;
        this.synchronize = this.tableMetadataArgs.synchronize === false ? false : true;
        this.targetName = typeof this.tableMetadataArgs.target === "function" ? this.tableMetadataArgs.target.name : this.tableMetadataArgs.target;
        if (this.tableMetadataArgs.type === "closure-junction") {
            this.tableNameWithoutPrefix = namingStrategy.closureJunctionTableName(this.givenTableName);
        } else if (this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata) {
            this.tableNameWithoutPrefix = namingStrategy.tableName(this.parentEntityMetadata.targetName, this.parentEntityMetadata.givenTableName);
        } else {
            this.tableNameWithoutPrefix = namingStrategy.tableName(this.targetName, this.givenTableName);
            if (this.tableMetadataArgs.type === "junction" && this.connection.driver.maxAliasLength && this.connection.driver.maxAliasLength > 0 && this.tableNameWithoutPrefix.length > this.connection.driver.maxAliasLength) {
                // note: we are not using DriverUtils.buildAlias here because we would like to avoid
                // hashed table names. However, current algorithm also isn't perfect, but we cannot
                // change it, since it's a big breaking change. Planned to 0.4.0
                this.tableNameWithoutPrefix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$StringUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["shorten"])(this.tableNameWithoutPrefix, {
                    separator: "_",
                    segmentLength: 3
                });
            }
        }
        this.tableName = entityPrefix ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;
        this.target = this.target ? this.target : this.tableName;
        this.name = this.targetName ? this.targetName : this.tableName;
        this.expression = this.tableMetadataArgs.expression;
        this.withoutRowid = this.tableMetadataArgs.withoutRowid === true ? true : false;
        this.tablePath = this.connection.driver.buildTableName(this.tableName, this.schema, this.database);
        this.orderBy = typeof this.tableMetadataArgs.orderBy === "function" ? this.tableMetadataArgs.orderBy(this.propertiesMap) : this.tableMetadataArgs.orderBy; // todo: is propertiesMap available here? Looks like its not
        if (entitySkipConstructor !== undefined) {
            this.isAlwaysUsingConstructor = !entitySkipConstructor;
        }
        this.isJunction = this.tableMetadataArgs.type === "closure-junction" || this.tableMetadataArgs.type === "junction";
        this.isClosureJunction = this.tableMetadataArgs.type === "closure-junction";
        this.comment = this.tableMetadataArgs.comment;
    }
    /**
     * Registers a new column in the entity and recomputes all depend properties.
     */ registerColumn(column) {
        if (this.ownColumns.indexOf(column) !== -1) return;
        this.ownColumns.push(column);
        this.columns = this.embeddeds.reduce((columns, embedded)=>columns.concat(embedded.columnsFromTree), this.ownColumns);
        this.primaryColumns = this.columns.filter((column)=>column.isPrimary);
        this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;
        this.hasUUIDGeneratedColumns = this.columns.filter((column)=>column.isGenerated || column.generationStrategy === "uuid").length > 0;
        this.propertiesMap = this.createPropertiesMap();
        if (this.childEntityMetadatas) this.childEntityMetadatas.forEach((entityMetadata)=>entityMetadata.registerColumn(column));
    }
    /**
     * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)
     * in a special format - { propertyName: propertyName }.
     *
     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.
     * This method will create following object:
     * { id: "id", counterEmbed: { count: "counterEmbed.count" }, category: "category" }
     */ createPropertiesMap() {
        const map = {};
        this.columns.forEach((column)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$OrmUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["OrmUtils"].mergeDeep(map, column.createValueMap(column.propertyPath)));
        this.relations.forEach((relation)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$OrmUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["OrmUtils"].mergeDeep(map, relation.createValueMap(relation.propertyPath)));
        return map;
    }
    /**
     * Checks if entity has any column which rely on returning data,
     * e.g. columns with auto generated value, DEFAULT values considered as dependant of returning data.
     * For example, if we need to have RETURNING after INSERT (or we need returned id for DBs not supporting RETURNING),
     * it means we cannot execute bulk inserts in some cases.
     */ getInsertionReturningColumns() {
        return this.columns.filter((column)=>{
            return column.default !== undefined || column.asExpression !== undefined || column.isGenerated || column.isCreateDate || column.isUpdateDate || column.isDeleteDate || column.isVersion;
        });
    }
} //# sourceMappingURL=EntityMetadata.js.map
}}),
"[project]/node_modules/typeorm/browser/metadata/ColumnMetadata.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ColumnMetadata": (()=>ColumnMetadata)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:buffer [external] (node:buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$OrmUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/util/OrmUtils.js [middleware-edge] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ApplyValueTransformers$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/util/ApplyValueTransformers.js [middleware-edge] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ObjectUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/util/ObjectUtils.js [middleware-edge] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$InstanceChecker$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/util/InstanceChecker.js [middleware-edge] (ecmascript)");
;
;
;
;
class ColumnMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("ColumnMetadata");
        /**
         * Type's length in the database.
         */ this.length = "";
        /**
         * Indicates if this column is a primary key.
         */ this.isPrimary = false;
        /**
         * Indicates if this column is generated (auto increment or generated other way).
         */ this.isGenerated = false;
        /**
         * Indicates if column can contain nulls or not.
         */ this.isNullable = false;
        /**
         * Indicates if column is selected by query builder or not.
         */ this.isSelect = true;
        /**
         * Indicates if column is inserted by default or not.
         */ this.isInsert = true;
        /**
         * Indicates if column allows updates or not.
         */ this.isUpdate = true;
        /**
         * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.
         * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column
         */ this.zerofill = false;
        /**
         * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.
         */ this.unsigned = false;
        /**
         * Indicates if this column is an array.
         */ this.isArray = false;
        /**
         * Indicates if column is virtual. Virtual columns are not mapped to the entity.
         */ this.isVirtual = false;
        /**
         * Indicates if column is a virtual property. Virtual properties are not mapped to the entity.
         * This property is used in tandem the virtual column decorator.
         * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.
         */ this.isVirtualProperty = false;
        /**
         * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.
         */ this.isDiscriminator = false;
        /**
         * Indicates if column is tree-level column. Tree-level columns are used in closure entities.
         */ this.isTreeLevel = false;
        /**
         * Indicates if this column contains an entity creation date.
         */ this.isCreateDate = false;
        /**
         * Indicates if this column contains an entity update date.
         */ this.isUpdateDate = false;
        /**
         * Indicates if this column contains an entity delete date.
         */ this.isDeleteDate = false;
        /**
         * Indicates if this column contains an entity version.
         */ this.isVersion = false;
        /**
         * Indicates if this column contains an object id.
         */ this.isObjectId = false;
        /**
         * Indicates if this column is nested set's left column.
         * Used only in tree entities with nested-set type.
         */ this.isNestedSetLeft = false;
        /**
         * Indicates if this column is nested set's right column.
         * Used only in tree entities with nested-set type.
         */ this.isNestedSetRight = false;
        /**
         * Indicates if this column is materialized path's path column.
         * Used only in tree entities with materialized path type.
         */ this.isMaterializedPath = false;
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        this.referencedColumn = options.referencedColumn;
        if (options.args.target) this.target = options.args.target;
        if (options.args.propertyName) this.propertyName = options.args.propertyName;
        if (options.args.options.name) this.givenDatabaseName = options.args.options.name;
        if (options.args.options.type) this.type = options.args.options.type;
        if (options.args.options.length) this.length = options.args.options.length ? options.args.options.length.toString() : "";
        if (options.args.options.width) this.width = options.args.options.width;
        if (options.args.options.charset) this.charset = options.args.options.charset;
        if (options.args.options.collation) this.collation = options.args.options.collation;
        if (options.args.options.primary) this.isPrimary = options.args.options.primary;
        if (options.args.options.default === null) // to make sure default: null is the same as nullable: true
        this.isNullable = true;
        if (options.args.options.nullable !== undefined) this.isNullable = options.args.options.nullable;
        if (options.args.options.select !== undefined) this.isSelect = options.args.options.select;
        if (options.args.options.insert !== undefined) this.isInsert = options.args.options.insert;
        if (options.args.options.update !== undefined) this.isUpdate = options.args.options.update;
        if (options.args.options.readonly !== undefined) this.isUpdate = !options.args.options.readonly;
        if (options.args.options.comment) this.comment = options.args.options.comment;
        if (options.args.options.default !== undefined) this.default = options.args.options.default;
        if (options.args.options.onUpdate) this.onUpdate = options.args.options.onUpdate;
        if (options.args.options.generatedIdentity) this.generatedIdentity = options.args.options.generatedIdentity;
        if (options.args.options.scale !== null && options.args.options.scale !== undefined) this.scale = options.args.options.scale;
        if (options.args.options.zerofill) {
            this.zerofill = options.args.options.zerofill;
            this.unsigned = true; // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column
        }
        if (options.args.options.unsigned) this.unsigned = options.args.options.unsigned;
        if (options.args.options.precision !== null) this.precision = options.args.options.precision;
        if (options.args.options.enum) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ObjectUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["ObjectUtils"].isObject(options.args.options.enum) && !Array.isArray(options.args.options.enum)) {
                this.enum = Object.keys(options.args.options.enum)// remove numeric keys - typescript numeric enum types generate them
                // From the documentation: “declaration merging” means that the compiler merges two separate declarations
                // declared with the same name into a single definition. This concept is often used to merge enum with namespace
                // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages
                // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise
                // generated SQL statements contains string representation of that function which leads into syntax error
                // at database side.
                .filter((key)=>isNaN(+key) && typeof options.args.options.enum[key] !== "function").map((key)=>options.args.options.enum[key]);
            } else {
                this.enum = options.args.options.enum;
            }
        }
        if (options.args.options.enumName) {
            this.enumName = options.args.options.enumName;
        }
        if (options.args.options.primaryKeyConstraintName) {
            this.primaryKeyConstraintName = options.args.options.primaryKeyConstraintName;
        }
        if (options.args.options.foreignKeyConstraintName) {
            this.foreignKeyConstraintName = options.args.options.foreignKeyConstraintName;
        }
        if (options.args.options.asExpression) {
            this.asExpression = options.args.options.asExpression;
            this.generatedType = options.args.options.generatedType ? options.args.options.generatedType : "VIRTUAL";
        }
        if (options.args.options.hstoreType) this.hstoreType = options.args.options.hstoreType;
        if (options.args.options.array) this.isArray = options.args.options.array;
        if (options.args.mode) {
            this.isVirtualProperty = options.args.mode === "virtual-property";
            this.isVirtual = options.args.mode === "virtual";
            this.isTreeLevel = options.args.mode === "treeLevel";
            this.isCreateDate = options.args.mode === "createDate";
            this.isUpdateDate = options.args.mode === "updateDate";
            this.isDeleteDate = options.args.mode === "deleteDate";
            this.isVersion = options.args.mode === "version";
            this.isObjectId = options.args.mode === "objectId";
        }
        if (this.isVirtualProperty) {
            this.isInsert = false;
            this.isUpdate = false;
        }
        if (options.args.options.transformer) this.transformer = options.args.options.transformer;
        if (options.args.options.spatialFeatureType) this.spatialFeatureType = options.args.options.spatialFeatureType;
        if (options.args.options.srid !== undefined) this.srid = options.args.options.srid;
        if (options.args.options.query) this.query = options.args.options.query;
        if (this.isTreeLevel) this.type = options.connection.driver.mappedDataTypes.treeLevel;
        if (this.isCreateDate) {
            if (!this.type) this.type = options.connection.driver.mappedDataTypes.createDate;
            if (!this.default) this.default = ()=>options.connection.driver.mappedDataTypes.createDateDefault;
            // skip precision if it was explicitly set to "null" in column options. Otherwise use default precision if it exist.
            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.createDatePrecision) this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;
        }
        if (this.isUpdateDate) {
            if (!this.type) this.type = options.connection.driver.mappedDataTypes.updateDate;
            if (!this.default) this.default = ()=>options.connection.driver.mappedDataTypes.updateDateDefault;
            if (!this.onUpdate) this.onUpdate = options.connection.driver.mappedDataTypes.updateDateDefault;
            // skip precision if it was explicitly set to "null" in column options. Otherwise use default precision if it exist.
            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.updateDatePrecision) this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;
        }
        if (this.isDeleteDate) {
            if (!this.type) this.type = options.connection.driver.mappedDataTypes.deleteDate;
            if (!this.isNullable) this.isNullable = options.connection.driver.mappedDataTypes.deleteDateNullable;
            // skip precision if it was explicitly set to "null" in column options. Otherwise use default precision if it exist.
            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.deleteDatePrecision) this.precision = options.connection.driver.mappedDataTypes.deleteDatePrecision;
        }
        if (this.isVersion) this.type = options.connection.driver.mappedDataTypes.version;
        if (options.closureType) this.closureType = options.closureType;
        if (options.nestedSetLeft) this.isNestedSetLeft = options.nestedSetLeft;
        if (options.nestedSetRight) this.isNestedSetRight = options.nestedSetRight;
        if (options.materializedPath) this.isMaterializedPath = options.materializedPath;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Creates entity id map from the given entity ids array.
     */ createValueMap(value, useDatabaseName = false) {
        // extract column value from embeds of entity if column is in embedded
        if (this.embeddedMetadata) {
            // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
            // we need to get value of "id" column from the post real entity object and return it in a
            // { data: { information: { counters: { id: ... } } } } format
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const propertyNames = [
                ...this.embeddedMetadata.parentPropertyNames
            ];
            // now need to access post[data][information][counters] to get column value from the counters
            // and on each step we need to create complex literal object, e.g. first { data },
            // then { data: { information } }, then { data: { information: { counters } } },
            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }
            // this recursive function helps doing that
            const extractEmbeddedColumnValue = (propertyNames, map)=>{
                const propertyName = propertyNames.shift();
                if (propertyName) {
                    map[propertyName] = {};
                    extractEmbeddedColumnValue(propertyNames, map[propertyName]);
                    return map;
                }
                // this is bugfix for #720 when increment number is bigint we need to make sure its a string
                if ((this.generationStrategy === "increment" || this.generationStrategy === "rowid") && this.type === "bigint" && value !== null) value = String(value);
                map[useDatabaseName ? this.databaseName : this.propertyName] = value;
                return map;
            };
            return extractEmbeddedColumnValue(propertyNames, {});
        } else {
            // no embeds - no problems. Simply return column property name and its value of the entity
            // this is bugfix for #720 when increment number is bigint we need to make sure its a string
            if ((this.generationStrategy === "increment" || this.generationStrategy === "rowid") && this.type === "bigint" && value !== null) value = String(value);
            return {
                [useDatabaseName ? this.databaseName : this.propertyName]: value
            };
        }
    }
    /**
     * Extracts column value and returns its column name with this value in a literal object.
     * If column is in embedded (or recursive embedded) it returns complex literal object.
     *
     * Examples what this method can return depend if this column is in embeds.
     * { id: 1 } or { title: "hello" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }
     */ getEntityValueMap(entity, options) {
        const returnNulls = false; // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.
        // extract column value from embeds of entity if column is in embedded
        if (this.embeddedMetadata) {
            // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
            // we need to get value of "id" column from the post real entity object and return it in a
            // { data: { information: { counters: { id: ... } } } } format
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const propertyNames = [
                ...this.embeddedMetadata.parentPropertyNames
            ];
            const isEmbeddedArray = this.embeddedMetadata.isArray;
            // now need to access post[data][information][counters] to get column value from the counters
            // and on each step we need to create complex literal object, e.g. first { data },
            // then { data: { information } }, then { data: { information: { counters } } },
            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }
            // this recursive function helps doing that
            const extractEmbeddedColumnValue = (propertyNames, value)=>{
                if (value === undefined) {
                    return {};
                }
                const propertyName = propertyNames.shift();
                if (propertyName) {
                    const submap = extractEmbeddedColumnValue(propertyNames, value[propertyName]);
                    if (Object.keys(submap).length > 0) {
                        return {
                            [propertyName]: submap
                        };
                    }
                    return {};
                }
                if (isEmbeddedArray && Array.isArray(value)) {
                    return value.map((v)=>({
                            [this.propertyName]: v[this.propertyName]
                        }));
                }
                if (value[this.propertyName] !== undefined && (returnNulls === false || value[this.propertyName] !== null)) {
                    return {
                        [this.propertyName]: value[this.propertyName]
                    };
                }
                return {};
            };
            const map = extractEmbeddedColumnValue(propertyNames, entity);
            return Object.keys(map).length > 0 ? map : undefined;
        } else {
            // no embeds - no problems. Simply return column property name and its value of the entity
            /**
             * Object.getOwnPropertyDescriptor checks if the relation is lazy, in which case value is a Promise
             * DO NOT use `entity[
                this.relationMetadata.propertyName] instanceof Promise`, which will invoke property getter and make unwanted DB request
             * refer: https://github.com/typeorm/typeorm/pull/8676#issuecomment-1049906331
             */ if (this.relationMetadata && !Object.getOwnPropertyDescriptor(entity, this.relationMetadata.propertyName)?.get && entity[this.relationMetadata.propertyName] && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ObjectUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["ObjectUtils"].isObject(entity[this.relationMetadata.propertyName])) {
                if (this.relationMetadata.joinColumns.length > 1) {
                    const map = this.relationMetadata.joinColumns.reduce((map, joinColumn)=>{
                        const value = joinColumn.referencedColumn.getEntityValueMap(entity[this.relationMetadata.propertyName]);
                        if (value === undefined) return map;
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$OrmUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["OrmUtils"].mergeDeep(map, value);
                    }, {});
                    if (Object.keys(map).length > 0) return {
                        [this.propertyName]: map
                    };
                } else {
                    const value = this.relationMetadata.joinColumns[0].referencedColumn.getEntityValue(entity[this.relationMetadata.propertyName]);
                    if (value) {
                        return {
                            [this.propertyName]: value
                        };
                    }
                }
                return undefined;
            } else {
                if (entity[this.propertyName] !== undefined && (returnNulls === false || entity[this.propertyName] !== null)) {
                    return {
                        [this.propertyName]: entity[this.propertyName]
                    };
                }
                return undefined;
            }
        }
    }
    /**
     * Extracts column value from the given entity.
     * If column is in embedded (or recursive embedded) it extracts its value from there.
     */ getEntityValue(entity, transform = false) {
        if (entity === undefined || entity === null) return undefined;
        // extract column value from embeddeds of entity if column is in embedded
        let value = undefined;
        if (this.embeddedMetadata) {
            // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
            // we need to get value of "id" column from the post real entity object
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const propertyNames = [
                ...this.embeddedMetadata.parentPropertyNames
            ];
            const isEmbeddedArray = this.embeddedMetadata.isArray;
            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters
            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed
            const extractEmbeddedColumnValue = (propertyNames, value)=>{
                const propertyName = propertyNames.shift();
                return propertyName && value ? extractEmbeddedColumnValue(propertyNames, value[propertyName]) : value;
            };
            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]
            const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);
            if (embeddedObject) {
                if (this.relationMetadata && this.referencedColumn) {
                    const relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);
                    if (relatedEntity && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ObjectUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["ObjectUtils"].isObject(relatedEntity) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$InstanceChecker$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["InstanceChecker"].isFindOperator(relatedEntity) && !__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].isBuffer(relatedEntity)) {
                        value = this.referencedColumn.getEntityValue(relatedEntity);
                    } else if (embeddedObject[this.propertyName] && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ObjectUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["ObjectUtils"].isObject(embeddedObject[this.propertyName]) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$InstanceChecker$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["InstanceChecker"].isFindOperator(embeddedObject[this.propertyName]) && !__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].isBuffer(embeddedObject[this.propertyName]) && !(embeddedObject[this.propertyName] instanceof Date)) {
                        value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);
                    } else {
                        value = embeddedObject[this.propertyName];
                    }
                } else if (this.referencedColumn) {
                    value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);
                } else if (isEmbeddedArray && Array.isArray(embeddedObject)) {
                    value = embeddedObject.map((o)=>o[this.propertyName]);
                } else {
                    value = embeddedObject[this.propertyName];
                }
            }
        } else {
            // no embeds - no problems. Simply return column name by property name of the entity
            if (this.relationMetadata && this.referencedColumn) {
                const relatedEntity = this.relationMetadata.getEntityValue(entity);
                if (relatedEntity && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ObjectUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["ObjectUtils"].isObject(relatedEntity) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$InstanceChecker$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["InstanceChecker"].isFindOperator(relatedEntity) && !(typeof relatedEntity === "function") && !__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].isBuffer(relatedEntity)) {
                    value = this.referencedColumn.getEntityValue(relatedEntity);
                } else if (entity[this.propertyName] && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ObjectUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["ObjectUtils"].isObject(entity[this.propertyName]) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$InstanceChecker$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["InstanceChecker"].isFindOperator(entity[this.propertyName]) && !(typeof entity[this.propertyName] === "function") && !__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Buffer"].isBuffer(entity[this.propertyName]) && !(entity[this.propertyName] instanceof Date)) {
                    value = this.referencedColumn.getEntityValue(entity[this.propertyName]);
                } else {
                    value = entity[this.propertyName];
                }
            } else if (this.referencedColumn) {
                value = this.referencedColumn.getEntityValue(entity[this.propertyName]);
            } else {
                value = entity[this.propertyName];
            }
        }
        if (transform && this.transformer) value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ApplyValueTransformers$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["ApplyValueTransformers"].transformTo(this.transformer, value);
        return value;
    }
    /**
     * Sets given entity's column value.
     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.
     */ setEntityValue(entity, value) {
        if (this.embeddedMetadata) {
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const extractEmbeddedColumnValue = (embeddedMetadatas, map)=>{
                // if (!object[embeddedMetadata.propertyName])
                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();
                const embeddedMetadata = embeddedMetadatas.shift();
                if (embeddedMetadata) {
                    if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();
                    extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);
                    return map;
                }
                map[this.propertyName] = value;
                return map;
            };
            return extractEmbeddedColumnValue([
                ...this.embeddedMetadata.embeddedMetadataTree
            ], entity);
        } else {
            // we write a deep object in this entity only if the column is virtual
            // because if its not virtual it means the user defined a real column for this relation
            // also we don't do it if column is inside a junction table
            if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) {
                if (!(this.propertyName in entity)) {
                    entity[this.propertyName] = {};
                }
                entity[this.propertyName][this.referencedColumn.propertyName] = value;
            } else {
                entity[this.propertyName] = value;
            }
        }
    }
    /**
     * Compares given entity's column value with a given value.
     */ compareEntityValue(entity, valueToCompareWith) {
        const columnValue = this.getEntityValue(entity);
        if (typeof columnValue?.equals === "function") {
            return columnValue.equals(valueToCompareWith);
        }
        return columnValue === valueToCompareWith;
    }
    // ---------------------------------------------------------------------
    // Builder Methods
    // ---------------------------------------------------------------------
    build(connection) {
        this.propertyPath = this.buildPropertyPath();
        this.propertyAliasName = this.propertyPath.replace(".", "_");
        this.databaseName = this.buildDatabaseName(connection);
        this.databasePath = this.buildDatabasePath();
        this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);
        return this;
    }
    buildPropertyPath() {
        let path = "";
        if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(".") + ".";
        path += this.propertyName;
        // we add reference column to property path only if this column is virtual
        // because if its not virtual it means user defined a real column for this relation
        // also we don't do it if column is inside a junction table
        if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) path += "." + this.referencedColumn.propertyName;
        return path;
    }
    buildDatabasePath() {
        let path = "";
        if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(".") + ".";
        path += this.databaseName;
        // we add reference column to property path only if this column is virtual
        // because if its not virtual it means user defined a real column for this relation
        // also we don't do it if column is inside a junction table
        if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.databaseName !== this.databaseName) path += "." + this.referencedColumn.databaseName;
        return path;
    }
    buildDatabaseName(connection) {
        let propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPrefixes : [];
        if (connection.driver.options.type === "mongodb") // we don't need to include embedded name for the mongodb column names
        propertyNames = [];
        return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);
    }
} //# sourceMappingURL=ColumnMetadata.js.map
}}),
"[project]/node_modules/typeorm/browser/metadata/IndexMetadata.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "IndexMetadata": (()=>IndexMetadata)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$index$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/index.js [middleware-edge] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$TypeORMError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/TypeORMError.js [middleware-edge] (ecmascript)");
;
class IndexMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        /**
         * Indicates if this index must be unique.
         */ this.isUnique = false;
        /**
         * The SPATIAL modifier indexes the entire column and does not allow indexed columns to contain NULL values.
         * Works only in MySQL.
         */ this.isSpatial = false;
        /**
         * The FULLTEXT modifier indexes the entire column and does not allow prefixing.
         * Works only in MySQL.
         */ this.isFulltext = false;
        /**
         * NULL_FILTERED indexes are particularly useful for indexing sparse columns, where most rows contain a NULL value.
         * In these cases, the NULL_FILTERED index can be considerably smaller and more efficient to maintain than
         * a normal index that includes NULL values.
         *
         * Works only in Spanner.
         */ this.isNullFiltered = false;
        /**
         * Indicates if this index must synchronize with database index.
         */ this.synchronize = true;
        /**
         * Indexed columns.
         */ this.columns = [];
        /**
         * Map of column names with order set.
         * Used only by MongoDB driver.
         */ this.columnNamesWithOrderingMap = {};
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        if (options.columns) this.columns = options.columns;
        if (options.args) {
            this.target = options.args.target;
            if (options.args.synchronize !== null && options.args.synchronize !== undefined) this.synchronize = options.args.synchronize;
            this.isUnique = !!options.args.unique;
            this.isSpatial = !!options.args.spatial;
            this.isFulltext = !!options.args.fulltext;
            this.isNullFiltered = !!options.args.nullFiltered;
            this.parser = options.args.parser;
            this.where = options.args.where;
            this.isSparse = options.args.sparse;
            this.isBackground = options.args.background;
            this.isConcurrent = options.args.concurrent;
            this.expireAfterSeconds = options.args.expireAfterSeconds;
            this.givenName = options.args.name;
            this.givenColumnNames = options.args.columns;
        }
    }
    // ---------------------------------------------------------------------
    // Public Build Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend index properties.
     * Must be called after all entity metadata's properties map, columns and relations are built.
     */ build(namingStrategy) {
        if (this.synchronize === false) {
            this.name = this.givenName;
            return this;
        }
        const map = {};
        // if columns already an array of string then simply return it
        if (this.givenColumnNames) {
            let columnPropertyPaths = [];
            if (Array.isArray(this.givenColumnNames)) {
                columnPropertyPaths = this.givenColumnNames.map((columnName)=>{
                    if (this.embeddedMetadata) return this.embeddedMetadata.propertyPath + "." + columnName;
                    return columnName.trim();
                });
                columnPropertyPaths.forEach((propertyPath)=>map[propertyPath] = 1);
            } else {
                // todo: indices in embeds are not implemented in this syntax. deprecate this syntax?
                // if columns is a function that returns array of field names then execute it and get columns names from it
                const columnsFnResult = this.givenColumnNames(this.entityMetadata.propertiesMap);
                if (Array.isArray(columnsFnResult)) {
                    columnPropertyPaths = columnsFnResult.map((i)=>String(i));
                    columnPropertyPaths.forEach((name)=>map[name] = 1);
                } else {
                    columnPropertyPaths = Object.keys(columnsFnResult).map((i)=>String(i));
                    Object.keys(columnsFnResult).forEach((columnName)=>map[columnName] = columnsFnResult[columnName]);
                }
            }
            this.columns = columnPropertyPaths.map((propertyPath)=>{
                const columnWithSameName = this.entityMetadata.columns.find((column)=>column.propertyPath === propertyPath);
                if (columnWithSameName) {
                    return [
                        columnWithSameName
                    ];
                }
                const relationWithSameName = this.entityMetadata.relations.find((relation)=>relation.isWithJoinColumn && relation.propertyName === propertyPath);
                if (relationWithSameName) {
                    return relationWithSameName.joinColumns;
                }
                const indexName = this.givenName ? '"' + this.givenName + '" ' : "";
                const entityName = this.entityMetadata.targetName;
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$TypeORMError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["TypeORMError"](`Index ${indexName}contains column that is missing in the entity (${entityName}): ` + propertyPath);
            }).reduce((a, b)=>a.concat(b));
        }
        this.columnNamesWithOrderingMap = Object.keys(map).reduce((updatedMap, key)=>{
            const column = this.entityMetadata.columns.find((column)=>column.propertyPath === key);
            if (column) updatedMap[column.databasePath] = map[key];
            return updatedMap;
        }, {});
        this.name = this.givenName ? this.givenName : namingStrategy.indexName(this.entityMetadata.tableName, this.columns.map((column)=>column.databaseName), this.where);
        return this;
    }
} //# sourceMappingURL=IndexMetadata.js.map
}}),
"[project]/node_modules/typeorm/browser/metadata/RelationMetadata.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RelationMetadata": (()=>RelationMetadata)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$metadata$2f$EntityMetadata$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/metadata/EntityMetadata.js [middleware-edge] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$index$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/index.js [middleware-edge] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$TypeORMError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/TypeORMError.js [middleware-edge] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ObjectUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/util/ObjectUtils.js [middleware-edge] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$InstanceChecker$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/util/InstanceChecker.js [middleware-edge] (ecmascript)");
;
;
;
;
class RelationMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        /**
         * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.
         */ this.isTreeParent = false;
        /**
         * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.
         */ this.isTreeChildren = false;
        /**
         * Indicates if this relation's column is a primary key.
         * Can be used only for many-to-one and owner one-to-one relations.
         */ this.isPrimary = false;
        /**
         * Indicates if this relation is lazily loaded.
         */ this.isLazy = false;
        /**
         * Indicates if this relation is eagerly loaded.
         */ this.isEager = false;
        /**
         * Indicates if persistence is enabled for the relation.
         * By default its enabled, but if you want to avoid any changes in the relation to be reflected in the database you can disable it.
         * If its disabled you can only change a relation from inverse side of a relation or using relation query builder functionality.
         * This is useful for performance optimization since its disabling avoid multiple extra queries during entity save.
         */ this.persistenceEnabled = true;
        /**
         * If set to true then related objects are allowed to be inserted to the database.
         */ this.isCascadeInsert = false;
        /**
         * If set to true then related objects are allowed to be updated in the database.
         */ this.isCascadeUpdate = false;
        /**
         * If set to true then related objects are allowed to be remove from the database.
         */ this.isCascadeRemove = false;
        /**
         * If set to true then related objects are allowed to be soft-removed from the database.
         */ this.isCascadeSoftRemove = false;
        /**
         * If set to true then related objects are allowed to be recovered from the database.
         */ this.isCascadeRecover = false;
        /**
         * Indicates if relation column value can be nullable or not.
         */ this.isNullable = true;
        /**
         * Indicates whether foreign key constraints will be created for join columns.
         * Can be used only for many-to-one and owner one-to-one relations.
         * Defaults to true.
         */ this.createForeignKeyConstraints = true;
        /**
         * Indicates if this side is an owner of this relation.
         */ this.isOwning = false;
        /**
         * Checks if this relation's type is "one-to-one".
         */ this.isOneToOne = false;
        /**
         * Checks if this relation is owner side of the "one-to-one" relation.
         * Owner side means this side of relation has a join column in the table.
         */ this.isOneToOneOwner = false;
        /**
         * Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).
         */ this.isWithJoinColumn = false;
        /**
         * Checks if this relation is NOT owner side of the "one-to-one" relation.
         * NOT owner side means this side of relation does not have a join column in the table.
         */ this.isOneToOneNotOwner = false;
        /**
         * Checks if this relation's type is "one-to-many".
         */ this.isOneToMany = false;
        /**
         * Checks if this relation's type is "many-to-one".
         */ this.isManyToOne = false;
        /**
         * Checks if this relation's type is "many-to-many".
         */ this.isManyToMany = false;
        /**
         * Checks if this relation's type is "many-to-many", and is owner side of the relationship.
         * Owner side means this side of relation has a join table.
         */ this.isManyToManyOwner = false;
        /**
         * Checks if this relation's type is "many-to-many", and is NOT owner side of the relationship.
         * Not owner side means this side of relation does not have a join table.
         */ this.isManyToManyNotOwner = false;
        /**
         * Foreign keys created for this relation.
         */ this.foreignKeys = [];
        /**
         * Join table columns.
         * Join columns can be obtained only from owner side of the relation.
         * From non-owner side of the relation join columns will be empty.
         * If this relation is a many-to-one/one-to-one then it takes join columns from the current entity.
         * If this relation is many-to-many then it takes all owner join columns from the junction entity.
         */ this.joinColumns = [];
        /**
         * Inverse join table columns.
         * Inverse join columns are supported only for many-to-many relations
         * and can be obtained only from owner side of the relation.
         * From non-owner side of the relation join columns will be undefined.
         */ this.inverseJoinColumns = [];
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        const args = options.args;
        this.target = args.target;
        this.propertyName = args.propertyName;
        this.relationType = args.relationType;
        if (args.inverseSideProperty) this.givenInverseSidePropertyFactory = args.inverseSideProperty;
        this.isLazy = args.isLazy || false;
        // this.isCascadeInsert = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf("insert") !== -1);
        // this.isCascadeUpdate = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf("update") !== -1);
        // this.isCascadeRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf("remove") !== -1);
        // this.isCascadeSoftRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf("soft-remove") !== -1);
        // this.isCascadeRecover = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf("recover") !== -1);
        this.isCascadeInsert = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("insert") !== -1;
        this.isCascadeUpdate = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("update") !== -1;
        this.isCascadeRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("remove") !== -1;
        this.isCascadeSoftRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("soft-remove") !== -1;
        this.isCascadeRecover = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("recover") !== -1;
        // this.isPrimary = args.options.primary || false;
        this.isNullable = args.options.nullable === false || this.isPrimary ? false : true;
        this.onDelete = args.options.onDelete;
        this.onUpdate = args.options.onUpdate;
        this.deferrable = args.options.deferrable;
        this.createForeignKeyConstraints = args.options.createForeignKeyConstraints === false ? false : true;
        this.isEager = args.options.eager || false;
        this.persistenceEnabled = args.options.persistence === false ? false : true;
        this.orphanedRowAction = args.options.orphanedRowAction || "nullify";
        this.isTreeParent = args.isTreeParent || false;
        this.isTreeChildren = args.isTreeChildren || false;
        if (typeof args.type === "function") {
            this.type = typeof args.type === "function" ? args.type() : args.type;
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$InstanceChecker$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["InstanceChecker"].isEntitySchema(args.type)) {
            this.type = args.type.options.name;
        } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ObjectUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["ObjectUtils"].isObject(args.type) && typeof args.type.name === "string") {
            this.type = args.type.name;
        } else {
            this.type = args.type;
        }
        this.isOneToOne = this.relationType === "one-to-one";
        this.isOneToMany = this.relationType === "one-to-many";
        this.isManyToOne = this.relationType === "many-to-one";
        this.isManyToMany = this.relationType === "many-to-many";
        this.isOneToOneNotOwner = this.isOneToOne ? true : false;
        this.isManyToManyNotOwner = this.isManyToMany ? true : false;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Creates join column ids map from the given related entity ids array.
     */ getRelationIdMap(entity) {
        const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;
        const referencedColumns = joinColumns.map((joinColumn)=>joinColumn.referencedColumn);
        // console.log("entity", entity);
        // console.log("referencedColumns", referencedColumns);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$metadata$2f$EntityMetadata$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["EntityMetadata"].getValueMap(entity, referencedColumns);
    }
    /**
     * Ensures that given object is an entity id map.
     * If given id is an object then it means its already id map.
     * If given id isn't an object then it means its a value of the id column
     * and it creates a new id map with this value and name of the primary column.
     */ ensureRelationIdMap(id) {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$util$2f$ObjectUtils$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["ObjectUtils"].isObject(id)) return id;
        const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;
        const referencedColumns = joinColumns.map((joinColumn)=>joinColumn.referencedColumn);
        if (referencedColumns.length > 1) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$TypeORMError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["TypeORMError"](`Cannot create relation id map for a single value because relation contains multiple referenced columns.`);
        return referencedColumns[0].createValueMap(id);
    }
    /**
     * Extracts column value from the given entity.
     * If column is in embedded (or recursive embedded) it extracts its value from there.
     */ getEntityValue(entity, getLazyRelationsPromiseValue = false) {
        if (entity === null || entity === undefined) return undefined;
        // extract column value from embeddeds of entity if column is in embedded
        if (this.embeddedMetadata) {
            // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
            // we need to get value of "id" column from the post real entity object
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const propertyNames = [
                ...this.embeddedMetadata.parentPropertyNames
            ];
            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters
            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed
            const extractEmbeddedColumnValue = (propertyNames, value)=>{
                const propertyName = propertyNames.shift();
                if (propertyName) {
                    if (value[propertyName]) {
                        return extractEmbeddedColumnValue(propertyNames, value[propertyName]);
                    }
                    return undefined;
                }
                return value;
            };
            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]
            const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);
            if (this.isLazy) {
                if (embeddedObject["__" + this.propertyName + "__"] !== undefined) return embeddedObject["__" + this.propertyName + "__"];
                if (getLazyRelationsPromiseValue === true) return embeddedObject[this.propertyName];
                return undefined;
            }
            return embeddedObject ? embeddedObject[this.isLazy ? "__" + this.propertyName + "__" : this.propertyName] : undefined;
        } else {
            // no embeds - no problems. Simply return column name by property name of the entity
            if (this.isLazy) {
                if (entity["__" + this.propertyName + "__"] !== undefined) return entity["__" + this.propertyName + "__"];
                if (getLazyRelationsPromiseValue === true) return entity[this.propertyName];
                return undefined;
            }
            return entity[this.propertyName];
        }
    }
    /**
     * Sets given entity's relation's value.
     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.
     *
     * If merge is set to true, it merges given value into currently
     */ setEntityValue(entity, value) {
        const propertyName = this.isLazy ? "__" + this.propertyName + "__" : this.propertyName;
        if (this.embeddedMetadata) {
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const extractEmbeddedColumnValue = (embeddedMetadatas, map)=>{
                // if (!object[embeddedMetadata.propertyName])
                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();
                const embeddedMetadata = embeddedMetadatas.shift();
                if (embeddedMetadata) {
                    if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();
                    extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);
                    return map;
                }
                map[propertyName] = value;
                return map;
            };
            return extractEmbeddedColumnValue([
                ...this.embeddedMetadata.embeddedMetadataTree
            ], entity);
        } else {
            entity[propertyName] = value;
        }
    }
    /**
     * Creates entity id map from the given entity ids array.
     */ createValueMap(value) {
        // extract column value from embeds of entity if column is in embedded
        if (this.embeddedMetadata) {
            // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
            // we need to get value of "id" column from the post real entity object and return it in a
            // { data: { information: { counters: { id: ... } } } } format
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const propertyNames = [
                ...this.embeddedMetadata.parentPropertyNames
            ];
            // now need to access post[data][information][counters] to get column value from the counters
            // and on each step we need to create complex literal object, e.g. first { data },
            // then { data: { information } }, then { data: { information: { counters } } },
            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }
            // this recursive function helps doing that
            const extractEmbeddedColumnValue = (propertyNames, map)=>{
                const propertyName = propertyNames.shift();
                if (propertyName) {
                    map[propertyName] = {};
                    extractEmbeddedColumnValue(propertyNames, map[propertyName]);
                    return map;
                }
                map[this.propertyName] = value;
                return map;
            };
            return extractEmbeddedColumnValue(propertyNames, {});
        } else {
            // no embeds - no problems. Simply return column property name and its value of the entity
            return {
                [this.propertyName]: value
            };
        }
    }
    // ---------------------------------------------------------------------
    // Builder Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend relation metadata properties.
     * This builder method should be used only after embedded metadata tree was build.
     */ build() {
        this.propertyPath = this.buildPropertyPath();
    }
    /**
     * Registers given foreign keys in the relation.
     * This builder method should be used to register foreign key in the relation.
     */ registerForeignKeys(...foreignKeys) {
        this.foreignKeys.push(...foreignKeys);
    }
    /**
     * Registers given join columns in the relation.
     * This builder method should be used to register join column in the relation.
     */ registerJoinColumns(joinColumns = [], inverseJoinColumns = []) {
        this.joinColumns = joinColumns;
        this.inverseJoinColumns = inverseJoinColumns;
        this.isOwning = this.isManyToOne || (this.isManyToMany || this.isOneToOne) && this.joinColumns.length > 0;
        this.isOneToOneOwner = this.isOneToOne && this.isOwning;
        this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning;
        this.isManyToManyOwner = this.isManyToMany && this.isOwning;
        this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning;
        this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner;
    }
    /**
     * Registers a given junction entity metadata.
     * This builder method can be called after junction entity metadata for the many-to-many relation was created.
     */ registerJunctionEntityMetadata(junctionEntityMetadata) {
        this.junctionEntityMetadata = junctionEntityMetadata;
        this.joinTableName = junctionEntityMetadata.tableName;
        if (this.inverseRelation) {
            this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;
            this.joinTableName = junctionEntityMetadata.tableName;
        }
    }
    /**
     * Builds inverse side property path based on given inverse side property factory.
     * This builder method should be used only after properties map of the inverse entity metadata was build.
     */ buildInverseSidePropertyPath() {
        if (this.givenInverseSidePropertyFactory) {
            const ownerEntityPropertiesMap = this.inverseEntityMetadata.propertiesMap;
            if (typeof this.givenInverseSidePropertyFactory === "function") return this.givenInverseSidePropertyFactory(ownerEntityPropertiesMap);
            if (typeof this.givenInverseSidePropertyFactory === "string") return this.givenInverseSidePropertyFactory;
        } else if (this.isTreeParent && this.entityMetadata.treeChildrenRelation) {
            return this.entityMetadata.treeChildrenRelation.propertyName;
        } else if (this.isTreeChildren && this.entityMetadata.treeParentRelation) {
            return this.entityMetadata.treeParentRelation.propertyName;
        }
        return "";
    }
    /**
     * Builds relation's property path based on its embedded tree.
     */ buildPropertyPath() {
        if (!this.embeddedMetadata || !this.embeddedMetadata.parentPropertyNames.length) return this.propertyName;
        return this.embeddedMetadata.parentPropertyNames.join(".") + "." + this.propertyName;
    }
} //# sourceMappingURL=RelationMetadata.js.map
}}),
"[project]/node_modules/typeorm/browser/metadata/EmbeddedMetadata.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "EmbeddedMetadata": (()=>EmbeddedMetadata)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$index$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/index.js [middleware-edge] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$TypeORMError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/TypeORMError.js [middleware-edge] (ecmascript)");
;
class EmbeddedMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        /**
         * Columns inside this embed.
         */ this.columns = [];
        /**
         * Relations inside this embed.
         */ this.relations = [];
        /**
         * Entity listeners inside this embed.
         */ this.listeners = [];
        /**
         * Indices applied to the embed columns.
         */ this.indices = [];
        /**
         * Uniques applied to the embed columns.
         */ this.uniques = [];
        /**
         * Relation ids inside this embed.
         */ this.relationIds = [];
        /**
         * Relation counts inside this embed.
         */ this.relationCounts = [];
        /**
         * Nested embeddable in this embeddable (which has current embedded as parent embedded).
         */ this.embeddeds = [];
        /**
         * Indicates if the entity should be instantiated using the constructor
         * or via allocating a new object via `Object.create()`.
         */ this.isAlwaysUsingConstructor = true;
        /**
         * Indicates if this embedded is in array mode.
         *
         * This option works only in mongodb.
         */ this.isArray = false;
        /**
         * Returns array of property names of current embed and all its parent embeds.
         *
         * example: post[data][information][counters].id where "data", "information" and "counters" are embeds
         * we need to get value of "id" column from the post real entity object.
         * this method will return ["data", "information", "counters"]
         */ this.parentPropertyNames = [];
        /**
         * Returns array of prefixes of current embed and all its parent embeds.
         */ this.parentPrefixes = [];
        /**
         * Returns embed metadatas from all levels of the parent tree.
         *
         * example: post[data][information][counters].id where "data", "information" and "counters" are embeds
         * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]
         */ this.embeddedMetadataTree = [];
        /**
         * Embed metadatas from all levels of the parent tree.
         *
         * example: post[data][information][counters].id where "data", "information" and "counters" are embeds
         * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]
         */ this.columnsFromTree = [];
        /**
         * Relations of this embed and all relations from its child embeds.
         */ this.relationsFromTree = [];
        /**
         * Relations of this embed and all relations from its child embeds.
         */ this.listenersFromTree = [];
        /**
         * Indices of this embed and all indices from its child embeds.
         */ this.indicesFromTree = [];
        /**
         * Uniques of this embed and all uniques from its child embeds.
         */ this.uniquesFromTree = [];
        /**
         * Relation ids of this embed and all relation ids from its child embeds.
         */ this.relationIdsFromTree = [];
        /**
         * Relation counts of this embed and all relation counts from its child embeds.
         */ this.relationCountsFromTree = [];
        this.entityMetadata = options.entityMetadata;
        this.type = options.args.type();
        this.propertyName = options.args.propertyName;
        this.customPrefix = options.args.prefix;
        this.isArray = options.args.isArray;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Creates a new embedded object.
     */ create(options) {
        if (!(typeof this.type === "function")) {
            return {};
        }
        if (options?.fromDeserializer || !this.isAlwaysUsingConstructor) {
            return Object.create(this.type.prototype);
        } else {
            return new this.type();
        }
    }
    // ---------------------------------------------------------------------
    // Builder Methods
    // ---------------------------------------------------------------------
    build(connection) {
        this.embeddeds.forEach((embedded)=>embedded.build(connection));
        this.prefix = this.buildPrefix(connection);
        this.parentPropertyNames = this.buildParentPropertyNames();
        this.parentPrefixes = this.buildParentPrefixes();
        this.propertyPath = this.parentPropertyNames.join(".");
        this.embeddedMetadataTree = this.buildEmbeddedMetadataTree();
        this.columnsFromTree = this.buildColumnsFromTree();
        this.relationsFromTree = this.buildRelationsFromTree();
        this.listenersFromTree = this.buildListenersFromTree();
        this.indicesFromTree = this.buildIndicesFromTree();
        this.uniquesFromTree = this.buildUniquesFromTree();
        this.relationIdsFromTree = this.buildRelationIdsFromTree();
        this.relationCountsFromTree = this.buildRelationCountsFromTree();
        if (connection.options.entitySkipConstructor) {
            this.isAlwaysUsingConstructor = !connection.options.entitySkipConstructor;
        }
        return this;
    }
    // ---------------------------------------------------------------------
    // Protected Methods
    // ---------------------------------------------------------------------
    buildPartialPrefix() {
        // if prefix option was not set or explicitly set to true - default prefix
        if (this.customPrefix === undefined || this.customPrefix === true) {
            return [
                this.propertyName
            ];
        }
        // if prefix option was set to empty string or explicity set to false - disable prefix
        if (this.customPrefix === "" || this.customPrefix === false) {
            return [];
        }
        // use custom prefix
        if (typeof this.customPrefix === "string") {
            return [
                this.customPrefix
            ];
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$TypeORMError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["TypeORMError"](`Invalid prefix option given for ${this.entityMetadata.targetName}#${this.propertyName}`);
    }
    buildPrefix(connection) {
        if (connection.driver.options.type === "mongodb") return this.propertyName;
        const prefixes = [];
        if (this.parentEmbeddedMetadata) prefixes.push(this.parentEmbeddedMetadata.buildPrefix(connection));
        prefixes.push(...this.buildPartialPrefix());
        return prefixes.join("_"); // todo: use naming strategy instead of "_"  !!!
    }
    buildParentPropertyNames() {
        return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPropertyNames().concat(this.propertyName) : [
            this.propertyName
        ];
    }
    buildParentPrefixes() {
        return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPrefixes().concat(this.buildPartialPrefix()) : this.buildPartialPrefix();
    }
    buildEmbeddedMetadataTree() {
        return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildEmbeddedMetadataTree().concat(this) : [
            this
        ];
    }
    buildColumnsFromTree() {
        return this.embeddeds.reduce((columns, embedded)=>columns.concat(embedded.buildColumnsFromTree()), this.columns);
    }
    buildRelationsFromTree() {
        return this.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.buildRelationsFromTree()), this.relations);
    }
    buildListenersFromTree() {
        return this.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.buildListenersFromTree()), this.listeners);
    }
    buildIndicesFromTree() {
        return this.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.buildIndicesFromTree()), this.indices);
    }
    buildUniquesFromTree() {
        return this.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.buildUniquesFromTree()), this.uniques);
    }
    buildRelationIdsFromTree() {
        return this.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.buildRelationIdsFromTree()), this.relationIds);
    }
    buildRelationCountsFromTree() {
        return this.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.buildRelationCountsFromTree()), this.relationCounts);
    }
} //# sourceMappingURL=EmbeddedMetadata.js.map
}}),
"[project]/node_modules/typeorm/browser/metadata/RelationIdMetadata.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RelationIdMetadata": (()=>RelationIdMetadata)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$index$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/index.js [middleware-edge] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$TypeORMError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/TypeORMError.js [middleware-edge] (ecmascript)");
;
class RelationIdMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this.entityMetadata = options.entityMetadata;
        this.target = options.args.target;
        this.propertyName = options.args.propertyName;
        this.relationNameOrFactory = options.args.relation;
        this.alias = options.args.alias;
        this.queryBuilderFactory = options.args.queryBuilderFactory;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Sets relation id value from the given entity.
     *
     * todo: make it to work in embeds as well.
     */ setValue(entity) {
        const inverseEntity = this.relation.getEntityValue(entity);
        if (Array.isArray(inverseEntity)) {
            entity[this.propertyName] = inverseEntity.map((item)=>{
                return this.relation.inverseEntityMetadata.getEntityIdMixedMap(item);
            }).filter((item)=>item !== null && item !== undefined);
        } else {
            const value = this.relation.inverseEntityMetadata.getEntityIdMixedMap(inverseEntity);
            if (value !== undefined) entity[this.propertyName] = value;
        }
    }
    // ---------------------------------------------------------------------
    // Public Builder Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend relation id properties.
     * This builder method should be used only after entity metadata, its properties map and all relations are build.
     */ build() {
        const propertyPath = typeof this.relationNameOrFactory === "function" ? this.relationNameOrFactory(this.entityMetadata.propertiesMap) : this.relationNameOrFactory;
        const relation = this.entityMetadata.findRelationWithPropertyPath(propertyPath);
        if (!relation) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$TypeORMError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["TypeORMError"](`Cannot find relation ${propertyPath}. Wrong relation specified for @RelationId decorator.`);
        this.relation = relation;
    }
} //# sourceMappingURL=RelationIdMetadata.js.map
}}),
"[project]/node_modules/typeorm/browser/metadata/RelationCountMetadata.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RelationCountMetadata": (()=>RelationCountMetadata)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$index$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/index.js [middleware-edge] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$TypeORMError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/TypeORMError.js [middleware-edge] (ecmascript)");
;
class RelationCountMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this.entityMetadata = options.entityMetadata;
        this.target = options.args.target;
        this.propertyName = options.args.propertyName;
        this.relationNameOrFactory = options.args.relation;
        this.alias = options.args.alias;
        this.queryBuilderFactory = options.args.queryBuilderFactory;
    }
    // ---------------------------------------------------------------------
    // Public Builder Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend relation count metadata properties.
     * This builder method should be used only after entity metadata, its properties map and all relations are build.
     */ build() {
        const propertyPath = typeof this.relationNameOrFactory === "function" ? this.relationNameOrFactory(this.entityMetadata.propertiesMap) : this.relationNameOrFactory;
        const relation = this.entityMetadata.findRelationWithPropertyPath(propertyPath);
        if (!relation) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$TypeORMError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["TypeORMError"](`Cannot find relation ${propertyPath}. Wrong relation specified for @RelationCount decorator.`);
        this.relation = relation;
    }
} //# sourceMappingURL=RelationCountMetadata.js.map
}}),
"[project]/node_modules/typeorm/browser/metadata/types/EventListenerTypes.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Provides a constants for each entity listener type.
 */ __turbopack_context__.s({
    "EventListenerTypes": (()=>EventListenerTypes)
});
class EventListenerTypes {
}
EventListenerTypes.AFTER_LOAD = "after-load";
EventListenerTypes.BEFORE_INSERT = "before-insert";
EventListenerTypes.AFTER_INSERT = "after-insert";
EventListenerTypes.BEFORE_UPDATE = "before-update";
EventListenerTypes.AFTER_UPDATE = "after-update";
EventListenerTypes.BEFORE_REMOVE = "before-remove";
EventListenerTypes.AFTER_REMOVE = "after-remove";
EventListenerTypes.BEFORE_SOFT_REMOVE = "before-soft-remove";
EventListenerTypes.AFTER_SOFT_REMOVE = "after-soft-remove";
EventListenerTypes.BEFORE_RECOVER = "before-recover";
EventListenerTypes.AFTER_RECOVER = "after-recover"; //# sourceMappingURL=EventListenerTypes.js.map
}}),
"[project]/node_modules/typeorm/browser/metadata/ForeignKeyMetadata.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Contains all information about entity's foreign key.
 */ __turbopack_context__.s({
    "ForeignKeyMetadata": (()=>ForeignKeyMetadata)
});
class ForeignKeyMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        /**
         * Array of columns of this foreign key.
         */ this.columns = [];
        /**
         * Array of referenced columns.
         */ this.referencedColumns = [];
        /**
         * Gets array of column names.
         */ this.columnNames = [];
        /**
         * Gets array of referenced column names.
         */ this.referencedColumnNames = [];
        this.entityMetadata = options.entityMetadata;
        this.referencedEntityMetadata = options.referencedEntityMetadata;
        this.columns = options.columns;
        this.referencedColumns = options.referencedColumns;
        this.onDelete = options.onDelete || "NO ACTION";
        this.onUpdate = options.onUpdate || "NO ACTION";
        this.deferrable = options.deferrable;
        this.givenName = options.name;
        if (options.namingStrategy) this.build(options.namingStrategy);
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend foreign key properties.
     * Must be called after all entity metadatas and their columns are built.
     */ build(namingStrategy) {
        this.columnNames = this.columns.map((column)=>column.databaseName);
        this.referencedColumnNames = this.referencedColumns.map((column)=>column.databaseName);
        this.referencedTablePath = this.referencedEntityMetadata.tablePath;
        this.name = this.givenName ? this.givenName : namingStrategy.foreignKeyName(this.entityMetadata.tableName, this.columnNames, this.referencedEntityMetadata.tableName, this.referencedColumnNames);
    }
} //# sourceMappingURL=ForeignKeyMetadata.js.map
}}),
"[project]/node_modules/typeorm/browser/metadata/UniqueMetadata.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "UniqueMetadata": (()=>UniqueMetadata)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$index$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/index.js [middleware-edge] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$TypeORMError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/browser/error/TypeORMError.js [middleware-edge] (ecmascript)");
;
class UniqueMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        /**
         * Unique columns.
         */ this.columns = [];
        /**
         * Map of column names with order set.
         * Used only by MongoDB driver.
         */ this.columnNamesWithOrderingMap = {};
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        if (options.columns) this.columns = options.columns;
        if (options.args) {
            this.target = options.args.target;
            this.givenName = options.args.name;
            this.givenColumnNames = options.args.columns;
            this.deferrable = options.args.deferrable;
        }
    }
    // ---------------------------------------------------------------------
    // Public Build Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend unique constraint properties.
     * Must be called after all entity metadata's properties map, columns and relations are built.
     */ build(namingStrategy) {
        const map = {};
        // if columns already an array of string then simply return it
        if (this.givenColumnNames) {
            let columnPropertyPaths = [];
            if (Array.isArray(this.givenColumnNames)) {
                columnPropertyPaths = this.givenColumnNames.map((columnName)=>{
                    if (this.embeddedMetadata) return this.embeddedMetadata.propertyPath + "." + columnName;
                    return columnName.trim();
                });
                columnPropertyPaths.forEach((propertyPath)=>map[propertyPath] = 1);
            } else {
                // if columns is a function that returns array of field names then execute it and get columns names from it
                const columnsFnResult = this.givenColumnNames(this.entityMetadata.propertiesMap);
                if (Array.isArray(columnsFnResult)) {
                    columnPropertyPaths = columnsFnResult.map((i)=>String(i));
                    columnPropertyPaths.forEach((name)=>map[name] = 1);
                } else {
                    columnPropertyPaths = Object.keys(columnsFnResult).map((i)=>String(i));
                    Object.keys(columnsFnResult).forEach((columnName)=>map[columnName] = columnsFnResult[columnName]);
                }
            }
            this.columns = columnPropertyPaths.map((propertyName)=>{
                const columnWithSameName = this.entityMetadata.columns.find((column)=>column.propertyPath === propertyName);
                if (columnWithSameName) {
                    return [
                        columnWithSameName
                    ];
                }
                const relationWithSameName = this.entityMetadata.relations.find((relation)=>relation.isWithJoinColumn && relation.propertyName === propertyName);
                if (relationWithSameName) {
                    return relationWithSameName.joinColumns;
                }
                const indexName = this.givenName ? '"' + this.givenName + '" ' : "";
                const entityName = this.entityMetadata.targetName;
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$browser$2f$error$2f$TypeORMError$2e$js__$5b$middleware$2d$edge$5d$__$28$ecmascript$29$__["TypeORMError"](`Unique constraint ${indexName}contains column that is missing in the entity (${entityName}): ` + propertyName);
            }).reduce((a, b)=>a.concat(b));
        }
        this.columnNamesWithOrderingMap = Object.keys(map).reduce((updatedMap, key)=>{
            const column = this.entityMetadata.columns.find((column)=>column.propertyPath === key);
            if (column) updatedMap[column.databasePath] = map[key];
            return updatedMap;
        }, {});
        this.name = this.givenName ? this.givenName : namingStrategy.uniqueConstraintName(this.entityMetadata.tableName, this.columns.map((column)=>column.databaseName));
        return this;
    }
} //# sourceMappingURL=UniqueMetadata.js.map
}}),
"[project]/node_modules/typeorm/browser/metadata/EntityListenerMetadata.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * This metadata contains all information about entity's listeners.
 */ __turbopack_context__.s({
    "EntityListenerMetadata": (()=>EntityListenerMetadata)
});
class EntityListenerMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        this.target = options.args.target;
        this.propertyName = options.args.propertyName;
        this.type = options.args.type;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Checks if entity listener is allowed to be executed on the given entity.
     */ isAllowed(entity) {
        // todo: create in entity metadata method like isInherited?
        return this.entityMetadata.target === entity.constructor || typeof this.entityMetadata.target === "function" && entity.constructor.prototype instanceof this.entityMetadata.target; // todo: also need to implement entity schema inheritance
    }
    /**
     * Executes listener method of the given entity.
     */ execute(entity) {
        // Check if the Embedded Metadata does not exist
        if (!this.embeddedMetadata) {
            // Get the Entity's Method
            const entityMethod = entity[this.propertyName];
            // Check if the Entity Method does not exist
            if (!entityMethod) throw new Error(`Entity listener method "${this.propertyName}" does not exist in entity "${entity.constructor.name}".`);
            // Check if the Entity Method is not a function
            if (typeof entityMethod !== "function") throw new Error(`Entity listener method "${this.propertyName}" in entity "${entity.constructor.name}" must be a function but got "${typeof entityMethod}".`);
            // Call and return the Entity Method
            return entityMethod.call(entity);
        }
        // Call the Embedded Method
        this.callEntityEmbeddedMethod(entity, this.embeddedMetadata.propertyPath.split("."));
    }
    // ---------------------------------------------------------------------
    // Protected Methods
    // ---------------------------------------------------------------------
    /**
     * Calls embedded entity listener method no matter how nested it is.
     */ callEntityEmbeddedMethod(entity, propertyPaths) {
        const propertyPath = propertyPaths.shift();
        if (!propertyPath || !entity[propertyPath]) return;
        if (propertyPaths.length === 0) {
            if (Array.isArray(entity[propertyPath])) {
                entity[propertyPath].map((embedded)=>embedded[this.propertyName]());
            } else {
                entity[propertyPath][this.propertyName]();
            }
        } else {
            if (entity[propertyPath]) this.callEntityEmbeddedMethod(entity[propertyPath], propertyPaths);
        }
    }
} //# sourceMappingURL=EntityListenerMetadata.js.map
}}),
"[project]/node_modules/typeorm/browser/metadata/CheckMetadata.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Check metadata contains all information about table's check constraints.
 */ __turbopack_context__.s({
    "CheckMetadata": (()=>CheckMetadata)
});
class CheckMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this.entityMetadata = options.entityMetadata;
        if (options.args) {
            this.target = options.args.target;
            this.expression = options.args.expression;
            this.givenName = options.args.name;
        }
    }
    // ---------------------------------------------------------------------
    // Public Build Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend check constraint properties.
     * Must be called after all entity metadata's properties map, columns and relations are built.
     */ build(namingStrategy) {
        this.name = this.givenName ? this.givenName : namingStrategy.checkConstraintName(this.entityMetadata.tableName, this.expression);
        return this;
    }
} //# sourceMappingURL=CheckMetadata.js.map
}}),
"[project]/node_modules/typeorm/browser/metadata/ExclusionMetadata.js [middleware-edge] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Exclusion metadata contains all information about table's exclusion constraints.
 */ __turbopack_context__.s({
    "ExclusionMetadata": (()=>ExclusionMetadata)
});
class ExclusionMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this.entityMetadata = options.entityMetadata;
        if (options.args) {
            this.target = options.args.target;
            this.expression = options.args.expression;
            this.givenName = options.args.name;
        }
    }
    // ---------------------------------------------------------------------
    // Public Build Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend exclusion constraint properties.
     * Must be called after all entity metadata's properties map, columns and relations are built.
     */ build(namingStrategy) {
        this.name = this.givenName ? this.givenName : namingStrategy.exclusionConstraintName(this.entityMetadata.tableName, this.expression);
        return this;
    }
} //# sourceMappingURL=ExclusionMetadata.js.map
}}),
}]);

//# sourceMappingURL=node_modules_typeorm_browser_metadata_d59433ab._.js.map