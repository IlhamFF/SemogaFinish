module.exports = {

"[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DriverUtils = void 0;
const StringUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/StringUtils.js [app-route] (ecmascript)");
const VersionUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/VersionUtils.js [app-route] (ecmascript)");
/**
 * Common driver utility functions.
 */ class DriverUtils {
    // -------------------------------------------------------------------------
    // Public Static Methods
    // -------------------------------------------------------------------------
    /**
     * Returns true if given driver is SQLite-based driver.
     */ static isSQLiteFamily(driver) {
        return [
            "sqlite",
            "cordova",
            "react-native",
            "nativescript",
            "sqljs",
            "expo",
            "better-sqlite3",
            "capacitor"
        ].includes(driver.options.type);
    }
    /**
     * Returns true if given driver is MySQL-based driver.
     */ static isMySQLFamily(driver) {
        return [
            "mysql",
            "mariadb"
        ].includes(driver.options.type);
    }
    static isReleaseVersionOrGreater(driver, version) {
        return VersionUtils_1.VersionUtils.isGreaterOrEqual(driver.version, version);
    }
    static isPostgresFamily(driver) {
        return [
            "postgres",
            "aurora-postgres",
            "cockroachdb"
        ].includes(driver.options.type);
    }
    /**
     * Normalizes and builds a new driver options.
     * Extracts settings from connection url and sets to a new options object.
     */ static buildDriverOptions(options, buildOptions) {
        if (options.url) {
            const urlDriverOptions = this.parseConnectionUrl(options.url);
            if (buildOptions && buildOptions.useSid && urlDriverOptions.database) {
                urlDriverOptions.sid = urlDriverOptions.database;
            }
            for (const key of Object.keys(urlDriverOptions)){
                if (typeof urlDriverOptions[key] === "undefined") {
                    delete urlDriverOptions[key];
                }
            }
            return Object.assign({}, options, urlDriverOptions);
        }
        return Object.assign({}, options);
    }
    /**
     * buildDriverOptions for MongodDB only to support replica set
     */ static buildMongoDBDriverOptions(options, buildOptions) {
        if (options.url) {
            const urlDriverOptions = this.parseMongoDBConnectionUrl(options.url);
            if (buildOptions && buildOptions.useSid && urlDriverOptions.database) {
                urlDriverOptions.sid = urlDriverOptions.database;
            }
            for (const key of Object.keys(urlDriverOptions)){
                if (typeof urlDriverOptions[key] === "undefined") {
                    delete urlDriverOptions[key];
                }
            }
            return Object.assign({}, options, urlDriverOptions);
        }
        return Object.assign({}, options);
    }
    /**
     * Joins and shortens alias if needed.
     *
     * If the alias length is greater than the limit allowed by the current
     * driver, replaces it with a shortend string, if the shortend string
     * is still too long, it will then hash the alias.
     *
     * @param driver Current `Driver`.
     * @param buildOptions Optional settings.
     * @param alias Alias parts.
     *
     * @return An alias that is no longer than the divers max alias length.
     */ static buildAlias({ maxAliasLength }, buildOptions, ...alias) {
        const joiner = buildOptions && buildOptions.joiner ? buildOptions.joiner : "_";
        const newAlias = alias.length === 1 ? alias[0] : alias.join(joiner);
        if (maxAliasLength && maxAliasLength > 0 && newAlias.length > maxAliasLength) {
            if (buildOptions && buildOptions.shorten === true) {
                const shortenedAlias = (0, StringUtils_1.shorten)(newAlias);
                if (shortenedAlias.length < maxAliasLength) {
                    return shortenedAlias;
                }
            }
            return (0, StringUtils_1.hash)(newAlias, {
                length: maxAliasLength
            });
        }
        return newAlias;
    }
    /**
     * @deprecated use `buildAlias` instead.
     */ static buildColumnAlias({ maxAliasLength }, buildOptions, ...alias) {
        if (typeof buildOptions === "string") {
            alias.unshift(buildOptions);
            buildOptions = {
                shorten: false,
                joiner: "_"
            };
        } else {
            buildOptions = Object.assign({
                shorten: false,
                joiner: "_"
            }, buildOptions);
        }
        return this.buildAlias({
            maxAliasLength
        }, buildOptions, ...alias);
    }
    // -------------------------------------------------------------------------
    // Private Static Methods
    // -------------------------------------------------------------------------
    /**
     * Extracts connection data from the connection url.
     */ static parseConnectionUrl(url) {
        const type = url.split(":")[0];
        const firstSlashes = url.indexOf("//");
        const preBase = url.substr(firstSlashes + 2);
        const secondSlash = preBase.indexOf("/");
        const base = secondSlash !== -1 ? preBase.substr(0, secondSlash) : preBase;
        let afterBase = secondSlash !== -1 ? preBase.substr(secondSlash + 1) : undefined;
        // remove mongodb query params
        if (afterBase && afterBase.indexOf("?") !== -1) {
            afterBase = afterBase.substr(0, afterBase.indexOf("?"));
        }
        const lastAtSign = base.lastIndexOf("@");
        const usernameAndPassword = base.substr(0, lastAtSign);
        const hostAndPort = base.substr(lastAtSign + 1);
        let username = usernameAndPassword;
        let password = "";
        const firstColon = usernameAndPassword.indexOf(":");
        if (firstColon !== -1) {
            username = usernameAndPassword.substr(0, firstColon);
            password = usernameAndPassword.substr(firstColon + 1);
        }
        const [host, port] = hostAndPort.split(":");
        return {
            type: type,
            host: host,
            username: decodeURIComponent(username),
            password: decodeURIComponent(password),
            port: port ? parseInt(port) : undefined,
            database: afterBase || undefined
        };
    }
    /**
     * Extracts connection data from the connection url for MongoDB to support replica set.
     */ static parseMongoDBConnectionUrl(url) {
        const type = url.split(":")[0];
        const firstSlashes = url.indexOf("//");
        const preBase = url.substr(firstSlashes + 2);
        const secondSlash = preBase.indexOf("/");
        const base = secondSlash !== -1 ? preBase.substr(0, secondSlash) : preBase;
        let afterBase = secondSlash !== -1 ? preBase.substr(secondSlash + 1) : undefined;
        let afterQuestionMark = "";
        let host = undefined;
        let port = undefined;
        let hostReplicaSet = undefined;
        let replicaSet = undefined;
        const optionsObject = {};
        if (afterBase && afterBase.indexOf("?") !== -1) {
            // split params
            afterQuestionMark = afterBase.substr(afterBase.indexOf("?") + 1, afterBase.length);
            const optionsList = afterQuestionMark.split("&");
            let optionKey;
            let optionValue;
            // create optionsObject for merge with connectionUrl object before return
            optionsList.forEach((optionItem)=>{
                optionKey = optionItem.split("=")[0];
                optionValue = optionItem.split("=")[1];
                optionsObject[optionKey] = optionValue;
            });
            // specific replicaSet value to set options about hostReplicaSet
            replicaSet = optionsObject["replicaSet"];
            afterBase = afterBase.substr(0, afterBase.indexOf("?"));
        }
        const lastAtSign = base.lastIndexOf("@");
        const usernameAndPassword = base.substr(0, lastAtSign);
        const hostAndPort = base.substr(lastAtSign + 1);
        let username = usernameAndPassword;
        let password = "";
        const firstColon = usernameAndPassword.indexOf(":");
        if (firstColon !== -1) {
            username = usernameAndPassword.substr(0, firstColon);
            password = usernameAndPassword.substr(firstColon + 1);
        }
        // If replicaSet have value set It as hostlist, If not set like standalone host
        if (replicaSet) {
            hostReplicaSet = hostAndPort;
        } else {
            ;
            [host, port] = hostAndPort.split(":");
        }
        const connectionUrl = {
            type: type,
            host: host,
            hostReplicaSet: hostReplicaSet,
            username: decodeURIComponent(username),
            password: decodeURIComponent(password),
            port: port ? parseInt(port) : undefined,
            database: afterBase || undefined
        };
        // Loop to set every options in connectionUrl to object
        for (const [key, value] of Object.entries(optionsObject)){
            connectionUrl[key] = value;
        }
        return connectionUrl;
    }
}
exports.DriverUtils = DriverUtils; //# sourceMappingURL=DriverUtils.js.map
}}),
"[project]/node_modules/typeorm/driver/Query.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Query = void 0;
/**
 * This class stores query and its parameters
 */ class Query {
    constructor(query, parameters){
        this.query = query;
        this.parameters = parameters;
        this["@instanceof"] = Symbol.for("Query");
    }
}
exports.Query = Query; //# sourceMappingURL=Query.js.map
}}),
"[project]/node_modules/typeorm/driver/SqlInMemory.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SqlInMemory = void 0;
/**
 * This class stores up and down queries needed for migrations functionality.
 */ class SqlInMemory {
    constructor(){
        this.upQueries = [];
        this.downQueries = [];
    }
}
exports.SqlInMemory = SqlInMemory; //# sourceMappingURL=SqlInMemory.js.map
}}),
"[project]/node_modules/typeorm/driver/types/MetadataTableType.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MetadataTableType = void 0;
var MetadataTableType;
(function(MetadataTableType) {
    MetadataTableType["VIEW"] = "VIEW";
    MetadataTableType["MATERIALIZED_VIEW"] = "MATERIALIZED_VIEW";
    MetadataTableType["GENERATED_COLUMN"] = "GENERATED_COLUMN";
})(MetadataTableType || (exports.MetadataTableType = MetadataTableType = {})); //# sourceMappingURL=MetadataTableType.js.map
}}),
"[project]/node_modules/typeorm/driver/types/DatabaseType.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=DatabaseType.js.map
}}),
"[project]/node_modules/typeorm/driver/types/GeoJsonTypes.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=GeoJsonTypes.js.map
}}),
"[project]/node_modules/typeorm/driver/types/ReplicationMode.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=ReplicationMode.js.map
}}),
"[project]/node_modules/typeorm/driver/mongodb/MongoQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MongoQueryRunner = void 0;
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Runs queries on a single MongoDB connection.
 */ class MongoQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection, databaseConnection){
        /**
         * Indicates if connection for this query runner is released.
         * Once its released, query runner cannot run queries anymore.
         * Always false for mongodb since mongodb has a single query executor instance.
         */ this.isReleased = false;
        /**
         * Indicates if transaction is active in this query executor.
         * Always false for mongodb since mongodb does not support transactions.
         */ this.isTransactionActive = false;
        /**
         * Stores temporarily user data.
         * Useful for sharing data with subscribers.
         */ this.data = {};
        this.connection = connection;
        this.databaseConnection = databaseConnection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Called before migrations are run.
     */ async beforeMigration() {
    // Do nothing
    }
    /**
     * Called after migrations are run.
     */ async afterMigration() {
    // Do nothing
    }
    /**
     * Creates a cursor for a query that can be used to iterate over results from MongoDB.
     */ cursor(collectionName, filter) {
        return this.getCollection(collectionName).find(filter || {});
    }
    /**
     * Execute an aggregation framework pipeline against the collection.
     */ aggregate(collectionName, pipeline, options) {
        return this.getCollection(collectionName).aggregate(pipeline, options || {});
    }
    /**
     * Perform a bulkWrite operation without a fluent API.
     */ async bulkWrite(collectionName, operations, options) {
        return await this.getCollection(collectionName).bulkWrite(operations, options || {});
    }
    /**
     * Count number of matching documents in the db to a query.
     */ async count(collectionName, filter, options) {
        return this.getCollection(collectionName).count(filter || {}, options || {});
    }
    /**
     * Count number of matching documents in the db to a query.
     */ async countDocuments(collectionName, filter, options) {
        return this.getCollection(collectionName).countDocuments(filter || {}, options || {});
    }
    /**
     * Creates an index on the db and collection.
     */ async createCollectionIndex(collectionName, indexSpec, options) {
        return this.getCollection(collectionName).createIndex(indexSpec, options || {});
    }
    /**
     * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.
     * Earlier version of MongoDB will throw a command not supported error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
     */ async createCollectionIndexes(collectionName, indexSpecs) {
        return this.getCollection(collectionName).createIndexes(indexSpecs);
    }
    /**
     * Delete multiple documents on MongoDB.
     */ async deleteMany(collectionName, filter, options) {
        return this.getCollection(collectionName).deleteMany(filter, options || {});
    }
    /**
     * Delete a document on MongoDB.
     */ async deleteOne(collectionName, filter, options) {
        return this.getCollection(collectionName).deleteOne(filter, options || {});
    }
    /**
     * The distinct command returns returns a list of distinct values for the given key across a collection.
     */ async distinct(collectionName, key, filter, options) {
        return this.getCollection(collectionName).distinct(key, filter, options || {});
    }
    /**
     * Drops an index from this collection.
     */ async dropCollectionIndex(collectionName, indexName, options) {
        return this.getCollection(collectionName).dropIndex(indexName, options || {});
    }
    /**
     * Drops all indexes from the collection.
     */ async dropCollectionIndexes(collectionName) {
        return this.getCollection(collectionName).dropIndexes();
    }
    /**
     * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
     */ async findOneAndDelete(collectionName, filter, options) {
        return this.getCollection(collectionName).findOneAndDelete(filter, options || {});
    }
    /**
     * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
     */ async findOneAndReplace(collectionName, filter, replacement, options) {
        return this.getCollection(collectionName).findOneAndReplace(filter, replacement, options || {});
    }
    /**
     * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
     */ async findOneAndUpdate(collectionName, filter, update, options) {
        return this.getCollection(collectionName).findOneAndUpdate(filter, update, options || {});
    }
    /**
     * Retrieve all the indexes on the collection.
     */ async collectionIndexes(collectionName) {
        return this.getCollection(collectionName).indexes();
    }
    /**
     * Retrieve all the indexes on the collection.
     */ async collectionIndexExists(collectionName, indexes) {
        return this.getCollection(collectionName).indexExists(indexes);
    }
    /**
     * Retrieves this collections index info.
     */ async collectionIndexInformation(collectionName, options) {
        return this.getCollection(collectionName).indexInformation(options || {});
    }
    /**
     * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
     */ initializeOrderedBulkOp(collectionName, options) {
        return this.getCollection(collectionName).initializeOrderedBulkOp(options);
    }
    /**
     * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
     */ initializeUnorderedBulkOp(collectionName, options) {
        return this.getCollection(collectionName).initializeUnorderedBulkOp(options);
    }
    /**
     * Inserts an array of documents into MongoDB.
     */ async insertMany(collectionName, docs, options) {
        return this.getCollection(collectionName).insertMany(docs, options || {});
    }
    /**
     * Inserts a single document into MongoDB.
     */ async insertOne(collectionName, doc, options) {
        return this.getCollection(collectionName).insertOne(doc, options || {});
    }
    /**
     * Returns if the collection is a capped collection.
     */ async isCapped(collectionName) {
        return this.getCollection(collectionName).isCapped();
    }
    /**
     * Get the list of all indexes information for the collection.
     */ listCollectionIndexes(collectionName, options) {
        return this.getCollection(collectionName).listIndexes(options);
    }
    /**
     * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
     */ async rename(collectionName, newName, options) {
        return this.getCollection(collectionName).rename(newName, options || {});
    }
    /**
     * Replace a document on MongoDB.
     */ async replaceOne(collectionName, filter, replacement, options) {
        return this.getCollection(collectionName).replaceOne(filter, replacement, options || {});
    }
    /**
     * Get all the collection statistics.
     */ async stats(collectionName, options) {
        return this.getCollection(collectionName).stats(options || {});
    }
    /**
     * Watching new changes as stream.
     */ watch(collectionName, pipeline, options) {
        return this.getCollection(collectionName).watch(pipeline, options);
    }
    /**
     * Update multiple documents on MongoDB.
     */ async updateMany(collectionName, filter, update, options) {
        return this.getCollection(collectionName).updateMany(filter, update, options || {});
    }
    /**
     * Update a single document on MongoDB.
     */ async updateOne(collectionName, filter, update, options) {
        return await this.getCollection(collectionName).updateOne(filter, update, options || {});
    }
    // -------------------------------------------------------------------------
    // Public Implemented Methods (from QueryRunner)
    // -------------------------------------------------------------------------
    /**
     * Removes all collections from the currently connected database.
     * Be careful with using this method and avoid using it in production or migrations
     * (because it can clear all your database).
     */ async clearDatabase() {
        await this.databaseConnection.db(this.connection.driver.database).dropDatabase();
    }
    /**
     * For MongoDB database we don't create connection, because its single connection already created by a driver.
     */ async connect() {}
    /**
     * For MongoDB database we don't release connection, because its single connection.
     */ async release() {
    // releasing connection are not supported by mongodb driver, so simply don't do anything here
    }
    /**
     * Starts transaction.
     */ async startTransaction() {
    // transactions are not supported by mongodb driver, so simply don't do anything here
    }
    /**
     * Commits transaction.
     */ async commitTransaction() {
    // transactions are not supported by mongodb driver, so simply don't do anything here
    }
    /**
     * Rollbacks transaction.
     */ async rollbackTransaction() {
    // transactions are not supported by mongodb driver, so simply don't do anything here
    }
    /**
     * Executes a given SQL query.
     */ query(query, parameters) {
        throw new error_1.TypeORMError(`Executing SQL query is not supported by MongoDB driver.`);
    }
    /**
     * Unsupported - Executing SQL query is not supported by MongoDB driver.
     */ async sql(strings, ...values) {
        throw new error_1.TypeORMError(`Executing SQL query is not supported by MongoDB driver.`);
    }
    /**
     * Returns raw data stream.
     */ stream(query, parameters, onEnd, onError) {
        throw new error_1.TypeORMError(`Stream is not supported by MongoDB driver. Use watch instead.`);
    }
    /**
     * Insert a new row with given values into the given table.
     * Returns value of inserted object id.

    async insert(collectionName: string, keyValues: ObjectLiteral): Promise<any> { // todo: fix any
        const results = await this.databaseConnection
            .collection(collectionName)
            .insertOne(keyValues);
        const generatedMap = this.connection.getMetadata(collectionName).objectIdColumn!.createValueMap(results.insertedId);
        return {
            result: results,
            generatedMap: generatedMap
        };
    }*/ /**
     * Updates rows that match given conditions in the given table.

    async update(collectionName: string, valuesMap: ObjectLiteral, conditions: ObjectLiteral): Promise<any> { // todo: fix any
        await this.databaseConnection
            .collection(collectionName)
            .updateOne(conditions, valuesMap);
    }*/ /**
     * Deletes from the given table by a given conditions.

    async delete(collectionName: string, conditions: ObjectLiteral|ObjectLiteral[]|string, maybeParameters?: any[]): Promise<any> { // todo: fix any
        if (typeof conditions === "string")
            throw new TypeORMError(`String condition is not supported by MongoDB driver.`);

        await this.databaseConnection
            .collection(collectionName)
            .deleteOne(conditions);
    }*/ /**
     * Returns all available database names including system databases.
     */ async getDatabases() {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Returns all available schema names including system schemas.
     * If database parameter specified, returns schemas of that database.
     */ async getSchemas(database) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Loads given table's data from the database.
     */ async getTable(collectionName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Loads all tables (with given names) from the database and creates a Table from them.
     */ async getTables(collectionNames) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Loads given views's data from the database.
     */ async getView(collectionName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Loads all views (with given names) from the database and creates a Table from them.
     */ async getViews(collectionNames) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    getReplicationMode() {
        return "master";
    }
    /**
     * Checks if database with the given name exist.
     */ async hasDatabase(database) {
        throw new error_1.TypeORMError(`Check database queries are not supported by MongoDB driver.`);
    }
    /**
     * Loads currently using database
     */ async getCurrentDatabase() {
        throw new error_1.TypeORMError(`Check database queries are not supported by MongoDB driver.`);
    }
    /**
     * Checks if schema with the given name exist.
     */ async hasSchema(schema) {
        throw new error_1.TypeORMError(`Check schema queries are not supported by MongoDB driver.`);
    }
    /**
     * Loads currently using database schema
     */ async getCurrentSchema() {
        throw new error_1.TypeORMError(`Check schema queries are not supported by MongoDB driver.`);
    }
    /**
     * Checks if table with the given name exist in the database.
     */ async hasTable(collectionName) {
        throw new error_1.TypeORMError(`Check schema queries are not supported by MongoDB driver.`);
    }
    /**
     * Checks if column with the given name exist in the given table.
     */ async hasColumn(tableOrName, columnName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a database if it's not created.
     */ async createDatabase(database) {
        throw new error_1.TypeORMError(`Database create queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops database.
     */ async dropDatabase(database, ifExist) {
        throw new error_1.TypeORMError(`Database drop queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new table schema.
     */ async createSchema(schemaPath, ifNotExist) {
        throw new error_1.TypeORMError(`Schema create queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops table schema.
     */ async dropSchema(schemaPath, ifExist) {
        throw new error_1.TypeORMError(`Schema drop queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new table from the given table and columns inside it.
     */ async createTable(table) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops the table.
     */ async dropTable(tableName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new view.
     */ async createView(view) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops the view.
     */ async dropView(target) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Renames the given table.
     */ async renameTable(oldTableOrName, newTableOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new column from the column in the table.
     */ async addColumn(tableOrName, column) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new columns from the column in the table.
     */ async addColumns(tableOrName, columns) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Renames column in the given table.
     */ async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Changes a column in the table.
     */ async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Changes a column in the table.
     */ async changeColumns(tableOrName, changedColumns) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops column in the table.
     */ async dropColumn(tableOrName, columnOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops the columns in the table.
     */ async dropColumns(tableOrName, columns) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new primary key.
     */ async createPrimaryKey(tableOrName, columnNames) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Updates composite primary keys.
     */ async updatePrimaryKeys(tableOrName, columns) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops a primary key.
     */ async dropPrimaryKey(tableOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new unique constraint.
     */ async createUniqueConstraint(tableOrName, uniqueConstraint) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new unique constraints.
     */ async createUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops an unique constraint.
     */ async dropUniqueConstraint(tableOrName, uniqueOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops an unique constraints.
     */ async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new check constraint.
     */ async createCheckConstraint(tableOrName, checkConstraint) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new check constraints.
     */ async createCheckConstraints(tableOrName, checkConstraints) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops check constraint.
     */ async dropCheckConstraint(tableOrName, checkOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops check constraints.
     */ async dropCheckConstraints(tableOrName, checkConstraints) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new exclusion constraint.
     */ async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new exclusion constraints.
     */ async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops exclusion constraint.
     */ async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops exclusion constraints.
     */ async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new foreign key.
     */ async createForeignKey(tableOrName, foreignKey) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new foreign keys.
     */ async createForeignKeys(tableOrName, foreignKeys) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops a foreign key from the table.
     */ async dropForeignKey(tableOrName, foreignKey) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops a foreign keys from the table.
     */ async dropForeignKeys(tableOrName, foreignKeys) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new index.
     */ async createIndex(tableOrName, index) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Creates a new indices
     */ async createIndices(tableOrName, indices) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops an index from the table.
     */ async dropIndex(collectionName, indexName) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops an indices from the table.
     */ async dropIndices(tableOrName, indices) {
        throw new error_1.TypeORMError(`Schema update queries are not supported by MongoDB driver.`);
    }
    /**
     * Drops collection.
     */ async clearTable(collectionName) {
        await this.databaseConnection.db(this.connection.driver.database).dropCollection(collectionName);
    }
    /**
     * Enables special query runner mode in which sql queries won't be executed,
     * instead they will be memorized into a special variable inside query runner.
     * You can get memorized sql using getMemorySql() method.
     */ enableSqlMemory() {
        throw new error_1.TypeORMError(`This operation is not supported by MongoDB driver.`);
    }
    /**
     * Disables special query runner mode in which sql queries won't be executed
     * started by calling enableSqlMemory() method.
     *
     * Previously memorized sql will be flushed.
     */ disableSqlMemory() {
        throw new error_1.TypeORMError(`This operation is not supported by MongoDB driver.`);
    }
    /**
     * Flushes all memorized sqls.
     */ clearSqlMemory() {
        throw new error_1.TypeORMError(`This operation is not supported by MongoDB driver.`);
    }
    /**
     * Gets sql stored in the memory. Parameters in the sql are already replaced.
     */ getMemorySql() {
        throw new error_1.TypeORMError(`This operation is not supported by MongoDB driver.`);
    }
    /**
     * Executes up sql queries.
     */ async executeMemoryUpSql() {
        throw new error_1.TypeORMError(`This operation is not supported by MongoDB driver.`);
    }
    /**
     * Executes down sql queries.
     */ async executeMemoryDownSql() {
        throw new error_1.TypeORMError(`This operation is not supported by MongoDB driver.`);
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Gets collection from the database with a given name.
     */ getCollection(collectionName) {
        return this.databaseConnection.db(this.connection.driver.database).collection(collectionName);
    }
    /**
     * Change table comment.
     */ changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`mongodb driver does not support change table comment.`);
    }
}
exports.MongoQueryRunner = MongoQueryRunner; //# sourceMappingURL=MongoQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/mongodb/MongoDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MongoDriver = void 0;
const ConnectionIsNotSetError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/ConnectionIsNotSetError.js [app-route] (ecmascript)");
const DriverPackageNotInstalledError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/DriverPackageNotInstalledError.js [app-route] (ecmascript)");
const MongoQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/mongodb/MongoQueryRunner.js [app-route] (ecmascript)");
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const MongoSchemaBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/MongoSchemaBuilder.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const ApplyValueTransformers_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Organizes communication with MongoDB.
 */ class MongoDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        this.connection = connection;
        /**
         * Indicates if replication is enabled.
         */ this.isReplicated = false;
        /**
         * Indicates if tree tables are supported by this driver.
         */ this.treeSupport = false;
        /**
         * Represent transaction support by this driver
         */ this.transactionSupport = "none";
        /**
         * Mongodb does not need to have column types because they are not used in schema sync.
         */ this.supportedDataTypes = [];
        /**
         * Gets list of spatial column data types.
         */ this.spatialTypes = [];
        /**
         * Gets list of column data types that support length by a driver.
         */ this.withLengthColumnTypes = [];
        /**
         * Gets list of column data types that support precision by a driver.
         */ this.withPrecisionColumnTypes = [];
        /**
         * Gets list of column data types that support scale by a driver.
         */ this.withScaleColumnTypes = [];
        /**
         * Mongodb does not need to have a strong defined mapped column types because they are not used in schema sync.
         */ this.mappedDataTypes = {
            createDate: "int",
            createDateDefault: "",
            updateDate: "int",
            updateDateDefault: "",
            deleteDate: "int",
            deleteDateNullable: true,
            version: "int",
            treeLevel: "int",
            migrationId: "int",
            migrationName: "int",
            migrationTimestamp: "int",
            cacheId: "int",
            cacheIdentifier: "int",
            cacheTime: "int",
            cacheDuration: "int",
            cacheQuery: "int",
            cacheResult: "int",
            metadataType: "int",
            metadataDatabase: "int",
            metadataSchema: "int",
            metadataTable: "int",
            metadataName: "int",
            metadataValue: "int"
        };
        this.cteCapabilities = {
            enabled: false
        };
        // -------------------------------------------------------------------------
        // Protected Properties
        // -------------------------------------------------------------------------
        /**
         * Valid mongo connection options
         * NOTE: Keep in sync with MongoConnectionOptions
         */ this.validOptionNames = [
            "appName",
            "authMechanism",
            "authSource",
            "autoEncryption",
            "checkServerIdentity",
            "compressors",
            "connectTimeoutMS",
            "directConnection",
            "family",
            "forceServerObjectId",
            "ignoreUndefined",
            "keepAlive",
            "keepAliveInitialDelay",
            "localThresholdMS",
            "maxStalenessSeconds",
            "minPoolSize",
            "monitorCommands",
            "noDelay",
            "pkFactory",
            "promoteBuffers",
            "promoteLongs",
            "promoteValues",
            "raw",
            "readConcern",
            "readPreference",
            "readPreferenceTags",
            "replicaSet",
            "retryWrites",
            "serializeFunctions",
            "socketTimeoutMS",
            "ssl",
            "sslCA",
            "sslCRL",
            "sslCert",
            "sslKey",
            "sslPass",
            "sslValidate",
            "tls",
            "tlsAllowInvalidCertificates",
            "tlsCAFile",
            "tlsCertificateKeyFile",
            "tlsCertificateKeyFilePassword",
            "w",
            "writeConcern",
            "wtimeoutMS",
            // Undocumented deprecated options
            // todo: remove next major version
            "appname",
            "fsync",
            "j",
            "useNewUrlParser",
            "useUnifiedTopology",
            "wtimeout"
        ];
        this.options = connection.options;
        // validate options to make sure everything is correct and driver will be able to establish connection
        this.validateOptions(connection.options);
        // load mongodb package
        this.loadDependencies();
        this.database = DriverUtils_1.DriverUtils.buildMongoDBDriverOptions(this.options).database;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Performs connection to the database.
     */ async connect() {
        const options = DriverUtils_1.DriverUtils.buildMongoDBDriverOptions(this.options);
        const client = await this.mongodb.MongoClient.connect(this.buildConnectionUrl(options), this.buildConnectionOptions(options));
        this.queryRunner = new MongoQueryRunner_1.MongoQueryRunner(this.connection, client);
        ObjectUtils_1.ObjectUtils.assign(this.queryRunner, {
            manager: this.connection.manager
        });
    }
    afterConnect() {
        return Promise.resolve();
    }
    /**
     * Closes connection with the database.
     */ async disconnect() {
        if (!this.queryRunner) throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("mongodb");
        // const handler = (err: any) => (err ? fail(err) : ok())
        this.queryRunner.databaseConnection.close();
        this.queryRunner = undefined;
    // return ok()
    }
    /**
     * Creates a schema builder used to build and sync a schema.
     */ createSchemaBuilder() {
        return new MongoSchemaBuilder_1.MongoSchemaBuilder(this.connection);
    }
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        return this.queryRunner;
    }
    /**
     * Replaces parameters in the given sql with special escaping character
     * and an array of parameter names to be passed to a query.
     */ escapeQueryWithParameters(sql, parameters, nativeParameters) {
        throw new error_1.TypeORMError(`This operation is not supported by Mongodb driver.`);
    }
    /**
     * Escapes a column name.
     */ escape(columnName) {
        return columnName;
    }
    /**
     * Build full table name with database name, schema name and table name.
     * E.g. myDB.mySchema.myTable
     */ buildTableName(tableName, schema, database) {
        return tableName;
    }
    /**
     * Parse a target table name or other types and return a normalized table definition.
     */ parseTableName(target) {
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
            return {
                tableName: target.tableName
            };
        }
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
            return {
                tableName: target.name
            };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
            return {
                tableName: target.referencedTableName
            };
        }
        return {
            tableName: target
        };
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type and metadata.
     */ preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        return value;
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type or metadata.
     */ prepareHydratedValue(value, columnMetadata) {
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
    }
    /**
     * Creates a database type from a given column metadata.
     */ normalizeType(column) {
        throw new error_1.TypeORMError(`MongoDB is schema-less, not supported by this driver.`);
    }
    /**
     * Normalizes "default" value of the column.
     */ normalizeDefault(columnMetadata) {
        throw new error_1.TypeORMError(`MongoDB is schema-less, not supported by this driver.`);
    }
    /**
     * Normalizes "isUnique" value of the column.
     */ normalizeIsUnique(column) {
        throw new error_1.TypeORMError(`MongoDB is schema-less, not supported by this driver.`);
    }
    /**
     * Calculates column length taking into account the default length values.
     */ getColumnLength(column) {
        throw new error_1.TypeORMError(`MongoDB is schema-less, not supported by this driver.`);
    }
    /**
     * Normalizes "default" value of the column.
     */ createFullType(column) {
        throw new error_1.TypeORMError(`MongoDB is schema-less, not supported by this driver.`);
    }
    /**
     * Obtains a new database connection to a master server.
     * Used for replication.
     * If replication is not setup then returns default connection's database connection.
     */ obtainMasterConnection() {
        return Promise.resolve();
    }
    /**
     * Obtains a new database connection to a slave server.
     * Used for replication.
     * If replication is not setup then returns master (default) connection's database connection.
     */ obtainSlaveConnection() {
        return Promise.resolve();
    }
    /**
     * Creates generated map of values generated or returned by database after INSERT query.
     */ createGeneratedMap(metadata, insertedId) {
        return metadata.objectIdColumn.createValueMap(insertedId);
    }
    /**
     * Differentiate columns of this table and columns from the given column metadatas columns
     * and returns only changed.
     */ findChangedColumns(tableColumns, columnMetadatas) {
        throw new error_1.TypeORMError(`MongoDB is schema-less, not supported by this driver.`);
    }
    /**
     * Returns true if driver supports RETURNING / OUTPUT statement.
     */ isReturningSqlSupported() {
        return false;
    }
    /**
     * Returns true if driver supports uuid values generation on its own.
     */ isUUIDGenerationSupported() {
        return false;
    }
    /**
     * Returns true if driver supports fulltext indices.
     */ isFullTextColumnTypeSupported() {
        return false;
    }
    /**
     * Creates an escaped parameter.
     */ createParameter(parameterName, index) {
        return "";
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Validate driver options to make sure everything is correct and driver will be able to establish connection.
     */ validateOptions(options) {
    // todo: fix
    // if (!options.url) {
    //     if (!options.database)
    //         throw new DriverOptionNotSetError("database");
    // }
    }
    /**
     * Loads all driver dependencies.
     */ loadDependencies() {
        try {
            const mongodb = this.options.driver || PlatformTools_1.PlatformTools.load("mongodb");
            this.mongodb = mongodb;
        } catch (e) {
            throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("MongoDB", "mongodb");
        }
    }
    /**
     * Builds connection url that is passed to underlying driver to perform connection to the mongodb database.
     */ buildConnectionUrl(options) {
        const schemaUrlPart = options.type.toLowerCase();
        const credentialsUrlPart = options.username && options.password ? `${encodeURIComponent(options.username)}:${encodeURIComponent(options.password)}@` : "";
        const portUrlPart = schemaUrlPart === "mongodb+srv" ? "" : `:${options.port || "27017"}`;
        let connectionString;
        if (options.replicaSet) {
            connectionString = `${schemaUrlPart}://${credentialsUrlPart}${options.hostReplicaSet || options.host + portUrlPart || "127.0.0.1" + portUrlPart}/${options.database || ""}`;
        } else {
            connectionString = `${schemaUrlPart}://${credentialsUrlPart}${options.host || "127.0.0.1"}${portUrlPart}/${options.database || ""}`;
        }
        return connectionString;
    }
    /**
     * Build connection options from MongoConnectionOptions
     */ buildConnectionOptions(options) {
        const mongoOptions = {};
        for (const optionName of this.validOptionNames){
            if (optionName in options) {
                mongoOptions[optionName] = options[optionName];
            }
        }
        mongoOptions.driverInfo = {
            name: "TypeORM"
        };
        if ("poolSize" in options) {
            mongoOptions["maxPoolSize"] = options["poolSize"];
        }
        Object.assign(mongoOptions, options.extra);
        return mongoOptions;
    }
}
exports.MongoDriver = MongoDriver; //# sourceMappingURL=MongoDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/mongodb/bson.typings.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BSON = void 0; //# sourceMappingURL=bson.typings.js.map
}}),
"[project]/node_modules/typeorm/driver/mongodb/typings.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Timestamp = exports.serialize = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.Double = exports.deserialize = exports.Decimal128 = exports.DBRef = exports.Code = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.BSON = exports.Binary = void 0;
const bson_typings_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/mongodb/bson.typings.js [app-route] (ecmascript)");
Object.defineProperty(exports, "BSON", {
    enumerable: true,
    get: function() {
        return bson_typings_1.BSON;
    }
});
Object.defineProperty(exports, "BSONRegExp", {
    enumerable: true,
    get: function() {
        return bson_typings_1.BSONRegExp;
    }
});
Object.defineProperty(exports, "BSONSymbol", {
    enumerable: true,
    get: function() {
        return bson_typings_1.BSONSymbol;
    }
});
Object.defineProperty(exports, "BSONType", {
    enumerable: true,
    get: function() {
        return bson_typings_1.BSONType;
    }
});
Object.defineProperty(exports, "Binary", {
    enumerable: true,
    get: function() {
        return bson_typings_1.Binary;
    }
});
Object.defineProperty(exports, "Code", {
    enumerable: true,
    get: function() {
        return bson_typings_1.Code;
    }
});
Object.defineProperty(exports, "DBRef", {
    enumerable: true,
    get: function() {
        return bson_typings_1.DBRef;
    }
});
Object.defineProperty(exports, "Decimal128", {
    enumerable: true,
    get: function() {
        return bson_typings_1.Decimal128;
    }
});
Object.defineProperty(exports, "Double", {
    enumerable: true,
    get: function() {
        return bson_typings_1.Double;
    }
});
Object.defineProperty(exports, "Int32", {
    enumerable: true,
    get: function() {
        return bson_typings_1.Int32;
    }
});
Object.defineProperty(exports, "Long", {
    enumerable: true,
    get: function() {
        return bson_typings_1.Long;
    }
});
Object.defineProperty(exports, "MaxKey", {
    enumerable: true,
    get: function() {
        return bson_typings_1.MaxKey;
    }
});
Object.defineProperty(exports, "MinKey", {
    enumerable: true,
    get: function() {
        return bson_typings_1.MinKey;
    }
});
Object.defineProperty(exports, "ObjectId", {
    enumerable: true,
    get: function() {
        return bson_typings_1.ObjectId;
    }
});
Object.defineProperty(exports, "Timestamp", {
    enumerable: true,
    get: function() {
        return bson_typings_1.Timestamp;
    }
});
Object.defineProperty(exports, "deserialize", {
    enumerable: true,
    get: function() {
        return bson_typings_1.deserialize;
    }
});
Object.defineProperty(exports, "serialize", {
    enumerable: true,
    get: function() {
        return bson_typings_1.serialize;
    }
}); //# sourceMappingURL=typings.js.map
}}),
"[project]/node_modules/typeorm/driver/oracle/OracleQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OracleQueryRunner = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const QueryFailedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)");
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const TransactionNotStartedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TransactionNotStartedError.js [app-route] (ecmascript)");
const BaseQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/BaseQueryRunner.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const Table_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/Table.js [app-route] (ecmascript)");
const TableCheck_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableCheck.js [app-route] (ecmascript)");
const TableColumn_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableColumn.js [app-route] (ecmascript)");
const TableForeignKey_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableForeignKey.js [app-route] (ecmascript)");
const TableIndex_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableIndex.js [app-route] (ecmascript)");
const TableUnique_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableUnique.js [app-route] (ecmascript)");
const View_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/view/View.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const Query_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/Query.js [app-route] (ecmascript)");
const MetadataTableType_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/types/MetadataTableType.js [app-route] (ecmascript)");
/**
 * Runs queries on a single oracle database connection.
 */ class OracleQueryRunner extends BaseQueryRunner_1.BaseQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver, mode){
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
        this.mode = mode;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates/uses database connection from the connection pool to perform further operations.
     * Returns obtained database connection.
     */ connect() {
        if (this.databaseConnection) return Promise.resolve(this.databaseConnection);
        if (this.databaseConnectionPromise) return this.databaseConnectionPromise;
        if (this.mode === "slave" && this.driver.isReplicated) {
            this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then((connection)=>{
                this.databaseConnection = connection;
                return this.databaseConnection;
            });
        } else {
            // master
            this.databaseConnectionPromise = this.driver.obtainMasterConnection().then((connection)=>{
                this.databaseConnection = connection;
                return this.databaseConnection;
            });
        }
        return this.databaseConnectionPromise;
    }
    /**
     * Releases used database connection.
     * You cannot use query runner methods once its released.
     */ async release() {
        this.isReleased = true;
        if (!this.databaseConnection) {
            return;
        }
        await this.databaseConnection.close();
    }
    /**
     * Starts transaction.
     */ async startTransaction(isolationLevel = "READ COMMITTED") {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        // await this.query("START TRANSACTION");
        if (isolationLevel !== "SERIALIZABLE" && isolationLevel !== "READ COMMITTED") {
            throw new error_1.TypeORMError(`Oracle only supports SERIALIZABLE and READ COMMITTED isolation`);
        }
        this.isTransactionActive = true;
        try {
            await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
            this.isTransactionActive = false;
            throw err;
        }
        if (this.transactionDepth === 0) {
            await this.query("SET TRANSACTION ISOLATION LEVEL " + isolationLevel);
        } else {
            await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
    }
    /**
     * Commits transaction.
     * Error will be thrown if transaction was not started.
     */ async commitTransaction() {
        if (!this.isTransactionActive) throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth === 1) {
            await this.query("COMMIT");
            this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
    }
    /**
     * Rollbacks transaction.
     * Error will be thrown if transaction was not started.
     */ async rollbackTransaction() {
        if (!this.isTransactionActive) throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
            await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
            await this.query("ROLLBACK");
            this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
    }
    /**
     * Executes a given SQL query.
     */ async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        const queryStartTime = Date.now();
        try {
            const executionOptions = {
                autoCommit: !this.isTransactionActive,
                outFormat: this.driver.oracle.OUT_FORMAT_OBJECT
            };
            const raw = await databaseConnection.execute(query, parameters || {}, executionOptions);
            // log slow queries if maxQueryExecution time is set
            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
            const queryEndTime = Date.now();
            const queryExecutionTime = queryEndTime - queryStartTime;
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, undefined);
            if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
            const result = new QueryResult_1.QueryResult();
            result.raw = raw.rows || raw.outBinds || raw.rowsAffected || raw.implicitResults;
            if (raw?.hasOwnProperty("rows") && Array.isArray(raw.rows)) {
                result.records = raw.rows;
            }
            if (raw?.hasOwnProperty("outBinds") && Array.isArray(raw.outBinds)) {
                result.records = raw.outBinds;
            }
            if (raw?.hasOwnProperty("implicitResults") && Array.isArray(raw.implicitResults)) {
                result.records = raw.implicitResults;
            }
            if (raw?.hasOwnProperty("rowsAffected")) {
                result.affected = raw.rowsAffected;
            }
            if (useStructuredResult) {
                return result;
            } else {
                return result.raw;
            }
        } catch (err) {
            this.driver.connection.logger.logQueryError(err, query, parameters, this);
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);
            throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        } finally{
            await broadcasterResult.wait();
        }
    }
    /**
     * Returns raw data stream.
     */ async stream(query, parameters, onEnd, onError) {
        if (this.isReleased) {
            throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        }
        const executionOptions = {
            autoCommit: !this.isTransactionActive,
            outFormat: this.driver.oracle.OUT_FORMAT_OBJECT
        };
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        try {
            const stream = databaseConnection.queryStream(query, parameters, executionOptions);
            if (onEnd) {
                stream.on("end", onEnd);
            }
            if (onError) {
                stream.on("error", onError);
            }
            return stream;
        } catch (err) {
            this.driver.connection.logger.logQueryError(err, query, parameters, this);
            throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        }
    }
    /**
     * Returns all available database names including system databases.
     */ async getDatabases() {
        return Promise.resolve([]);
    }
    /**
     * Returns all available schema names including system schemas.
     * If database parameter specified, returns schemas of that database.
     */ async getSchemas(database) {
        return Promise.resolve([]);
    }
    /**
     * Checks if database with the given name exist.
     */ async hasDatabase(database) {
        try {
            const query = await this.query(`SELECT 1 AS "exists" FROM global_name@"${database}"`);
            return query.length > 0;
        } catch (e) {
            return false;
        }
    }
    /**
     * Loads currently using database
     */ async getCurrentDatabase() {
        const query = await this.query(`SELECT SYS_CONTEXT('USERENV','DB_NAME') AS "db_name" FROM dual`);
        return query[0]["db_name"];
    }
    /**
     * Checks if schema with the given name exist.
     */ async hasSchema(schema) {
        return Promise.resolve(false);
    }
    /**
     * Loads currently using database schema
     */ async getCurrentSchema() {
        const query = await this.query(`SELECT SYS_CONTEXT('USERENV','CURRENT_SCHEMA') AS "schema_name" FROM dual`);
        return query[0]["schema_name"];
    }
    /**
     * Checks if table with the given name exist in the database.
     */ async hasTable(tableOrName) {
        const { tableName } = this.driver.parseTableName(tableOrName);
        const sql = `SELECT "TABLE_NAME" FROM "USER_TABLES" WHERE "TABLE_NAME" = '${tableName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
    }
    /**
     * Checks if column with the given name exist in the given table.
     */ async hasColumn(tableOrName, columnName) {
        const { tableName } = this.driver.parseTableName(tableOrName);
        const sql = `SELECT "COLUMN_NAME" FROM "USER_TAB_COLS" WHERE "TABLE_NAME" = '${tableName}' AND "COLUMN_NAME" = '${columnName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
    }
    /**
     * Creates a new database.
     */ async createDatabase(database, ifNotExist) {
        // Even with `IF NOT EXISTS` we get:
        //   ORA-01501: CREATE DATABASE failed
        //   ORA-01100: database already mounted
        if (ifNotExist) {
            try {
                await this.query(`CREATE DATABASE IF NOT EXISTS "${database}";`);
            } catch (e) {
                // if (e instanceof QueryFailedError) {
                if (e.message.includes("ORA-01100: database already mounted")) {
                    return;
                }
                // }
                throw e;
            }
        } else {
            await this.query(`CREATE DATABASE "${database}"`);
        }
    }
    /**
     * Drops database.
     */ async dropDatabase(database, ifExist) {
        return Promise.resolve();
    }
    /**
     * Creates a new table schema.
     */ async createSchema(schemaPath, ifNotExist) {
        throw new error_1.TypeORMError(`Schema create queries are not supported by Oracle driver.`);
    }
    /**
     * Drops table schema.
     */ async dropSchema(schemaPath, ifExist) {
        throw new error_1.TypeORMError(`Schema drop queries are not supported by Oracle driver.`);
    }
    /**
     * Creates a new table.
     */ async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
        if (ifNotExist) {
            const isTableExist = await this.hasTable(table);
            if (isTableExist) return Promise.resolve();
        }
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        // if createForeignKeys is true, we must drop created foreign keys in down query.
        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.
        if (createForeignKeys) table.foreignKeys.forEach((foreignKey)=>downQueries.push(this.dropForeignKeySql(table, foreignKey)));
        if (createIndices) {
            table.indices.forEach((index)=>{
                // new index may be passed without name. In this case we generate index name manually.
                if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
                upQueries.push(this.createIndexSql(table, index));
                downQueries.push(this.dropIndexSql(index));
            });
        }
        // if table have column with generated type, we must add the expression to the metadata table
        const generatedColumns = table.columns.filter((column)=>column.generatedType && column.asExpression);
        for (const column of generatedColumns){
            const insertQuery = this.insertTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            upQueries.push(insertQuery);
            downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Drops the table.
     */ async dropTable(tableOrName, ifExist, dropForeignKeys = true, dropIndices = true) {
        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need
        // to perform drop queries for foreign keys and indices.
        if (ifExist) {
            const isTableExist = await this.hasTable(tableOrName);
            if (!isTableExist) return Promise.resolve();
        }
        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.
        const createForeignKeys = dropForeignKeys;
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const upQueries = [];
        const downQueries = [];
        if (dropIndices) {
            table.indices.forEach((index)=>{
                upQueries.push(this.dropIndexSql(index));
                downQueries.push(this.createIndexSql(table, index));
            });
        }
        // if dropForeignKeys is true, we just drop the table, otherwise we also drop table foreign keys.
        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.
        if (dropForeignKeys) table.foreignKeys.forEach((foreignKey)=>upQueries.push(this.dropForeignKeySql(table, foreignKey)));
        upQueries.push(this.dropTableSql(table));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        // if table had columns with generated type, we must remove the expression from the metadata table
        const generatedColumns = table.columns.filter((column)=>column.generatedType && column.asExpression);
        for (const column of generatedColumns){
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            const insertQuery = this.insertTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            upQueries.push(deleteQuery);
            downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Creates a new view.
     */ async createView(view, syncWithMetadata = false) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        if (syncWithMetadata) upQueries.push(this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        if (syncWithMetadata) downQueries.push(this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Drops the view.
     */ async dropView(target) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Renames the given table.
     */ async renameTable(oldTableOrName, newTableName) {
        const upQueries = [];
        const downQueries = [];
        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);
        const newTable = oldTable.clone();
        const { database: dbName, tableName: oldTableName } = this.driver.parseTableName(oldTable);
        newTable.name = dbName ? `${dbName}.${newTableName}` : newTableName;
        // rename table
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(oldTable)} RENAME TO "${newTableName}"`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME TO "${oldTableName}"`));
        // rename primary key constraint
        if (newTable.primaryColumns.length > 0 && !newTable.primaryColumns[0].primaryKeyConstraintName) {
            const columnNames = newTable.primaryColumns.map((column)=>column.name);
            const oldPkName = this.connection.namingStrategy.primaryKeyName(oldTable, columnNames);
            const newPkName = this.connection.namingStrategy.primaryKeyName(newTable, columnNames);
            // build queries
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${oldPkName}" TO "${newPkName}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newPkName}" TO "${oldPkName}"`));
        }
        // rename unique constraints
        newTable.uniques.forEach((unique)=>{
            const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);
            // Skip renaming if Unique has user defined constraint name
            if (unique.name !== oldUniqueName) return;
            // build new constraint name
            const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);
            // build queries
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${unique.name}" TO "${newUniqueName}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newUniqueName}" TO "${unique.name}"`));
            // replace constraint name
            unique.name = newUniqueName;
        });
        // rename index constraints
        newTable.indices.forEach((index)=>{
            const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);
            // Skip renaming if Index has user defined constraint name
            if (index.name !== oldIndexName) return;
            // build new constraint name
            const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
            // build queries
            upQueries.push(new Query_1.Query(`ALTER INDEX "${index.name}" RENAME TO "${newIndexName}"`));
            downQueries.push(new Query_1.Query(`ALTER INDEX "${newIndexName}" RENAME TO "${index.name}"`));
            // replace constraint name
            index.name = newIndexName;
        });
        // rename foreign key constraints
        newTable.foreignKeys.forEach((foreignKey)=>{
            const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
            // Skip renaming if foreign key has user defined constraint name
            if (foreignKey.name !== oldForeignKeyName) return;
            // build new constraint name
            const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
            // build queries
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${foreignKey.name}" TO "${newForeignKeyName}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT "${newForeignKeyName}" TO "${foreignKey.name}"`));
            // replace constraint name
            foreignKey.name = newForeignKeyName;
        });
        await this.executeQueries(upQueries, downQueries);
        // rename old table and replace it in cached tabled;
        oldTable.name = newTable.name;
        this.replaceCachedTable(oldTable, newTable);
    }
    /**
     * Creates a new column from the column in the table.
     */ async addColumn(tableOrName, column) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
        // create or update primary key constraint
        if (column.isPrimary) {
            const primaryColumns = clonedTable.primaryColumns;
            // if table already have primary key, me must drop it and recreate again
            if (primaryColumns.length > 0) {
                const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column)=>column.name));
                const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
            }
            primaryColumns.push(column);
            const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column)=>column.name));
            const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        }
        // create column index
        const columnIndex = clonedTable.indices.find((index)=>index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
            clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
            upQueries.push(this.createIndexSql(table, columnIndex));
            downQueries.push(this.dropIndexSql(columnIndex));
        }
        // create unique constraint
        if (column.isUnique) {
            const uniqueConstraint = new TableUnique_1.TableUnique({
                name: this.connection.namingStrategy.uniqueConstraintName(table, [
                    column.name
                ]),
                columnNames: [
                    column.name
                ]
            });
            clonedTable.uniques.push(uniqueConstraint);
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${column.name}")`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
        }
        if (column.generatedType && column.asExpression) {
            const insertQuery = this.insertTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            upQueries.push(insertQuery);
            downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.addColumn(column);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Creates a new columns from the column in the table.
     */ async addColumns(tableOrName, columns) {
        for (const column of columns){
            await this.addColumn(tableOrName, column);
        }
    }
    /**
     * Renames column in the given table.
     */ async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c)=>c.name === oldTableColumnOrName);
        if (!oldColumn) throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the ${this.escapePath(table)} table.`);
        let newColumn = undefined;
        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
            newColumn = newTableColumnOrName;
        } else {
            newColumn = oldColumn.clone();
            newColumn.name = newTableColumnOrName;
        }
        await this.changeColumn(table, oldColumn, newColumn);
    }
    /**
     * Changes a column in the table.
     */ async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        let clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((column)=>column.name === oldTableColumnOrName);
        if (!oldColumn) throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the ${this.escapePath(table)} table.`);
        if (newColumn.isGenerated !== oldColumn.isGenerated && newColumn.generationStrategy !== "uuid" || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.generatedType !== newColumn.generatedType || oldColumn.asExpression !== newColumn.asExpression) {
            // Oracle does not support changing of IDENTITY column, so we must drop column and recreate it again.
            // Also, we recreate column if column type changed
            await this.dropColumn(table, oldColumn);
            await this.addColumn(table, newColumn);
            // update cloned table
            clonedTable = table.clone();
        } else {
            if (newColumn.name !== oldColumn.name) {
                // rename column
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${oldColumn.name}" TO "${newColumn.name}"`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN "${newColumn.name}" TO "${oldColumn.name}"`));
                // rename column primary key constraint
                if (oldColumn.isPrimary === true && !oldColumn.primaryKeyConstraintName) {
                    const primaryColumns = clonedTable.primaryColumns;
                    // build old primary constraint name
                    const columnNames = primaryColumns.map((column)=>column.name);
                    const oldPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
                    // replace old column name with new column name
                    columnNames.splice(columnNames.indexOf(oldColumn.name), 1);
                    columnNames.push(newColumn.name);
                    // build new primary constraint name
                    const newPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${oldPkName}" TO "${newPkName}"`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newPkName}" TO "${oldPkName}"`));
                }
                // rename unique constraints
                clonedTable.findColumnUniques(oldColumn).forEach((unique)=>{
                    const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
                    // Skip renaming if Unique has user defined constraint name
                    if (unique.name !== oldUniqueName) return;
                    // build new constraint name
                    unique.columnNames.splice(unique.columnNames.indexOf(oldColumn.name), 1);
                    unique.columnNames.push(newColumn.name);
                    const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);
                    // build queries
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${unique.name}" TO "${newUniqueName}"`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newUniqueName}" TO "${unique.name}"`));
                    // replace constraint name
                    unique.name = newUniqueName;
                });
                // rename index constraints
                clonedTable.findColumnIndices(oldColumn).forEach((index)=>{
                    const oldIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
                    // Skip renaming if Index has user defined constraint name
                    if (index.name !== oldIndexName) return;
                    // build new constraint name
                    index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
                    index.columnNames.push(newColumn.name);
                    const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
                    // build queries
                    upQueries.push(new Query_1.Query(`ALTER INDEX "${index.name}" RENAME TO "${newIndexName}"`));
                    downQueries.push(new Query_1.Query(`ALTER INDEX "${newIndexName}" RENAME TO "${index.name}"`));
                    // replace constraint name
                    index.name = newIndexName;
                });
                // rename foreign key constraints
                clonedTable.findColumnForeignKeys(oldColumn).forEach((foreignKey)=>{
                    const foreignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
                    // Skip renaming if foreign key has user defined constraint name
                    if (foreignKey.name !== foreignKeyName) return;
                    // build new constraint name
                    foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
                    foreignKey.columnNames.push(newColumn.name);
                    const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
                    // build queries
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${foreignKey.name}" TO "${newForeignKeyName}"`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT "${newForeignKeyName}" TO "${foreignKey.name}"`));
                    // replace constraint name
                    foreignKey.name = newForeignKeyName;
                });
                // rename old column in the Table object
                const oldTableColumn = clonedTable.columns.find((column)=>column.name === oldColumn.name);
                clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
                oldColumn.name = newColumn.name;
            }
            if (this.isColumnChanged(oldColumn, newColumn, true)) {
                let defaultUp = "";
                let defaultDown = "";
                let nullableUp = "";
                let nullableDown = "";
                // changing column default
                if (newColumn.default !== null && newColumn.default !== undefined) {
                    defaultUp = `DEFAULT ${newColumn.default}`;
                    if (oldColumn.default !== null && oldColumn.default !== undefined) {
                        defaultDown = `DEFAULT ${oldColumn.default}`;
                    } else {
                        defaultDown = "DEFAULT NULL";
                    }
                } else if (oldColumn.default !== null && oldColumn.default !== undefined) {
                    defaultUp = "DEFAULT NULL";
                    defaultDown = `DEFAULT ${oldColumn.default}`;
                }
                // changing column isNullable property
                if (newColumn.isNullable !== oldColumn.isNullable) {
                    if (newColumn.isNullable === true) {
                        nullableUp = "NULL";
                        nullableDown = "NOT NULL";
                    } else {
                        nullableUp = "NOT NULL";
                        nullableDown = "NULL";
                    }
                }
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} MODIFY "${oldColumn.name}" ${this.connection.driver.createFullType(newColumn)} ${defaultUp} ${nullableUp}`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} MODIFY "${oldColumn.name}" ${this.connection.driver.createFullType(oldColumn)} ${defaultDown} ${nullableDown}`));
            }
            if (newColumn.isPrimary !== oldColumn.isPrimary) {
                const primaryColumns = clonedTable.primaryColumns;
                // if primary column state changed, we must always drop existed constraint.
                if (primaryColumns.length > 0) {
                    const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column)=>column.name));
                    const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                }
                if (newColumn.isPrimary === true) {
                    primaryColumns.push(newColumn);
                    // update column in table
                    const column = clonedTable.columns.find((column)=>column.name === newColumn.name);
                    column.isPrimary = true;
                    const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column)=>column.name));
                    const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
                } else {
                    const primaryColumn = primaryColumns.find((c)=>c.name === newColumn.name);
                    primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
                    // update column in table
                    const column = clonedTable.columns.find((column)=>column.name === newColumn.name);
                    column.isPrimary = false;
                    // if we have another primary keys, we must recreate constraint.
                    if (primaryColumns.length > 0) {
                        const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column)=>column.name));
                        const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
                        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
                    }
                }
            }
            if (newColumn.isUnique !== oldColumn.isUnique) {
                if (newColumn.isUnique === true) {
                    const uniqueConstraint = new TableUnique_1.TableUnique({
                        name: this.connection.namingStrategy.uniqueConstraintName(table, [
                            newColumn.name
                        ]),
                        columnNames: [
                            newColumn.name
                        ]
                    });
                    clonedTable.uniques.push(uniqueConstraint);
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
                } else {
                    const uniqueConstraint = clonedTable.uniques.find((unique)=>{
                        return unique.columnNames.length === 1 && !!unique.columnNames.find((columnName)=>columnName === newColumn.name);
                    });
                    clonedTable.uniques.splice(clonedTable.uniques.indexOf(uniqueConstraint), 1);
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueConstraint.name}"`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE ("${newColumn.name}")`));
                }
            }
            await this.executeQueries(upQueries, downQueries);
            this.replaceCachedTable(table, clonedTable);
        }
    }
    /**
     * Changes a column in the table.
     */ async changeColumns(tableOrName, changedColumns) {
        for (const { oldColumn, newColumn } of changedColumns){
            await this.changeColumn(tableOrName, oldColumn, newColumn);
        }
    }
    /**
     * Drops column in the table.
     */ async dropColumn(tableOrName, columnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
        if (!column) throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table ${this.escapePath(table)}`);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        // drop primary key constraint
        if (column.isPrimary) {
            const pkName = column.primaryKeyConstraintName ? column.primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column)=>column.name));
            const columnNames = clonedTable.primaryColumns.map((primaryColumn)=>`"${primaryColumn.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
            // update column in table
            const tableColumn = clonedTable.findColumnByName(column.name);
            tableColumn.isPrimary = false;
            // if primary key have multiple columns, we must recreate it without dropped column
            if (clonedTable.primaryColumns.length > 0) {
                const pkName = clonedTable.primaryColumns[0].primaryKeyConstraintName ? clonedTable.primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column)=>column.name));
                const columnNames = clonedTable.primaryColumns.map((primaryColumn)=>`"${primaryColumn.name}"`).join(", ");
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNames})`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT "${pkName}"`));
            }
        }
        // drop column index
        const columnIndex = clonedTable.indices.find((index)=>index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
            upQueries.push(this.dropIndexSql(columnIndex));
            downQueries.push(this.createIndexSql(table, columnIndex));
        }
        // drop column check
        const columnCheck = clonedTable.checks.find((check)=>!!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);
        if (columnCheck) {
            clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);
            upQueries.push(this.dropCheckConstraintSql(table, columnCheck));
            downQueries.push(this.createCheckConstraintSql(table, columnCheck));
        }
        // drop column unique
        const columnUnique = clonedTable.uniques.find((unique)=>unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
        if (columnUnique) {
            clonedTable.uniques.splice(clonedTable.uniques.indexOf(columnUnique), 1);
            upQueries.push(this.dropUniqueConstraintSql(table, columnUnique));
            downQueries.push(this.createUniqueConstraintSql(table, columnUnique));
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN "${column.name}"`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));
        if (column.generatedType && column.asExpression) {
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            const insertQuery = this.insertTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            upQueries.push(deleteQuery);
            downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.removeColumn(column);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Drops the columns in the table.
     */ async dropColumns(tableOrName, columns) {
        for (const column of columns){
            await this.dropColumn(tableOrName, column);
        }
    }
    /**
     * Creates a new primary key.
     */ async createPrimaryKey(tableOrName, columnNames, constraintName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const up = this.createPrimaryKeySql(table, columnNames, constraintName);
        // mark columns as primary, because dropPrimaryKeySql build constraint name from table primary column names.
        clonedTable.columns.forEach((column)=>{
            if (columnNames.find((columnName)=>columnName === column.name)) column.isPrimary = true;
        });
        const down = this.dropPrimaryKeySql(clonedTable);
        await this.executeQueries(up, down);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Updates composite primary keys.
     */ async updatePrimaryKeys(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const columnNames = columns.map((column)=>column.name);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        // if table already have primary columns, we must drop them.
        const primaryColumns = clonedTable.primaryColumns;
        if (primaryColumns.length > 0) {
            const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column)=>column.name));
            const columnNamesString = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`));
        }
        // update columns in table.
        clonedTable.columns.filter((column)=>columnNames.indexOf(column.name) !== -1).forEach((column)=>column.isPrimary = true);
        const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);
        const columnNamesString = columnNames.map((columnName)=>`"${columnName}"`).join(", ");
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${pkName}" PRIMARY KEY (${columnNamesString})`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${pkName}"`));
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Drops a primary key.
     */ async dropPrimaryKey(tableOrName, constraintName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const up = this.dropPrimaryKeySql(table);
        const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column)=>column.name), constraintName);
        await this.executeQueries(up, down);
        table.primaryColumns.forEach((column)=>{
            column.isPrimary = false;
        });
    }
    /**
     * Creates a new unique constraint.
     */ async createUniqueConstraint(tableOrName, uniqueConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // new unique constraint may be passed without name. In this case we generate unique name manually.
        if (!uniqueConstraint.name) uniqueConstraint.name = this.connection.namingStrategy.uniqueConstraintName(table, uniqueConstraint.columnNames);
        const up = this.createUniqueConstraintSql(table, uniqueConstraint);
        const down = this.dropUniqueConstraintSql(table, uniqueConstraint);
        await this.executeQueries(up, down);
        table.addUniqueConstraint(uniqueConstraint);
    }
    /**
     * Creates a new unique constraints.
     */ async createUniqueConstraints(tableOrName, uniqueConstraints) {
        const promises = uniqueConstraints.map((uniqueConstraint)=>this.createUniqueConstraint(tableOrName, uniqueConstraint));
        await Promise.all(promises);
    }
    /**
     * Drops an unique constraint.
     */ async dropUniqueConstraint(tableOrName, uniqueOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const uniqueConstraint = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find((u)=>u.name === uniqueOrName);
        if (!uniqueConstraint) throw new error_1.TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);
        const up = this.dropUniqueConstraintSql(table, uniqueConstraint);
        const down = this.createUniqueConstraintSql(table, uniqueConstraint);
        await this.executeQueries(up, down);
        table.removeUniqueConstraint(uniqueConstraint);
    }
    /**
     * Creates an unique constraints.
     */ async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        const promises = uniqueConstraints.map((uniqueConstraint)=>this.dropUniqueConstraint(tableOrName, uniqueConstraint));
        await Promise.all(promises);
    }
    /**
     * Creates new check constraint.
     */ async createCheckConstraint(tableOrName, checkConstraint) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // new unique constraint may be passed without name. In this case we generate unique name manually.
        if (!checkConstraint.name) checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);
        const up = this.createCheckConstraintSql(table, checkConstraint);
        const down = this.dropCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.addCheckConstraint(checkConstraint);
    }
    /**
     * Creates new check constraints.
     */ async createCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint)=>this.createCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
    }
    /**
     * Drops check constraint.
     */ async dropCheckConstraint(tableOrName, checkOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const checkConstraint = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find((c)=>c.name === checkOrName);
        if (!checkConstraint) throw new error_1.TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
        const up = this.dropCheckConstraintSql(table, checkConstraint);
        const down = this.createCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.removeCheckConstraint(checkConstraint);
    }
    /**
     * Drops check constraints.
     */ async dropCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint)=>this.dropCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
    }
    /**
     * Creates a new exclusion constraint.
     */ async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`Oracle does not support exclusion constraints.`);
    }
    /**
     * Creates a new exclusion constraints.
     */ async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Oracle does not support exclusion constraints.`);
    }
    /**
     * Drops exclusion constraint.
     */ async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`Oracle does not support exclusion constraints.`);
    }
    /**
     * Drops exclusion constraints.
     */ async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Oracle does not support exclusion constraints.`);
    }
    /**
     * Creates a new foreign key.
     */ async createForeignKey(tableOrName, foreignKey) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // new FK may be passed without name. In this case we generate FK name manually.
        if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        const up = this.createForeignKeySql(table, foreignKey);
        const down = this.dropForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.addForeignKey(foreignKey);
    }
    /**
     * Creates a new foreign keys.
     */ async createForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey)=>this.createForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
    }
    /**
     * Drops a foreign key from the table.
     */ async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk)=>fk.name === foreignKeyOrName);
        if (!foreignKey) throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        const up = this.dropForeignKeySql(table, foreignKey);
        const down = this.createForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.removeForeignKey(foreignKey);
    }
    /**
     * Drops a foreign keys from the table.
     */ async dropForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey)=>this.dropForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
    }
    /**
     * Creates a new index.
     */ async createIndex(tableOrName, index) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // new index may be passed without name. In this case we generate index name manually.
        if (!index.name) index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(index);
        await this.executeQueries(up, down);
        table.addIndex(index);
    }
    /**
     * Creates a new indices
     */ async createIndices(tableOrName, indices) {
        const promises = indices.map((index)=>this.createIndex(tableOrName, index));
        await Promise.all(promises);
    }
    /**
     * Drops an index from the table.
     */ async dropIndex(tableOrName, indexOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i)=>i.name === indexOrName);
        if (!index) throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        // old index may be passed without name. In this case we generate index name manually.
        if (!index.name) index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index);
    }
    /**
     * Drops an indices from the table.
     */ async dropIndices(tableOrName, indices) {
        const promises = indices.map((index)=>this.dropIndex(tableOrName, index));
        await Promise.all(promises);
    }
    /**
     * Clears all table contents.
     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
     */ async clearTable(tableName) {
        await this.query(`TRUNCATE TABLE ${this.escapePath(tableName)}`);
    }
    /**
     * Removes all tables from the currently connected database.
     */ async clearDatabase() {
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive) await this.startTransaction();
        try {
            // drop views
            const dropViewsQuery = `SELECT 'DROP VIEW "' || VIEW_NAME || '"' AS "query" FROM "USER_VIEWS"`;
            const dropViewQueries = await this.query(dropViewsQuery);
            await Promise.all(dropViewQueries.map((query)=>this.query(query["query"])));
            // drop materialized views
            const dropMatViewsQuery = `SELECT 'DROP MATERIALIZED VIEW "' || MVIEW_NAME || '"' AS "query" FROM "USER_MVIEWS"`;
            const dropMatViewQueries = await this.query(dropMatViewsQuery);
            await Promise.all(dropMatViewQueries.map((query)=>this.query(query["query"])));
            // drop tables
            const dropTablesQuery = `SELECT 'DROP TABLE "' || TABLE_NAME || '" CASCADE CONSTRAINTS' AS "query" FROM "USER_TABLES"`;
            const dropTableQueries = await this.query(dropTablesQuery);
            await Promise.all(dropTableQueries.map((query)=>this.query(query["query"])));
            if (!isAnotherTransactionActive) await this.commitTransaction();
        } catch (error) {
            try {
                // we throw original error even if rollback thrown an error
                if (!isAnotherTransactionActive) await this.rollbackTransaction();
            } catch (rollbackError) {}
            throw error;
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    async loadViews(viewNames) {
        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
        if (!hasTable) {
            return [];
        }
        if (!viewNames) {
            viewNames = [];
        }
        const currentDatabase = await this.getCurrentDatabase();
        const currentSchema = await this.getCurrentSchema();
        const viewsCondition = viewNames.map((viewName)=>this.driver.parseTableName(viewName)).map(({ schema, tableName })=>{
            if (!schema) {
                schema = this.driver.options.schema || currentSchema;
            }
            return `("T"."schema" = '${schema}' AND "T"."name" = '${tableName}')`;
        }).join(" OR ");
        let query = `SELECT "T".* FROM ${this.escapePath(this.getTypeormMetadataTableName())} "T" ` + `INNER JOIN "USER_OBJECTS" "O" ON "O"."OBJECT_NAME" = "T"."name" AND "O"."OBJECT_TYPE" IN ( 'MATERIALIZED VIEW', 'VIEW' ) ` + `WHERE "T"."type" IN ('${MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW}', '${MetadataTableType_1.MetadataTableType.VIEW}')`;
        if (viewsCondition.length > 0) query += ` AND ${viewsCondition}`;
        const dbViews = await this.query(query);
        return dbViews.map((dbView)=>{
            const parsedName = this.driver.parseTableName(dbView["name"]);
            const view = new View_1.View();
            view.database = parsedName.database || dbView["database"] || currentDatabase;
            view.schema = parsedName.schema || dbView["schema"] || currentSchema;
            view.name = parsedName.tableName;
            view.expression = dbView["value"];
            view.materialized = dbView["type"] === MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW;
            return view;
        });
    }
    /**
     * Loads all tables (with given names) from the database and creates a Table from them.
     */ async loadTables(tableNames) {
        if (tableNames && tableNames.length === 0) {
            return [];
        }
        const dbTables = [];
        const currentSchema = await this.getCurrentSchema();
        const currentDatabase = await this.getCurrentDatabase();
        if (!tableNames) {
            const tablesSql = `SELECT "TABLE_NAME", "OWNER" FROM "ALL_TABLES"`;
            dbTables.push(...await this.query(tablesSql));
        } else {
            const tablesCondition = tableNames.map((tableName)=>{
                const parts = tableName.split(".");
                if (parts.length >= 3) {
                    const [, schema, name] = parts;
                    return `("OWNER" = '${schema}' AND "TABLE_NAME" = '${name}')`;
                } else if (parts.length === 2) {
                    const [schema, name] = parts;
                    return `("OWNER" = '${schema}' AND "TABLE_NAME" = '${name}')`;
                } else if (parts.length === 1) {
                    const [name] = parts;
                    return `("TABLE_NAME" = '${name}')`;
                } else {
                    return `(1=0)`;
                }
            }).join(" OR ");
            const tablesSql = `SELECT "TABLE_NAME", "OWNER" FROM "ALL_TABLES" WHERE ${tablesCondition}`;
            dbTables.push(...await this.query(tablesSql));
        }
        // if tables were not found in the db, no need to proceed
        if (dbTables.length === 0) {
            return [];
        }
        // load tables, columns, indices and foreign keys
        const columnsCondition = dbTables.map(({ TABLE_NAME, OWNER })=>{
            return `("C"."OWNER" = '${OWNER}' AND "C"."TABLE_NAME" = '${TABLE_NAME}')`;
        }).join(" OR ");
        const columnsSql = `SELECT * FROM "ALL_TAB_COLS" "C" WHERE (${columnsCondition})`;
        const indicesSql = `SELECT "C"."INDEX_NAME", "C"."OWNER", "C"."TABLE_NAME", "C"."UNIQUENESS", ` + `LISTAGG ("COL"."COLUMN_NAME", ',') WITHIN GROUP (ORDER BY "COL"."COLUMN_NAME") AS "COLUMN_NAMES" ` + `FROM "ALL_INDEXES" "C" ` + `INNER JOIN "ALL_IND_COLUMNS" "COL" ON "COL"."INDEX_OWNER" = "C"."OWNER" AND "COL"."INDEX_NAME" = "C"."INDEX_NAME" ` + `LEFT JOIN "ALL_CONSTRAINTS" "CON" ON "CON"."OWNER" = "C"."OWNER" AND "CON"."CONSTRAINT_NAME" = "C"."INDEX_NAME" ` + `WHERE (${columnsCondition}) AND "CON"."CONSTRAINT_NAME" IS NULL ` + `GROUP BY "C"."INDEX_NAME", "C"."OWNER", "C"."TABLE_NAME", "C"."UNIQUENESS"`;
        const foreignKeysSql = `SELECT "C"."CONSTRAINT_NAME", "C"."OWNER", "C"."TABLE_NAME", "COL"."COLUMN_NAME", "REF_COL"."TABLE_NAME" AS "REFERENCED_TABLE_NAME", ` + `"REF_COL"."COLUMN_NAME" AS "REFERENCED_COLUMN_NAME", "C"."DELETE_RULE" AS "ON_DELETE" ` + `FROM "ALL_CONSTRAINTS" "C" ` + `INNER JOIN "ALL_CONS_COLUMNS" "COL" ON "COL"."OWNER" = "C"."OWNER" AND "COL"."CONSTRAINT_NAME" = "C"."CONSTRAINT_NAME" ` + `INNER JOIN "ALL_CONS_COLUMNS" "REF_COL" ON "REF_COL"."OWNER" = "C"."R_OWNER" AND "REF_COL"."CONSTRAINT_NAME" = "C"."R_CONSTRAINT_NAME" AND "REF_COL"."POSITION" = "COL"."POSITION" ` + `WHERE (${columnsCondition}) AND "C"."CONSTRAINT_TYPE" = 'R'`;
        const constraintsSql = `SELECT "C"."CONSTRAINT_NAME", "C"."CONSTRAINT_TYPE", "C"."OWNER", "C"."TABLE_NAME", "COL"."COLUMN_NAME", "C"."SEARCH_CONDITION" ` + `FROM "ALL_CONSTRAINTS" "C" ` + `INNER JOIN "ALL_CONS_COLUMNS" "COL" ON "COL"."OWNER" = "C"."OWNER" AND "COL"."CONSTRAINT_NAME" = "C"."CONSTRAINT_NAME" ` + `WHERE (${columnsCondition}) AND "C"."CONSTRAINT_TYPE" IN ('C', 'U', 'P') AND "C"."GENERATED" = 'USER NAME'`;
        const [dbColumns, dbIndices, dbForeignKeys, dbConstraints] = await Promise.all([
            this.query(columnsSql),
            this.query(indicesSql),
            this.query(foreignKeysSql),
            this.query(constraintsSql)
        ]);
        // create tables for loaded tables
        return await Promise.all(dbTables.map(async (dbTable)=>{
            const table = new Table_1.Table();
            const owner = dbTable["OWNER"] === currentSchema && (!this.driver.options.schema || this.driver.options.schema === currentSchema) ? undefined : dbTable["OWNER"];
            table.database = currentDatabase;
            table.schema = dbTable["OWNER"];
            table.name = this.driver.buildTableName(dbTable["TABLE_NAME"], owner);
            // create columns from the loaded columns
            table.columns = await Promise.all(dbColumns.filter((dbColumn)=>dbColumn["OWNER"] === dbTable["OWNER"] && dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"] && // Filter out auto-generated virtual columns,
                // since TypeORM will have no info about them.
                !(dbColumn["VIRTUAL_COLUMN"] === "YES" && dbColumn["USER_GENERATED"] === "NO")).map(async (dbColumn)=>{
                const columnConstraints = dbConstraints.filter((dbConstraint)=>dbConstraint["OWNER"] === dbColumn["OWNER"] && dbConstraint["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbConstraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"]);
                const uniqueConstraints = columnConstraints.filter((constraint)=>constraint["CONSTRAINT_TYPE"] === "U");
                const isConstraintComposite = uniqueConstraints.every((uniqueConstraint)=>{
                    return dbConstraints.some((dbConstraint)=>dbConstraint["OWNER"] === dbColumn["OWNER"] && dbConstraint["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbConstraint["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"] && dbConstraint["CONSTRAINT_NAME"] === uniqueConstraint["CONSTRAINT_NAME"] && dbConstraint["CONSTRAINT_TYPE"] === "U");
                });
                const tableColumn = new TableColumn_1.TableColumn();
                tableColumn.name = dbColumn["COLUMN_NAME"];
                tableColumn.type = dbColumn["DATA_TYPE"].toLowerCase();
                if (tableColumn.type.indexOf("(") !== -1) tableColumn.type = tableColumn.type.replace(/\([0-9]*\)/, "");
                // check only columns that have length property
                if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {
                    const length = tableColumn.type === "raw" ? dbColumn["DATA_LENGTH"] : dbColumn["CHAR_COL_DECL_LENGTH"];
                    tableColumn.length = length && !this.isDefaultColumnLength(table, tableColumn, length) ? length.toString() : "";
                }
                if (tableColumn.type === "number" || tableColumn.type === "float") {
                    if (dbColumn["DATA_PRECISION"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["DATA_PRECISION"])) tableColumn.precision = dbColumn["DATA_PRECISION"];
                    if (dbColumn["DATA_SCALE"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn["DATA_SCALE"])) tableColumn.scale = dbColumn["DATA_SCALE"];
                } else if ((tableColumn.type === "timestamp" || tableColumn.type === "timestamp with time zone" || tableColumn.type === "timestamp with local time zone") && dbColumn["DATA_SCALE"] !== null) {
                    tableColumn.precision = !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["DATA_SCALE"]) ? dbColumn["DATA_SCALE"] : undefined;
                }
                tableColumn.default = dbColumn["DATA_DEFAULT"] !== null && dbColumn["DATA_DEFAULT"] !== undefined && dbColumn["VIRTUAL_COLUMN"] === "NO" && dbColumn["DATA_DEFAULT"].trim() !== "NULL" ? tableColumn.default = dbColumn["DATA_DEFAULT"].trim() : undefined;
                const primaryConstraint = columnConstraints.find((constraint)=>constraint["CONSTRAINT_TYPE"] === "P");
                if (primaryConstraint) {
                    tableColumn.isPrimary = true;
                    // find another columns involved in primary key constraint
                    const anotherPrimaryConstraints = dbConstraints.filter((constraint)=>constraint["OWNER"] === dbColumn["OWNER"] && constraint["TABLE_NAME"] === dbColumn["TABLE_NAME"] && constraint["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"] && constraint["CONSTRAINT_TYPE"] === "P");
                    // collect all column names
                    const columnNames = anotherPrimaryConstraints.map((constraint)=>constraint["COLUMN_NAME"]);
                    columnNames.push(dbColumn["COLUMN_NAME"]);
                    // build default primary key constraint name
                    const pkName = this.connection.namingStrategy.primaryKeyName(table, columnNames);
                    // if primary key has user-defined constraint name, write it in table column
                    if (primaryConstraint["CONSTRAINT_NAME"] !== pkName) {
                        tableColumn.primaryKeyConstraintName = primaryConstraint["CONSTRAINT_NAME"];
                    }
                }
                tableColumn.isNullable = dbColumn["NULLABLE"] === "Y";
                tableColumn.isUnique = uniqueConstraints.length > 0 && !isConstraintComposite;
                tableColumn.isGenerated = dbColumn["IDENTITY_COLUMN"] === "YES";
                if (tableColumn.isGenerated) {
                    tableColumn.generationStrategy = "increment";
                    tableColumn.default = undefined;
                }
                tableColumn.comment = ""; // todo
                if (dbColumn["VIRTUAL_COLUMN"] === "YES") {
                    tableColumn.generatedType = "VIRTUAL";
                    const asExpressionQuery = this.selectTypeormMetadataSql({
                        table: dbTable["TABLE_NAME"],
                        type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                        name: tableColumn.name
                    });
                    const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);
                    if (results[0] && results[0].value) {
                        tableColumn.asExpression = results[0].value;
                    } else {
                        tableColumn.asExpression = "";
                    }
                }
                return tableColumn;
            }));
            // find unique constraints of table, group them by constraint name and build TableUnique.
            const tableUniqueConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint)=>{
                return dbConstraint["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbConstraint["OWNER"] === dbTable["OWNER"] && dbConstraint["CONSTRAINT_TYPE"] === "U";
            }), (dbConstraint)=>dbConstraint["CONSTRAINT_NAME"]);
            table.uniques = tableUniqueConstraints.map((constraint)=>{
                const uniques = dbConstraints.filter((dbC)=>dbC["CONSTRAINT_NAME"] === constraint["CONSTRAINT_NAME"]);
                return new TableUnique_1.TableUnique({
                    name: constraint["CONSTRAINT_NAME"],
                    columnNames: uniques.map((u)=>u["COLUMN_NAME"])
                });
            });
            // find check constraints of table, group them by constraint name and build TableCheck.
            const tableCheckConstraints = OrmUtils_1.OrmUtils.uniq(dbConstraints.filter((dbConstraint)=>{
                return dbConstraint["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbConstraint["OWNER"] === dbTable["OWNER"] && dbConstraint["CONSTRAINT_TYPE"] === "C";
            }), (dbConstraint)=>dbConstraint["CONSTRAINT_NAME"]);
            table.checks = tableCheckConstraints.map((constraint)=>{
                const checks = dbConstraints.filter((dbC)=>dbC["TABLE_NAME"] === constraint["TABLE_NAME"] && dbC["OWNER"] === constraint["OWNER"] && dbC["CONSTRAINT_NAME"] === constraint["CONSTRAINT_NAME"]);
                return new TableCheck_1.TableCheck({
                    name: constraint["CONSTRAINT_NAME"],
                    columnNames: checks.map((c)=>c["COLUMN_NAME"]),
                    expression: constraint["SEARCH_CONDITION"]
                });
            });
            // find foreign key constraints of table, group them by constraint name and build TableForeignKey.
            const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey)=>dbForeignKey["OWNER"] === dbTable["OWNER"] && dbForeignKey["TABLE_NAME"] === dbTable["TABLE_NAME"]), (dbForeignKey)=>dbForeignKey["CONSTRAINT_NAME"]);
            table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey)=>{
                const foreignKeys = dbForeignKeys.filter((dbFk)=>dbFk["TABLE_NAME"] === dbForeignKey["TABLE_NAME"] && dbFk["OWNER"] === dbForeignKey["OWNER"] && dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
                return new TableForeignKey_1.TableForeignKey({
                    name: dbForeignKey["CONSTRAINT_NAME"],
                    columnNames: foreignKeys.map((dbFk)=>dbFk["COLUMN_NAME"]),
                    referencedDatabase: table.database,
                    referencedSchema: dbForeignKey["OWNER"],
                    referencedTableName: dbForeignKey["REFERENCED_TABLE_NAME"],
                    referencedColumnNames: foreignKeys.map((dbFk)=>dbFk["REFERENCED_COLUMN_NAME"]),
                    onDelete: dbForeignKey["ON_DELETE"],
                    onUpdate: "NO ACTION"
                });
            });
            // Attempt to map auto-generated virtual columns to their
            // referenced columns, through its 'DATA_DEFAULT' property.
            //
            // An example of this happening is when a column of type
            // TIMESTAMP WITH TIME ZONE is indexed. Oracle will create a
            // virtual column of type TIMESTAMP with a default value of
            // SYS_EXTRACT_UTC(<column>).
            const autoGenVirtualDbColumns = dbColumns.filter((dbColumn)=>dbColumn["OWNER"] === dbTable["OWNER"] && dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbColumn["VIRTUAL_COLUMN"] === "YES" && dbColumn["USER_GENERATED"] === "NO").reduce((acc, x)=>{
                const referencedDbColumn = dbColumns.find((dbColumn)=>x["DATA_DEFAULT"].includes(dbColumn["COLUMN_NAME"]));
                if (!referencedDbColumn) return acc;
                return {
                    ...acc,
                    [x["COLUMN_NAME"]]: referencedDbColumn["COLUMN_NAME"]
                };
            }, {});
            // create TableIndex objects from the loaded indices
            table.indices = dbIndices.filter((dbIndex)=>dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["OWNER"] === dbTable["OWNER"]).map((dbIndex)=>{
                //
                const columnNames = dbIndex["COLUMN_NAMES"].split(",").map((columnName)=>autoGenVirtualDbColumns[columnName] ?? columnName);
                return new TableIndex_1.TableIndex({
                    name: dbIndex["INDEX_NAME"],
                    columnNames,
                    isUnique: dbIndex["UNIQUENESS"] === "UNIQUE"
                });
            });
            return table;
        }));
    }
    /**
     * Builds and returns SQL for create table.
     */ createTableSql(table, createForeignKeys) {
        const columnDefinitions = table.columns.map((column)=>this.buildCreateColumnSql(column)).join(", ");
        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
        table.columns.filter((column)=>column.isUnique).forEach((column)=>{
            const isUniqueExist = table.uniques.some((unique)=>unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
            if (!isUniqueExist) table.uniques.push(new TableUnique_1.TableUnique({
                name: this.connection.namingStrategy.uniqueConstraintName(table, [
                    column.name
                ]),
                columnNames: [
                    column.name
                ]
            }));
        });
        if (table.uniques.length > 0) {
            const uniquesSql = table.uniques.map((unique)=>{
                const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);
                const columnNames = unique.columnNames.map((columnName)=>`"${columnName}"`).join(", ");
                return `CONSTRAINT "${uniqueName}" UNIQUE (${columnNames})`;
            }).join(", ");
            sql += `, ${uniquesSql}`;
        }
        if (table.checks.length > 0) {
            const checksSql = table.checks.map((check)=>{
                const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);
                return `CONSTRAINT "${checkName}" CHECK (${check.expression})`;
            }).join(", ");
            sql += `, ${checksSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
            const foreignKeysSql = table.foreignKeys.map((fk)=>{
                const columnNames = fk.columnNames.map((columnName)=>`"${columnName}"`).join(", ");
                if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
                const referencedColumnNames = fk.referencedColumnNames.map((columnName)=>`"${columnName}"`).join(", ");
                let constraint = `CONSTRAINT "${fk.name}" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
                if (fk.onDelete && fk.onDelete !== "NO ACTION") {
                    // Oracle does not support NO ACTION, but we set NO ACTION by default in EntityMetadata
                    constraint += ` ON DELETE ${fk.onDelete}`;
                }
                return constraint;
            }).join(", ");
            sql += `, ${foreignKeysSql}`;
        }
        const primaryColumns = table.columns.filter((column)=>column.isPrimary);
        if (primaryColumns.length > 0) {
            const primaryKeyName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map((column)=>column.name));
            const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
            sql += `, CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNames})`;
        }
        sql += `)`;
        return new Query_1.Query(sql);
    }
    /**
     * Builds drop table sql.
     */ dropTableSql(tableOrName, ifExist) {
        const query = ifExist ? `DROP TABLE IF EXISTS ${this.escapePath(tableOrName)}` : `DROP TABLE ${this.escapePath(tableOrName)}`;
        return new Query_1.Query(query);
    }
    createViewSql(view) {
        const materializedClause = view.materialized ? "MATERIALIZED " : "";
        if (typeof view.expression === "string") {
            return new Query_1.Query(`CREATE ${materializedClause}VIEW ${this.escapePath(view)} AS ${view.expression}`);
        } else {
            return new Query_1.Query(`CREATE ${materializedClause}VIEW ${this.escapePath(view)} AS ${view.expression(this.connection).getQuery()}`);
        }
    }
    insertViewDefinitionSql(view) {
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        const type = view.materialized ? MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW : MetadataTableType_1.MetadataTableType.VIEW;
        const { schema, tableName } = this.driver.parseTableName(view);
        return this.insertTypeormMetadataSql({
            type: type,
            name: tableName,
            schema: schema,
            value: expression
        });
    }
    /**
     * Builds drop view sql.
     */ dropViewSql(view) {
        const materializedClause = view.materialized ? "MATERIALIZED " : "";
        return new Query_1.Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);
    }
    /**
     * Builds remove view sql.
     */ deleteViewDefinitionSql(view) {
        const type = view.materialized ? MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW : MetadataTableType_1.MetadataTableType.VIEW;
        return this.deleteTypeormMetadataSql({
            type,
            name: view.name
        });
    }
    /**
     * Builds create index sql.
     */ createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName)=>`"${columnName}"`).join(", ");
        return new Query_1.Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX "${index.name}" ON ${this.escapePath(table)} (${columns})`);
    }
    /**
     * Builds drop index sql.
     */ dropIndexSql(indexOrName) {
        const indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
        return new Query_1.Query(`DROP INDEX "${indexName}"`);
    }
    /**
     * Builds create primary key sql.
     */ createPrimaryKeySql(table, columnNames, constraintName) {
        const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
        const columnNamesString = columnNames.map((columnName)=>`"${columnName}"`).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${primaryKeyName}" PRIMARY KEY (${columnNamesString})`);
    }
    /**
     * Builds drop primary key sql.
     */ dropPrimaryKeySql(table) {
        if (!table.primaryColumns.length) throw new error_1.TypeORMError(`Table ${table} has no primary keys.`);
        const columnNames = table.primaryColumns.map((column)=>column.name);
        const constraintName = table.primaryColumns[0].primaryKeyConstraintName;
        const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${primaryKeyName}"`);
    }
    /**
     * Builds create unique constraint sql.
     */ createUniqueConstraintSql(table, uniqueConstraint) {
        const columnNames = uniqueConstraint.columnNames.map((column)=>`"` + column + `"`).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${uniqueConstraint.name}" UNIQUE (${columnNames})`);
    }
    /**
     * Builds drop unique constraint sql.
     */ dropUniqueConstraintSql(table, uniqueOrName) {
        const uniqueName = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName.name : uniqueOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${uniqueName}"`);
    }
    /**
     * Builds create check constraint sql.
     */ createCheckConstraintSql(table, checkConstraint) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${checkConstraint.name}" CHECK (${checkConstraint.expression})`);
    }
    /**
     * Builds drop check constraint sql.
     */ dropCheckConstraintSql(table, checkOrName) {
        const checkName = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName.name : checkOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${checkName}"`);
    }
    /**
     * Builds create foreign key sql.
     */ createForeignKeySql(table, foreignKey) {
        const columnNames = foreignKey.columnNames.map((column)=>`"` + column + `"`).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column)=>`"` + column + `"`).join(",");
        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT "${foreignKey.name}" FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))} (${referencedColumnNames})`;
        // Oracle does not support NO ACTION, but we set NO ACTION by default in EntityMetadata
        if (foreignKey.onDelete && foreignKey.onDelete !== "NO ACTION") {
            sql += ` ON DELETE ${foreignKey.onDelete}`;
        }
        return new Query_1.Query(sql);
    }
    /**
     * Builds drop foreign key sql.
     */ dropForeignKeySql(table, foreignKeyOrName) {
        const foreignKeyName = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT "${foreignKeyName}"`);
    }
    /**
     * Builds a query for create column.
     */ buildCreateColumnSql(column) {
        let c = `"${column.name}" ` + this.connection.driver.createFullType(column);
        if (column.charset) c += " CHARACTER SET " + column.charset;
        if (column.collation) c += " COLLATE " + column.collation;
        if (column.asExpression) c += ` AS (${column.asExpression}) VIRTUAL`;
        if (column.default !== undefined && column.default !== null) // DEFAULT must be placed before NOT NULL
        c += " DEFAULT " + column.default;
        if (column.isNullable !== true && !column.isGenerated) // NOT NULL is not supported with GENERATED
        c += " NOT NULL";
        if (column.isGenerated === true && column.generationStrategy === "increment") c += " GENERATED BY DEFAULT AS IDENTITY";
        return c;
    }
    /**
     * Escapes given table or view path.
     */ escapePath(target) {
        // Ignore database when escaping paths
        const { schema, tableName } = this.driver.parseTableName(target);
        if (schema && schema !== this.driver.schema) {
            return `"${schema}"."${tableName}"`;
        }
        return `"${tableName}"`;
    }
    /**
     * Change table comment.
     */ changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`oracle driver does not support change table comment.`);
    }
}
exports.OracleQueryRunner = OracleQueryRunner; //# sourceMappingURL=OracleQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/oracle/OracleDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OracleDriver = void 0;
const ConnectionIsNotSetError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/ConnectionIsNotSetError.js [app-route] (ecmascript)");
const DriverPackageNotInstalledError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/DriverPackageNotInstalledError.js [app-route] (ecmascript)");
const OracleQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/oracle/OracleQueryRunner.js [app-route] (ecmascript)");
const DateUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/DateUtils.js [app-route] (ecmascript)");
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const RdbmsSchemaBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/RdbmsSchemaBuilder.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const ApplyValueTransformers_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Organizes communication with Oracle RDBMS.
 */ class OracleDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        /**
         * Pool for slave databases.
         * Used in replication.
         */ this.slaves = [];
        /**
         * Indicates if replication is enabled.
         */ this.isReplicated = false;
        /**
         * Indicates if tree tables are supported by this driver.
         */ this.treeSupport = true;
        /**
         * Represent transaction support by this driver
         */ this.transactionSupport = "nested";
        /**
         * Gets list of supported column data types by a driver.
         *
         * @see https://www.techonthenet.com/oracle/datatypes.php
         * @see https://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT012
         */ this.supportedDataTypes = [
            "char",
            "nchar",
            "nvarchar2",
            "varchar2",
            "long",
            "raw",
            "long raw",
            "number",
            "numeric",
            "float",
            "dec",
            "decimal",
            "integer",
            "int",
            "smallint",
            "real",
            "double precision",
            "date",
            "timestamp",
            "timestamp with time zone",
            "timestamp with local time zone",
            "interval year to month",
            "interval day to second",
            "bfile",
            "blob",
            "clob",
            "nclob",
            "rowid",
            "urowid",
            "simple-json",
            "json"
        ];
        /**
         * Returns type of upsert supported by driver if any
         */ this.supportedUpsertTypes = [];
        /**
         * Returns list of supported onDelete types by driver.
         * https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/sql-language-reference.pdf
         * Oracle does not support NO ACTION, but NO ACTION is set by default in EntityMetadata
         */ this.supportedOnDeleteTypes = [
            "CASCADE",
            "SET NULL",
            "NO ACTION"
        ];
        /**
         * Returns list of supported onUpdate types by driver.
         * Oracle does not have onUpdate option, but we allow NO ACTION since it is set by default in EntityMetadata
         */ this.supportedOnUpdateTypes = [
            "NO ACTION"
        ];
        /**
         * Gets list of spatial column data types.
         */ this.spatialTypes = [];
        /**
         * Gets list of column data types that support length by a driver.
         */ this.withLengthColumnTypes = [
            "char",
            "nchar",
            "nvarchar2",
            "varchar2",
            "varchar",
            "raw"
        ];
        /**
         * Gets list of column data types that support precision by a driver.
         */ this.withPrecisionColumnTypes = [
            "number",
            "float",
            "timestamp",
            "timestamp with time zone",
            "timestamp with local time zone"
        ];
        /**
         * Gets list of column data types that support scale by a driver.
         */ this.withScaleColumnTypes = [
            "number"
        ];
        /**
         * Orm has special columns and we need to know what database column types should be for those types.
         * Column types are driver dependant.
         */ this.mappedDataTypes = {
            createDate: "timestamp",
            createDateDefault: "CURRENT_TIMESTAMP",
            updateDate: "timestamp",
            updateDateDefault: "CURRENT_TIMESTAMP",
            deleteDate: "timestamp",
            deleteDateNullable: true,
            version: "number",
            treeLevel: "number",
            migrationId: "number",
            migrationName: "varchar2",
            migrationTimestamp: "number",
            cacheId: "number",
            cacheIdentifier: "varchar2",
            cacheTime: "number",
            cacheDuration: "number",
            cacheQuery: "clob",
            cacheResult: "clob",
            metadataType: "varchar2",
            metadataDatabase: "varchar2",
            metadataSchema: "varchar2",
            metadataTable: "varchar2",
            metadataName: "varchar2",
            metadataValue: "clob"
        };
        /**
         * The prefix used for the parameters
         */ this.parametersPrefix = ":";
        /**
         * Default values of length, precision and scale depends on column data type.
         * Used in the cases when length/precision/scale is not specified by user.
         */ this.dataTypeDefaults = {
            char: {
                length: 1
            },
            nchar: {
                length: 1
            },
            varchar: {
                length: 255
            },
            varchar2: {
                length: 255
            },
            nvarchar2: {
                length: 255
            },
            raw: {
                length: 2000
            },
            float: {
                precision: 126
            },
            timestamp: {
                precision: 6
            },
            "timestamp with time zone": {
                precision: 6
            },
            "timestamp with local time zone": {
                precision: 6
            }
        };
        /**
         * Max length allowed by Oracle for aliases.
         * @see https://docs.oracle.com/database/121/SQLRF/sql_elements008.htm#SQLRF51129
         * > The following list of rules applies to both quoted and nonquoted identifiers unless otherwise indicated
         * > Names must be from 1 to 30 bytes long with these exceptions:
         * > [...]
         *
         * Since Oracle 12.2 (with a compatible driver/client), the limit has been set to 128.
         * @see https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sqlrf/Database-Object-Names-and-Qualifiers.html
         *
         * > If COMPATIBLE is set to a value of 12.2 or higher, then names must be from 1 to 128 bytes long with these exceptions
         */ this.maxAliasLength = 29;
        this.cteCapabilities = {
            enabled: true
        };
        this.dummyTableName = "DUAL";
        this.connection = connection;
        this.options = connection.options;
        if (this.options.useUTC === true) {
            process.env.ORA_SDTZ = "UTC";
        }
        // load oracle package
        this.loadDependencies();
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options.replication ? this.options.replication.master : this.options).database;
        this.schema = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).schema;
    // Object.assign(connection.options, DriverUtils.buildDriverOptions(connection.options)); // todo: do it better way
    // validate options to make sure everything is set
    // if (!this.options.host)
    //     throw new DriverOptionNotSetError("host");
    // if (!this.options.username)
    //     throw new DriverOptionNotSetError("username");
    // if (!this.options.sid)
    //     throw new DriverOptionNotSetError("sid");
    //
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Performs connection to the database.
     * Based on pooling options, it can either create connection immediately,
     * either create a pool and create connection when needed.
     */ async connect() {
        this.oracle.fetchAsString = [
            this.oracle.DB_TYPE_CLOB
        ];
        this.oracle.fetchAsBuffer = [
            this.oracle.DB_TYPE_BLOB
        ];
        if (this.options.replication) {
            this.slaves = await Promise.all(this.options.replication.slaves.map((slave)=>{
                return this.createPool(this.options, slave);
            }));
            this.master = await this.createPool(this.options, this.options.replication.master);
        } else {
            this.master = await this.createPool(this.options, this.options);
        }
        if (!this.database || !this.schema) {
            const queryRunner = this.createQueryRunner("master");
            if (!this.database) {
                this.database = await queryRunner.getCurrentDatabase();
            }
            if (!this.schema) {
                this.schema = await queryRunner.getCurrentSchema();
            }
            await queryRunner.release();
        }
    }
    /**
     * Makes any action after connection (e.g. create extensions in Postgres driver).
     */ afterConnect() {
        return Promise.resolve();
    }
    /**
     * Closes connection with the database.
     */ async disconnect() {
        if (!this.master) return Promise.reject(new ConnectionIsNotSetError_1.ConnectionIsNotSetError("oracle"));
        await this.closePool(this.master);
        await Promise.all(this.slaves.map((slave)=>this.closePool(slave)));
        this.master = undefined;
        this.slaves = [];
    }
    /**
     * Creates a schema builder used to build and sync a schema.
     */ createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
    }
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        return new OracleQueryRunner_1.OracleQueryRunner(this, mode);
    }
    /**
     * Replaces parameters in the given sql with special escaping character
     * and an array of parameter names to be passed to a query.
     */ escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key)=>{
            if (typeof nativeParameters[key] === "boolean") return nativeParameters[key] ? 1 : 0;
            return nativeParameters[key];
        });
        if (!parameters || !Object.keys(parameters).length) return [
            sql,
            escapedParameters
        ];
        const parameterIndexMap = new Map();
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key)=>{
            if (!parameters.hasOwnProperty(key)) {
                return full;
            }
            if (parameterIndexMap.has(key)) {
                return this.parametersPrefix + parameterIndexMap.get(key);
            }
            const value = parameters[key];
            if (isArray) {
                return value.map((v)=>{
                    escapedParameters.push(v);
                    return this.createParameter(key, escapedParameters.length - 1);
                }).join(", ");
            }
            if (typeof value === "function") {
                return value();
            }
            if (typeof value === "boolean") {
                return value ? "1" : "0";
            }
            escapedParameters.push(value);
            parameterIndexMap.set(key, escapedParameters.length);
            return this.createParameter(key, escapedParameters.length - 1);
        }); // todo: make replace only in value statements, otherwise problems
        return [
            sql,
            escapedParameters
        ];
    }
    /**
     * Escapes a column name.
     */ escape(columnName) {
        return `"${columnName}"`;
    }
    /**
     * Build full table name with database name, schema name and table name.
     * Oracle does not support table schemas. One user can have only one schema.
     */ buildTableName(tableName, schema, database) {
        const tablePath = [
            tableName
        ];
        if (schema) {
            tablePath.unshift(schema);
        }
        return tablePath.join(".");
    }
    /**
     * Parse a target table name or other types and return a normalized table definition.
     */ parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = this.schema;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
            const parsed = this.parseTableName(target.name);
            return {
                database: target.database || parsed.database || driverDatabase,
                schema: target.schema || parsed.schema || driverSchema,
                tableName: parsed.tableName
            };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
            const parsed = this.parseTableName(target.referencedTableName);
            return {
                database: target.referencedDatabase || parsed.database || driverDatabase,
                schema: target.referencedSchema || parsed.schema || driverSchema,
                tableName: parsed.tableName
            };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
            // EntityMetadata tableName is never a path
            return {
                database: target.database || driverDatabase,
                schema: target.schema || driverSchema,
                tableName: target.tableName
            };
        }
        const parts = target.split(".");
        if (parts.length === 3) {
            return {
                database: parts[0] || driverDatabase,
                schema: parts[1] || driverSchema,
                tableName: parts[2]
            };
        } else if (parts.length === 2) {
            return {
                database: driverDatabase,
                schema: parts[0] || driverSchema,
                tableName: parts[1]
            };
        } else {
            return {
                database: driverDatabase,
                schema: driverSchema,
                tableName: target
            };
        }
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type and metadata.
     */ preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === undefined) return value;
        if (columnMetadata.type === Boolean) {
            return value ? 1 : 0;
        } else if (columnMetadata.type === "date") {
            if (typeof value === "string") value = value.replace(/[^0-9-]/g, "");
            return ()=>`TO_DATE('${DateUtils_1.DateUtils.mixedDateToDateString(value)}', 'YYYY-MM-DD')`;
        } else if (columnMetadata.type === Date || columnMetadata.type === "timestamp" || columnMetadata.type === "timestamp with time zone" || columnMetadata.type === "timestamp with local time zone") {
            return DateUtils_1.DateUtils.mixedDateToDate(value);
        } else if (columnMetadata.type === "simple-array") {
            return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-json") {
            return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "json") {
            return DateUtils_1.DateUtils.simpleJsonToString(value);
        }
        return value;
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type or metadata.
     */ prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === Boolean) {
            value = !!value;
        } else if (columnMetadata.type === "date") {
            value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
            value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === Date || columnMetadata.type === "timestamp" || columnMetadata.type === "timestamp with time zone" || columnMetadata.type === "timestamp with local time zone") {
            value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "simple-array") {
            value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-json") {
            value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if (columnMetadata.type === Number) {
            // convert to number if number
            value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
    }
    /**
     * Creates a database type from a given column metadata.
     */ normalizeType(column) {
        if (column.type === Number || column.type === Boolean || column.type === "numeric" || column.type === "dec" || column.type === "decimal" || column.type === "int" || column.type === "integer" || column.type === "smallint") {
            return "number";
        } else if (column.type === "real" || column.type === "double precision") {
            return "float";
        } else if (column.type === String || column.type === "varchar") {
            return "varchar2";
        } else if (column.type === Date) {
            return "timestamp";
        } else if (column.type === Buffer) {
            return "blob";
        } else if (column.type === "uuid") {
            return "varchar2";
        } else if (column.type === "simple-array") {
            return "clob";
        } else if (column.type === "simple-json") {
            return "clob";
        } else if (column.type === "json") {
            return "json";
        } else {
            return column.type || "";
        }
    }
    /**
     * Normalizes "default" value of the column.
     */ normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (typeof defaultValue === "number") {
            return "" + defaultValue;
        }
        if (typeof defaultValue === "boolean") {
            return defaultValue ? "1" : "0";
        }
        if (typeof defaultValue === "function") {
            return defaultValue();
        }
        if (typeof defaultValue === "string") {
            return `'${defaultValue}'`;
        }
        if (defaultValue === null || defaultValue === undefined) {
            return undefined;
        }
        return `${defaultValue}`;
    }
    /**
     * Normalizes "isUnique" value of the column.
     */ normalizeIsUnique(column) {
        return column.entityMetadata.uniques.some((uq)=>uq.columns.length === 1 && uq.columns[0] === column);
    }
    /**
     * Calculates column length taking into account the default length values.
     */ getColumnLength(column) {
        if (column.length) return column.length.toString();
        switch(column.type){
            case String:
            case "varchar":
            case "varchar2":
            case "nvarchar2":
                return "255";
            case "raw":
                return "2000";
            case "uuid":
                return "36";
            default:
                return "";
        }
    }
    createFullType(column) {
        let type = column.type;
        // used 'getColumnLength()' method, because in Oracle column length is required for some data types.
        if (this.getColumnLength(column)) {
            type += `(${this.getColumnLength(column)})`;
        } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {
            type += "(" + column.precision + "," + column.scale + ")";
        } else if (column.precision !== null && column.precision !== undefined) {
            type += "(" + column.precision + ")";
        }
        if (column.type === "timestamp with time zone") {
            type = "TIMESTAMP" + (column.precision !== null && column.precision !== undefined ? "(" + column.precision + ")" : "") + " WITH TIME ZONE";
        } else if (column.type === "timestamp with local time zone") {
            type = "TIMESTAMP" + (column.precision !== null && column.precision !== undefined ? "(" + column.precision + ")" : "") + " WITH LOCAL TIME ZONE";
        }
        if (column.isArray) type += " array";
        return type;
    }
    /**
     * Obtains a new database connection to a master server.
     * Used for replication.
     * If replication is not setup then returns default connection's database connection.
     */ obtainMasterConnection() {
        return new Promise((ok, fail)=>{
            if (!this.master) {
                return fail(new error_1.TypeORMError("Driver not Connected"));
            }
            this.master.getConnection((err, connection, release)=>{
                if (err) return fail(err);
                ok(connection);
            });
        });
    }
    /**
     * Obtains a new database connection to a slave server.
     * Used for replication.
     * If replication is not setup then returns master (default) connection's database connection.
     */ obtainSlaveConnection() {
        if (!this.slaves.length) return this.obtainMasterConnection();
        return new Promise((ok, fail)=>{
            const random = Math.floor(Math.random() * this.slaves.length);
            this.slaves[random].getConnection((err, connection)=>{
                if (err) return fail(err);
                ok(connection);
            });
        });
    }
    /**
     * Creates generated map of values generated or returned by database after INSERT query.
     */ createGeneratedMap(metadata, insertResult) {
        if (!insertResult) return undefined;
        return Object.keys(insertResult).reduce((map, key)=>{
            const column = metadata.findColumnWithDatabaseName(key);
            if (column) {
                OrmUtils_1.OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column)));
            }
            return map;
        }, {});
    }
    /**
     * Differentiate columns of this table and columns from the given column metadatas columns
     * and returns only changed.
     */ findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata)=>{
            const tableColumn = tableColumns.find((c)=>c.name === columnMetadata.databaseName);
            if (!tableColumn) return false; // we don't need new columns, we only need exist and changed
            const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== this.getColumnLength(columnMetadata) || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || // || tableColumn.comment !== columnMetadata.comment
            tableColumn.default !== this.normalizeDefault(columnMetadata) || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
            // DEBUG SECTION
            // if (isColumnChanged) {
            //     console.log("table:", columnMetadata.entityMetadata.tableName)
            //     console.log(
            //         "name:",
            //         tableColumn.name,
            //         columnMetadata.databaseName,
            //     )
            //     console.log(
            //         "type:",
            //         tableColumn.type,
            //         this.normalizeType(columnMetadata),
            //     )
            //     console.log(
            //         "length:",
            //         tableColumn.length,
            //         columnMetadata.length,
            //     )
            //     console.log(
            //         "precision:",
            //         tableColumn.precision,
            //         columnMetadata.precision,
            //     )
            //     console.log("scale:", tableColumn.scale, columnMetadata.scale)
            //     console.log(
            //         "comment:",
            //         tableColumn.comment,
            //         columnMetadata.comment,
            //     )
            //     console.log(
            //         "default:",
            //         tableColumn.default,
            //         this.normalizeDefault(columnMetadata),
            //     )
            //     console.log(
            //         "enum:",
            //         tableColumn.enum &&
            //             columnMetadata.enum &&
            //             !OrmUtils.isArraysEqual(
            //                 tableColumn.enum,
            //                 columnMetadata.enum.map((val) => val + ""),
            //             ),
            //     )
            //     console.log(
            //         "onUpdate:",
            //         tableColumn.onUpdate,
            //         columnMetadata.onUpdate,
            //     )
            //     console.log(
            //         "isPrimary:",
            //         tableColumn.isPrimary,
            //         columnMetadata.isPrimary,
            //     )
            //     console.log(
            //         "isNullable:",
            //         tableColumn.isNullable,
            //         columnMetadata.isNullable,
            //     )
            //     console.log(
            //         "asExpression:",
            //         tableColumn.asExpression,
            //         columnMetadata.asExpression,
            //     )
            //     console.log(
            //         "generatedType:",
            //         tableColumn.generatedType,
            //         columnMetadata.generatedType,
            //     )
            //     console.log(
            //         "isUnique:",
            //         tableColumn.isUnique,
            //         this.normalizeIsUnique(columnMetadata),
            //     )
            //     console.log(
            //         "isGenerated:",
            //         tableColumn.isGenerated,
            //         columnMetadata.isGenerated,
            //     )
            //     console.log("==========================================")
            // }
            return isColumnChanged;
        });
    }
    /**
     * Returns true if driver supports RETURNING / OUTPUT statement.
     */ isReturningSqlSupported() {
        return true;
    }
    /**
     * Returns true if driver supports uuid values generation on its own.
     */ isUUIDGenerationSupported() {
        return false;
    }
    /**
     * Returns true if driver supports fulltext indices.
     */ isFullTextColumnTypeSupported() {
        return false;
    }
    /**
     * Creates an escaped parameter.
     */ createParameter(parameterName, index) {
        return this.parametersPrefix + (index + 1);
    }
    /**
     * Converts column type in to native oracle type.
     */ columnTypeToNativeParameter(type) {
        switch(this.normalizeType({
            type: type
        })){
            case "number":
            case "numeric":
            case "int":
            case "integer":
            case "smallint":
            case "dec":
            case "decimal":
                return this.oracle.DB_TYPE_NUMBER;
            case "char":
            case "nchar":
            case "nvarchar2":
            case "varchar2":
                return this.oracle.DB_TYPE_VARCHAR;
            case "blob":
                return this.oracle.DB_TYPE_BLOB;
            case "simple-json":
            case "clob":
                return this.oracle.DB_TYPE_CLOB;
            case "date":
            case "timestamp":
            case "timestamp with time zone":
            case "timestamp with local time zone":
                return this.oracle.DB_TYPE_TIMESTAMP;
            case "json":
                return this.oracle.DB_TYPE_JSON;
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Loads all driver dependencies.
     */ loadDependencies() {
        try {
            const oracle = this.options.driver || PlatformTools_1.PlatformTools.load("oracledb");
            this.oracle = oracle;
        } catch (e) {
            throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Oracle", "oracledb");
        }
        const thickMode = this.options.thickMode;
        if (thickMode) {
            typeof thickMode === "object" ? this.oracle.initOracleClient(thickMode) : this.oracle.initOracleClient();
        }
    }
    /**
     * Creates a new connection pool for a given database credentials.
     */ async createPool(options, credentials) {
        credentials = Object.assign({}, credentials, DriverUtils_1.DriverUtils.buildDriverOptions(credentials)); // todo: do it better way
        if (!credentials.connectString) {
            let address = `(PROTOCOL=TCP)`;
            if (credentials.host) {
                address += `(HOST=${credentials.host})`;
            }
            if (credentials.port) {
                address += `(PORT=${credentials.port})`;
            }
            let connectData = `(SERVER=DEDICATED)`;
            if (credentials.sid) {
                connectData += `(SID=${credentials.sid})`;
            }
            if (credentials.serviceName) {
                connectData += `(SERVICE_NAME=${credentials.serviceName})`;
            }
            const connectString = `(DESCRIPTION=(ADDRESS=${address})(CONNECT_DATA=${connectData}))`;
            Object.assign(credentials, {
                connectString
            });
        }
        // build connection options for the driver
        const connectionOptions = Object.assign({}, {
            user: credentials.username,
            password: credentials.password,
            connectString: credentials.connectString
        }, {
            poolMax: options.poolSize
        }, options.extra || {});
        // pooling is enabled either when its set explicitly to true,
        // either when its not defined at all (e.g. enabled by default)
        return new Promise((ok, fail)=>{
            this.oracle.createPool(connectionOptions, (err, pool)=>{
                if (err) return fail(err);
                ok(pool);
            });
        });
    }
    /**
     * Closes connection pool.
     */ async closePool(pool) {
        return new Promise((ok, fail)=>{
            pool.close((err)=>err ? fail(err) : ok());
            pool = undefined;
        });
    }
}
exports.OracleDriver = OracleDriver; //# sourceMappingURL=OracleDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AbstractSqliteQueryRunner = void 0;
const TransactionNotStartedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TransactionNotStartedError.js [app-route] (ecmascript)");
const TableColumn_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableColumn.js [app-route] (ecmascript)");
const Table_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/Table.js [app-route] (ecmascript)");
const TableIndex_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableIndex.js [app-route] (ecmascript)");
const TableForeignKey_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableForeignKey.js [app-route] (ecmascript)");
const View_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/view/View.js [app-route] (ecmascript)");
const Query_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/Query.js [app-route] (ecmascript)");
const TableUnique_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableUnique.js [app-route] (ecmascript)");
const BaseQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/BaseQueryRunner.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const TableCheck_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableCheck.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const MetadataTableType_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/types/MetadataTableType.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Runs queries on a single sqlite database connection.
 */ class AbstractSqliteQueryRunner extends BaseQueryRunner_1.BaseQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(){
        super();
        this.transactionPromise = null;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates/uses database connection from the connection pool to perform further operations.
     * Returns obtained database connection.
     */ connect() {
        return Promise.resolve(this.driver.databaseConnection);
    }
    /**
     * Releases used database connection.
     * We just clear loaded tables and sql in memory, because sqlite do not support multiple connections thus query runners.
     */ release() {
        this.loadedTables = [];
        this.clearSqlMemory();
        return Promise.resolve();
    }
    /**
     * Starts transaction.
     */ async startTransaction(isolationLevel) {
        if (this.driver.transactionSupport === "none") throw new error_1.TypeORMError(`Transactions aren't supported by ${this.connection.driver.options.type}.`);
        if (this.isTransactionActive && this.driver.transactionSupport === "simple") throw new error_1.TransactionAlreadyStartedError();
        if (isolationLevel && isolationLevel !== "READ UNCOMMITTED" && isolationLevel !== "SERIALIZABLE") throw new error_1.TypeORMError(`SQLite only supports SERIALIZABLE and READ UNCOMMITTED isolation`);
        this.isTransactionActive = true;
        try {
            await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
            this.isTransactionActive = false;
            throw err;
        }
        if (this.transactionDepth === 0) {
            if (isolationLevel) {
                if (isolationLevel === "READ UNCOMMITTED") {
                    await this.query("PRAGMA read_uncommitted = true");
                } else {
                    await this.query("PRAGMA read_uncommitted = false");
                }
            }
            await this.query("BEGIN TRANSACTION");
        } else {
            await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
    }
    /**
     * Commits transaction.
     * Error will be thrown if transaction was not started.
     */ async commitTransaction() {
        if (!this.isTransactionActive) throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth > 1) {
            await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
            await this.query("COMMIT");
            this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
    }
    /**
     * Rollbacks transaction.
     * Error will be thrown if transaction was not started.
     */ async rollbackTransaction() {
        if (!this.isTransactionActive) throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
            await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
            await this.query("ROLLBACK");
            this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
    }
    /**
     * Returns raw data stream.
     */ stream(query, parameters, onEnd, onError) {
        throw new error_1.TypeORMError(`Stream is not supported by sqlite driver.`);
    }
    /**
     * Returns all available database names including system databases.
     */ async getDatabases() {
        return Promise.resolve([]);
    }
    /**
     * Returns all available schema names including system schemas.
     * If database parameter specified, returns schemas of that database.
     */ async getSchemas(database) {
        return Promise.resolve([]);
    }
    /**
     * Checks if database with the given name exist.
     */ async hasDatabase(database) {
        return Promise.resolve(false);
    }
    /**
     * Loads currently using database
     */ async getCurrentDatabase() {
        return Promise.resolve(undefined);
    }
    /**
     * Checks if schema with the given name exist.
     */ async hasSchema(schema) {
        throw new error_1.TypeORMError(`This driver does not support table schemas`);
    }
    /**
     * Loads currently using database schema
     */ async getCurrentSchema() {
        return Promise.resolve(undefined);
    }
    /**
     * Checks if table with the given name exist in the database.
     */ async hasTable(tableOrName) {
        const tableName = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;
        const sql = `SELECT * FROM "sqlite_master" WHERE "type" = 'table' AND "name" = '${tableName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
    }
    /**
     * Checks if column with the given name exist in the given table.
     */ async hasColumn(tableOrName, columnName) {
        const tableName = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;
        const sql = `PRAGMA table_xinfo(${this.escapePath(tableName)})`;
        const columns = await this.query(sql);
        return !!columns.find((column)=>column["name"] === columnName);
    }
    /**
     * Creates a new database.
     */ async createDatabase(database, ifNotExist) {
        return Promise.resolve();
    }
    /**
     * Drops database.
     */ async dropDatabase(database, ifExist) {
        return Promise.resolve();
    }
    /**
     * Creates a new table schema.
     */ async createSchema(schemaPath, ifNotExist) {
        return Promise.resolve();
    }
    /**
     * Drops table schema.
     */ async dropSchema(schemaPath, ifExist) {
        return Promise.resolve();
    }
    /**
     * Creates a new table.
     */ async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
        const upQueries = [];
        const downQueries = [];
        if (ifNotExist) {
            const isTableExist = await this.hasTable(table);
            if (isTableExist) return Promise.resolve();
        }
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        if (createIndices) {
            table.indices.forEach((index)=>{
                // new index may be passed without name. In this case we generate index name manually.
                if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
                upQueries.push(this.createIndexSql(table, index));
                downQueries.push(this.dropIndexSql(index));
            });
        }
        // if table have column with generated type, we must add the expression to the metadata table
        const generatedColumns = table.columns.filter((column)=>column.generatedType && column.asExpression);
        for (const column of generatedColumns){
            const insertQuery = this.insertTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            upQueries.push(insertQuery);
            downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Drops the table.
     */ async dropTable(tableOrName, ifExist, dropForeignKeys = true, dropIndices = true) {
        if (ifExist) {
            const isTableExist = await this.hasTable(tableOrName);
            if (!isTableExist) return Promise.resolve();
        }
        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.
        const createForeignKeys = dropForeignKeys;
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const upQueries = [];
        const downQueries = [];
        if (dropIndices) {
            table.indices.forEach((index)=>{
                upQueries.push(this.dropIndexSql(index));
                downQueries.push(this.createIndexSql(table, index));
            });
        }
        upQueries.push(this.dropTableSql(table, ifExist));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        // if table had columns with generated type, we must remove the expression from the metadata table
        const generatedColumns = table.columns.filter((column)=>column.generatedType && column.asExpression);
        for (const column of generatedColumns){
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            const insertQuery = this.insertTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            upQueries.push(deleteQuery);
            downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Creates a new view.
     */ async createView(view, syncWithMetadata = false) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        if (syncWithMetadata) upQueries.push(this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        if (syncWithMetadata) downQueries.push(this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Drops the view.
     */ async dropView(target) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Renames the given table.
     */ async renameTable(oldTableOrName, newTableName) {
        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);
        const newTable = oldTable.clone();
        newTable.name = newTableName;
        // rename table
        const up = new Query_1.Query(`ALTER TABLE ${this.escapePath(oldTable.name)} RENAME TO ${this.escapePath(newTableName)}`);
        const down = new Query_1.Query(`ALTER TABLE ${this.escapePath(newTableName)} RENAME TO ${this.escapePath(oldTable.name)}`);
        await this.executeQueries(up, down);
        // rename unique constraints
        newTable.uniques.forEach((unique)=>{
            const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);
            // Skip renaming if Unique has user defined constraint name
            if (unique.name !== oldUniqueName) return;
            unique.name = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);
        });
        // rename foreign key constraints
        newTable.foreignKeys.forEach((foreignKey)=>{
            const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
            // Skip renaming if foreign key has user defined constraint name
            if (foreignKey.name !== oldForeignKeyName) return;
            foreignKey.name = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        });
        // rename indices
        newTable.indices.forEach((index)=>{
            const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);
            // Skip renaming if Index has user defined constraint name
            if (index.name !== oldIndexName) return;
            index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
        });
        // rename old table;
        oldTable.name = newTable.name;
        // recreate table with new constraint names
        await this.recreateTable(newTable, oldTable);
    }
    /**
     * Creates a new column from the column in the table.
     */ async addColumn(tableOrName, column) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        return this.addColumns(table, [
            column
        ]);
    }
    /**
     * Creates a new columns from the column in the table.
     */ async addColumns(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        columns.forEach((column)=>changedTable.addColumn(column));
        await this.recreateTable(changedTable, table);
    }
    /**
     * Renames column in the given table.
     */ async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c)=>c.name === oldTableColumnOrName);
        if (!oldColumn) throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        let newColumn = undefined;
        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
            newColumn = newTableColumnOrName;
        } else {
            newColumn = oldColumn.clone();
            newColumn.name = newTableColumnOrName;
        }
        return this.changeColumn(table, oldColumn, newColumn);
    }
    /**
     * Changes a column in the table.
     */ async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c)=>c.name === oldTableColumnOrName);
        if (!oldColumn) throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        await this.changeColumns(table, [
            {
                oldColumn,
                newColumn
            }
        ]);
    }
    /**
     * Changes a column in the table.
     * Changed column looses all its keys in the db.
     */ async changeColumns(tableOrName, changedColumns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const changedTable = table.clone();
        changedColumns.forEach((changedColumnSet)=>{
            if (changedColumnSet.newColumn.name !== changedColumnSet.oldColumn.name) {
                changedTable.findColumnUniques(changedColumnSet.oldColumn).forEach((unique)=>{
                    const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);
                    unique.columnNames.splice(unique.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);
                    unique.columnNames.push(changedColumnSet.newColumn.name);
                    // rename Unique only if it has default constraint name
                    if (unique.name === uniqueName) {
                        unique.name = this.connection.namingStrategy.uniqueConstraintName(changedTable, unique.columnNames);
                    }
                });
                changedTable.findColumnForeignKeys(changedColumnSet.oldColumn).forEach((foreignKey)=>{
                    const foreignKeyName = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
                    foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);
                    foreignKey.columnNames.push(changedColumnSet.newColumn.name);
                    // rename FK only if it has default constraint name
                    if (foreignKey.name === foreignKeyName) {
                        foreignKey.name = this.connection.namingStrategy.foreignKeyName(changedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
                    }
                });
                changedTable.findColumnIndices(changedColumnSet.oldColumn).forEach((index)=>{
                    const indexName = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
                    index.columnNames.splice(index.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);
                    index.columnNames.push(changedColumnSet.newColumn.name);
                    // rename Index only if it has default constraint name
                    if (index.name === indexName) {
                        index.name = this.connection.namingStrategy.indexName(changedTable, index.columnNames, index.where);
                    }
                });
            }
            const originalColumn = changedTable.columns.find((column)=>column.name === changedColumnSet.oldColumn.name);
            if (originalColumn) changedTable.columns[changedTable.columns.indexOf(originalColumn)] = changedColumnSet.newColumn;
        });
        await this.recreateTable(changedTable, table);
    }
    /**
     * Drops column in the table.
     */ async dropColumn(tableOrName, columnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
        if (!column) throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
        await this.dropColumns(table, [
            column
        ]);
    }
    /**
     * Drops the columns in the table.
     */ async dropColumns(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // clone original table and remove column and its constraints from cloned table
        const changedTable = table.clone();
        columns.forEach((column)=>{
            const columnInstance = InstanceChecker_1.InstanceChecker.isTableColumn(column) ? column : table.findColumnByName(column);
            if (!columnInstance) throw new Error(`Column "${column}" was not found in table "${table.name}"`);
            changedTable.removeColumn(columnInstance);
            changedTable.findColumnUniques(columnInstance).forEach((unique)=>changedTable.removeUniqueConstraint(unique));
            changedTable.findColumnIndices(columnInstance).forEach((index)=>changedTable.removeIndex(index));
            changedTable.findColumnForeignKeys(columnInstance).forEach((fk)=>changedTable.removeForeignKey(fk));
        });
        await this.recreateTable(changedTable, table);
    }
    /**
     * Creates a new primary key.
     */ async createPrimaryKey(tableOrName, columnNames) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // clone original table and mark columns as primary
        const changedTable = table.clone();
        changedTable.columns.forEach((column)=>{
            if (columnNames.find((columnName)=>columnName === column.name)) column.isPrimary = true;
        });
        await this.recreateTable(changedTable, table);
        // mark columns as primary in original table
        table.columns.forEach((column)=>{
            if (columnNames.find((columnName)=>columnName === column.name)) column.isPrimary = true;
        });
    }
    /**
     * Updates composite primary keys.
     */ async updatePrimaryKeys(tableOrName, columns) {
        await Promise.resolve();
    }
    /**
     * Drops a primary key.
     */ async dropPrimaryKey(tableOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // clone original table and mark primary columns as non-primary
        const changedTable = table.clone();
        changedTable.primaryColumns.forEach((column)=>{
            column.isPrimary = false;
        });
        await this.recreateTable(changedTable, table);
        // mark primary columns as non-primary in original table
        table.primaryColumns.forEach((column)=>{
            column.isPrimary = false;
        });
    }
    /**
     * Creates a new unique constraint.
     */ async createUniqueConstraint(tableOrName, uniqueConstraint) {
        await this.createUniqueConstraints(tableOrName, [
            uniqueConstraint
        ]);
    }
    /**
     * Creates a new unique constraints.
     */ async createUniqueConstraints(tableOrName, uniqueConstraints) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // clone original table and add unique constraints in to cloned table
        const changedTable = table.clone();
        uniqueConstraints.forEach((uniqueConstraint)=>changedTable.addUniqueConstraint(uniqueConstraint));
        await this.recreateTable(changedTable, table);
    }
    /**
     * Drops an unique constraint.
     */ async dropUniqueConstraint(tableOrName, uniqueOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const uniqueConstraint = InstanceChecker_1.InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find((u)=>u.name === uniqueOrName);
        if (!uniqueConstraint) throw new error_1.TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);
        await this.dropUniqueConstraints(table, [
            uniqueConstraint
        ]);
    }
    /**
     * Creates an unique constraints.
     */ async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // clone original table and remove unique constraints from cloned table
        const changedTable = table.clone();
        uniqueConstraints.forEach((uniqueConstraint)=>changedTable.removeUniqueConstraint(uniqueConstraint));
        await this.recreateTable(changedTable, table);
    }
    /**
     * Creates new check constraint.
     */ async createCheckConstraint(tableOrName, checkConstraint) {
        await this.createCheckConstraints(tableOrName, [
            checkConstraint
        ]);
    }
    /**
     * Creates new check constraints.
     */ async createCheckConstraints(tableOrName, checkConstraints) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // clone original table and add check constraints in to cloned table
        const changedTable = table.clone();
        checkConstraints.forEach((checkConstraint)=>changedTable.addCheckConstraint(checkConstraint));
        await this.recreateTable(changedTable, table);
    }
    /**
     * Drops check constraint.
     */ async dropCheckConstraint(tableOrName, checkOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const checkConstraint = InstanceChecker_1.InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find((c)=>c.name === checkOrName);
        if (!checkConstraint) throw new error_1.TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
        await this.dropCheckConstraints(table, [
            checkConstraint
        ]);
    }
    /**
     * Drops check constraints.
     */ async dropCheckConstraints(tableOrName, checkConstraints) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // clone original table and remove check constraints from cloned table
        const changedTable = table.clone();
        checkConstraints.forEach((checkConstraint)=>changedTable.removeCheckConstraint(checkConstraint));
        await this.recreateTable(changedTable, table);
    }
    /**
     * Creates a new exclusion constraint.
     */ async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`Sqlite does not support exclusion constraints.`);
    }
    /**
     * Creates a new exclusion constraints.
     */ async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Sqlite does not support exclusion constraints.`);
    }
    /**
     * Drops exclusion constraint.
     */ async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`Sqlite does not support exclusion constraints.`);
    }
    /**
     * Drops exclusion constraints.
     */ async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Sqlite does not support exclusion constraints.`);
    }
    /**
     * Creates a new foreign key.
     */ async createForeignKey(tableOrName, foreignKey) {
        await this.createForeignKeys(tableOrName, [
            foreignKey
        ]);
    }
    /**
     * Creates a new foreign keys.
     */ async createForeignKeys(tableOrName, foreignKeys) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // clone original table and add foreign keys in to cloned table
        const changedTable = table.clone();
        foreignKeys.forEach((foreignKey)=>changedTable.addForeignKey(foreignKey));
        await this.recreateTable(changedTable, table);
    }
    /**
     * Drops a foreign key from the table.
     */ async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk)=>fk.name === foreignKeyOrName);
        if (!foreignKey) throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        await this.dropForeignKeys(tableOrName, [
            foreignKey
        ]);
    }
    /**
     * Drops a foreign keys from the table.
     */ async dropForeignKeys(tableOrName, foreignKeys) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // clone original table and remove foreign keys from cloned table
        const changedTable = table.clone();
        foreignKeys.forEach((foreignKey)=>changedTable.removeForeignKey(foreignKey));
        await this.recreateTable(changedTable, table);
    }
    /**
     * Creates a new index.
     */ async createIndex(tableOrName, index) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // new index may be passed without name. In this case we generate index name manually.
        if (!index.name) index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(index);
        await this.executeQueries(up, down);
        table.addIndex(index);
    }
    /**
     * Creates a new indices
     */ async createIndices(tableOrName, indices) {
        const promises = indices.map((index)=>this.createIndex(tableOrName, index));
        await Promise.all(promises);
    }
    /**
     * Drops an index from the table.
     */ async dropIndex(tableOrName, indexOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i)=>i.name === indexOrName);
        if (!index) throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        // old index may be passed without name. In this case we generate index name manually.
        if (!index.name) index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index);
    }
    /**
     * Drops an indices from the table.
     */ async dropIndices(tableOrName, indices) {
        const promises = indices.map((index)=>this.dropIndex(tableOrName, index));
        await Promise.all(promises);
    }
    /**
     * Clears all table contents.
     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
     */ async clearTable(tableName) {
        await this.query(`DELETE FROM ${this.escapePath(tableName)}`);
    }
    /**
     * Removes all tables from the currently connected database.
     */ async clearDatabase(database) {
        let dbPath = undefined;
        if (database && this.driver.getAttachedDatabaseHandleByRelativePath(database)) {
            dbPath = this.driver.getAttachedDatabaseHandleByRelativePath(database);
        }
        await this.query(`PRAGMA foreign_keys = OFF`);
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive) await this.startTransaction();
        try {
            const selectViewDropsQuery = dbPath ? `SELECT 'DROP VIEW "${dbPath}"."' || name || '";' as query FROM "${dbPath}"."sqlite_master" WHERE "type" = 'view'` : `SELECT 'DROP VIEW "' || name || '";' as query FROM "sqlite_master" WHERE "type" = 'view'`;
            const dropViewQueries = await this.query(selectViewDropsQuery);
            await Promise.all(dropViewQueries.map((q)=>this.query(q["query"])));
            const selectTableDropsQuery = dbPath ? `SELECT 'DROP TABLE "${dbPath}"."' || name || '";' as query FROM "${dbPath}"."sqlite_master" WHERE "type" = 'table' AND "name" != 'sqlite_sequence'` : `SELECT 'DROP TABLE "' || name || '";' as query FROM "sqlite_master" WHERE "type" = 'table' AND "name" != 'sqlite_sequence'`;
            const dropTableQueries = await this.query(selectTableDropsQuery);
            await Promise.all(dropTableQueries.map((q)=>this.query(q["query"])));
            if (!isAnotherTransactionActive) await this.commitTransaction();
        } catch (error) {
            try {
                // we throw original error even if rollback thrown an error
                if (!isAnotherTransactionActive) await this.rollbackTransaction();
            } catch (rollbackError) {}
            throw error;
        } finally{
            await this.query(`PRAGMA foreign_keys = ON`);
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    async loadViews(viewNames) {
        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
        if (!hasTable) {
            return [];
        }
        if (!viewNames) {
            viewNames = [];
        }
        const viewNamesString = viewNames.map((name)=>"'" + name + "'").join(", ");
        let query = `SELECT "t".* FROM "${this.getTypeormMetadataTableName()}" "t" INNER JOIN "sqlite_master" s ON "s"."name" = "t"."name" AND "s"."type" = 'view' WHERE "t"."type" = '${MetadataTableType_1.MetadataTableType.VIEW}'`;
        if (viewNamesString.length > 0) query += ` AND "t"."name" IN (${viewNamesString})`;
        const dbViews = await this.query(query);
        return dbViews.map((dbView)=>{
            const view = new View_1.View();
            view.name = dbView["name"];
            view.expression = dbView["value"];
            return view;
        });
    }
    async loadTableRecords(tablePath, tableOrIndex) {
        let database = undefined;
        const [schema, tableName] = this.splitTablePath(tablePath);
        if (schema && this.driver.getAttachedDatabasePathRelativeByHandle(schema)) {
            database = this.driver.getAttachedDatabasePathRelativeByHandle(schema);
        }
        return this.query(`SELECT ${database ? `'${database}'` : null} as database, ${schema ? `'${schema}'` : null} as schema, * FROM ${schema ? `"${schema}".` : ""}${this.escapePath(`sqlite_master`)} WHERE "type" = '${tableOrIndex}' AND "${tableOrIndex === "table" ? "name" : "tbl_name"}" IN ('${tableName}')`);
    }
    async loadPragmaRecords(tablePath, pragma) {
        const [, tableName] = this.splitTablePath(tablePath);
        return this.query(`PRAGMA ${pragma}("${tableName}")`);
    }
    /**
     * Loads all tables (with given names) from the database and creates a Table from them.
     */ async loadTables(tableNames) {
        // if no tables given then no need to proceed
        if (tableNames && tableNames.length === 0) {
            return [];
        }
        let dbTables = [];
        let dbIndicesDef;
        if (!tableNames) {
            const tablesSql = `SELECT * FROM "sqlite_master" WHERE "type" = 'table'`;
            dbTables.push(...await this.query(tablesSql));
            const tableNamesString = dbTables.map(({ name })=>`'${name}'`).join(", ");
            dbIndicesDef = await this.query(`SELECT * FROM "sqlite_master" WHERE "type" = 'index' AND "tbl_name" IN (${tableNamesString})`);
        } else {
            const tableNamesWithoutDot = tableNames.filter((tableName)=>{
                return tableName.split(".").length === 1;
            }).map((tableName)=>`'${tableName}'`);
            const tableNamesWithDot = tableNames.filter((tableName)=>{
                return tableName.split(".").length > 1;
            });
            const queryPromises = (type)=>{
                const promises = [
                    ...tableNamesWithDot.map((tableName)=>this.loadTableRecords(tableName, type))
                ];
                if (tableNamesWithoutDot.length) {
                    promises.push(this.query(`SELECT * FROM "sqlite_master" WHERE "type" = '${type}' AND "${type === "table" ? "name" : "tbl_name"}" IN (${tableNamesWithoutDot})`));
                }
                return promises;
            };
            dbTables = (await Promise.all(queryPromises("table"))).reduce((acc, res)=>[
                    ...acc,
                    ...res
                ], []).filter(Boolean);
            dbIndicesDef = (await Promise.all(queryPromises("index"))).reduce((acc, res)=>[
                    ...acc,
                    ...res
                ], []).filter(Boolean);
        }
        // if tables were not found in the db, no need to proceed
        if (dbTables.length === 0) {
            return [];
        }
        // create table schemas for loaded tables
        return Promise.all(dbTables.map(async (dbTable)=>{
            const tablePath = dbTable["database"] && this.driver.getAttachedDatabaseHandleByRelativePath(dbTable["database"]) ? `${this.driver.getAttachedDatabaseHandleByRelativePath(dbTable["database"])}.${dbTable["name"]}` : dbTable["name"];
            const sql = dbTable["sql"];
            const withoutRowid = sql.includes("WITHOUT ROWID");
            const table = new Table_1.Table({
                name: tablePath,
                withoutRowid
            });
            // load columns and indices
            const [dbColumns, dbIndices, dbForeignKeys] = await Promise.all([
                this.loadPragmaRecords(tablePath, `table_xinfo`),
                this.loadPragmaRecords(tablePath, `index_list`),
                this.loadPragmaRecords(tablePath, `foreign_key_list`)
            ]);
            // find column name with auto increment
            let autoIncrementColumnName = undefined;
            const tableSql = dbTable["sql"];
            const autoIncrementIndex = tableSql.toUpperCase().indexOf("AUTOINCREMENT");
            if (autoIncrementIndex !== -1) {
                autoIncrementColumnName = tableSql.substr(0, autoIncrementIndex);
                const comma = autoIncrementColumnName.lastIndexOf(",");
                const bracket = autoIncrementColumnName.lastIndexOf("(");
                if (comma !== -1) {
                    autoIncrementColumnName = autoIncrementColumnName.substr(comma);
                    autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('"'));
                    autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('"') + 1);
                } else if (bracket !== -1) {
                    autoIncrementColumnName = autoIncrementColumnName.substr(bracket);
                    autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('"'));
                    autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('"') + 1);
                }
            }
            // create columns from the loaded columns
            table.columns = await Promise.all(dbColumns.map(async (dbColumn)=>{
                const tableColumn = new TableColumn_1.TableColumn();
                tableColumn.name = dbColumn["name"];
                tableColumn.type = dbColumn["type"].toLowerCase();
                tableColumn.default = dbColumn["dflt_value"] !== null && dbColumn["dflt_value"] !== undefined ? dbColumn["dflt_value"] : undefined;
                tableColumn.isNullable = dbColumn["notnull"] === 0;
                // primary keys are numbered starting with 1, columns that aren't primary keys are marked with 0
                tableColumn.isPrimary = dbColumn["pk"] > 0;
                tableColumn.comment = ""; // SQLite does not support column comments
                tableColumn.isGenerated = autoIncrementColumnName === dbColumn["name"];
                if (tableColumn.isGenerated) {
                    tableColumn.generationStrategy = "increment";
                }
                if (dbColumn["hidden"] === 2 || dbColumn["hidden"] === 3) {
                    tableColumn.generatedType = dbColumn["hidden"] === 2 ? "VIRTUAL" : "STORED";
                    const asExpressionQuery = this.selectTypeormMetadataSql({
                        table: table.name,
                        type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                        name: tableColumn.name
                    });
                    const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);
                    if (results[0] && results[0].value) {
                        tableColumn.asExpression = results[0].value;
                    } else {
                        tableColumn.asExpression = "";
                    }
                }
                if (tableColumn.type === "varchar") {
                    tableColumn.enum = OrmUtils_1.OrmUtils.parseSqlCheckExpression(sql, tableColumn.name);
                }
                // parse datatype and attempt to retrieve length, precision and scale
                const pos = tableColumn.type.indexOf("(");
                if (pos !== -1) {
                    const fullType = tableColumn.type;
                    const dataType = fullType.substr(0, pos);
                    if (this.driver.withLengthColumnTypes.find((col)=>col === dataType)) {
                        const len = parseInt(fullType.substring(pos + 1, fullType.length - 1));
                        if (len) {
                            tableColumn.length = len.toString();
                            tableColumn.type = dataType; // remove the length part from the datatype
                        }
                    }
                    if (this.driver.withPrecisionColumnTypes.find((col)=>col === dataType)) {
                        const re = new RegExp(`^${dataType}\\((\\d+),?\\s?(\\d+)?\\)`);
                        const matches = fullType.match(re);
                        if (matches && matches[1]) {
                            tableColumn.precision = +matches[1];
                        }
                        if (this.driver.withScaleColumnTypes.find((col)=>col === dataType)) {
                            if (matches && matches[2]) {
                                tableColumn.scale = +matches[2];
                            }
                        }
                        tableColumn.type = dataType; // remove the precision/scale part from the datatype
                    }
                }
                return tableColumn;
            }));
            // find foreign key constraints from CREATE TABLE sql
            let fkResult;
            const fkMappings = [];
            const fkRegex = /CONSTRAINT "([^"]*)" FOREIGN KEY ?\((.*?)\) REFERENCES "([^"]*)"/g;
            while((fkResult = fkRegex.exec(sql)) !== null){
                fkMappings.push({
                    name: fkResult[1],
                    columns: fkResult[2].substr(1, fkResult[2].length - 2).split(`", "`),
                    referencedTableName: fkResult[3]
                });
            }
            // build foreign keys
            const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys, (dbForeignKey)=>dbForeignKey["id"]);
            table.foreignKeys = tableForeignKeyConstraints.map((foreignKey)=>{
                const ownForeignKeys = dbForeignKeys.filter((dbForeignKey)=>dbForeignKey["id"] === foreignKey["id"] && dbForeignKey["table"] === foreignKey["table"]);
                const columnNames = ownForeignKeys.map((dbForeignKey)=>dbForeignKey["from"]);
                const referencedColumnNames = ownForeignKeys.map((dbForeignKey)=>dbForeignKey["to"]);
                // find related foreign key mapping
                const fkMapping = fkMappings.find((it)=>it.referencedTableName === foreignKey["table"] && it.columns.every((column)=>columnNames.indexOf(column) !== -1));
                return new TableForeignKey_1.TableForeignKey({
                    name: fkMapping?.name,
                    columnNames: columnNames,
                    referencedTableName: foreignKey["table"],
                    referencedColumnNames: referencedColumnNames,
                    onDelete: foreignKey["on_delete"],
                    onUpdate: foreignKey["on_update"]
                });
            });
            // find unique constraints from CREATE TABLE sql
            let uniqueRegexResult;
            const uniqueMappings = [];
            const uniqueRegex = /CONSTRAINT "([^"]*)" UNIQUE ?\((.*?)\)/g;
            while((uniqueRegexResult = uniqueRegex.exec(sql)) !== null){
                uniqueMappings.push({
                    name: uniqueRegexResult[1],
                    columns: uniqueRegexResult[2].substr(1, uniqueRegexResult[2].length - 2).split(`", "`)
                });
            }
            // build unique constraints
            const tableUniquePromises = dbIndices.filter((dbIndex)=>dbIndex["origin"] === "u").map((dbIndex)=>dbIndex["name"]).filter((value, index, self)=>self.indexOf(value) === index).map(async (dbIndexName)=>{
                const dbIndex = dbIndices.find((dbIndex)=>dbIndex["name"] === dbIndexName);
                const indexInfos = await this.query(`PRAGMA index_info("${dbIndex["name"]}")`);
                const indexColumns = indexInfos.sort((indexInfo1, indexInfo2)=>parseInt(indexInfo1["seqno"]) - parseInt(indexInfo2["seqno"])).map((indexInfo)=>indexInfo["name"]);
                if (indexColumns.length === 1) {
                    const column = table.columns.find((column)=>{
                        return !!indexColumns.find((indexColumn)=>indexColumn === column.name);
                    });
                    if (column) column.isUnique = true;
                }
                // find existent mapping by a column names
                const foundMapping = uniqueMappings.find((mapping)=>{
                    return mapping.columns.every((column)=>indexColumns.indexOf(column) !== -1);
                });
                return new TableUnique_1.TableUnique({
                    name: foundMapping ? foundMapping.name : this.connection.namingStrategy.uniqueConstraintName(table, indexColumns),
                    columnNames: indexColumns
                });
            });
            table.uniques = await Promise.all(tableUniquePromises);
            // build checks
            let result;
            const regexp = /CONSTRAINT "([^"]*)" CHECK ?(\(.*?\))([,]|[)]$)/g;
            while((result = regexp.exec(sql)) !== null){
                table.checks.push(new TableCheck_1.TableCheck({
                    name: result[1],
                    expression: result[2]
                }));
            }
            // build indices
            const indicesPromises = dbIndices.filter((dbIndex)=>dbIndex["origin"] === "c").map((dbIndex)=>dbIndex["name"]).filter((value, index, self)=>self.indexOf(value) === index) // unqiue
            .map(async (dbIndexName)=>{
                const indexDef = dbIndicesDef.find((dbIndexDef)=>dbIndexDef["name"] === dbIndexName);
                const condition = /WHERE (.*)/.exec(indexDef["sql"]);
                const dbIndex = dbIndices.find((dbIndex)=>dbIndex["name"] === dbIndexName);
                const indexInfos = await this.query(`PRAGMA index_info("${dbIndex["name"]}")`);
                const indexColumns = indexInfos.sort((indexInfo1, indexInfo2)=>parseInt(indexInfo1["seqno"]) - parseInt(indexInfo2["seqno"])).map((indexInfo)=>indexInfo["name"]);
                const dbIndexPath = `${dbTable["database"] ? `${dbTable["database"]}.` : ""}${dbIndex["name"]}`;
                const isUnique = dbIndex["unique"] === "1" || dbIndex["unique"] === 1;
                return new TableIndex_1.TableIndex({
                    table: table,
                    name: dbIndexPath,
                    columnNames: indexColumns,
                    isUnique: isUnique,
                    where: condition ? condition[1] : undefined
                });
            });
            const indices = await Promise.all(indicesPromises);
            table.indices = indices.filter((index)=>!!index);
            return table;
        }));
    }
    /**
     * Builds create table sql.
     */ createTableSql(table, createForeignKeys, temporaryTable) {
        const primaryColumns = table.columns.filter((column)=>column.isPrimary);
        const hasAutoIncrement = primaryColumns.find((column)=>column.isGenerated && column.generationStrategy === "increment");
        const skipPrimary = primaryColumns.length > 1;
        if (skipPrimary && hasAutoIncrement) throw new error_1.TypeORMError(`Sqlite does not support AUTOINCREMENT on composite primary key`);
        const columnDefinitions = table.columns.map((column)=>this.buildCreateColumnSql(column, skipPrimary)).join(", ");
        const [database] = this.splitTablePath(table.name);
        let sql = `CREATE TABLE ${this.escapePath(table.name)} (${columnDefinitions}`;
        const [databaseNew, tableName] = this.splitTablePath(table.name);
        const newTableName = temporaryTable ? `${databaseNew ? `${databaseNew}.` : ""}${tableName.replace(/^temporary_/, "")}` : table.name;
        // need for `addColumn()` method, because it recreates table.
        table.columns.filter((column)=>column.isUnique).forEach((column)=>{
            const isUniqueExist = table.uniques.some((unique)=>unique.columnNames.length === 1 && unique.columnNames[0] === column.name);
            if (!isUniqueExist) table.uniques.push(new TableUnique_1.TableUnique({
                name: this.connection.namingStrategy.uniqueConstraintName(table, [
                    column.name
                ]),
                columnNames: [
                    column.name
                ]
            }));
        });
        if (table.uniques.length > 0) {
            const uniquesSql = table.uniques.map((unique)=>{
                const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(newTableName, unique.columnNames);
                const columnNames = unique.columnNames.map((columnName)=>`"${columnName}"`).join(", ");
                return `CONSTRAINT "${uniqueName}" UNIQUE (${columnNames})`;
            }).join(", ");
            sql += `, ${uniquesSql}`;
        }
        if (table.checks.length > 0) {
            const checksSql = table.checks.map((check)=>{
                const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(newTableName, check.expression);
                return `CONSTRAINT "${checkName}" CHECK (${check.expression})`;
            }).join(", ");
            sql += `, ${checksSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
            const foreignKeysSql = table.foreignKeys.filter((fk)=>{
                const [referencedDatabase] = this.splitTablePath(fk.referencedTableName);
                if (referencedDatabase !== database) {
                    return false;
                }
                return true;
            }).map((fk)=>{
                const [, referencedTable] = this.splitTablePath(fk.referencedTableName);
                const columnNames = fk.columnNames.map((columnName)=>`"${columnName}"`).join(", ");
                if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(newTableName, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
                const referencedColumnNames = fk.referencedColumnNames.map((columnName)=>`"${columnName}"`).join(", ");
                let constraint = `CONSTRAINT "${fk.name}" FOREIGN KEY (${columnNames}) REFERENCES "${referencedTable}" (${referencedColumnNames})`;
                if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;
                if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;
                if (fk.deferrable) constraint += ` DEFERRABLE ${fk.deferrable}`;
                return constraint;
            }).join(", ");
            sql += `, ${foreignKeysSql}`;
        }
        if (primaryColumns.length > 1) {
            const columnNames = primaryColumns.map((column)=>`"${column.name}"`).join(", ");
            sql += `, PRIMARY KEY (${columnNames})`;
        }
        sql += `)`;
        if (table.withoutRowid) {
            sql += " WITHOUT ROWID";
        }
        return new Query_1.Query(sql);
    }
    /**
     * Builds drop table sql.
     */ dropTableSql(tableOrName, ifExist) {
        const tableName = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;
        const query = ifExist ? `DROP TABLE IF EXISTS ${this.escapePath(tableName)}` : `DROP TABLE ${this.escapePath(tableName)}`;
        return new Query_1.Query(query);
    }
    createViewSql(view) {
        if (typeof view.expression === "string") {
            return new Query_1.Query(`CREATE VIEW "${view.name}" AS ${view.expression}`);
        } else {
            return new Query_1.Query(`CREATE VIEW "${view.name}" AS ${view.expression(this.connection).getQuery()}`);
        }
    }
    insertViewDefinitionSql(view) {
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        return this.insertTypeormMetadataSql({
            type: MetadataTableType_1.MetadataTableType.VIEW,
            name: view.name,
            value: expression
        });
    }
    /**
     * Builds drop view sql.
     */ dropViewSql(viewOrPath) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;
        return new Query_1.Query(`DROP VIEW "${viewName}"`);
    }
    /**
     * Builds remove view sql.
     */ deleteViewDefinitionSql(viewOrPath) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;
        return this.deleteTypeormMetadataSql({
            type: MetadataTableType_1.MetadataTableType.VIEW,
            name: viewName
        });
    }
    /**
     * Builds create index sql.
     */ createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName)=>`"${columnName}"`).join(", ");
        const [database, tableName] = this.splitTablePath(table.name);
        return new Query_1.Query(`CREATE ${index.isUnique ? "UNIQUE " : ""}INDEX ${database ? `"${database}".` : ""}${this.escapePath(index.name)} ON "${tableName}" (${columns}) ${index.where ? "WHERE " + index.where : ""}`);
    }
    /**
     * Builds drop index sql.
     */ dropIndexSql(indexOrName) {
        const indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
        return new Query_1.Query(`DROP INDEX ${this.escapePath(indexName)}`);
    }
    /**
     * Builds a query for create column.
     */ buildCreateColumnSql(column, skipPrimary) {
        let c = '"' + column.name + '"';
        if (InstanceChecker_1.InstanceChecker.isColumnMetadata(column)) {
            c += " " + this.driver.normalizeType(column);
        } else {
            c += " " + this.connection.driver.createFullType(column);
        }
        if (column.enum) c += ' CHECK( "' + column.name + '" IN (' + column.enum.map((val)=>"'" + val + "'").join(",") + ") )";
        if (column.isPrimary && !skipPrimary) c += " PRIMARY KEY";
        if (column.isGenerated === true && column.generationStrategy === "increment") // don't use skipPrimary here since updates can update already exist primary without auto inc.
        c += " AUTOINCREMENT";
        if (column.collation) c += " COLLATE " + column.collation;
        if (column.isNullable !== true) c += " NOT NULL";
        if (column.asExpression) {
            c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : "VIRTUAL"}`;
        } else {
            if (column.default !== undefined && column.default !== null) c += " DEFAULT (" + column.default + ")";
        }
        return c;
    }
    async recreateTable(newTable, oldTable, migrateData = true) {
        const upQueries = [];
        const downQueries = [];
        // drop old table indices
        oldTable.indices.forEach((index)=>{
            upQueries.push(this.dropIndexSql(index));
            downQueries.push(this.createIndexSql(oldTable, index));
        });
        // change table name into 'temporary_table'
        let [databaseNew, tableNameNew] = this.splitTablePath(newTable.name);
        const [, tableNameOld] = this.splitTablePath(oldTable.name);
        newTable.name = tableNameNew = `${databaseNew ? `${databaseNew}.` : ""}temporary_${tableNameNew}`;
        // create new table
        upQueries.push(this.createTableSql(newTable, true, true));
        downQueries.push(this.dropTableSql(newTable));
        // migrate all data from the old table into new table
        if (migrateData) {
            let newColumnNames = newTable.columns.filter((column)=>!column.generatedType).map((column)=>`"${column.name}"`);
            let oldColumnNames = oldTable.columns.filter((column)=>!column.generatedType).map((column)=>`"${column.name}"`);
            if (oldColumnNames.length < newColumnNames.length) {
                newColumnNames = newTable.columns.filter((column)=>{
                    const oldColumn = oldTable.columns.find((c)=>c.name === column.name);
                    if (oldColumn && oldColumn.generatedType) return false;
                    return !column.generatedType && oldColumn;
                }).map((column)=>`"${column.name}"`);
            } else if (oldColumnNames.length > newColumnNames.length) {
                oldColumnNames = oldTable.columns.filter((column)=>{
                    return !column.generatedType && newTable.columns.find((c)=>c.name === column.name);
                }).map((column)=>`"${column.name}"`);
            }
            upQueries.push(new Query_1.Query(`INSERT INTO ${this.escapePath(newTable.name)}(${newColumnNames.join(", ")}) SELECT ${oldColumnNames.join(", ")} FROM ${this.escapePath(oldTable.name)}`));
            downQueries.push(new Query_1.Query(`INSERT INTO ${this.escapePath(oldTable.name)}(${oldColumnNames.join(", ")}) SELECT ${newColumnNames.join(", ")} FROM ${this.escapePath(newTable.name)}`));
        }
        // drop old table
        upQueries.push(this.dropTableSql(oldTable));
        downQueries.push(this.createTableSql(oldTable, true));
        // rename old table
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable.name)} RENAME TO ${this.escapePath(tableNameOld)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(oldTable.name)} RENAME TO ${this.escapePath(tableNameNew)}`));
        newTable.name = oldTable.name;
        // recreate table indices
        newTable.indices.forEach((index)=>{
            // new index may be passed without name. In this case we generate index name manually.
            if (!index.name) index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
            upQueries.push(this.createIndexSql(newTable, index));
            downQueries.push(this.dropIndexSql(index));
        });
        // update generated columns in "typeorm_metadata" table
        // Step 1: clear data for removed generated columns
        oldTable.columns.filter((column)=>{
            const newTableColumn = newTable.columns.find((c)=>c.name === column.name);
            // we should delete record from "typeorm_metadata" if generated column was removed
            // or it was changed to non-generated
            return column.generatedType && column.asExpression && (!newTableColumn || !newTableColumn.generatedType && !newTableColumn.asExpression);
        }).forEach((column)=>{
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: oldTable.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            const insertQuery = this.insertTypeormMetadataSql({
                table: oldTable.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            upQueries.push(deleteQuery);
            downQueries.push(insertQuery);
        });
        // Step 2: add data for new generated columns
        newTable.columns.filter((column)=>column.generatedType && column.asExpression && !oldTable.columns.some((c)=>c.name === column.name)).forEach((column)=>{
            const insertQuery = this.insertTypeormMetadataSql({
                table: newTable.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: newTable.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            upQueries.push(insertQuery);
            downQueries.push(deleteQuery);
        });
        // Step 3: update changed expressions
        newTable.columns.filter((column)=>column.generatedType && column.asExpression).forEach((column)=>{
            const oldColumn = oldTable.columns.find((c)=>c.name === column.name && c.generatedType && column.generatedType && c.asExpression !== column.asExpression);
            if (!oldColumn) return;
            // update expression
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: oldTable.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: oldColumn.name
            });
            const insertQuery = this.insertTypeormMetadataSql({
                table: newTable.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            upQueries.push(deleteQuery);
            upQueries.push(insertQuery);
            // revert update
            const revertInsertQuery = this.insertTypeormMetadataSql({
                table: newTable.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: oldColumn.name,
                value: oldColumn.asExpression
            });
            const revertDeleteQuery = this.deleteTypeormMetadataSql({
                table: oldTable.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            downQueries.push(revertInsertQuery);
            downQueries.push(revertDeleteQuery);
        });
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(oldTable, newTable);
    }
    /**
     * tablePath e.g. "myDB.myTable", "myTable"
     */ splitTablePath(tablePath) {
        return tablePath.indexOf(".") !== -1 ? tablePath.split(".") : [
            undefined,
            tablePath
        ];
    }
    /**
     * Escapes given table or view path. Tolerates leading/trailing dots
     */ escapePath(target, disableEscape) {
        const tableName = InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        return tableName.replace(/^\.+|\.+$/g, "").split(".").map((i)=>disableEscape ? i : `"${i}"`).join(".");
    }
    /**
     * Change table comment.
     */ changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`sqlit driver does not support change comment.`);
    }
}
exports.AbstractSqliteQueryRunner = AbstractSqliteQueryRunner; //# sourceMappingURL=AbstractSqliteQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AbstractSqliteDriver = void 0;
const DateUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/DateUtils.js [app-route] (ecmascript)");
const RdbmsSchemaBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/RdbmsSchemaBuilder.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const ApplyValueTransformers_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Organizes communication with sqlite DBMS.
 */ class AbstractSqliteDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        /**
         * Indicates if replication is enabled.
         */ this.isReplicated = false;
        /**
         * Indicates if tree tables are supported by this driver.
         */ this.treeSupport = true;
        /**
         * Represent transaction support by this driver
         */ this.transactionSupport = "nested";
        /**
         * Gets list of supported column data types by a driver.
         *
         * @see https://www.tutorialspoint.com/sqlite/sqlite_data_types.htm
         * @see https://sqlite.org/datatype3.html
         */ this.supportedDataTypes = [
            "int",
            "integer",
            "tinyint",
            "smallint",
            "mediumint",
            "bigint",
            "unsigned big int",
            "int2",
            "int8",
            "integer",
            "character",
            "varchar",
            "varying character",
            "nchar",
            "native character",
            "nvarchar",
            "text",
            "clob",
            "text",
            "blob",
            "real",
            "double",
            "double precision",
            "float",
            "real",
            "numeric",
            "decimal",
            "boolean",
            "date",
            "time",
            "datetime",
            "json"
        ];
        /**
         * Returns type of upsert supported by driver if any
         */ this.supportedUpsertTypes = [
            "on-conflict-do-update"
        ];
        /**
         * Gets list of column data types that support length by a driver.
         */ this.withLengthColumnTypes = [
            "character",
            "varchar",
            "varying character",
            "nchar",
            "native character",
            "nvarchar",
            "text",
            "blob",
            "clob"
        ];
        /**
         * Gets list of spatial column data types.
         */ this.spatialTypes = [];
        /**
         * Gets list of column data types that support precision by a driver.
         */ this.withPrecisionColumnTypes = [
            "real",
            "double",
            "double precision",
            "float",
            "real",
            "numeric",
            "decimal",
            "date",
            "time",
            "datetime"
        ];
        /**
         * Gets list of column data types that support scale by a driver.
         */ this.withScaleColumnTypes = [
            "real",
            "double",
            "double precision",
            "float",
            "real",
            "numeric",
            "decimal"
        ];
        /**
         * Orm has special columns and we need to know what database column types should be for those types.
         * Column types are driver dependant.
         */ this.mappedDataTypes = {
            createDate: "datetime",
            createDateDefault: "datetime('now')",
            updateDate: "datetime",
            updateDateDefault: "datetime('now')",
            deleteDate: "datetime",
            deleteDateNullable: true,
            version: "integer",
            treeLevel: "integer",
            migrationId: "integer",
            migrationName: "varchar",
            migrationTimestamp: "bigint",
            cacheId: "int",
            cacheIdentifier: "varchar",
            cacheTime: "bigint",
            cacheDuration: "int",
            cacheQuery: "text",
            cacheResult: "text",
            metadataType: "varchar",
            metadataDatabase: "varchar",
            metadataSchema: "varchar",
            metadataTable: "varchar",
            metadataName: "varchar",
            metadataValue: "text"
        };
        this.cteCapabilities = {
            enabled: true,
            requiresRecursiveHint: true
        };
        // -------------------------------------------------------------------------
        // Protected Properties
        // -------------------------------------------------------------------------
        /**
         * Any attached databases (excepting default 'main')
         */ this.attachedDatabases = {};
        this.connection = connection;
        this.options = connection.options;
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).database;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Performs connection to the database.
     */ async connect() {
        this.databaseConnection = await this.createDatabaseConnection();
    }
    /**
     * Makes any action after connection (e.g. create extensions in Postgres driver).
     */ afterConnect() {
        return Promise.resolve();
    }
    /**
     * Closes connection with database.
     */ async disconnect() {
        return new Promise((ok, fail)=>{
            this.queryRunner = undefined;
            this.databaseConnection.close((err)=>err ? fail(err) : ok());
        });
    }
    hasAttachedDatabases() {
        return !!Object.keys(this.attachedDatabases).length;
    }
    getAttachedDatabaseHandleByRelativePath(path) {
        return this.attachedDatabases?.[path]?.attachHandle;
    }
    getAttachedDatabasePathRelativeByHandle(handle) {
        return Object.values(this.attachedDatabases).find(({ attachHandle })=>handle === attachHandle)?.attachFilepathRelative;
    }
    /**
     * Creates a schema builder used to build and sync a schema.
     */ createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type and metadata.
     */ preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === undefined) return value;
        if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
            return value === true ? 1 : 0;
        } else if (columnMetadata.type === "date") {
            return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
            return DateUtils_1.DateUtils.mixedDateToTimeString(value);
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
            // to string conversation needs because SQLite stores date as integer number, when date came as Object
            // TODO: think about `toUTC` conversion
            return DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(value);
        } else if (columnMetadata.type === "json" || columnMetadata.type === "simple-json") {
            return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "simple-array") {
            return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-enum") {
            return DateUtils_1.DateUtils.simpleEnumToString(value);
        }
        return value;
    }
    /**
     * Prepares given value to a value to be hydrated, based on its column type or metadata.
     */ prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
            value = value ? true : false;
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
            /**
             * Fix date conversion issue
             *
             * If the format of the date string is "2018-03-14 02:33:33.906", Safari (and iOS WKWebView) will convert it to an invalid date object.
             * We need to modify the date string to "2018-03-14T02:33:33.906Z" and Safari will convert it correctly.
             *
             * ISO 8601
             * https://www.w3.org/TR/NOTE-datetime
             */ if (value && typeof value === "string") {
                // There are various valid time string formats a sqlite time string might have:
                // https://www.sqlite.org/lang_datefunc.html
                // There are two separate fixes we may need to do:
                //   1) Add 'T' separator if space is used instead
                //   2) Add 'Z' UTC suffix if no timezone or offset specified
                if (/^\d\d\d\d-\d\d-\d\d \d\d:\d\d/.test(value)) {
                    value = value.replace(" ", "T");
                }
                if (/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d(:\d\d(\.\d\d\d)?)?$/.test(value)) {
                    value += "Z";
                }
            }
            value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "date") {
            value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
            value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === "json" || columnMetadata.type === "simple-json") {
            value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if (columnMetadata.type === "simple-array") {
            value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-enum") {
            value = DateUtils_1.DateUtils.stringToSimpleEnum(value, columnMetadata);
        } else if (columnMetadata.type === Number) {
            // convert to number if number
            value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
    }
    /**
     * Replaces parameters in the given sql with special escaping character
     * and an array of parameter names to be passed to a query.
     */ escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key)=>{
            // Mapping boolean values to their numeric representation
            if (typeof nativeParameters[key] === "boolean") {
                return nativeParameters[key] === true ? 1 : 0;
            }
            if (nativeParameters[key] instanceof Date) {
                return DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(nativeParameters[key]);
            }
            return nativeParameters[key];
        });
        if (!parameters || !Object.keys(parameters).length) return [
            sql,
            escapedParameters
        ];
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key)=>{
            if (!parameters.hasOwnProperty(key)) {
                return full;
            }
            const value = parameters[key];
            if (isArray) {
                return value.map((v)=>{
                    escapedParameters.push(v);
                    return this.createParameter(key, escapedParameters.length - 1);
                }).join(", ");
            }
            if (typeof value === "function") {
                return value();
            } else if (typeof value === "number") {
                return String(value);
            }
            // Sqlite does not have a boolean data type so we have to transform
            // it to 1 or 0
            if (typeof value === "boolean") {
                escapedParameters.push(+value);
                return this.createParameter(key, escapedParameters.length - 1);
            }
            if (value instanceof Date) {
                escapedParameters.push(DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(value));
                return this.createParameter(key, escapedParameters.length - 1);
            }
            escapedParameters.push(value);
            return this.createParameter(key, escapedParameters.length - 1);
        }); // todo: make replace only in value statements, otherwise problems
        return [
            sql,
            escapedParameters
        ];
    }
    /**
     * Escapes a column name.
     */ escape(columnName) {
        return '"' + columnName + '"';
    }
    /**
     * Build full table name with database name, schema name and table name.
     * E.g. myDB.mySchema.myTable
     *
     * Returns only simple table name because all inherited drivers does not supports schema and database.
     */ buildTableName(tableName, schema, database) {
        return tableName;
    }
    /**
     * Parse a target table name or other types and return a normalized table definition.
     */ parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = undefined;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
            const parsed = this.parseTableName(target.schema ? `"${target.schema}"."${target.name}"` : target.name);
            return {
                database: target.database || parsed.database || driverDatabase,
                schema: target.schema || parsed.schema || driverSchema,
                tableName: parsed.tableName
            };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
            const parsed = this.parseTableName(target.referencedTableName);
            return {
                database: target.referencedDatabase || parsed.database || driverDatabase,
                schema: target.referencedSchema || parsed.schema || driverSchema,
                tableName: parsed.tableName
            };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
            // EntityMetadata tableName is never a path
            return {
                database: target.database || driverDatabase,
                schema: target.schema || driverSchema,
                tableName: target.tableName
            };
        }
        const parts = target.split(".");
        if (parts.length === 3) {
            return {
                database: parts[0] || driverDatabase,
                schema: parts[1] || driverSchema,
                tableName: parts[2]
            };
        } else if (parts.length === 2) {
            const database = this.getAttachedDatabasePathRelativeByHandle(parts[0]) ?? driverDatabase;
            return {
                database: database,
                schema: parts[0],
                tableName: parts[1]
            };
        } else {
            return {
                database: driverDatabase,
                schema: driverSchema,
                tableName: target
            };
        }
    }
    /**
     * Creates a database type from a given column metadata.
     */ normalizeType(column) {
        if (column.type === Number || column.type === "int") {
            return "integer";
        } else if (column.type === String) {
            return "varchar";
        } else if (column.type === Date) {
            return "datetime";
        } else if (column.type === Boolean) {
            return "boolean";
        } else if (column.type === "uuid") {
            return "varchar";
        } else if (column.type === "simple-array") {
            return "text";
        } else if (column.type === "simple-json") {
            return "text";
        } else if (column.type === "simple-enum") {
            return "varchar";
        } else {
            return column.type || "";
        }
    }
    /**
     * Normalizes "default" value of the column.
     */ normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (typeof defaultValue === "number") {
            return "" + defaultValue;
        }
        if (typeof defaultValue === "boolean") {
            return defaultValue ? "1" : "0";
        }
        if (typeof defaultValue === "function") {
            return defaultValue();
        }
        if (typeof defaultValue === "string") {
            return `'${defaultValue}'`;
        }
        if (defaultValue === null || defaultValue === undefined) {
            return undefined;
        }
        return `${defaultValue}`;
    }
    /**
     * Normalizes "isUnique" value of the column.
     */ normalizeIsUnique(column) {
        return column.entityMetadata.uniques.some((uq)=>uq.columns.length === 1 && uq.columns[0] === column);
    }
    /**
     * Calculates column length taking into account the default length values.
     */ getColumnLength(column) {
        return column.length ? column.length.toString() : "";
    }
    /**
     * Normalizes "default" value of the column.
     */ createFullType(column) {
        let type = column.type;
        if (column.enum) {
            return "varchar";
        }
        if (column.length) {
            type += "(" + column.length + ")";
        } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {
            type += "(" + column.precision + "," + column.scale + ")";
        } else if (column.precision !== null && column.precision !== undefined) {
            type += "(" + column.precision + ")";
        }
        if (column.isArray) type += " array";
        return type;
    }
    /**
     * Obtains a new database connection to a master server.
     * Used for replication.
     * If replication is not setup then returns default connection's database connection.
     */ obtainMasterConnection() {
        return Promise.resolve();
    }
    /**
     * Obtains a new database connection to a slave server.
     * Used for replication.
     * If replication is not setup then returns master (default) connection's database connection.
     */ obtainSlaveConnection() {
        return Promise.resolve();
    }
    /**
     * Creates generated map of values generated or returned by database after INSERT query.
     */ createGeneratedMap(metadata, insertResult, entityIndex, entityNum) {
        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn)=>{
            let value;
            if (generatedColumn.generationStrategy === "increment" && insertResult) {
                // NOTE: When INSERT statement is successfully completed, the last inserted row ID is returned.
                // see also: SqliteQueryRunner.query()
                value = insertResult - entityNum + entityIndex + 1;
            // } else if (generatedColumn.generationStrategy === "uuid") {
            //     value = insertValue[generatedColumn.databaseName];
            }
            if (!value) return map;
            return OrmUtils_1.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
        }, {});
        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;
    }
    /**
     * Differentiate columns of this table and columns from the given column metadatas columns
     * and returns only changed.
     */ findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata)=>{
            const tableColumn = tableColumns.find((c)=>c.name === columnMetadata.databaseName);
            if (!tableColumn) return false; // we don't need new columns, we only need exist and changed
            const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || this.normalizeDefault(columnMetadata) !== tableColumn.default || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || tableColumn.enum && columnMetadata.enum && !OrmUtils_1.OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val)=>val + "")) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
            // DEBUG SECTION
            // if (isColumnChanged) {
            //     console.log("table:", columnMetadata.entityMetadata.tableName)
            //     console.log(
            //         "name:",
            //         tableColumn.name,
            //         columnMetadata.databaseName,
            //     )
            //     console.log(
            //         "type:",
            //         tableColumn.type,
            //         this.normalizeType(columnMetadata),
            //     )
            //     console.log(
            //         "length:",
            //         tableColumn.length,
            //         columnMetadata.length,
            //     )
            //     console.log(
            //         "precision:",
            //         tableColumn.precision,
            //         columnMetadata.precision,
            //     )
            //     console.log("scale:", tableColumn.scale, columnMetadata.scale)
            //     console.log(
            //         "default:",
            //         this.normalizeDefault(columnMetadata),
            //         columnMetadata.default,
            //     )
            //     console.log(
            //         "isPrimary:",
            //         tableColumn.isPrimary,
            //         columnMetadata.isPrimary,
            //     )
            //     console.log(
            //         "isNullable:",
            //         tableColumn.isNullable,
            //         columnMetadata.isNullable,
            //     )
            //     console.log(
            //         "generatedType:",
            //         tableColumn.generatedType,
            //         columnMetadata.generatedType,
            //     )
            //     console.log(
            //         "asExpression:",
            //         tableColumn.asExpression,
            //         columnMetadata.asExpression,
            //     )
            //     console.log(
            //         "isUnique:",
            //         tableColumn.isUnique,
            //         this.normalizeIsUnique(columnMetadata),
            //     )
            //     console.log(
            //         "enum:",
            //         tableColumn.enum &&
            //             columnMetadata.enum &&
            //             !OrmUtils.isArraysEqual(
            //                 tableColumn.enum,
            //                 columnMetadata.enum.map((val) => val + ""),
            //             ),
            //     )
            //     console.log(
            //         "isGenerated:",
            //         tableColumn.isGenerated,
            //         columnMetadata.isGenerated,
            //     )
            // }
            return isColumnChanged;
        });
    }
    /**
     * Returns true if driver supports RETURNING / OUTPUT statement.
     */ isReturningSqlSupported() {
        return false;
    }
    /**
     * Returns true if driver supports uuid values generation on its own.
     */ isUUIDGenerationSupported() {
        return false;
    }
    /**
     * Returns true if driver supports fulltext indices.
     */ isFullTextColumnTypeSupported() {
        return false;
    }
    /**
     * Creates an escaped parameter.
     */ createParameter(parameterName, index) {
        // return "$" + (index + 1);
        return "?";
    // return "$" + parameterName;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates connection with the database.
     */ createDatabaseConnection() {
        throw new error_1.TypeORMError("Do not use AbstractSqlite directly, it has to be used with one of the sqlite drivers");
    }
    /**
     * If driver dependency is not given explicitly, then try to load it via "require".
     */ loadDependencies() {
    // dependencies have to be loaded in the specific driver
    }
}
exports.AbstractSqliteDriver = AbstractSqliteDriver; //# sourceMappingURL=AbstractSqliteDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/sqlite/SqliteQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SqliteQueryRunner = void 0;
const ConnectionIsNotSetError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/ConnectionIsNotSetError.js [app-route] (ecmascript)");
const QueryFailedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)");
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
const AbstractSqliteQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner.js [app-route] (ecmascript)");
/**
 * Runs queries on a single sqlite database connection.
 *
 * Does not support compose primary keys with autoincrement field.
 * todo: need to throw exception for this case.
 */ class SqliteQueryRunner extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver){
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
    }
    /**
     * Called before migrations are run.
     */ async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
    }
    /**
     * Called after migrations are run.
     */ async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
    }
    /**
     * Executes a given SQL query.
     */ async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const connection = this.driver.connection;
        const options = connection.options;
        const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
        const broadcaster = this.broadcaster;
        if (!connection.isInitialized) {
            throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("sqlite");
        }
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        return new Promise(async (ok, fail)=>{
            try {
                const queryStartTime = Date.now();
                const isInsertQuery = query.startsWith("INSERT ");
                const isDeleteQuery = query.startsWith("DELETE ");
                const isUpdateQuery = query.startsWith("UPDATE ");
                const execute = async ()=>{
                    if (isInsertQuery || isDeleteQuery || isUpdateQuery) {
                        await databaseConnection.run(query, parameters, handler);
                    } else {
                        await databaseConnection.all(query, parameters, handler);
                    }
                };
                const self = this;
                const handler = function(err, rows) {
                    if (err && err.toString().indexOf("SQLITE_BUSY:") !== -1) {
                        if (typeof options.busyErrorRetry === "number" && options.busyErrorRetry > 0) {
                            setTimeout(execute, options.busyErrorRetry);
                            return;
                        }
                    }
                    // log slow queries if maxQueryExecution time is set
                    const queryEndTime = Date.now();
                    const queryExecutionTime = queryEndTime - queryStartTime;
                    if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) connection.logger.logQuerySlow(queryExecutionTime, query, parameters, self);
                    if (err) {
                        connection.logger.logQueryError(err, query, parameters, self);
                        broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);
                        return fail(new QueryFailedError_1.QueryFailedError(query, parameters, err));
                    } else {
                        const result = new QueryResult_1.QueryResult();
                        if (isInsertQuery) {
                            result.raw = this["lastID"];
                        } else {
                            result.raw = rows;
                        }
                        broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, result.raw, undefined);
                        if (Array.isArray(rows)) {
                            result.records = rows;
                        }
                        result.affected = this["changes"];
                        if (useStructuredResult) {
                            ok(result);
                        } else {
                            ok(result.raw);
                        }
                    }
                };
                await execute();
            } catch (err) {
                fail(err);
            } finally{
                await broadcasterResult.wait();
            }
        });
    }
}
exports.SqliteQueryRunner = SqliteQueryRunner; //# sourceMappingURL=SqliteQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/sqlite/SqliteDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SqliteDriver = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const promises_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/fs/promises [external] (fs/promises, cjs)"));
const path_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const DriverPackageNotInstalledError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/DriverPackageNotInstalledError.js [app-route] (ecmascript)");
const SqliteQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite/SqliteQueryRunner.js [app-route] (ecmascript)");
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const AbstractSqliteDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteDriver.js [app-route] (ecmascript)");
const PathUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/PathUtils.js [app-route] (ecmascript)");
/**
 * Organizes communication with sqlite DBMS.
 */ class SqliteDriver extends AbstractSqliteDriver_1.AbstractSqliteDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        super(connection);
        this.connection = connection;
        this.options = connection.options;
        this.database = this.options.database;
        // load sqlite package
        this.loadDependencies();
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Closes connection with database.
     */ async disconnect() {
        return new Promise((ok, fail)=>{
            this.queryRunner = undefined;
            this.databaseConnection.close((err)=>err ? fail(err) : ok());
        });
    }
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        if (!this.queryRunner) this.queryRunner = new SqliteQueryRunner_1.SqliteQueryRunner(this);
        return this.queryRunner;
    }
    normalizeType(column) {
        if (column.type === Buffer) {
            return "blob";
        }
        return super.normalizeType(column);
    }
    async afterConnect() {
        return this.attachDatabases();
    }
    /**
     * For SQLite, the database may be added in the decorator metadata. It will be a filepath to a database file.
     */ buildTableName(tableName, _schema, database) {
        if (!database) return tableName;
        if (this.getAttachedDatabaseHandleByRelativePath(database)) return `${this.getAttachedDatabaseHandleByRelativePath(database)}.${tableName}`;
        if (database === this.options.database) return tableName;
        // we use the decorated name as supplied when deriving attach handle (ideally without non-portable absolute path)
        const identifierHash = (0, PathUtils_1.filepathToName)(database);
        // decorated name will be assumed relative to main database file when non absolute. Paths supplied as absolute won't be portable
        const absFilepath = (0, PathUtils_1.isAbsolute)(database) ? database : path_1.default.join(this.getMainDatabasePath(), database);
        this.attachedDatabases[database] = {
            attachFilepathAbsolute: absFilepath,
            attachFilepathRelative: database,
            attachHandle: identifierHash
        };
        return `${identifierHash}.${tableName}`;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates connection with the database.
     */ async createDatabaseConnection() {
        if (this.options.flags === undefined || !(this.options.flags & this.sqlite.OPEN_URI)) {
            await this.createDatabaseDirectory(this.options.database);
        }
        const databaseConnection = await new Promise((ok, fail)=>{
            if (this.options.flags === undefined) {
                const connection = new this.sqlite.Database(this.options.database, (err)=>{
                    if (err) return fail(err);
                    ok(connection);
                });
            } else {
                const connection = new this.sqlite.Database(this.options.database, this.options.flags, (err)=>{
                    if (err) return fail(err);
                    ok(connection);
                });
            }
        });
        // Internal function to run a command on the connection and fail if an error occured.
        function run(line) {
            return new Promise((ok, fail)=>{
                databaseConnection.run(line, (err)=>{
                    if (err) return fail(err);
                    ok();
                });
            });
        }
        // in the options, if encryption key for SQLCipher is setted.
        // Must invoke key pragma before trying to do any other interaction with the database.
        if (this.options.key) {
            await run(`PRAGMA key = ${JSON.stringify(this.options.key)}`);
        }
        if (this.options.enableWAL) {
            await run(`PRAGMA journal_mode = WAL`);
        }
        if (this.options.busyTimeout && typeof this.options.busyTimeout === "number" && this.options.busyTimeout > 0) {
            await run(`PRAGMA busy_timeout = ${this.options.busyTimeout}`);
        }
        // we need to enable foreign keys in sqlite to make sure all foreign key related features
        // working properly. this also makes onDelete to work with sqlite.
        await run(`PRAGMA foreign_keys = ON`);
        return databaseConnection;
    }
    /**
     * If driver dependency is not given explicitly, then try to load it via "require".
     */ loadDependencies() {
        try {
            const sqlite = this.options.driver || PlatformTools_1.PlatformTools.load("sqlite3");
            this.sqlite = sqlite.verbose();
        } catch (e) {
            throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("SQLite", "sqlite3");
        }
    }
    /**
     * Auto creates database directory if it does not exist.
     */ async createDatabaseDirectory(fullPath) {
        await promises_1.default.mkdir(path_1.default.dirname(fullPath), {
            recursive: true
        });
    }
    /**
     * Performs the attaching of the database files. The attachedDatabase should have been populated during calls to #buildTableName
     * during EntityMetadata production (see EntityMetadata#buildTablePath)
     *
     * https://sqlite.org/lang_attach.html
     */ async attachDatabases() {
        // @todo - possibly check number of databases (but unqueriable at runtime sadly) - https://www.sqlite.org/limits.html#max_attached
        for await (const { attachHandle, attachFilepathAbsolute } of Object.values(this.attachedDatabases)){
            await this.createDatabaseDirectory(attachFilepathAbsolute);
            await this.connection.query(`ATTACH "${attachFilepathAbsolute}" AS "${attachHandle}"`);
        }
    }
    getMainDatabasePath() {
        const optionsDb = this.options.database;
        return path_1.default.dirname((0, PathUtils_1.isAbsolute)(optionsDb) ? optionsDb : path_1.default.join(process.cwd(), optionsDb));
    }
}
exports.SqliteDriver = SqliteDriver; //# sourceMappingURL=SqliteDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/cordova/CordovaQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CordovaQueryRunner = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const QueryFailedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)");
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
const AbstractSqliteQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner.js [app-route] (ecmascript)");
/**
 * Runs queries on a single sqlite database connection.
 */ class CordovaQueryRunner extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver){
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
    }
    /**
     * Called before migrations are run.
     */ async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
    }
    /**
     * Called after migrations are run.
     */ async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
    }
    /**
     * Executes a given SQL query.
     */ async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        const queryStartTime = Date.now();
        try {
            const raw = await new Promise(async (ok, fail)=>{
                databaseConnection.executeSql(query, parameters, (raw)=>ok(raw), (err)=>fail(err));
            });
            // log slow queries if maxQueryExecution time is set
            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
            const queryEndTime = Date.now();
            const queryExecutionTime = queryEndTime - queryStartTime;
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, undefined);
            if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
                this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
            }
            const result = new QueryResult_1.QueryResult();
            if (query.substr(0, 11) === "INSERT INTO") {
                result.raw = raw.insertId;
            } else {
                const resultSet = [];
                for(let i = 0; i < raw.rows.length; i++){
                    resultSet.push(raw.rows.item(i));
                }
                result.records = resultSet;
                result.raw = resultSet;
            }
            if (useStructuredResult) {
                return result;
            } else {
                return result.raw;
            }
        } catch (err) {
            this.driver.connection.logger.logQueryError(err, query, parameters, this);
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);
            throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        } finally{
            await broadcasterResult.wait();
        }
    }
    /**
     * Insert a new row with given values into the given table.
     * Returns value of the generated column if given and generate column exist in the table.
     // todo: implement new syntax
    async insert(tableName: string, keyValues: ObjectLiteral): Promise<InsertResult> {
        const keys = Object.keys(keyValues);
        const columns = keys.map(key => `"${key}"`).join(", ");
        const values = keys.map(key => "?").join(",");
        const generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];
        const sql = columns.length > 0 ? (`INSERT INTO "${tableName}"(${columns}) VALUES (${values})`) : `INSERT INTO "${tableName}" DEFAULT VALUES`;
        const parameters = keys.map(key => keyValues[key]);

        return new Promise<InsertResult>(async (ok, fail) => {
            this.driver.connection.logger.logQuery(sql, parameters, this);
            const __this = this;
            const databaseConnection = await this.connect();
            databaseConnection.executeSql(sql, parameters, (resultSet: any) => {
                const generatedMap = generatedColumns.reduce((map, generatedColumn) => {
                    const value = generatedColumn.isPrimary && generatedColumn.generationStrategy === "increment" && resultSet.insertId ? resultSet.insertId : keyValues[generatedColumn.databaseName];
                    if (!value) return map;
                    return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
                }, {} as ObjectLiteral);

                ok({
                    result: undefined,
                    generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined
                });
            }, (err: any) => {
                __this.driver.connection.logger.logQueryError(err, sql, parameters, this);
                fail(err);
            });
        });
    }*/ /**
     * Would start a transaction but this driver does not support transactions.
     */ async startTransaction() {
        throw new error_1.TypeORMError("Transactions are not supported by the Cordova driver");
    }
    /**
     * Would start a transaction but this driver does not support transactions.
     */ async commitTransaction() {
        throw new error_1.TypeORMError("Transactions are not supported by the Cordova driver");
    }
    /**
     * Would start a transaction but this driver does not support transactions.
     */ async rollbackTransaction() {
        throw new error_1.TypeORMError("Transactions are not supported by the Cordova driver");
    }
    /**
     * Removes all tables from the currently connected database.
     * Be careful with using this method and avoid using it in production or migrations
     * (because it can clear all your database).
     */ async clearDatabase() {
        await this.query(`PRAGMA foreign_keys = OFF`);
        try {
            const selectViewDropsQuery = `SELECT 'DROP VIEW "' || name || '";' as query FROM "sqlite_master" WHERE "type" = 'view'`;
            const dropViewQueries = await this.query(selectViewDropsQuery);
            const selectTableDropsQuery = `SELECT 'DROP TABLE "' || name || '";' as query FROM "sqlite_master" WHERE "type" = 'table' AND "name" != 'sqlite_sequence'`;
            const dropTableQueries = await this.query(selectTableDropsQuery);
            await Promise.all(dropViewQueries.map((q)=>this.query(q["query"])));
            await Promise.all(dropTableQueries.map((q)=>this.query(q["query"])));
        } finally{
            await this.query(`PRAGMA foreign_keys = ON`);
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Parametrizes given object of values. Used to create column=value queries.
     */ parametrize(objectLiteral, startIndex = 0) {
        return Object.keys(objectLiteral).map((key, index)=>`"${key}"` + "=?");
    }
}
exports.CordovaQueryRunner = CordovaQueryRunner; //# sourceMappingURL=CordovaQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/cordova/CordovaDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CordovaDriver = void 0;
const AbstractSqliteDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteDriver.js [app-route] (ecmascript)");
const CordovaQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/cordova/CordovaQueryRunner.js [app-route] (ecmascript)");
const DriverPackageNotInstalledError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/DriverPackageNotInstalledError.js [app-route] (ecmascript)");
class CordovaDriver extends AbstractSqliteDriver_1.AbstractSqliteDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        super(connection);
        this.transactionSupport = "none";
        // this.connection = connection;
        // this.options = connection.options as CordovaConnectionOptions;
        this.database = this.options.database;
        // load sqlite package
        this.loadDependencies();
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Closes connection with database.
     */ async disconnect() {
        this.queryRunner = undefined;
        return new Promise((ok, fail)=>{
            this.databaseConnection.close(ok, fail);
        });
    }
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        if (!this.queryRunner) this.queryRunner = new CordovaQueryRunner_1.CordovaQueryRunner(this);
        return this.queryRunner;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates connection with the database.
     */ async createDatabaseConnection() {
        const options = Object.assign({}, {
            name: this.options.database,
            location: this.options.location
        }, this.options.extra || {});
        const connection = await new Promise((resolve, fail)=>{
            this.sqlite.openDatabase(options, (db)=>resolve(db), (err)=>fail(err));
        });
        await new Promise((ok, fail)=>{
            // we need to enable foreign keys in sqlite to make sure all foreign key related features
            // working properly. this also makes onDelete to work with sqlite.
            connection.executeSql(`PRAGMA foreign_keys = ON`, [], ()=>ok(), (err)=>fail(err));
        });
        return connection;
    }
    /**
     * If driver dependency is not given explicitly, then try to load it via "require".
     */ loadDependencies() {
        try {
            const sqlite = this.options.driver || window.sqlitePlugin;
            this.sqlite = sqlite;
        } catch (e) {
            throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Cordova-SQLite", "cordova-sqlite-storage");
        }
    }
}
exports.CordovaDriver = CordovaDriver; //# sourceMappingURL=CordovaDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/react-native/ReactNativeQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReactNativeQueryRunner = void 0;
const QueryFailedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)");
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
const AbstractSqliteQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner.js [app-route] (ecmascript)");
/**
 * Runs queries on a single sqlite database connection.
 */ class ReactNativeQueryRunner extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver){
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
    }
    /**
     * Called before migrations are run.
     */ async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
    }
    /**
     * Called after migrations are run.
     */ async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
    }
    /**
     * Executes a given SQL query.
     */ async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        const queryStartTime = Date.now();
        return new Promise(async (ok, fail)=>{
            try {
                databaseConnection.executeSql(query, parameters, async (raw)=>{
                    // log slow queries if maxQueryExecution time is set
                    const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
                    const queryEndTime = Date.now();
                    const queryExecutionTime = queryEndTime - queryStartTime;
                    this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, undefined);
                    if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
                    if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);
                    const result = new QueryResult_1.QueryResult();
                    if (raw?.hasOwnProperty("rowsAffected")) {
                        result.affected = raw.rowsAffected;
                    }
                    if (raw?.hasOwnProperty("rows")) {
                        const records = [];
                        for(let i = 0; i < raw.rows.length; i++){
                            records.push(raw.rows.item(i));
                        }
                        result.raw = records;
                        result.records = records;
                    }
                    // return id of inserted row, if query was insert statement.
                    if (query.substr(0, 11) === "INSERT INTO") {
                        result.raw = raw.insertId;
                    }
                    if (useStructuredResult) {
                        ok(result);
                    } else {
                        ok(result.raw);
                    }
                }, async (err)=>{
                    this.driver.connection.logger.logQueryError(err, query, parameters, this);
                    this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);
                    fail(new QueryFailedError_1.QueryFailedError(query, parameters, err));
                });
            } catch (err) {
                fail(err);
            } finally{
                await broadcasterResult.wait();
            }
        });
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Parametrizes given object of values. Used to create column=value queries.
     */ parametrize(objectLiteral, startIndex = 0) {
        return Object.keys(objectLiteral).map((key, index)=>`"${key}"` + "=?");
    }
}
exports.ReactNativeQueryRunner = ReactNativeQueryRunner; //# sourceMappingURL=ReactNativeQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/react-native/ReactNativeDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReactNativeDriver = void 0;
const DateUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/DateUtils.js [app-route] (ecmascript)");
const RdbmsSchemaBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/RdbmsSchemaBuilder.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const ApplyValueTransformers_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
const ReactNativeQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/react-native/ReactNativeQueryRunner.js [app-route] (ecmascript)");
/**
 * Organizes communication with sqlite DBMS.
 */ class ReactNativeDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        /**
         * Indicates if replication is enabled.
         */ this.isReplicated = false;
        /**
         * Indicates if tree tables are supported by this driver.
         */ this.treeSupport = true;
        /**
         * Represent transaction support by this driver
         */ this.transactionSupport = "nested";
        /**
         * Gets list of supported column data types by a driver.
         *
         * @see https://www.tutorialspoint.com/sqlite/sqlite_data_types.htm
         * @see https://sqlite.org/datatype3.html
         */ this.supportedDataTypes = [
            "int",
            "integer",
            "tinyint",
            "smallint",
            "mediumint",
            "bigint",
            "unsigned big int",
            "int2",
            "int8",
            "integer",
            "character",
            "varchar",
            "varying character",
            "nchar",
            "native character",
            "nvarchar",
            "text",
            "clob",
            "text",
            "blob",
            "real",
            "double",
            "double precision",
            "float",
            "real",
            "numeric",
            "decimal",
            "boolean",
            "date",
            "time",
            "datetime"
        ];
        /**
         * Returns type of upsert supported by driver if any
         */ this.supportedUpsertTypes = [
            "on-conflict-do-update"
        ];
        /**
         * Gets list of column data types that support length by a driver.
         */ this.withLengthColumnTypes = [
            "character",
            "varchar",
            "varying character",
            "nchar",
            "native character",
            "nvarchar",
            "text",
            "blob",
            "clob"
        ];
        /**
         * Gets list of spatial column data types.
         */ this.spatialTypes = [];
        /**
         * Gets list of column data types that support precision by a driver.
         */ this.withPrecisionColumnTypes = [
            "real",
            "double",
            "double precision",
            "float",
            "real",
            "numeric",
            "decimal",
            "date",
            "time",
            "datetime"
        ];
        /**
         * Gets list of column data types that support scale by a driver.
         */ this.withScaleColumnTypes = [
            "real",
            "double",
            "double precision",
            "float",
            "real",
            "numeric",
            "decimal"
        ];
        /**
         * Orm has special columns and we need to know what database column types should be for those types.
         * Column types are driver dependant.
         */ this.mappedDataTypes = {
            createDate: "datetime",
            createDateDefault: "datetime('now')",
            updateDate: "datetime",
            updateDateDefault: "datetime('now')",
            deleteDate: "datetime",
            deleteDateNullable: true,
            version: "integer",
            treeLevel: "integer",
            migrationId: "integer",
            migrationName: "varchar",
            migrationTimestamp: "bigint",
            cacheId: "int",
            cacheIdentifier: "varchar",
            cacheTime: "bigint",
            cacheDuration: "int",
            cacheQuery: "text",
            cacheResult: "text",
            metadataType: "varchar",
            metadataDatabase: "varchar",
            metadataSchema: "varchar",
            metadataTable: "varchar",
            metadataName: "varchar",
            metadataValue: "text"
        };
        this.cteCapabilities = {
            enabled: true,
            requiresRecursiveHint: true
        };
        // -------------------------------------------------------------------------
        // Protected Properties
        // -------------------------------------------------------------------------
        /**
         * Any attached databases (excepting default 'main')
         */ this.attachedDatabases = {};
        this.connection = connection;
        this.options = connection.options;
        // this.database = DriverUtils.buildDriverOptions(this.options).database
        this.database = this.options.database;
        this.loadDependencies();
    }
    // -------------------------------------------------------------------------
    // Public Abstract
    // -------------------------------------------------------------------------
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        if (!this.queryRunner) this.queryRunner = new ReactNativeQueryRunner_1.ReactNativeQueryRunner(this);
        return this.queryRunner;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Performs connection to the database.
     */ async connect() {
        this.databaseConnection = await this.createDatabaseConnection();
    }
    /**
     * Makes any action after connection (e.g. create extensions in Postgres driver).
     */ afterConnect() {
        return Promise.resolve();
    }
    /**
     * Closes connection with database.
     */ async disconnect() {
        return new Promise((ok, fail)=>{
            this.queryRunner = undefined;
            this.databaseConnection.close(ok, fail);
        });
    }
    hasAttachedDatabases() {
        return !!Object.keys(this.attachedDatabases).length;
    }
    getAttachedDatabaseHandleByRelativePath(path) {
        return this.attachedDatabases?.[path]?.attachHandle;
    }
    getAttachedDatabasePathRelativeByHandle(handle) {
        return Object.values(this.attachedDatabases).find(({ attachHandle })=>handle === attachHandle)?.attachFilepathRelative;
    }
    /**
     * Creates a schema builder used to build and sync a schema.
     */ createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type and metadata.
     */ preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === undefined) return value;
        if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
            return value === true ? 1 : 0;
        } else if (columnMetadata.type === "date") {
            return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
            return DateUtils_1.DateUtils.mixedDateToTimeString(value);
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
            // to string conversation needs because SQLite stores date as integer number, when date came as Object
            // TODO: think about `toUTC` conversion
            return DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(value);
        } else if (columnMetadata.type === "simple-array") {
            return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-json") {
            return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "simple-enum") {
            return DateUtils_1.DateUtils.simpleEnumToString(value);
        }
        return value;
    }
    /**
     * Prepares given value to a value to be hydrated, based on its column type or metadata.
     */ prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
            value = value ? true : false;
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
            /**
             * Fix date conversion issue
             *
             * If the format of the date string is "2018-03-14 02:33:33.906", Safari (and iOS WKWebView) will convert it to an invalid date object.
             * We need to modify the date string to "2018-03-14T02:33:33.906Z" and Safari will convert it correctly.
             *
             * ISO 8601
             * https://www.w3.org/TR/NOTE-datetime
             */ if (value && typeof value === "string") {
                // There are various valid time string formats a sqlite time string might have:
                // https://www.sqlite.org/lang_datefunc.html
                // There are two separate fixes we may need to do:
                //   1) Add 'T' separator if space is used instead
                //   2) Add 'Z' UTC suffix if no timezone or offset specified
                if (/^\d\d\d\d-\d\d-\d\d \d\d:\d\d/.test(value)) {
                    value = value.replace(" ", "T");
                }
                if (/^\d\d\d\d-\d\d-\d\dT\d\d:\d\d(:\d\d(\.\d\d\d)?)?$/.test(value)) {
                    value += "Z";
                }
            }
            value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "date") {
            value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
            value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === "simple-array") {
            value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-json") {
            value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if (columnMetadata.type === "simple-enum") {
            value = DateUtils_1.DateUtils.stringToSimpleEnum(value, columnMetadata);
        } else if (columnMetadata.type === Number) {
            // convert to number if number
            value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
    }
    /**
     * Replaces parameters in the given sql with special escaping character
     * and an array of parameter names to be passed to a query.
     */ escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key)=>{
            // Mapping boolean values to their numeric representation
            if (typeof nativeParameters[key] === "boolean") {
                return nativeParameters[key] === true ? 1 : 0;
            }
            if (nativeParameters[key] instanceof Date) {
                return DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(nativeParameters[key]);
            }
            return nativeParameters[key];
        });
        if (!parameters || !Object.keys(parameters).length) return [
            sql,
            escapedParameters
        ];
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key)=>{
            if (!parameters.hasOwnProperty(key)) {
                return full;
            }
            const value = parameters[key];
            if (isArray) {
                return value.map((v)=>{
                    escapedParameters.push(v);
                    return this.createParameter(key, escapedParameters.length - 1);
                }).join(", ");
            }
            if (typeof value === "function") {
                return value();
            } else if (typeof value === "number") {
                return String(value);
            }
            // Sqlite does not have a boolean data type so we have to transform
            // it to 1 or 0
            if (typeof value === "boolean") {
                escapedParameters.push(+value);
                return this.createParameter(key, escapedParameters.length - 1);
            }
            if (value instanceof Date) {
                escapedParameters.push(DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(value));
                return this.createParameter(key, escapedParameters.length - 1);
            }
            escapedParameters.push(value);
            return this.createParameter(key, escapedParameters.length - 1);
        }); // todo: make replace only in value statements, otherwise problems
        return [
            sql,
            escapedParameters
        ];
    }
    /**
     * Escapes a column name.
     */ escape(columnName) {
        return '"' + columnName + '"';
    }
    /**
     * Build full table name with database name, schema name and table name.
     * E.g. myDB.mySchema.myTable
     *
     * Returns only simple table name because all inherited drivers does not supports schema and database.
     */ buildTableName(tableName, schema, database) {
        return tableName;
    }
    /**
     * Parse a target table name or other types and return a normalized table definition.
     */ parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = undefined;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
            const parsed = this.parseTableName(target.schema ? `"${target.schema}"."${target.name}"` : target.name);
            return {
                database: target.database || parsed.database || driverDatabase,
                schema: target.schema || parsed.schema || driverSchema,
                tableName: parsed.tableName
            };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
            const parsed = this.parseTableName(target.referencedTableName);
            return {
                database: target.referencedDatabase || parsed.database || driverDatabase,
                schema: target.referencedSchema || parsed.schema || driverSchema,
                tableName: parsed.tableName
            };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
            // EntityMetadata tableName is never a path
            return {
                database: target.database || driverDatabase,
                schema: target.schema || driverSchema,
                tableName: target.tableName
            };
        }
        const parts = target.split(".");
        if (parts.length === 3) {
            return {
                database: parts[0] || driverDatabase,
                schema: parts[1] || driverSchema,
                tableName: parts[2]
            };
        } else if (parts.length === 2) {
            const database = this.getAttachedDatabasePathRelativeByHandle(parts[0]) ?? driverDatabase;
            return {
                database: database,
                schema: parts[0],
                tableName: parts[1]
            };
        } else {
            return {
                database: driverDatabase,
                schema: driverSchema,
                tableName: target
            };
        }
    }
    /**
     * Creates a database type from a given column metadata.
     */ normalizeType(column) {
        if (column.type === Number || column.type === "int") {
            return "integer";
        } else if (column.type === String) {
            return "varchar";
        } else if (column.type === Date) {
            return "datetime";
        } else if (column.type === Boolean) {
            return "boolean";
        } else if (column.type === "uuid") {
            return "varchar";
        } else if (column.type === "simple-array") {
            return "text";
        } else if (column.type === "simple-json") {
            return "text";
        } else if (column.type === "simple-enum") {
            return "varchar";
        } else {
            return column.type || "";
        }
    }
    /**
     * Normalizes "default" value of the column.
     */ normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (typeof defaultValue === "number") {
            return "" + defaultValue;
        }
        if (typeof defaultValue === "boolean") {
            return defaultValue ? "1" : "0";
        }
        if (typeof defaultValue === "function") {
            return defaultValue();
        }
        if (typeof defaultValue === "string") {
            return `'${defaultValue}'`;
        }
        if (defaultValue === null || defaultValue === undefined) {
            return undefined;
        }
        return `${defaultValue}`;
    }
    /**
     * Normalizes "isUnique" value of the column.
     */ normalizeIsUnique(column) {
        return column.entityMetadata.uniques.some((uq)=>uq.columns.length === 1 && uq.columns[0] === column);
    }
    /**
     * Calculates column length taking into account the default length values.
     */ getColumnLength(column) {
        return column.length ? column.length.toString() : "";
    }
    /**
     * Normalizes "default" value of the column.
     */ createFullType(column) {
        let type = column.type;
        if (column.enum) {
            return "varchar";
        }
        if (column.length) {
            type += "(" + column.length + ")";
        } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {
            type += "(" + column.precision + "," + column.scale + ")";
        } else if (column.precision !== null && column.precision !== undefined) {
            type += "(" + column.precision + ")";
        }
        if (column.isArray) type += " array";
        return type;
    }
    /**
     * Obtains a new database connection to a master server.
     * Used for replication.
     * If replication is not setup then returns default connection's database connection.
     */ obtainMasterConnection() {
        return Promise.resolve();
    }
    /**
     * Obtains a new database connection to a slave server.
     * Used for replication.
     * If replication is not setup then returns master (default) connection's database connection.
     */ obtainSlaveConnection() {
        return Promise.resolve();
    }
    /**
     * Creates generated map of values generated or returned by database after INSERT query.
     */ createGeneratedMap(metadata, insertResult, entityIndex, entityNum) {
        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn)=>{
            let value;
            if (generatedColumn.generationStrategy === "increment" && insertResult) {
                // NOTE: When INSERT statement is successfully completed, the last inserted row ID is returned.
                // see also: SqliteQueryRunner.query()
                value = insertResult - entityNum + entityIndex + 1;
            // } else if (generatedColumn.generationStrategy === "uuid") {
            //     value = insertValue[generatedColumn.databaseName];
            }
            if (!value) return map;
            return OrmUtils_1.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
        }, {});
        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;
    }
    /**
     * Differentiate columns of this table and columns from the given column metadatas columns
     * and returns only changed.
     */ findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata)=>{
            const tableColumn = tableColumns.find((c)=>c.name === columnMetadata.databaseName);
            if (!tableColumn) return false; // we don't need new columns, we only need exist and changed
            const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadata.length || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || this.normalizeDefault(columnMetadata) !== tableColumn.default || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || tableColumn.enum && columnMetadata.enum && !OrmUtils_1.OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val)=>val + "")) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
            // DEBUG SECTION
            // if (isColumnChanged) {
            //     console.log("table:", columnMetadata.entityMetadata.tableName)
            //     console.log(
            //         "name:",
            //         tableColumn.name,
            //         columnMetadata.databaseName,
            //     )
            //     console.log(
            //         "type:",
            //         tableColumn.type,
            //         this.normalizeType(columnMetadata),
            //     )
            //     console.log(
            //         "length:",
            //         tableColumn.length,
            //         columnMetadata.length,
            //     )
            //     console.log(
            //         "precision:",
            //         tableColumn.precision,
            //         columnMetadata.precision,
            //     )
            //     console.log("scale:", tableColumn.scale, columnMetadata.scale)
            //     console.log(
            //         "default:",
            //         this.normalizeDefault(columnMetadata),
            //         columnMetadata.default,
            //     )
            //     console.log(
            //         "isPrimary:",
            //         tableColumn.isPrimary,
            //         columnMetadata.isPrimary,
            //     )
            //     console.log(
            //         "isNullable:",
            //         tableColumn.isNullable,
            //         columnMetadata.isNullable,
            //     )
            //     console.log(
            //         "generatedType:",
            //         tableColumn.generatedType,
            //         columnMetadata.generatedType,
            //     )
            //     console.log(
            //         "asExpression:",
            //         tableColumn.asExpression,
            //         columnMetadata.asExpression,
            //     )
            //     console.log(
            //         "isUnique:",
            //         tableColumn.isUnique,
            //         this.normalizeIsUnique(columnMetadata),
            //     )
            //     console.log(
            //         "enum:",
            //         tableColumn.enum &&
            //             columnMetadata.enum &&
            //             !OrmUtils.isArraysEqual(
            //                 tableColumn.enum,
            //                 columnMetadata.enum.map((val) => val + ""),
            //             ),
            //     )
            //     console.log(
            //         "isGenerated:",
            //         tableColumn.isGenerated,
            //         columnMetadata.isGenerated,
            //     )
            // }
            return isColumnChanged;
        });
    }
    /**
     * Returns true if driver supports RETURNING / OUTPUT statement.
     */ isReturningSqlSupported() {
        return false;
    }
    /**
     * Returns true if driver supports uuid values generation on its own.
     */ isUUIDGenerationSupported() {
        return false;
    }
    /**
     * Returns true if driver supports fulltext indices.
     */ isFullTextColumnTypeSupported() {
        return false;
    }
    /**
     * Creates an escaped parameter.
     */ createParameter(parameterName, index) {
        // return "$" + (index + 1);
        return "?";
    // return "$" + parameterName;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates connection with the database.
     */ createDatabaseConnection() {
        return new Promise((ok, fail)=>{
            const options = Object.assign({}, {
                name: this.options.database,
                location: this.options.location
            }, this.options.extra || {});
            this.sqlite.openDatabase(options, (db)=>{
                const databaseConnection = db;
                // we need to enable foreign keys in sqlite to make sure all foreign key related features
                // working properly. this also makes onDelete work with sqlite.
                databaseConnection.executeSql(`PRAGMA foreign_keys = ON`, [], (result)=>{
                    ok(databaseConnection);
                }, (error)=>{
                    fail(error);
                });
            }, (error)=>{
                fail(error);
            });
        });
    }
    /**
     * If driver dependency is not given explicitly, then try to load it via "require".
     */ loadDependencies() {
        try {
            const sqlite = this.options.driver || (()=>{
                const e = new Error("Cannot find module 'react-native-sqlite-storage'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
            this.sqlite = sqlite;
        } catch (e) {
            throw new error_1.DriverPackageNotInstalledError("React-Native", "react-native-sqlite-storage");
        }
    }
}
exports.ReactNativeDriver = ReactNativeDriver; //# sourceMappingURL=ReactNativeDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/nativescript/NativescriptQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NativescriptQueryRunner = void 0;
const QueryFailedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)");
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const AbstractSqliteQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner.js [app-route] (ecmascript)");
/**
 * Runs queries on a single sqlite database connection.
 */ class NativescriptQueryRunner extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver){
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
    }
    /**
     * Called before migrations are run.
     */ async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
    }
    /**
     * Called after migrations are run.
     */ async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
    }
    /**
     * Executes a given SQL query.
     */ async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) {
            throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        }
        const connection = this.driver.connection;
        const databaseConnection = await this.connect();
        return new Promise(async (ok, fail)=>{
            const isInsertQuery = query.substr(0, 11) === "INSERT INTO";
            connection.logger.logQuery(query, parameters, this);
            const handler = (err, raw)=>{
                // log slow queries if maxQueryExecution time is set
                const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
                const queryEndTime = Date.now();
                const queryExecutionTime = queryEndTime - queryStartTime;
                if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
                    connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
                }
                if (err) {
                    connection.logger.logQueryError(err, query, parameters, this);
                    fail(new QueryFailedError_1.QueryFailedError(query, parameters, err));
                }
                const result = new QueryResult_1.QueryResult();
                result.raw = raw;
                if (!isInsertQuery && Array.isArray(raw)) {
                    result.records = raw;
                }
                if (useStructuredResult) {
                    ok(result);
                } else {
                    ok(result.raw);
                }
            };
            const queryStartTime = Date.now();
            if (isInsertQuery) {
                databaseConnection.execSQL(query, parameters, handler);
            } else {
                databaseConnection.all(query, parameters, handler);
            }
        });
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Parametrizes given object of values. Used to create column=value queries.
     */ parametrize(objectLiteral, startIndex = 0) {
        return Object.keys(objectLiteral).map((key, index)=>`"${key}"` + "=?");
    }
}
exports.NativescriptQueryRunner = NativescriptQueryRunner; //# sourceMappingURL=NativescriptQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/nativescript/NativescriptDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NativescriptDriver = void 0;
const AbstractSqliteDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteDriver.js [app-route] (ecmascript)");
const NativescriptQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/nativescript/NativescriptQueryRunner.js [app-route] (ecmascript)");
const DriverPackageNotInstalledError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/DriverPackageNotInstalledError.js [app-route] (ecmascript)");
/**
 * Organizes communication with sqlite DBMS within Nativescript.
 */ class NativescriptDriver extends AbstractSqliteDriver_1.AbstractSqliteDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        super(connection);
        this.connection = connection;
        this.options = connection.options;
        this.database = this.options.database;
        this.driver = this.options.driver;
        // load sqlite package
        this.loadDependencies();
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Closes connection with database.
     */ async disconnect() {
        return new Promise((ok, fail)=>{
            this.queryRunner = undefined;
            this.databaseConnection.close().then(ok).catch(fail);
        });
    }
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        if (!this.queryRunner) {
            this.queryRunner = new NativescriptQueryRunner_1.NativescriptQueryRunner(this);
        }
        return this.queryRunner;
    }
    normalizeType(column) {
        if (column.type === Buffer) {
            return "blob";
        }
        return super.normalizeType(column);
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates connection with the database.
     */ createDatabaseConnection() {
        return new Promise((ok, fail)=>{
            const options = Object.assign({}, {
                readOnly: this.options.readOnly,
                key: this.options.key,
                multithreading: this.options.multithreading,
                migrate: this.options.migrate,
                iosFlags: this.options.iosFlags,
                androidFlags: this.options.androidFlags
            }, this.options.extra || {});
            new this.sqlite(this.options.database, options, (err, db)=>{
                if (err) return fail(err);
                // use object mode to work with TypeORM
                db.resultType(this.sqlite.RESULTSASOBJECT);
                // we need to enable foreign keys in sqlite to make sure all foreign key related features
                // working properly. this also makes onDelete work with sqlite.
                db.execSQL(`PRAGMA foreign_keys = ON`, [], (err, result)=>{
                    if (err) return fail(err);
                    // We are all set
                    ok(db);
                });
            });
        });
    }
    /**
     * If driver dependency is not given explicitly, then try to load it via "require".
     */ loadDependencies() {
        this.sqlite = this.driver;
        if (!this.driver) {
            throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Nativescript", "nativescript-sqlite");
        }
    }
}
exports.NativescriptDriver = NativescriptDriver; //# sourceMappingURL=NativescriptDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/sqljs/SqljsQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SqljsQueryRunner = void 0;
const QueryFailedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)");
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
const AbstractSqliteQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner.js [app-route] (ecmascript)");
/**
 * Runs queries on a single sqlite database connection.
 */ class SqljsQueryRunner extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver){
        super();
        /**
         * Flag to determine if a modification has happened since the last time this query runner has requested a save.
         */ this.isDirty = false;
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
    }
    // -------------------------------------------------------------------------
    // Public methods
    // -------------------------------------------------------------------------
    /**
     * Called before migrations are run.
     */ async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
    }
    /**
     * Called after migrations are run.
     */ async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
    }
    async flush() {
        if (this.isDirty) {
            await this.driver.autoSave();
            this.isDirty = false;
        }
    }
    async release() {
        await this.flush();
        return super.release();
    }
    /**
     * Commits transaction.
     * Error will be thrown if transaction was not started.
     */ async commitTransaction() {
        await super.commitTransaction();
        if (!this.isTransactionActive) {
            await this.flush();
        }
    }
    /**
     * Executes a given SQL query.
     */ async query(query, parameters = [], useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const command = query.trim().split(" ", 1)[0];
        const databaseConnection = this.driver.databaseConnection;
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        const queryStartTime = Date.now();
        let statement;
        try {
            statement = databaseConnection.prepare(query);
            if (parameters) {
                parameters = parameters.map((p)=>typeof p !== "undefined" ? p : null);
                statement.bind(parameters);
            }
            // log slow queries if maxQueryExecution time is set
            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
            const queryEndTime = Date.now();
            const queryExecutionTime = queryEndTime - queryStartTime;
            if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
            const records = [];
            while(statement.step()){
                records.push(statement.getAsObject());
            }
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, records, undefined);
            const result = new QueryResult_1.QueryResult();
            result.affected = databaseConnection.getRowsModified();
            result.records = records;
            result.raw = records;
            statement.free();
            if (command !== "SELECT") {
                this.isDirty = true;
            }
            if (useStructuredResult) {
                return result;
            } else {
                return result.raw;
            }
        } catch (err) {
            if (statement) {
                statement.free();
            }
            this.driver.connection.logger.logQueryError(err, query, parameters, this);
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);
            throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        } finally{
            await broadcasterResult.wait();
        }
    }
}
exports.SqljsQueryRunner = SqljsQueryRunner; //# sourceMappingURL=SqljsQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/sqljs/SqljsDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SqljsDriver = void 0;
const AbstractSqliteDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteDriver.js [app-route] (ecmascript)");
const SqljsQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqljs/SqljsQueryRunner.js [app-route] (ecmascript)");
const DriverPackageNotInstalledError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/DriverPackageNotInstalledError.js [app-route] (ecmascript)");
const DriverOptionNotSetError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/DriverOptionNotSetError.js [app-route] (ecmascript)");
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
class SqljsDriver extends AbstractSqliteDriver_1.AbstractSqliteDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        super(connection);
        // If autoSave is enabled by user, location or autoSaveCallback have to be set
        // because either autoSave saves to location or calls autoSaveCallback.
        if (this.options.autoSave && !this.options.location && !this.options.autoSaveCallback) {
            throw new DriverOptionNotSetError_1.DriverOptionNotSetError(`location or autoSaveCallback`);
        }
        // load sql.js package
        this.loadDependencies();
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Performs connection to the database.
     */ async connect() {
        this.databaseConnection = await this.createDatabaseConnection();
    }
    /**
     * Closes connection with database.
     */ async disconnect() {
        this.queryRunner = undefined;
        this.databaseConnection.close();
    }
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        if (!this.queryRunner) this.queryRunner = new SqljsQueryRunner_1.SqljsQueryRunner(this);
        return this.queryRunner;
    }
    /**
     * Loads a database from a given file (Node.js), local storage key (browser) or array.
     * This will delete the current database!
     */ async load(fileNameOrLocalStorageOrData, checkIfFileOrLocalStorageExists = true) {
        if (typeof fileNameOrLocalStorageOrData === "string") {
            // content has to be loaded
            if (PlatformTools_1.PlatformTools.type === "node") {
                // Node.js
                // fileNameOrLocalStorageOrData should be a path to the file
                if (PlatformTools_1.PlatformTools.fileExist(fileNameOrLocalStorageOrData)) {
                    const database = PlatformTools_1.PlatformTools.readFileSync(fileNameOrLocalStorageOrData);
                    return this.createDatabaseConnectionWithImport(database);
                } else if (checkIfFileOrLocalStorageExists) {
                    throw new error_1.TypeORMError(`File ${fileNameOrLocalStorageOrData} does not exist`);
                } else {
                    // File doesn't exist and checkIfFileOrLocalStorageExists is set to false.
                    // Therefore open a database without importing an existing file.
                    // File will be written on first write operation.
                    return this.createDatabaseConnectionWithImport();
                }
            } else {
                // browser
                // fileNameOrLocalStorageOrData should be a local storage / indexedDB key
                let localStorageContent = null;
                if (this.options.useLocalForage) {
                    if (window.localforage) {
                        localStorageContent = await window.localforage.getItem(fileNameOrLocalStorageOrData);
                    } else {
                        throw new error_1.TypeORMError(`localforage is not defined - please import localforage.js into your site`);
                    }
                } else {
                    localStorageContent = PlatformTools_1.PlatformTools.getGlobalVariable().localStorage.getItem(fileNameOrLocalStorageOrData);
                }
                if (localStorageContent != null) {
                    // localStorage value exists.
                    return this.createDatabaseConnectionWithImport(JSON.parse(localStorageContent));
                } else if (checkIfFileOrLocalStorageExists) {
                    throw new error_1.TypeORMError(`File ${fileNameOrLocalStorageOrData} does not exist`);
                } else {
                    // localStorage value doesn't exist and checkIfFileOrLocalStorageExists is set to false.
                    // Therefore open a database without importing anything.
                    // localStorage value will be written on first write operation.
                    return this.createDatabaseConnectionWithImport();
                }
            }
        } else {
            return this.createDatabaseConnectionWithImport(fileNameOrLocalStorageOrData);
        }
    }
    /**
     * Saved the current database to the given file (Node.js), local storage key (browser) or
     * indexedDB key (browser with enabled useLocalForage option).
     * If no location path is given, the location path in the options (if specified) will be used.
     */ async save(location) {
        if (!location && !this.options.location) {
            throw new error_1.TypeORMError(`No location is set, specify a location parameter or add the location option to your configuration`);
        }
        let path = "";
        if (location) {
            path = location;
        } else if (this.options.location) {
            path = this.options.location;
        }
        if (PlatformTools_1.PlatformTools.type === "node") {
            try {
                const content = Buffer.from(this.databaseConnection.export());
                await PlatformTools_1.PlatformTools.writeFile(path, content);
            } catch (e) {
                throw new error_1.TypeORMError(`Could not save database, error: ${e}`);
            }
        } else {
            const database = this.databaseConnection.export();
            // convert Uint8Array to number array to improve local-storage storage
            const databaseArray = [].slice.call(database);
            if (this.options.useLocalForage) {
                if (window.localforage) {
                    await window.localforage.setItem(path, JSON.stringify(databaseArray));
                } else {
                    throw new error_1.TypeORMError(`localforage is not defined - please import localforage.js into your site`);
                }
            } else {
                PlatformTools_1.PlatformTools.getGlobalVariable().localStorage.setItem(path, JSON.stringify(databaseArray));
            }
        }
    }
    /**
     * This gets called by the QueryRunner when a change to the database is made.
     * If a custom autoSaveCallback is specified, it get's called with the database as Uint8Array,
     * otherwise the save method is called which saves it to file (Node.js), local storage (browser)
     * or indexedDB (browser with enabled useLocalForage option).
     * Don't auto-save when in transaction as the call to export will end the current transaction
     */ async autoSave() {
        if (this.options.autoSave && !this.queryRunner?.isTransactionActive) {
            if (this.options.autoSaveCallback) {
                await this.options.autoSaveCallback(this.export());
            } else {
                await this.save();
            }
        }
    }
    /**
     * Returns the current database as Uint8Array.
     */ export() {
        return this.databaseConnection.export();
    }
    /**
     * Creates generated map of values generated or returned by database after INSERT query.
     */ createGeneratedMap(metadata, insertResult) {
        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn)=>{
            // seems to be the only way to get the inserted id, see https://github.com/kripken/sql.js/issues/77
            if (generatedColumn.isPrimary && generatedColumn.generationStrategy === "increment") {
                const query = "SELECT last_insert_rowid()";
                try {
                    const result = this.databaseConnection.exec(query);
                    this.connection.logger.logQuery(query);
                    return OrmUtils_1.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(result[0].values[0][0]));
                } catch (e) {
                    this.connection.logger.logQueryError(e, query, []);
                }
            }
            return map;
        }, {});
        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates connection with the database.
     * If the location option is set, the database is loaded first.
     */ createDatabaseConnection() {
        if (this.options.location) {
            return this.load(this.options.location, false);
        }
        return this.createDatabaseConnectionWithImport(this.options.database);
    }
    /**
     * Creates connection with an optional database.
     * If database is specified it is loaded, otherwise a new empty database is created.
     */ async createDatabaseConnectionWithImport(database) {
        // sql.js < 1.0 exposes an object with a `Database` method.
        const isLegacyVersion = typeof this.sqlite.Database === "function";
        const sqlite = isLegacyVersion ? this.sqlite : await this.sqlite(this.options.sqlJsConfig);
        if (database && database.length > 0) {
            this.databaseConnection = new sqlite.Database(database);
        } else {
            this.databaseConnection = new sqlite.Database();
        }
        this.databaseConnection.exec(`PRAGMA foreign_keys = ON`);
        return this.databaseConnection;
    }
    /**
     * If driver dependency is not given explicitly, then try to load it via "require".
     */ loadDependencies() {
        if (PlatformTools_1.PlatformTools.type === "browser") {
            const sqlite = this.options.driver || window.SQL;
            this.sqlite = sqlite;
        } else {
            try {
                const sqlite = this.options.driver || PlatformTools_1.PlatformTools.load("sql.js");
                this.sqlite = sqlite;
            } catch (e) {
                throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("sql.js", "sql.js");
            }
        }
    }
}
exports.SqljsDriver = SqljsDriver; //# sourceMappingURL=SqljsDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/expo/ExpoQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExpoQueryRunner = void 0;
const QueryFailedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)");
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
const AbstractSqliteQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner.js [app-route] (ecmascript)");
class ExpoQueryRunner extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
    constructor(driver){
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
    }
    async beforeMigration() {
        await this.query("PRAGMA foreign_keys = OFF");
    }
    async afterMigration() {
        await this.query("PRAGMA foreign_keys = ON");
    }
    async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const queryStartTime = Date.now();
        const statement = await databaseConnection.prepareAsync(query);
        try {
            const rawResult = await statement.executeAsync(parameters);
            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
            const queryEndTime = Date.now();
            const queryExecutionTime = queryEndTime - queryStartTime;
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, rawResult, undefined);
            await broadcasterResult.wait();
            if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
                this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
            }
            const result = new QueryResult_1.QueryResult();
            result.affected = rawResult.changes;
            result.records = await rawResult.getAllAsync();
            result.raw = query.startsWith("INSERT INTO") ? rawResult.lastInsertRowId : result.records;
            return useStructuredResult ? result : result.raw;
        } catch (err) {
            this.driver.connection.logger.logQueryError(err, query, parameters, this);
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, 0, undefined, err);
            await broadcasterResult.wait();
            throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        } finally{
            await broadcasterResult.wait();
            await statement.finalizeAsync();
        }
    }
}
exports.ExpoQueryRunner = ExpoQueryRunner; //# sourceMappingURL=ExpoQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/expo/ExpoDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExpoDriver = void 0;
const AbstractSqliteDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteDriver.js [app-route] (ecmascript)");
const ExpoQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/expo/ExpoQueryRunner.js [app-route] (ecmascript)");
class ExpoDriver extends AbstractSqliteDriver_1.AbstractSqliteDriver {
    constructor(connection){
        super(connection);
        this.sqlite = this.options.driver;
    }
    async disconnect() {
        this.queryRunner = undefined;
        await this.databaseConnection.closeAsync();
        this.databaseConnection = undefined;
    }
    createQueryRunner() {
        if (!this.queryRunner) this.queryRunner = new ExpoQueryRunner_1.ExpoQueryRunner(this);
        return this.queryRunner;
    }
    async createDatabaseConnection() {
        this.databaseConnection = await this.sqlite.openDatabaseAsync(this.options.database);
        await this.databaseConnection.runAsync("PRAGMA foreign_keys = ON");
        return this.databaseConnection;
    }
}
exports.ExpoDriver = ExpoDriver; //# sourceMappingURL=ExpoDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/expo/legacy/ExpoLegacyQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExpoLegacyQueryRunner = void 0;
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const QueryFailedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)");
const AbstractSqliteQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner.js [app-route] (ecmascript)");
const TransactionNotStartedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TransactionNotStartedError.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
/**
 * Runs queries on a single sqlite database connection.
 */ class ExpoLegacyQueryRunner extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver){
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
    }
    /**
     * Starts transaction. Within Expo, all database operations happen in a
     * transaction context, so issuing a `BEGIN TRANSACTION` command is
     * redundant and will result in the following error:
     *
     * `Error: Error code 1: cannot start a transaction within a transaction`
     *
     * Instead, we keep track of a `Transaction` object in `this.transaction`
     * and continue using the same object until we wish to commit the
     * transaction.
     */ async startTransaction() {
        this.isTransactionActive = true;
        try {
            await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
            this.isTransactionActive = false;
            throw err;
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
    }
    /**
     * Commits transaction.
     * Error will be thrown if transaction was not started.
     * Since Expo will automatically commit the transaction once all the
     * callbacks of the transaction object have been completed, "committing" a
     * transaction in this driver's context means that we delete the transaction
     * object and set the stage for the next transaction.
     */ async commitTransaction() {
        if (!this.isTransactionActive && typeof this.transaction === "undefined") throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        this.transaction = undefined;
        this.isTransactionActive = false;
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
    }
    /**
     * Rollbacks transaction.
     * Error will be thrown if transaction was not started.
     * This method's functionality is identical to `commitTransaction()` because
     * the transaction lifecycle is handled within the Expo transaction object.
     * Issuing separate statements for `COMMIT` or `ROLLBACK` aren't necessary.
     */ async rollbackTransaction() {
        if (!this.isTransactionActive && typeof this.transaction === "undefined") throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        this.transaction = undefined;
        this.isTransactionActive = false;
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
    }
    /**
     * Called before migrations are run.
     */ async beforeMigration() {
        const databaseConnection = await this.connect();
        return new Promise((ok, fail)=>{
            databaseConnection.exec([
                {
                    sql: "PRAGMA foreign_keys = OFF",
                    args: []
                }
            ], false, (err)=>err ? fail(err) : ok());
        });
    }
    /**
     * Called after migrations are run.
     */ async afterMigration() {
        const databaseConnection = await this.connect();
        return new Promise((ok, fail)=>{
            databaseConnection.exec([
                {
                    sql: "PRAGMA foreign_keys = ON",
                    args: []
                }
            ], false, (err)=>err ? fail(err) : ok());
        });
    }
    /**
     * Executes a given SQL query.
     */ async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        return new Promise(async (ok, fail)=>{
            const databaseConnection = await this.connect();
            const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
            this.driver.connection.logger.logQuery(query, parameters, this);
            this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);
            const queryStartTime = Date.now();
            // All Expo SQL queries are executed in a transaction context
            databaseConnection.transaction(async (transaction)=>{
                if (typeof this.transaction === "undefined") {
                    await this.startTransaction();
                    this.transaction = transaction;
                }
                this.transaction.executeSql(query, parameters, async (t, raw)=>{
                    // log slow queries if maxQueryExecution time is set
                    const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
                    const queryEndTime = Date.now();
                    const queryExecutionTime = queryEndTime - queryStartTime;
                    this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, raw, undefined);
                    await broadcasterResult.wait();
                    if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) {
                        this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
                    }
                    const result = new QueryResult_1.QueryResult();
                    if (raw?.hasOwnProperty("rowsAffected")) {
                        result.affected = raw.rowsAffected;
                    }
                    if (raw?.hasOwnProperty("rows")) {
                        let resultSet = [];
                        for(let i = 0; i < raw.rows.length; i++){
                            resultSet.push(raw.rows.item(i));
                        }
                        result.raw = resultSet;
                        result.records = resultSet;
                    }
                    // return id of inserted row, if query was insert statement.
                    if (query.startsWith("INSERT INTO")) {
                        result.raw = raw.insertId;
                    }
                    if (useStructuredResult) {
                        ok(result);
                    } else {
                        ok(result.raw);
                    }
                }, async (t, err)=>{
                    this.driver.connection.logger.logQueryError(err, query, parameters, this);
                    this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);
                    await broadcasterResult.wait();
                    fail(new QueryFailedError_1.QueryFailedError(query, parameters, err));
                });
            }, async (err)=>{
                await this.rollbackTransaction();
                fail(err);
            }, ()=>{
                this.isTransactionActive = false;
                this.transaction = undefined;
            });
        });
    }
}
exports.ExpoLegacyQueryRunner = ExpoLegacyQueryRunner; //# sourceMappingURL=ExpoLegacyQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/expo/legacy/ExpoLegacyDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExpoLegacyDriver = void 0;
const AbstractSqliteDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteDriver.js [app-route] (ecmascript)");
const ExpoLegacyQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/expo/legacy/ExpoLegacyQueryRunner.js [app-route] (ecmascript)");
class ExpoLegacyDriver extends AbstractSqliteDriver_1.AbstractSqliteDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        super(connection);
        this.database = this.options.database;
        // load sqlite package
        this.sqlite = this.options.driver;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Closes connection with database.
     */ async disconnect() {
        return new Promise((ok, fail)=>{
            try {
                this.queryRunner = undefined;
                this.databaseConnection._db.close();
                this.databaseConnection = undefined;
                ok();
            } catch (error) {
                fail(error);
            }
        });
    }
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        if (!this.queryRunner) this.queryRunner = new ExpoLegacyQueryRunner_1.ExpoLegacyQueryRunner(this);
        return this.queryRunner;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates connection with the database.
     */ createDatabaseConnection() {
        return new Promise((ok, fail)=>{
            try {
                const databaseConnection = this.sqlite.openDatabase(this.options.database);
                /*
                // we need to enable foreign keys in sqlite to make sure all foreign key related features
                // working properly. this also makes onDelete work with sqlite.
                */ databaseConnection.transaction((tsx)=>{
                    tsx.executeSql(`PRAGMA foreign_keys = ON`, [], (t, result)=>{
                        ok(databaseConnection);
                    }, (t, err)=>{
                        fail({
                            transaction: t,
                            error: err
                        });
                    });
                }, (err)=>{
                    fail(err);
                });
            } catch (error) {
                fail(error);
            }
        });
    }
}
exports.ExpoLegacyDriver = ExpoLegacyDriver; //# sourceMappingURL=ExpoLegacyDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/expo/ExpoDriverFactory.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExpoDriverFactory = void 0;
const ExpoDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/expo/ExpoDriver.js [app-route] (ecmascript)");
const ExpoLegacyDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/expo/legacy/ExpoLegacyDriver.js [app-route] (ecmascript)");
class ExpoDriverFactory {
    constructor(connection){
        this.connection = connection;
    }
    create() {
        if (this.isLegacyDriver) {
            return new ExpoLegacyDriver_1.ExpoLegacyDriver(this.connection);
        }
        return new ExpoDriver_1.ExpoDriver(this.connection);
    }
    get isLegacyDriver() {
        return !("openDatabaseAsync" in this.connection.options.driver);
    }
}
exports.ExpoDriverFactory = ExpoDriverFactory; //# sourceMappingURL=ExpoDriverFactory.js.map
}}),
"[project]/node_modules/typeorm/driver/aurora-mysql/AuroraMysqlQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AuroraMysqlQueryRunner = void 0;
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const TransactionNotStartedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TransactionNotStartedError.js [app-route] (ecmascript)");
const TableColumn_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableColumn.js [app-route] (ecmascript)");
const Table_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/Table.js [app-route] (ecmascript)");
const TableForeignKey_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableForeignKey.js [app-route] (ecmascript)");
const TableIndex_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableIndex.js [app-route] (ecmascript)");
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const View_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/view/View.js [app-route] (ecmascript)");
const Query_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/Query.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const TableUnique_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableUnique.js [app-route] (ecmascript)");
const BaseQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/BaseQueryRunner.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const MetadataTableType_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/types/MetadataTableType.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Runs queries on a single mysql database connection.
 */ class AuroraMysqlQueryRunner extends BaseQueryRunner_1.BaseQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver, client){
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.client = client;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates/uses database connection from the connection pool to perform further operations.
     * Returns obtained database connection.
     */ async connect() {
        return {};
    }
    /**
     * Releases used database connection.
     * You cannot use query runner methods once its released.
     */ release() {
        this.isReleased = true;
        if (this.databaseConnection) this.databaseConnection.release();
        return Promise.resolve();
    }
    /**
     * Starts transaction on the current connection.
     */ async startTransaction(isolationLevel) {
        this.isTransactionActive = true;
        try {
            await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
            this.isTransactionActive = false;
            throw err;
        }
        if (this.transactionDepth === 0) {
            await this.client.startTransaction();
        } else {
            await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
    }
    /**
     * Commits transaction.
     * Error will be thrown if transaction was not started.
     */ async commitTransaction() {
        if (!this.isTransactionActive) throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth > 1) {
            await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
            await this.client.commitTransaction();
            this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
    }
    /**
     * Rollbacks transaction.
     * Error will be thrown if transaction was not started.
     */ async rollbackTransaction() {
        if (!this.isTransactionActive) throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
            await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
            await this.client.rollbackTransaction();
            this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
    }
    /**
     * Executes a raw SQL query.
     */ async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const raw = await this.client.query(query, parameters);
        const result = new QueryResult_1.QueryResult();
        result.raw = raw;
        if (raw?.hasOwnProperty("records") && Array.isArray(raw.records)) {
            result.records = raw.records;
        }
        if (raw?.hasOwnProperty("numberOfRecordsUpdated")) {
            result.affected = raw.numberOfRecordsUpdated;
        }
        if (!useStructuredResult) {
            return result.raw;
        }
        return result;
    }
    /**
     * Returns raw data stream.
     */ stream(query, parameters, onEnd, onError) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        return new Promise(async (ok, fail)=>{
            try {
                const databaseConnection = await this.connect();
                const stream = databaseConnection.query(query, parameters);
                if (onEnd) stream.on("end", onEnd);
                if (onError) stream.on("error", onError);
                ok(stream);
            } catch (err) {
                fail(err);
            }
        });
    }
    /**
     * Returns all available database names including system databases.
     */ async getDatabases() {
        return Promise.resolve([]);
    }
    /**
     * Returns all available schema names including system schemas.
     * If database parameter specified, returns schemas of that database.
     */ async getSchemas(database) {
        throw new error_1.TypeORMError(`MySql driver does not support table schemas`);
    }
    /**
     * Checks if database with the given name exist.
     */ async hasDatabase(database) {
        const result = await this.query(`SELECT * FROM \`INFORMATION_SCHEMA\`.\`SCHEMATA\` WHERE \`SCHEMA_NAME\` = '${database}'`);
        return result.length ? true : false;
    }
    /**
     * Loads currently using database
     */ async getCurrentDatabase() {
        const query = await this.query(`SELECT DATABASE() AS \`db_name\``);
        return query[0]["db_name"];
    }
    /**
     * Checks if schema with the given name exist.
     */ async hasSchema(schema) {
        throw new error_1.TypeORMError(`MySql driver does not support table schemas`);
    }
    /**
     * Loads currently using database schema
     */ async getCurrentSchema() {
        const query = await this.query(`SELECT SCHEMA() AS \`schema_name\``);
        return query[0]["schema_name"];
    }
    /**
     * Checks if table with the given name exist in the database.
     */ async hasTable(tableOrName) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_SCHEMA\` = '${parsedTableName.database}' AND \`TABLE_NAME\` = '${parsedTableName.tableName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
    }
    /**
     * Checks if column with the given name exist in the given table.
     */ async hasColumn(tableOrName, column) {
        const parsedTableName = this.driver.parseTableName(tableOrName);
        const columnName = InstanceChecker_1.InstanceChecker.isTableColumn(column) ? column.name : column;
        const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_SCHEMA\` = '${parsedTableName.database}' AND \`TABLE_NAME\` = '${parsedTableName.tableName}' AND \`COLUMN_NAME\` = '${columnName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
    }
    /**
     * Creates a new database.
     */ async createDatabase(database, ifNotExist) {
        const up = ifNotExist ? `CREATE DATABASE IF NOT EXISTS \`${database}\`` : `CREATE DATABASE \`${database}\``;
        const down = `DROP DATABASE \`${database}\``;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
    }
    /**
     * Drops database.
     */ async dropDatabase(database, ifExist) {
        const up = ifExist ? `DROP DATABASE IF EXISTS \`${database}\`` : `DROP DATABASE \`${database}\``;
        const down = `CREATE DATABASE \`${database}\``;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
    }
    /**
     * Creates a new table schema.
     */ async createSchema(schemaPath, ifNotExist) {
        throw new error_1.TypeORMError(`Schema create queries are not supported by MySql driver.`);
    }
    /**
     * Drops table schema.
     */ async dropSchema(schemaPath, ifExist) {
        throw new error_1.TypeORMError(`Schema drop queries are not supported by MySql driver.`);
    }
    /**
     * Creates a new table.
     */ async createTable(table, ifNotExist = false, createForeignKeys = true) {
        if (ifNotExist) {
            const isTableExist = await this.hasTable(table);
            if (isTableExist) return Promise.resolve();
        }
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        // we must first drop indices, than drop foreign keys, because drop queries runs in reversed order
        // and foreign keys will be dropped first as indices. This order is very important, because we can't drop index
        // if it related to the foreign key.
        // createTable does not need separate method to create indices, because it create indices in the same query with table creation.
        table.indices.forEach((index)=>downQueries.push(this.dropIndexSql(table, index)));
        // if createForeignKeys is true, we must drop created foreign keys in down query.
        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.
        if (createForeignKeys) table.foreignKeys.forEach((foreignKey)=>downQueries.push(this.dropForeignKeySql(table, foreignKey)));
        return this.executeQueries(upQueries, downQueries);
    }
    /**
     * Drop the table.
     */ async dropTable(target, ifExist, dropForeignKeys = true) {
        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need
        // to perform drop queries for foreign keys and indices.
        if (ifExist) {
            const isTableExist = await this.hasTable(target);
            if (!isTableExist) return Promise.resolve();
        }
        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.
        const createForeignKeys = dropForeignKeys;
        const tablePath = this.getTablePath(target);
        const table = await this.getCachedTable(tablePath);
        const upQueries = [];
        const downQueries = [];
        if (dropForeignKeys) table.foreignKeys.forEach((foreignKey)=>upQueries.push(this.dropForeignKeySql(table, foreignKey)));
        table.indices.forEach((index)=>upQueries.push(this.dropIndexSql(table, index)));
        upQueries.push(this.dropTableSql(table));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Creates a new view.
     */ async createView(view, syncWithMetadata = false) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        if (syncWithMetadata) upQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        if (syncWithMetadata) downQueries.push(await this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Drops the view.
     */ async dropView(target) {
        const viewName = InstanceChecker_1.InstanceChecker.isView(target) ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(await this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Renames a table.
     */ async renameTable(oldTableOrName, newTableName) {
        const upQueries = [];
        const downQueries = [];
        const oldTable = InstanceChecker_1.InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : await this.getCachedTable(oldTableOrName);
        const newTable = oldTable.clone();
        const { database } = this.driver.parseTableName(oldTable);
        newTable.name = database ? `${database}.${newTableName}` : newTableName;
        // rename table
        upQueries.push(new Query_1.Query(`RENAME TABLE ${this.escapePath(oldTable)} TO ${this.escapePath(newTable)}`));
        downQueries.push(new Query_1.Query(`RENAME TABLE ${this.escapePath(newTable)} TO ${this.escapePath(oldTable)}`));
        // rename index constraints
        newTable.indices.forEach((index)=>{
            // build new constraint name
            const columnNames = index.columnNames.map((column)=>`\`${column}\``).join(", ");
            const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);
            // build queries
            let indexType = "";
            if (index.isUnique) indexType += "UNIQUE ";
            if (index.isSpatial) indexType += "SPATIAL ";
            if (index.isFulltext) indexType += "FULLTEXT ";
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \`${index.name}\`, ADD ${indexType}INDEX \`${newIndexName}\` (${columnNames})`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(newTable)} DROP INDEX \`${newIndexName}\`, ADD ${indexType}INDEX \`${index.name}\` (${columnNames})`));
            // replace constraint name
            index.name = newIndexName;
        });
        // rename foreign key constraint
        newTable.foreignKeys.forEach((foreignKey)=>{
            // build new constraint name
            const columnNames = foreignKey.columnNames.map((column)=>`\`${column}\``).join(", ");
            const referencedColumnNames = foreignKey.referencedColumnNames.map((column)=>`\`${column}\``).join(",");
            const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames);
            // build queries
            let up = `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \`${foreignKey.name}\`, ADD CONSTRAINT \`${newForeignKeyName}\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
            if (foreignKey.onDelete) up += ` ON DELETE ${foreignKey.onDelete}`;
            if (foreignKey.onUpdate) up += ` ON UPDATE ${foreignKey.onUpdate}`;
            let down = `ALTER TABLE ${this.escapePath(newTable)} DROP FOREIGN KEY \`${newForeignKeyName}\`, ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
            if (foreignKey.onDelete) down += ` ON DELETE ${foreignKey.onDelete}`;
            if (foreignKey.onUpdate) down += ` ON UPDATE ${foreignKey.onUpdate}`;
            upQueries.push(new Query_1.Query(up));
            downQueries.push(new Query_1.Query(down));
            // replace constraint name
            foreignKey.name = newForeignKeyName;
        });
        await this.executeQueries(upQueries, downQueries);
        // rename old table and replace it in cached tabled;
        oldTable.name = newTable.name;
        this.replaceCachedTable(oldTable, newTable);
    }
    /**
     * Creates a new column from the column in the table.
     */ async addColumn(tableOrName, column) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const skipColumnLevelPrimary = clonedTable.primaryColumns.length > 0;
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column, skipColumnLevelPrimary, false)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \`${column.name}\``));
        // create or update primary key constraint
        if (column.isPrimary && skipColumnLevelPrimary) {
            // if we already have generated column, we must temporary drop AUTO_INCREMENT property.
            const generatedColumn = clonedTable.columns.find((column)=>column.isGenerated && column.generationStrategy === "increment");
            if (generatedColumn) {
                const nonGeneratedColumn = generatedColumn.clone();
                nonGeneratedColumn.isGenerated = false;
                nonGeneratedColumn.generationStrategy = undefined;
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${column.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(column, true)}`));
            }
            const primaryColumns = clonedTable.primaryColumns;
            let columnNames = primaryColumns.map((column)=>`\`${column.name}\``).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
            primaryColumns.push(column);
            columnNames = primaryColumns.map((column)=>`\`${column.name}\``).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
            // if we previously dropped AUTO_INCREMENT property, we must bring it back
            if (generatedColumn) {
                const nonGeneratedColumn = generatedColumn.clone();
                nonGeneratedColumn.isGenerated = false;
                nonGeneratedColumn.generationStrategy = undefined;
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(column, true)}`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${column.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
            }
        }
        // create column index
        const columnIndex = clonedTable.indices.find((index)=>index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
            upQueries.push(this.createIndexSql(table, columnIndex));
            downQueries.push(this.dropIndexSql(table, columnIndex));
        } else if (column.isUnique) {
            const uniqueIndex = new TableIndex_1.TableIndex({
                name: this.connection.namingStrategy.indexName(table, [
                    column.name
                ]),
                columnNames: [
                    column.name
                ],
                isUnique: true
            });
            clonedTable.indices.push(uniqueIndex);
            clonedTable.uniques.push(new TableUnique_1.TableUnique({
                name: uniqueIndex.name,
                columnNames: uniqueIndex.columnNames
            }));
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${uniqueIndex.name}\` (\`${column.name}\`)`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${uniqueIndex.name}\``));
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.addColumn(column);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Creates a new columns from the column in the table.
     */ async addColumns(tableOrName, columns) {
        for (const column of columns){
            await this.addColumn(tableOrName, column);
        }
    }
    /**
     * Renames column in the given table.
     */ async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find((c)=>c.name === oldTableColumnOrName);
        if (!oldColumn) throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        let newColumn = undefined;
        if (InstanceChecker_1.InstanceChecker.isTableColumn(newTableColumnOrName)) {
            newColumn = newTableColumnOrName;
        } else {
            newColumn = oldColumn.clone();
            newColumn.name = newTableColumnOrName;
        }
        await this.changeColumn(table, oldColumn, newColumn);
    }
    /**
     * Changes a column in the table.
     */ async changeColumn(tableOrName, oldColumnOrName, newColumn) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        let clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const oldColumn = InstanceChecker_1.InstanceChecker.isTableColumn(oldColumnOrName) ? oldColumnOrName : table.columns.find((column)=>column.name === oldColumnOrName);
        if (!oldColumn) throw new error_1.TypeORMError(`Column "${oldColumnOrName}" was not found in the "${table.name}" table.`);
        if (newColumn.isGenerated !== oldColumn.isGenerated && newColumn.generationStrategy !== "uuid" || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.generatedType !== newColumn.generatedType) {
            await this.dropColumn(table, oldColumn);
            await this.addColumn(table, newColumn);
            // update cloned table
            clonedTable = table.clone();
        } else {
            if (newColumn.name !== oldColumn.name) {
                // We don't change any column properties, just rename it.
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${oldColumn.name}\` \`${newColumn.name}\` ${this.buildCreateColumnSql(oldColumn, true, true)}`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${newColumn.name}\` \`${oldColumn.name}\` ${this.buildCreateColumnSql(oldColumn, true, true)}`));
                // rename index constraints
                clonedTable.findColumnIndices(oldColumn).forEach((index)=>{
                    // build new constraint name
                    index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);
                    index.columnNames.push(newColumn.name);
                    const columnNames = index.columnNames.map((column)=>`\`${column}\``).join(", ");
                    const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);
                    // build queries
                    let indexType = "";
                    if (index.isUnique) indexType += "UNIQUE ";
                    if (index.isSpatial) indexType += "SPATIAL ";
                    if (index.isFulltext) indexType += "FULLTEXT ";
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${index.name}\`, ADD ${indexType}INDEX \`${newIndexName}\` (${columnNames})`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${newIndexName}\`, ADD ${indexType}INDEX \`${index.name}\` (${columnNames})`));
                    // replace constraint name
                    index.name = newIndexName;
                });
                // rename foreign key constraints
                clonedTable.findColumnForeignKeys(oldColumn).forEach((foreignKey)=>{
                    // build new constraint name
                    foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);
                    foreignKey.columnNames.push(newColumn.name);
                    const columnNames = foreignKey.columnNames.map((column)=>`\`${column}\``).join(", ");
                    const referencedColumnNames = foreignKey.referencedColumnNames.map((column)=>`\`${column}\``).join(",");
                    const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames);
                    // build queries
                    let up = `ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \`${foreignKey.name}\`, ADD CONSTRAINT \`${newForeignKeyName}\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
                    if (foreignKey.onDelete) up += ` ON DELETE ${foreignKey.onDelete}`;
                    if (foreignKey.onUpdate) up += ` ON UPDATE ${foreignKey.onUpdate}`;
                    let down = `ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \`${newForeignKeyName}\`, ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
                    if (foreignKey.onDelete) down += ` ON DELETE ${foreignKey.onDelete}`;
                    if (foreignKey.onUpdate) down += ` ON UPDATE ${foreignKey.onUpdate}`;
                    upQueries.push(new Query_1.Query(up));
                    downQueries.push(new Query_1.Query(down));
                    // replace constraint name
                    foreignKey.name = newForeignKeyName;
                });
                // rename old column in the Table object
                const oldTableColumn = clonedTable.columns.find((column)=>column.name === oldColumn.name);
                clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;
                oldColumn.name = newColumn.name;
            }
            if (this.isColumnChanged(oldColumn, newColumn, true)) {
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${oldColumn.name}\` ${this.buildCreateColumnSql(newColumn, true)}`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${newColumn.name}\` ${this.buildCreateColumnSql(oldColumn, true)}`));
            }
            if (newColumn.isPrimary !== oldColumn.isPrimary) {
                // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.
                const generatedColumn = clonedTable.columns.find((column)=>column.isGenerated && column.generationStrategy === "increment");
                if (generatedColumn) {
                    const nonGeneratedColumn = generatedColumn.clone();
                    nonGeneratedColumn.isGenerated = false;
                    nonGeneratedColumn.generationStrategy = undefined;
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
                }
                const primaryColumns = clonedTable.primaryColumns;
                // if primary column state changed, we must always drop existed constraint.
                if (primaryColumns.length > 0) {
                    const columnNames = primaryColumns.map((column)=>`\`${column.name}\``).join(", ");
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
                }
                if (newColumn.isPrimary === true) {
                    primaryColumns.push(newColumn);
                    // update column in table
                    const column = clonedTable.columns.find((column)=>column.name === newColumn.name);
                    column.isPrimary = true;
                    const columnNames = primaryColumns.map((column)=>`\`${column.name}\``).join(", ");
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
                } else {
                    const primaryColumn = primaryColumns.find((c)=>c.name === newColumn.name);
                    primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);
                    // update column in table
                    const column = clonedTable.columns.find((column)=>column.name === newColumn.name);
                    column.isPrimary = false;
                    // if we have another primary keys, we must recreate constraint.
                    if (primaryColumns.length > 0) {
                        const columnNames = primaryColumns.map((column)=>`\`${column.name}\``).join(", ");
                        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
                        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
                    }
                }
                // if we have generated column, and we dropped AUTO_INCREMENT property before, we must bring it back
                if (generatedColumn) {
                    const nonGeneratedColumn = generatedColumn.clone();
                    nonGeneratedColumn.isGenerated = false;
                    nonGeneratedColumn.generationStrategy = undefined;
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
                }
            }
            if (newColumn.isUnique !== oldColumn.isUnique) {
                if (newColumn.isUnique === true) {
                    const uniqueIndex = new TableIndex_1.TableIndex({
                        name: this.connection.namingStrategy.indexName(table, [
                            newColumn.name
                        ]),
                        columnNames: [
                            newColumn.name
                        ],
                        isUnique: true
                    });
                    clonedTable.indices.push(uniqueIndex);
                    clonedTable.uniques.push(new TableUnique_1.TableUnique({
                        name: uniqueIndex.name,
                        columnNames: uniqueIndex.columnNames
                    }));
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${uniqueIndex.name}\` (\`${newColumn.name}\`)`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${uniqueIndex.name}\``));
                } else {
                    const uniqueIndex = clonedTable.indices.find((index)=>{
                        return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find((columnName)=>columnName === newColumn.name);
                    });
                    clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);
                    const tableUnique = clonedTable.uniques.find((unique)=>unique.name === uniqueIndex.name);
                    clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${uniqueIndex.name}\``));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${uniqueIndex.name}\` (\`${newColumn.name}\`)`));
                }
            }
        }
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Changes a column in the table.
     */ async changeColumns(tableOrName, changedColumns) {
        for (const { oldColumn, newColumn } of changedColumns){
            await this.changeColumn(tableOrName, oldColumn, newColumn);
        }
    }
    /**
     * Drops column in the table.
     */ async dropColumn(tableOrName, columnOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const column = InstanceChecker_1.InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);
        if (!column) throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        // drop primary key constraint
        if (column.isPrimary) {
            // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.
            const generatedColumn = clonedTable.columns.find((column)=>column.isGenerated && column.generationStrategy === "increment");
            if (generatedColumn) {
                const nonGeneratedColumn = generatedColumn.clone();
                nonGeneratedColumn.isGenerated = false;
                nonGeneratedColumn.generationStrategy = undefined;
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
            }
            // dropping primary key constraint
            const columnNames = clonedTable.primaryColumns.map((primaryColumn)=>`\`${primaryColumn.name}\``).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP PRIMARY KEY`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD PRIMARY KEY (${columnNames})`));
            // update column in table
            const tableColumn = clonedTable.findColumnByName(column.name);
            tableColumn.isPrimary = false;
            // if primary key have multiple columns, we must recreate it without dropped column
            if (clonedTable.primaryColumns.length > 0) {
                const columnNames = clonedTable.primaryColumns.map((primaryColumn)=>`\`${primaryColumn.name}\``).join(", ");
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD PRIMARY KEY (${columnNames})`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP PRIMARY KEY`));
            }
            // if we have generated column, and we dropped AUTO_INCREMENT property before, and this column is not current dropping column, we must bring it back
            if (generatedColumn && generatedColumn.name !== column.name) {
                const nonGeneratedColumn = generatedColumn.clone();
                nonGeneratedColumn.isGenerated = false;
                nonGeneratedColumn.generationStrategy = undefined;
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
            }
        }
        // drop column index
        const columnIndex = clonedTable.indices.find((index)=>index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
            clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
            upQueries.push(this.dropIndexSql(table, columnIndex));
            downQueries.push(this.createIndexSql(table, columnIndex));
        } else if (column.isUnique) {
            // we splice constraints both from table uniques and indices.
            const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, [
                column.name
            ]);
            const foundUnique = clonedTable.uniques.find((unique)=>unique.name === uniqueName);
            if (foundUnique) clonedTable.uniques.splice(clonedTable.uniques.indexOf(foundUnique), 1);
            const indexName = this.connection.namingStrategy.indexName(table, [
                column.name
            ]);
            const foundIndex = clonedTable.indices.find((index)=>index.name === indexName);
            if (foundIndex) clonedTable.indices.splice(clonedTable.indices.indexOf(foundIndex), 1);
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP INDEX \`${indexName}\``));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD UNIQUE INDEX \`${indexName}\` (\`${column.name}\`)`));
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \`${column.name}\``));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column, true)}`));
        await this.executeQueries(upQueries, downQueries);
        clonedTable.removeColumn(column);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Drops the columns in the table.
     */ async dropColumns(tableOrName, columns) {
        for (const column of columns){
            await this.dropColumn(tableOrName, column);
        }
    }
    /**
     * Creates a new primary key.
     */ async createPrimaryKey(tableOrName, columnNames) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const up = this.createPrimaryKeySql(table, columnNames);
        const down = this.dropPrimaryKeySql(table);
        await this.executeQueries(up, down);
        clonedTable.columns.forEach((column)=>{
            if (columnNames.find((columnName)=>columnName === column.name)) column.isPrimary = true;
        });
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Updates composite primary keys.
     */ async updatePrimaryKeys(tableOrName, columns) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const columnNames = columns.map((column)=>column.name);
        const upQueries = [];
        const downQueries = [];
        // if table have generated column, we must drop AUTO_INCREMENT before changing primary constraints.
        const generatedColumn = clonedTable.columns.find((column)=>column.isGenerated && column.generationStrategy === "increment");
        if (generatedColumn) {
            const nonGeneratedColumn = generatedColumn.clone();
            nonGeneratedColumn.isGenerated = false;
            nonGeneratedColumn.generationStrategy = undefined;
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${generatedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(generatedColumn, true)}`));
        }
        // if table already have primary columns, we must drop them.
        const primaryColumns = clonedTable.primaryColumns;
        if (primaryColumns.length > 0) {
            const columnNames = primaryColumns.map((column)=>`\`${column.name}\``).join(", ");
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNames})`));
        }
        // update columns in table.
        clonedTable.columns.filter((column)=>columnNames.indexOf(column.name) !== -1).forEach((column)=>column.isPrimary = true);
        const columnNamesString = columnNames.map((columnName)=>`\`${columnName}\``).join(", ");
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNamesString})`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`));
        // if we already have generated column or column is changed to generated, and we dropped AUTO_INCREMENT property before, we must bring it back
        const newOrExistGeneratedColumn = generatedColumn ? generatedColumn : columns.find((column)=>column.isGenerated && column.generationStrategy === "increment");
        if (newOrExistGeneratedColumn) {
            const nonGeneratedColumn = newOrExistGeneratedColumn.clone();
            nonGeneratedColumn.isGenerated = false;
            nonGeneratedColumn.generationStrategy = undefined;
            upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${nonGeneratedColumn.name}\` ${this.buildCreateColumnSql(newOrExistGeneratedColumn, true)}`));
            downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} CHANGE \`${newOrExistGeneratedColumn.name}\` ${this.buildCreateColumnSql(nonGeneratedColumn, true)}`));
            // if column changed to generated, we must update it in table
            const changedGeneratedColumn = clonedTable.columns.find((column)=>column.name === newOrExistGeneratedColumn.name);
            changedGeneratedColumn.isGenerated = true;
            changedGeneratedColumn.generationStrategy = "increment";
        }
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Drops a primary key.
     */ async dropPrimaryKey(tableOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const up = this.dropPrimaryKeySql(table);
        const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column)=>column.name));
        await this.executeQueries(up, down);
        table.primaryColumns.forEach((column)=>{
            column.isPrimary = false;
        });
    }
    /**
     * Creates a new unique constraint.
     */ async createUniqueConstraint(tableOrName, uniqueConstraint) {
        throw new error_1.TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
    }
    /**
     * Creates a new unique constraints.
     */ async createUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
    }
    /**
     * Drops an unique constraint.
     */ async dropUniqueConstraint(tableOrName, uniqueOrName) {
        throw new error_1.TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
    }
    /**
     * Drops an unique constraints.
     */ async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`MySql does not support unique constraints. Use unique index instead.`);
    }
    /**
     * Creates a new check constraint.
     */ async createCheckConstraint(tableOrName, checkConstraint) {
        throw new error_1.TypeORMError(`MySql does not support check constraints.`);
    }
    /**
     * Creates a new check constraints.
     */ async createCheckConstraints(tableOrName, checkConstraints) {
        throw new error_1.TypeORMError(`MySql does not support check constraints.`);
    }
    /**
     * Drops check constraint.
     */ async dropCheckConstraint(tableOrName, checkOrName) {
        throw new error_1.TypeORMError(`MySql does not support check constraints.`);
    }
    /**
     * Drops check constraints.
     */ async dropCheckConstraints(tableOrName, checkConstraints) {
        throw new error_1.TypeORMError(`MySql does not support check constraints.`);
    }
    /**
     * Creates a new exclusion constraint.
     */ async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`MySql does not support exclusion constraints.`);
    }
    /**
     * Creates a new exclusion constraints.
     */ async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`MySql does not support exclusion constraints.`);
    }
    /**
     * Drops exclusion constraint.
     */ async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`MySql does not support exclusion constraints.`);
    }
    /**
     * Drops exclusion constraints.
     */ async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`MySql does not support exclusion constraints.`);
    }
    /**
     * Creates a new foreign key.
     */ async createForeignKey(tableOrName, foreignKey) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // new FK may be passed without name. In this case we generate FK name manually.
        if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames);
        const up = this.createForeignKeySql(table, foreignKey);
        const down = this.dropForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.addForeignKey(foreignKey);
    }
    /**
     * Creates a new foreign keys.
     */ async createForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey)=>this.createForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
    }
    /**
     * Drops a foreign key.
     */ async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find((fk)=>fk.name === foreignKeyOrName);
        if (!foreignKey) throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        const up = this.dropForeignKeySql(table, foreignKey);
        const down = this.createForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.removeForeignKey(foreignKey);
    }
    /**
     * Drops a foreign keys from the table.
     */ async dropForeignKeys(tableOrName, foreignKeys) {
        const promises = foreignKeys.map((foreignKey)=>this.dropForeignKey(tableOrName, foreignKey));
        await Promise.all(promises);
    }
    /**
     * Creates a new index.
     */ async createIndex(tableOrName, index) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        // new index may be passed without name. In this case we generate index name manually.
        if (!index.name) index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(table, index);
        await this.executeQueries(up, down);
        table.addIndex(index, true);
    }
    /**
     * Creates a new indices
     */ async createIndices(tableOrName, indices) {
        const promises = indices.map((index)=>this.createIndex(tableOrName, index));
        await Promise.all(promises);
    }
    /**
     * Drops an index.
     */ async dropIndex(tableOrName, indexOrName) {
        const table = InstanceChecker_1.InstanceChecker.isTable(tableOrName) ? tableOrName : await this.getCachedTable(tableOrName);
        const index = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find((i)=>i.name === indexOrName);
        if (!index) throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        // old index may be passed without name. In this case we generate index name manually.
        if (!index.name) index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(table, index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index, true);
    }
    /**
     * Drops an indices from the table.
     */ async dropIndices(tableOrName, indices) {
        const promises = indices.map((index)=>this.dropIndex(tableOrName, index));
        await Promise.all(promises);
    }
    /**
     * Clears all table contents.
     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.
     */ async clearTable(tableOrName) {
        await this.query(`TRUNCATE TABLE ${this.escapePath(tableOrName)}`);
    }
    /**
     * Removes all tables from the currently connected database.
     * Be careful using this method and avoid using it in production or migrations
     * (because it can clear all your database).
     */ async clearDatabase(database) {
        const dbName = database ? database : this.driver.database;
        if (dbName) {
            const isDatabaseExist = await this.hasDatabase(dbName);
            if (!isDatabaseExist) return Promise.resolve();
        } else {
            throw new error_1.TypeORMError(`Can not clear database. No database is specified`);
        }
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive) await this.startTransaction();
        try {
            const selectViewDropsQuery = `SELECT concat('DROP VIEW IF EXISTS \`', table_schema, '\`.\`', table_name, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`VIEWS\` WHERE \`TABLE_SCHEMA\` = '${dbName}'`;
            const dropViewQueries = await this.query(selectViewDropsQuery);
            await Promise.all(dropViewQueries.map((q)=>this.query(q["query"])));
            const disableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 0;`;
            const dropTablesQuery = `SELECT concat('DROP TABLE IF EXISTS \`', table_schema, '\`.\`', table_name, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE \`TABLE_SCHEMA\` = '${dbName}'`;
            const enableForeignKeysCheckQuery = `SET FOREIGN_KEY_CHECKS = 1;`;
            await this.query(disableForeignKeysCheckQuery);
            const dropQueries = await this.query(dropTablesQuery);
            await Promise.all(dropQueries.map((query)=>this.query(query["query"])));
            await this.query(enableForeignKeysCheckQuery);
            if (!isAnotherTransactionActive) {
                await this.commitTransaction();
            }
        } catch (error) {
            try {
                // we throw original error even if rollback thrown an error
                if (!isAnotherTransactionActive) {
                    await this.rollbackTransaction();
                }
            } catch (rollbackError) {}
            throw error;
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    async loadViews(viewNames) {
        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());
        if (!hasTable) {
            return [];
        }
        if (!viewNames) {
            viewNames = [];
        }
        const currentDatabase = await this.getCurrentDatabase();
        const viewsCondition = viewNames.map((tableName)=>{
            let { database, tableName: name } = this.driver.parseTableName(tableName);
            if (!database) {
                database = currentDatabase;
            }
            return `(\`t\`.\`schema\` = '${database}' AND \`t\`.\`name\` = '${name}')`;
        }).join(" OR ");
        const query = `SELECT \`t\`.*, \`v\`.\`check_option\` FROM ${this.escapePath(this.getTypeormMetadataTableName())} \`t\` ` + `INNER JOIN \`information_schema\`.\`views\` \`v\` ON \`v\`.\`table_schema\` = \`t\`.\`schema\` AND \`v\`.\`table_name\` = \`t\`.\`name\` WHERE \`t\`.\`type\` = '${MetadataTableType_1.MetadataTableType.VIEW}' ${viewsCondition ? `AND (${viewsCondition})` : ""}`;
        const dbViews = await this.query(query);
        return dbViews.map((dbView)=>{
            const view = new View_1.View();
            const db = dbView["schema"] === currentDatabase ? undefined : dbView["schema"];
            view.database = dbView["schema"];
            view.name = this.driver.buildTableName(dbView["name"], undefined, db);
            view.expression = dbView["value"];
            return view;
        });
    }
    /**
     * Loads all tables (with given names) from the database and creates a Table from them.
     */ async loadTables(tableNames) {
        // if no tables given then no need to proceed
        if (tableNames && tableNames.length === 0) {
            return [];
        }
        const dbTables = [];
        const currentDatabase = await this.getCurrentDatabase();
        if (!tableNames) {
            const tablesSql = `SELECT TABLE_NAME, TABLE_SCHEMA FROM \`INFORMATION_SCHEMA\`.\`TABLES\``;
            dbTables.push(...await this.query(tablesSql));
        } else {
            const tablesCondition = tableNames.map((tableName)=>{
                let [database, name] = tableName.split(".");
                if (!name) {
                    name = database;
                    database = this.driver.database || currentDatabase;
                }
                return `(\`TABLE_SCHEMA\` = '${database}' AND \`TABLE_NAME\` = '${name}')`;
            }).join(" OR ");
            const tablesSql = `SELECT TABLE_NAME, TABLE_SCHEMA FROM \`INFORMATION_SCHEMA\`.\`TABLES\` WHERE ` + tablesCondition;
            dbTables.push(...await this.query(tablesSql));
        }
        if (dbTables.length === 0) {
            return [];
        }
        const columnsCondition = dbTables.map(({ TABLE_NAME, TABLE_SCHEMA })=>{
            return `(\`TABLE_SCHEMA\` = '${TABLE_SCHEMA}' AND \`TABLE_NAME\` = '${TABLE_NAME}')`;
        }).join(" OR ");
        const columnsSql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE ` + columnsCondition;
        const primaryKeySql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` WHERE \`CONSTRAINT_NAME\` = 'PRIMARY' AND (${columnsCondition})`;
        const collationsSql = `SELECT \`SCHEMA_NAME\`, \`DEFAULT_CHARACTER_SET_NAME\` as \`CHARSET\`, \`DEFAULT_COLLATION_NAME\` AS \`COLLATION\` FROM \`INFORMATION_SCHEMA\`.\`SCHEMATA\``;
        const indicesCondition = dbTables.map(({ TABLE_NAME, TABLE_SCHEMA })=>{
            return `(\`s\`.\`TABLE_SCHEMA\` = '${TABLE_SCHEMA}' AND \`s\`.\`TABLE_NAME\` = '${TABLE_NAME}')`;
        }).join(" OR ");
        const indicesSql = `SELECT \`s\`.* FROM \`INFORMATION_SCHEMA\`.\`STATISTICS\` \`s\` ` + `LEFT JOIN \`INFORMATION_SCHEMA\`.\`REFERENTIAL_CONSTRAINTS\` \`rc\` ON \`s\`.\`INDEX_NAME\` = \`rc\`.\`CONSTRAINT_NAME\` ` + `WHERE (${indicesCondition}) AND \`s\`.\`INDEX_NAME\` != 'PRIMARY' AND \`rc\`.\`CONSTRAINT_NAME\` IS NULL`;
        const foreignKeysCondition = dbTables.map(({ TABLE_NAME, TABLE_SCHEMA })=>{
            return `(\`kcu\`.\`TABLE_SCHEMA\` = '${TABLE_SCHEMA}' AND \`kcu\`.\`TABLE_NAME\` = '${TABLE_NAME}')`;
        }).join(" OR ");
        const foreignKeysSql = `SELECT \`kcu\`.\`TABLE_SCHEMA\`, \`kcu\`.\`TABLE_NAME\`, \`kcu\`.\`CONSTRAINT_NAME\`, \`kcu\`.\`COLUMN_NAME\`, \`kcu\`.\`REFERENCED_TABLE_SCHEMA\`, ` + `\`kcu\`.\`REFERENCED_TABLE_NAME\`, \`kcu\`.\`REFERENCED_COLUMN_NAME\`, \`rc\`.\`DELETE_RULE\` \`ON_DELETE\`, \`rc\`.\`UPDATE_RULE\` \`ON_UPDATE\` ` + `FROM \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` \`kcu\` ` + `INNER JOIN \`INFORMATION_SCHEMA\`.\`REFERENTIAL_CONSTRAINTS\` \`rc\` ON \`rc\`.\`constraint_name\` = \`kcu\`.\`constraint_name\` ` + `WHERE ` + foreignKeysCondition;
        const [dbColumns, dbPrimaryKeys, dbCollations, dbIndices, dbForeignKeys] = await Promise.all([
            this.query(columnsSql),
            this.query(primaryKeySql),
            this.query(collationsSql),
            this.query(indicesSql),
            this.query(foreignKeysSql)
        ]);
        // create tables for loaded tables
        return Promise.all(dbTables.map(async (dbTable)=>{
            const table = new Table_1.Table();
            const dbCollation = dbCollations.find((coll)=>coll["SCHEMA_NAME"] === dbTable["TABLE_SCHEMA"]);
            const defaultCollation = dbCollation["COLLATION"];
            const defaultCharset = dbCollation["CHARSET"];
            // We do not need to join database name, when database is by default.
            const db = dbTable["TABLE_SCHEMA"] === currentDatabase ? undefined : dbTable["TABLE_SCHEMA"];
            table.database = dbTable["TABLE_SCHEMA"];
            table.name = this.driver.buildTableName(dbTable["TABLE_NAME"], undefined, db);
            // create columns from the loaded columns
            table.columns = dbColumns.filter((dbColumn)=>dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbColumn["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"]).map((dbColumn)=>{
                const columnUniqueIndices = dbIndices.filter((dbIndex)=>{
                    return dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"] && dbIndex["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] && parseInt(dbIndex["NON_UNIQUE"], 10) === 0;
                });
                const tableMetadata = this.connection.entityMetadatas.find((metadata)=>this.getTablePath(table) === this.getTablePath(metadata));
                const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some((index)=>{
                    return columnUniqueIndices.some((uniqueIndex)=>{
                        return index.name === uniqueIndex["INDEX_NAME"] && index.synchronize === false;
                    });
                });
                const isConstraintComposite = columnUniqueIndices.every((uniqueIndex)=>{
                    return dbIndices.some((dbIndex)=>dbIndex["INDEX_NAME"] === uniqueIndex["INDEX_NAME"] && dbIndex["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"]);
                });
                const tableColumn = new TableColumn_1.TableColumn();
                tableColumn.name = dbColumn["COLUMN_NAME"];
                tableColumn.type = dbColumn["DATA_TYPE"].toLowerCase();
                // Unsigned columns are handled differently when it comes to width.
                // Hence, we need to set the unsigned attribute before we check the width.
                tableColumn.unsigned = tableColumn.zerofill ? true : dbColumn["COLUMN_TYPE"].indexOf("unsigned") !== -1;
                if (this.driver.withWidthColumnTypes.indexOf(tableColumn.type) !== -1) {
                    const width = dbColumn["COLUMN_TYPE"].substring(dbColumn["COLUMN_TYPE"].indexOf("(") + 1, dbColumn["COLUMN_TYPE"].indexOf(")"));
                    tableColumn.width = width && !this.isDefaultColumnWidth(table, tableColumn, parseInt(width)) ? parseInt(width) : undefined;
                }
                if (dbColumn["COLUMN_DEFAULT"] === null || dbColumn["COLUMN_DEFAULT"] === undefined) {
                    tableColumn.default = undefined;
                } else {
                    tableColumn.default = dbColumn["COLUMN_DEFAULT"] === "CURRENT_TIMESTAMP" ? dbColumn["COLUMN_DEFAULT"] : `'${dbColumn["COLUMN_DEFAULT"]}'`;
                }
                if (dbColumn["EXTRA"].indexOf("on update") !== -1) {
                    tableColumn.onUpdate = dbColumn["EXTRA"].substring(dbColumn["EXTRA"].indexOf("on update") + 10);
                }
                if (dbColumn["GENERATION_EXPRESSION"]) {
                    tableColumn.asExpression = dbColumn["GENERATION_EXPRESSION"];
                    tableColumn.generatedType = dbColumn["EXTRA"].indexOf("VIRTUAL") !== -1 ? "VIRTUAL" : "STORED";
                }
                tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;
                tableColumn.isNullable = dbColumn["IS_NULLABLE"] === "YES";
                tableColumn.isPrimary = dbPrimaryKeys.some((dbPrimaryKey)=>{
                    return dbPrimaryKey["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbPrimaryKey["TABLE_SCHEMA"] === dbColumn["TABLE_SCHEMA"] && dbPrimaryKey["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
                });
                tableColumn.zerofill = dbColumn["COLUMN_TYPE"].indexOf("zerofill") !== -1;
                tableColumn.isGenerated = dbColumn["EXTRA"].indexOf("auto_increment") !== -1;
                if (tableColumn.isGenerated) tableColumn.generationStrategy = "increment";
                tableColumn.comment = typeof dbColumn["COLUMN_COMMENT"] === "string" && dbColumn["COLUMN_COMMENT"].length === 0 ? undefined : dbColumn["COLUMN_COMMENT"];
                if (dbColumn["CHARACTER_SET_NAME"]) tableColumn.charset = dbColumn["CHARACTER_SET_NAME"] === defaultCharset ? undefined : dbColumn["CHARACTER_SET_NAME"];
                if (dbColumn["COLLATION_NAME"]) tableColumn.collation = dbColumn["COLLATION_NAME"] === defaultCollation ? undefined : dbColumn["COLLATION_NAME"];
                // check only columns that have length property
                if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1 && dbColumn["CHARACTER_MAXIMUM_LENGTH"]) {
                    const length = dbColumn["CHARACTER_MAXIMUM_LENGTH"].toString();
                    tableColumn.length = !this.isDefaultColumnLength(table, tableColumn, length) ? length : "";
                }
                if (tableColumn.type === "decimal" || tableColumn.type === "double" || tableColumn.type === "float") {
                    if (dbColumn["NUMERIC_PRECISION"] !== null && !this.isDefaultColumnPrecision(table, tableColumn, dbColumn["NUMERIC_PRECISION"])) tableColumn.precision = parseInt(dbColumn["NUMERIC_PRECISION"]);
                    if (dbColumn["NUMERIC_SCALE"] !== null && !this.isDefaultColumnScale(table, tableColumn, dbColumn["NUMERIC_SCALE"])) tableColumn.scale = parseInt(dbColumn["NUMERIC_SCALE"]);
                }
                if (tableColumn.type === "enum" || tableColumn.type === "simple-enum" || tableColumn.type === "set") {
                    const colType = dbColumn["COLUMN_TYPE"];
                    const items = colType.substring(colType.indexOf("(") + 1, colType.lastIndexOf(")")).split(",");
                    tableColumn.enum = items.map((item)=>{
                        return item.substring(1, item.length - 1);
                    });
                    tableColumn.length = "";
                }
                if ((tableColumn.type === "datetime" || tableColumn.type === "time" || tableColumn.type === "timestamp") && dbColumn["DATETIME_PRECISION"] !== null && dbColumn["DATETIME_PRECISION"] !== undefined && !this.isDefaultColumnPrecision(table, tableColumn, parseInt(dbColumn["DATETIME_PRECISION"]))) {
                    tableColumn.precision = parseInt(dbColumn["DATETIME_PRECISION"]);
                }
                return tableColumn;
            });
            // find foreign key constraints of table, group them by constraint name and build TableForeignKey.
            const tableForeignKeyConstraints = OrmUtils_1.OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey)=>{
                return dbForeignKey["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbForeignKey["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"];
            }), (dbForeignKey)=>dbForeignKey["CONSTRAINT_NAME"]);
            table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey)=>{
                const foreignKeys = dbForeignKeys.filter((dbFk)=>dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
                // if referenced table located in currently used db, we don't need to concat db name to table name.
                const database = dbForeignKey["REFERENCED_TABLE_SCHEMA"] === currentDatabase ? undefined : dbForeignKey["REFERENCED_TABLE_SCHEMA"];
                const referencedTableName = this.driver.buildTableName(dbForeignKey["REFERENCED_TABLE_NAME"], undefined, database);
                return new TableForeignKey_1.TableForeignKey({
                    name: dbForeignKey["CONSTRAINT_NAME"],
                    columnNames: foreignKeys.map((dbFk)=>dbFk["COLUMN_NAME"]),
                    referencedDatabase: dbForeignKey["REFERENCED_TABLE_SCHEMA"],
                    referencedTableName: referencedTableName,
                    referencedColumnNames: foreignKeys.map((dbFk)=>dbFk["REFERENCED_COLUMN_NAME"]),
                    onDelete: dbForeignKey["ON_DELETE"],
                    onUpdate: dbForeignKey["ON_UPDATE"]
                });
            });
            // find index constraints of table, group them by constraint name and build TableIndex.
            const tableIndexConstraints = OrmUtils_1.OrmUtils.uniq(dbIndices.filter((dbIndex)=>{
                return dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["TABLE_SCHEMA"] === dbTable["TABLE_SCHEMA"];
            }), (dbIndex)=>dbIndex["INDEX_NAME"]);
            table.indices = tableIndexConstraints.map((constraint)=>{
                const indices = dbIndices.filter((index)=>{
                    return index["TABLE_SCHEMA"] === constraint["TABLE_SCHEMA"] && index["TABLE_NAME"] === constraint["TABLE_NAME"] && index["INDEX_NAME"] === constraint["INDEX_NAME"];
                });
                const nonUnique = parseInt(constraint["NON_UNIQUE"], 10);
                return new TableIndex_1.TableIndex({
                    table: table,
                    name: constraint["INDEX_NAME"],
                    columnNames: indices.map((i)=>i["COLUMN_NAME"]),
                    isUnique: nonUnique === 0,
                    isSpatial: constraint["INDEX_TYPE"] === "SPATIAL",
                    isFulltext: constraint["INDEX_TYPE"] === "FULLTEXT"
                });
            });
            return table;
        }));
    }
    /**
     * Builds create table sql
     */ createTableSql(table, createForeignKeys) {
        const columnDefinitions = table.columns.map((column)=>this.buildCreateColumnSql(column, true)).join(", ");
        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
        // we create unique indexes instead of unique constraints, because MySql does not have unique constraints.
        // if we mark column as Unique, it means that we create UNIQUE INDEX.
        table.columns.filter((column)=>column.isUnique).forEach((column)=>{
            const isUniqueIndexExist = table.indices.some((index)=>{
                return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;
            });
            const isUniqueConstraintExist = table.uniques.some((unique)=>{
                return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;
            });
            if (!isUniqueIndexExist && !isUniqueConstraintExist) table.indices.push(new TableIndex_1.TableIndex({
                name: this.connection.namingStrategy.uniqueConstraintName(table, [
                    column.name
                ]),
                columnNames: [
                    column.name
                ],
                isUnique: true
            }));
        });
        // as MySql does not have unique constraints, we must create table indices from table uniques and mark them as unique.
        if (table.uniques.length > 0) {
            table.uniques.forEach((unique)=>{
                const uniqueExist = table.indices.some((index)=>index.name === unique.name);
                if (!uniqueExist) {
                    table.indices.push(new TableIndex_1.TableIndex({
                        name: unique.name,
                        columnNames: unique.columnNames,
                        isUnique: true
                    }));
                }
            });
        }
        if (table.indices.length > 0) {
            const indicesSql = table.indices.map((index)=>{
                const columnNames = index.columnNames.map((columnName)=>`\`${columnName}\``).join(", ");
                if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
                let indexType = "";
                if (index.isUnique) indexType += "UNIQUE ";
                if (index.isSpatial) indexType += "SPATIAL ";
                if (index.isFulltext) indexType += "FULLTEXT ";
                return `${indexType}INDEX \`${index.name}\` (${columnNames})`;
            }).join(", ");
            sql += `, ${indicesSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
            const foreignKeysSql = table.foreignKeys.map((fk)=>{
                const columnNames = fk.columnNames.map((columnName)=>`\`${columnName}\``).join(", ");
                if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames);
                const referencedColumnNames = fk.referencedColumnNames.map((columnName)=>`\`${columnName}\``).join(", ");
                let constraint = `CONSTRAINT \`${fk.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
                if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;
                if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;
                return constraint;
            }).join(", ");
            sql += `, ${foreignKeysSql}`;
        }
        if (table.primaryColumns.length > 0) {
            const columnNames = table.primaryColumns.map((column)=>`\`${column.name}\``).join(", ");
            sql += `, PRIMARY KEY (${columnNames})`;
        }
        sql += `) ENGINE=${table.engine || "InnoDB"}`;
        return new Query_1.Query(sql);
    }
    /**
     * Builds drop table sql
     */ dropTableSql(tableOrName) {
        return new Query_1.Query(`DROP TABLE ${this.escapePath(tableOrName)}`);
    }
    createViewSql(view) {
        if (typeof view.expression === "string") {
            return new Query_1.Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression}`);
        } else {
            return new Query_1.Query(`CREATE VIEW ${this.escapePath(view)} AS ${view.expression(this.connection).getQuery()}`);
        }
    }
    async insertViewDefinitionSql(view) {
        const currentDatabase = await this.getCurrentDatabase();
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        return this.insertTypeormMetadataSql({
            type: MetadataTableType_1.MetadataTableType.VIEW,
            schema: currentDatabase,
            name: view.name,
            value: expression
        });
    }
    /**
     * Builds drop view sql.
     */ dropViewSql(viewOrPath) {
        return new Query_1.Query(`DROP VIEW ${this.escapePath(viewOrPath)}`);
    }
    /**
     * Builds remove view sql.
     */ async deleteViewDefinitionSql(viewOrPath) {
        const currentDatabase = await this.getCurrentDatabase();
        const viewName = InstanceChecker_1.InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;
        return this.deleteTypeormMetadataSql({
            type: MetadataTableType_1.MetadataTableType.VIEW,
            schema: currentDatabase,
            name: viewName
        });
    }
    /**
     * Builds create index sql.
     */ createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName)=>`\`${columnName}\``).join(", ");
        let indexType = "";
        if (index.isUnique) indexType += "UNIQUE ";
        if (index.isSpatial) indexType += "SPATIAL ";
        if (index.isFulltext) indexType += "FULLTEXT ";
        return new Query_1.Query(`CREATE ${indexType}INDEX \`${index.name}\` ON ${this.escapePath(table)} (${columns})`);
    }
    /**
     * Builds drop index sql.
     */ dropIndexSql(table, indexOrName) {
        const indexName = InstanceChecker_1.InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;
        return new Query_1.Query(`DROP INDEX \`${indexName}\` ON ${this.escapePath(table)}`);
    }
    /**
     * Builds create primary key sql.
     */ createPrimaryKeySql(table, columnNames) {
        const columnNamesString = columnNames.map((columnName)=>`\`${columnName}\``).join(", ");
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD PRIMARY KEY (${columnNamesString})`);
    }
    /**
     * Builds drop primary key sql.
     */ dropPrimaryKeySql(table) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP PRIMARY KEY`);
    }
    /**
     * Builds create foreign key sql.
     */ createForeignKeySql(table, foreignKey) {
        const columnNames = foreignKey.columnNames.map((column)=>`\`${column}\``).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column)=>`\`${column}\``).join(",");
        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;
        if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`;
        if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`;
        return new Query_1.Query(sql);
    }
    /**
     * Builds drop foreign key sql.
     */ dropForeignKeySql(table, foreignKeyOrName) {
        const foreignKeyName = InstanceChecker_1.InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP FOREIGN KEY \`${foreignKeyName}\``);
    }
    /**
     * Escapes a given comment so it's safe to include in a query.
     */ escapeComment(comment) {
        if (!comment || comment.length === 0) {
            return `''`;
        }
        comment = comment.replace(/\\/g, "\\\\") // MySQL allows escaping characters via backslashes
        .replace(/'/g, "''").replace(/\u0000/g, ""); // Null bytes aren't allowed in comments
        return `'${comment}'`;
    }
    /**
     * Escapes given table or view path.
     */ escapePath(target) {
        const { database, tableName } = this.driver.parseTableName(target);
        if (database && database !== this.driver.database) {
            return `\`${database}\`.\`${tableName}\``;
        }
        return `\`${tableName}\``;
    }
    /**
     * Builds a part of query to create/change a column.
     */ buildCreateColumnSql(column, skipPrimary, skipName = false) {
        let c = "";
        if (skipName) {
            c = this.connection.driver.createFullType(column);
        } else {
            c = `\`${column.name}\` ${this.connection.driver.createFullType(column)}`;
        }
        if (column.asExpression) c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : "VIRTUAL"}`;
        // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to that column.
        if (column.zerofill) {
            c += " ZEROFILL";
        } else if (column.unsigned) {
            c += " UNSIGNED";
        }
        if (column.enum) c += ` (${column.enum.map((value)=>"'" + value + "'").join(", ")})`;
        if (column.charset) c += ` CHARACTER SET "${column.charset}"`;
        if (column.collation) c += ` COLLATE "${column.collation}"`;
        if (!column.isNullable) c += " NOT NULL";
        if (column.isNullable) c += " NULL";
        if (column.isPrimary && !skipPrimary) c += " PRIMARY KEY";
        if (column.isGenerated && column.generationStrategy === "increment") // don't use skipPrimary here since updates can update already exist primary without auto inc.
        c += " AUTO_INCREMENT";
        if (column.comment) c += ` COMMENT ${this.escapeComment(column.comment)}`;
        if (column.default !== undefined && column.default !== null) c += ` DEFAULT ${column.default}`;
        if (column.onUpdate) c += ` ON UPDATE ${column.onUpdate}`;
        return c;
    }
    /**
     * Checks if column display width is by default.
     */ isDefaultColumnWidth(table, column, width) {
        // if table have metadata, we check if length is specified in column metadata
        if (this.connection.hasMetadata(table.name)) {
            const metadata = this.connection.getMetadata(table.name);
            const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
            if (columnMetadata && columnMetadata.width) return false;
        }
        const defaultWidthForType = this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].width;
        if (defaultWidthForType) {
            // In MariaDB & MySQL 5.7, the default widths of certain numeric types are 1 less than
            // the usual defaults when the column is unsigned.
            // This also applies to Aurora MySQL.
            const typesWithReducedUnsignedDefault = [
                "int",
                "tinyint",
                "smallint",
                "mediumint"
            ];
            const needsAdjustment = typesWithReducedUnsignedDefault.indexOf(column.type) !== -1;
            if (column.unsigned && needsAdjustment) {
                return defaultWidthForType - 1 === width;
            } else {
                return defaultWidthForType === width;
            }
        }
        return false;
    }
    /**
     * Change table comment.
     */ changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`aurora-mysql driver does not support change table comment.`);
    }
}
exports.AuroraMysqlQueryRunner = AuroraMysqlQueryRunner; //# sourceMappingURL=AuroraMysqlQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/aurora-mysql/AuroraMysqlDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AuroraMysqlDriver = void 0;
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const AuroraMysqlQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/aurora-mysql/AuroraMysqlQueryRunner.js [app-route] (ecmascript)");
const DateUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/DateUtils.js [app-route] (ecmascript)");
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const RdbmsSchemaBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/RdbmsSchemaBuilder.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const ApplyValueTransformers_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Organizes communication with MySQL DBMS.
 */ class AuroraMysqlDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        /**
         * Indicates if replication is enabled.
         */ this.isReplicated = false;
        /**
         * Indicates if tree tables are supported by this driver.
         */ this.treeSupport = true;
        /**
         * Represent transaction support by this driver
         */ this.transactionSupport = "nested";
        /**
         * Gets list of supported column data types by a driver.
         *
         * @see https://www.tutorialspoint.com/mysql/mysql-data-types.htm
         * @see https://dev.mysql.com/doc/refman/8.0/en/data-types.html
         */ this.supportedDataTypes = [
            // numeric types
            "bit",
            "int",
            "integer",
            "tinyint",
            "smallint",
            "mediumint",
            "bigint",
            "float",
            "double",
            "double precision",
            "real",
            "decimal",
            "dec",
            "numeric",
            "fixed",
            "bool",
            "boolean",
            // date and time types
            "date",
            "datetime",
            "timestamp",
            "time",
            "year",
            // string types
            "char",
            "nchar",
            "national char",
            "varchar",
            "nvarchar",
            "national varchar",
            "blob",
            "text",
            "tinyblob",
            "tinytext",
            "mediumblob",
            "mediumtext",
            "longblob",
            "longtext",
            "enum",
            "set",
            "binary",
            "varbinary",
            // json data type
            "json",
            // spatial data types
            "geometry",
            "point",
            "linestring",
            "polygon",
            "multipoint",
            "multilinestring",
            "multipolygon",
            "geometrycollection"
        ];
        /**
         * Returns type of upsert supported by driver if any
         */ this.supportedUpsertTypes = [
            "on-duplicate-key-update"
        ];
        /**
         * Gets list of spatial column data types.
         */ this.spatialTypes = [
            "geometry",
            "point",
            "linestring",
            "polygon",
            "multipoint",
            "multilinestring",
            "multipolygon",
            "geometrycollection"
        ];
        /**
         * Gets list of column data types that support length by a driver.
         */ this.withLengthColumnTypes = [
            "char",
            "varchar",
            "nvarchar",
            "binary",
            "varbinary"
        ];
        /**
         * Gets list of column data types that support length by a driver.
         */ this.withWidthColumnTypes = [
            "bit",
            "tinyint",
            "smallint",
            "mediumint",
            "int",
            "integer",
            "bigint"
        ];
        /**
         * Gets list of column data types that support precision by a driver.
         */ this.withPrecisionColumnTypes = [
            "decimal",
            "dec",
            "numeric",
            "fixed",
            "float",
            "double",
            "double precision",
            "real",
            "time",
            "datetime",
            "timestamp"
        ];
        /**
         * Gets list of column data types that supports scale by a driver.
         */ this.withScaleColumnTypes = [
            "decimal",
            "dec",
            "numeric",
            "fixed",
            "float",
            "double",
            "double precision",
            "real"
        ];
        /**
         * Gets list of column data types that supports UNSIGNED and ZEROFILL attributes.
         */ this.unsignedAndZerofillTypes = [
            "int",
            "integer",
            "smallint",
            "tinyint",
            "mediumint",
            "bigint",
            "decimal",
            "dec",
            "numeric",
            "fixed",
            "float",
            "double",
            "double precision",
            "real"
        ];
        /**
         * ORM has special columns and we need to know what database column types should be for those columns.
         * Column types are driver dependant.
         */ this.mappedDataTypes = {
            createDate: "datetime",
            createDatePrecision: 6,
            createDateDefault: "CURRENT_TIMESTAMP(6)",
            updateDate: "datetime",
            updateDatePrecision: 6,
            updateDateDefault: "CURRENT_TIMESTAMP(6)",
            deleteDate: "datetime",
            deleteDatePrecision: 6,
            deleteDateNullable: true,
            version: "int",
            treeLevel: "int",
            migrationId: "int",
            migrationName: "varchar",
            migrationTimestamp: "bigint",
            cacheId: "int",
            cacheIdentifier: "varchar",
            cacheTime: "bigint",
            cacheDuration: "int",
            cacheQuery: "text",
            cacheResult: "text",
            metadataType: "varchar",
            metadataDatabase: "varchar",
            metadataSchema: "varchar",
            metadataTable: "varchar",
            metadataName: "varchar",
            metadataValue: "text"
        };
        /**
         * Default values of length, precision and scale depends on column data type.
         * Used in the cases when length/precision/scale is not specified by user.
         */ this.dataTypeDefaults = {
            varchar: {
                length: 255
            },
            nvarchar: {
                length: 255
            },
            "national varchar": {
                length: 255
            },
            char: {
                length: 1
            },
            binary: {
                length: 1
            },
            varbinary: {
                length: 255
            },
            decimal: {
                precision: 10,
                scale: 0
            },
            dec: {
                precision: 10,
                scale: 0
            },
            numeric: {
                precision: 10,
                scale: 0
            },
            fixed: {
                precision: 10,
                scale: 0
            },
            float: {
                precision: 12
            },
            double: {
                precision: 22
            },
            time: {
                precision: 0
            },
            datetime: {
                precision: 0
            },
            timestamp: {
                precision: 0
            },
            bit: {
                width: 1
            },
            int: {
                width: 11
            },
            integer: {
                width: 11
            },
            tinyint: {
                width: 4
            },
            smallint: {
                width: 6
            },
            mediumint: {
                width: 9
            },
            bigint: {
                width: 20
            }
        };
        /**
         * Max length allowed by MySQL for aliases.
         * @see https://dev.mysql.com/doc/refman/5.5/en/identifiers.html
         */ this.maxAliasLength = 63;
        this.cteCapabilities = {
            enabled: false
        };
        this.connection = connection;
        this.options = connection.options;
        // load mysql package
        this.loadDependencies();
        this.client = new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters)=>this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions);
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).database;
    // validate options to make sure everything is set
    // todo: revisit validation with replication in mind
    // if (!(this.options.host || (this.options.extra && this.options.extra.socketPath)) && !this.options.socketPath)
    //     throw new DriverOptionNotSetError("socketPath and host");
    // if (!this.options.username)
    //     throw new DriverOptionNotSetError("username");
    // if (!this.options.database)
    //     throw new DriverOptionNotSetError("database");
    // todo: check what is going on when connection is setup without database and how to connect to a database then?
    // todo: provide options to auto-create a database if it does not exist yet
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Performs connection to the database.
     */ async connect() {
        if (!this.database) {
            const queryRunner = this.createQueryRunner("master");
            this.database = await queryRunner.getCurrentDatabase();
            await queryRunner.release();
        }
    }
    /**
     * Makes any action after connection (e.g. create extensions in Postgres driver).
     */ afterConnect() {
        return Promise.resolve();
    }
    /**
     * Closes connection with the database.
     */ async disconnect() {}
    /**
     * Creates a schema builder used to build and sync a schema.
     */ createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
    }
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        return new AuroraMysqlQueryRunner_1.AuroraMysqlQueryRunner(this, new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters)=>this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions));
    }
    /**
     * Replaces parameters in the given sql with special escaping character
     * and an array of parameter names to be passed to a query.
     */ escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key)=>nativeParameters[key]);
        if (!parameters || !Object.keys(parameters).length) return [
            sql,
            escapedParameters
        ];
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key)=>{
            if (!parameters.hasOwnProperty(key)) {
                return full;
            }
            const value = parameters[key];
            if (isArray) {
                return value.map((v)=>{
                    escapedParameters.push(v);
                    return this.createParameter(key, escapedParameters.length - 1);
                }).join(", ");
            }
            if (typeof value === "function") {
                return value();
            }
            escapedParameters.push(value);
            return this.createParameter(key, escapedParameters.length - 1);
        }); // todo: make replace only in value statements, otherwise problems
        return [
            sql,
            escapedParameters
        ];
    }
    /**
     * Escapes a column name.
     */ escape(columnName) {
        return "`" + columnName + "`";
    }
    /**
     * Build full table name with database name, schema name and table name.
     * E.g. myDB.mySchema.myTable
     */ buildTableName(tableName, schema, database) {
        const tablePath = [
            tableName
        ];
        if (database) {
            tablePath.unshift(database);
        }
        return tablePath.join(".");
    }
    /**
     * Parse a target table name or other types and return a normalized table definition.
     */ parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = undefined;
        if (InstanceChecker_1.InstanceChecker.isTable(target) || InstanceChecker_1.InstanceChecker.isView(target)) {
            const parsed = this.parseTableName(target.name);
            return {
                database: target.database || parsed.database || driverDatabase,
                schema: target.schema || parsed.schema || driverSchema,
                tableName: parsed.tableName
            };
        }
        if (InstanceChecker_1.InstanceChecker.isTableForeignKey(target)) {
            const parsed = this.parseTableName(target.referencedTableName);
            return {
                database: target.referencedDatabase || parsed.database || driverDatabase,
                schema: target.referencedSchema || parsed.schema || driverSchema,
                tableName: parsed.tableName
            };
        }
        if (InstanceChecker_1.InstanceChecker.isEntityMetadata(target)) {
            // EntityMetadata tableName is never a path
            return {
                database: target.database || driverDatabase,
                schema: target.schema || driverSchema,
                tableName: target.tableName
            };
        }
        const parts = target.split(".");
        return {
            database: (parts.length > 1 ? parts[0] : undefined) || driverDatabase,
            schema: driverSchema,
            tableName: parts.length > 1 ? parts[1] : parts[0]
        };
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type and metadata.
     */ preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (!this.options.formatOptions || this.options.formatOptions.castParameters !== false) {
            return this.client.preparePersistentValue(value, columnMetadata);
        }
        if (value === null || value === undefined) return value;
        if (columnMetadata.type === Boolean) {
            return value === true ? 1 : 0;
        } else if (columnMetadata.type === "date") {
            return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "time") {
            return DateUtils_1.DateUtils.mixedDateToTimeString(value);
        } else if (columnMetadata.type === "json") {
            return JSON.stringify(value);
        } else if (columnMetadata.type === "timestamp" || columnMetadata.type === "datetime" || columnMetadata.type === Date) {
            return DateUtils_1.DateUtils.mixedDateToDate(value);
        } else if (columnMetadata.type === "simple-array" || columnMetadata.type === "set") {
            return DateUtils_1.DateUtils.simpleArrayToString(value);
        } else if (columnMetadata.type === "simple-json") {
            return DateUtils_1.DateUtils.simpleJsonToString(value);
        } else if (columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") {
            return "" + value;
        }
        return value;
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type or metadata.
     */ prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (!this.options.formatOptions || this.options.formatOptions.castParameters !== false) {
            return this.client.prepareHydratedValue(value, columnMetadata);
        }
        if (columnMetadata.type === Boolean || columnMetadata.type === "bool" || columnMetadata.type === "boolean") {
            value = value ? true : false;
        } else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
            value = DateUtils_1.DateUtils.normalizeHydratedDate(value);
        } else if (columnMetadata.type === "date") {
            value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "json") {
            value = typeof value === "string" ? JSON.parse(value) : value;
        } else if (columnMetadata.type === "time") {
            value = DateUtils_1.DateUtils.mixedTimeToString(value);
        } else if (columnMetadata.type === "simple-array" || columnMetadata.type === "set") {
            value = DateUtils_1.DateUtils.stringToSimpleArray(value);
        } else if (columnMetadata.type === "simple-json") {
            value = DateUtils_1.DateUtils.stringToSimpleJson(value);
        } else if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") && columnMetadata.enum && !isNaN(value) && columnMetadata.enum.indexOf(parseInt(value)) >= 0) {
            // convert to number if that exists in possible enum options
            value = parseInt(value);
        } else if (columnMetadata.type === Number) {
            // convert to number if number
            value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
    }
    /**
     * Creates a database type from a given column metadata.
     */ normalizeType(column) {
        if (column.type === Number || column.type === "integer") {
            return "int";
        } else if (column.type === String) {
            return "varchar";
        } else if (column.type === Date) {
            return "datetime";
        } else if (column.type === Buffer) {
            return "blob";
        } else if (column.type === Boolean) {
            return "tinyint";
        } else if (column.type === "uuid") {
            return "varchar";
        } else if (column.type === "simple-array" || column.type === "simple-json") {
            return "text";
        } else if (column.type === "simple-enum") {
            return "enum";
        } else if (column.type === "double precision" || column.type === "real") {
            return "double";
        } else if (column.type === "dec" || column.type === "numeric" || column.type === "fixed") {
            return "decimal";
        } else if (column.type === "bool" || column.type === "boolean") {
            return "tinyint";
        } else if (column.type === "nvarchar" || column.type === "national varchar") {
            return "varchar";
        } else if (column.type === "nchar" || column.type === "national char") {
            return "char";
        } else {
            return column.type || "";
        }
    }
    /**
     * Normalizes "default" value of the column.
     */ normalizeDefault(columnMetadata) {
        const defaultValue = columnMetadata.default;
        if (defaultValue === null) {
            return undefined;
        }
        if ((columnMetadata.type === "enum" || columnMetadata.type === "simple-enum") && defaultValue !== undefined) {
            return `'${defaultValue}'`;
        }
        if (columnMetadata.type === "set" && defaultValue !== undefined) {
            return `'${DateUtils_1.DateUtils.simpleArrayToString(defaultValue)}'`;
        }
        if (typeof defaultValue === "number") {
            return `${defaultValue}`;
        }
        if (typeof defaultValue === "boolean") {
            return defaultValue ? "1" : "0";
        }
        if (typeof defaultValue === "function") {
            return defaultValue();
        }
        if (typeof defaultValue === "string") {
            return `'${defaultValue}'`;
        }
        if (defaultValue === undefined) {
            return undefined;
        }
        return `${defaultValue}`;
    }
    /**
     * Normalizes "isUnique" value of the column.
     */ normalizeIsUnique(column) {
        return column.entityMetadata.indices.some((idx)=>idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);
    }
    /**
     * Returns default column lengths, which is required on column creation.
     */ getColumnLength(column) {
        if (column.length) return column.length.toString();
        /**
         * fix https://github.com/typeorm/typeorm/issues/1139
         */ if (column.generationStrategy === "uuid") return "36";
        switch(column.type){
            case String:
            case "varchar":
            case "nvarchar":
            case "national varchar":
                return "255";
            case "varbinary":
                return "255";
            default:
                return "";
        }
    }
    /**
     * Creates column type definition including length, precision and scale
     */ createFullType(column) {
        let type = column.type;
        // used 'getColumnLength()' method, because MySQL requires column length for `varchar`, `nvarchar` and `varbinary` data types
        if (this.getColumnLength(column)) {
            type += `(${this.getColumnLength(column)})`;
        } else if (column.width) {
            type += `(${column.width})`;
        } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {
            type += `(${column.precision},${column.scale})`;
        } else if (column.precision !== null && column.precision !== undefined) {
            type += `(${column.precision})`;
        }
        if (column.isArray) type += " array";
        return type;
    }
    /**
     * Obtains a new database connection to a master server.
     * Used for replication.
     * If replication is not setup then returns default connection's database connection.
     */ obtainMasterConnection() {
        return new Promise((ok, fail)=>{
            if (this.poolCluster) {
                this.poolCluster.getConnection("MASTER", (err, dbConnection)=>{
                    err ? fail(err) : ok(this.prepareDbConnection(dbConnection));
                });
            } else if (this.pool) {
                this.pool.getConnection((err, dbConnection)=>{
                    err ? fail(err) : ok(this.prepareDbConnection(dbConnection));
                });
            } else {
                fail(new error_1.TypeORMError(`Connection is not established with mysql database`));
            }
        });
    }
    /**
     * Obtains a new database connection to a slave server.
     * Used for replication.
     * If replication is not setup then returns master (default) connection's database connection.
     */ obtainSlaveConnection() {
        if (!this.poolCluster) return this.obtainMasterConnection();
        return new Promise((ok, fail)=>{
            this.poolCluster.getConnection("SLAVE*", (err, dbConnection)=>{
                err ? fail(err) : ok(this.prepareDbConnection(dbConnection));
            });
        });
    }
    /**
     * Creates generated map of values generated or returned by database after INSERT query.
     */ createGeneratedMap(metadata, insertResult, entityIndex) {
        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn)=>{
            let value;
            if (generatedColumn.generationStrategy === "increment" && insertResult.insertId) {
                // NOTE: When multiple rows is inserted by a single INSERT statement,
                // `insertId` is the value generated for the first inserted row only.
                value = insertResult.insertId + entityIndex;
            // } else if (generatedColumn.generationStrategy === "uuid") {
            //     console.log("getting db value:", generatedColumn.databaseName);
            //     value = generatedColumn.getEntityValue(uuidMap);
            }
            return OrmUtils_1.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
        }, {});
        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;
    }
    /**
     * Differentiate columns of this table and columns from the given column metadatas columns
     * and returns only changed.
     */ findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata)=>{
            const tableColumn = tableColumns.find((c)=>c.name === columnMetadata.databaseName);
            if (!tableColumn) return false; // we don't need new columns, we only need exist and changed
            // console.log("table:", columnMetadata.entityMetadata.tableName);
            // console.log("name:", tableColumn.name, columnMetadata.databaseName);
            // console.log("type:", tableColumn.type, this.normalizeType(columnMetadata));
            // console.log("length:", tableColumn.length, columnMetadata.length);
            // console.log("width:", tableColumn.width, columnMetadata.width);
            // console.log("precision:", tableColumn.precision, columnMetadata.precision);
            // console.log("scale:", tableColumn.scale, columnMetadata.scale);
            // console.log("zerofill:", tableColumn.zerofill, columnMetadata.zerofill);
            // console.log("unsigned:", tableColumn.unsigned, columnMetadata.unsigned);
            // console.log("asExpression:", tableColumn.asExpression, columnMetadata.asExpression);
            // console.log("generatedType:", tableColumn.generatedType, columnMetadata.generatedType);
            // console.log("comment:", tableColumn.comment, this.escapeComment(columnMetadata.comment));
            // console.log("default:", tableColumn.default, columnMetadata.default);
            // console.log("enum:", tableColumn.enum, columnMetadata.enum);
            // console.log("default changed:", !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default));
            // console.log("onUpdate:", tableColumn.onUpdate, columnMetadata.onUpdate);
            // console.log("isPrimary:", tableColumn.isPrimary, columnMetadata.isPrimary);
            // console.log("isNullable:", tableColumn.isNullable, columnMetadata.isNullable);
            // console.log("isUnique:", tableColumn.isUnique, this.normalizeIsUnique(columnMetadata));
            // console.log("isGenerated:", tableColumn.isGenerated, columnMetadata.isGenerated);
            // console.log((columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated));
            // console.log("==========================================");
            let columnMetadataLength = columnMetadata.length;
            if (!columnMetadataLength && columnMetadata.generationStrategy === "uuid") {
                // fixing #3374
                columnMetadataLength = this.getColumnLength(columnMetadata);
            }
            return tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== columnMetadataLength || tableColumn.width !== columnMetadata.width || tableColumn.precision !== columnMetadata.precision || tableColumn.scale !== columnMetadata.scale || tableColumn.zerofill !== columnMetadata.zerofill || tableColumn.unsigned !== columnMetadata.unsigned || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.comment !== this.escapeComment(columnMetadata.comment) || !this.compareDefaultValues(this.normalizeDefault(columnMetadata), tableColumn.default) || tableColumn.enum && columnMetadata.enum && !OrmUtils_1.OrmUtils.isArraysEqual(tableColumn.enum, columnMetadata.enum.map((val)=>val + "")) || tableColumn.onUpdate !== columnMetadata.onUpdate || tableColumn.isPrimary !== columnMetadata.isPrimary || tableColumn.isNullable !== columnMetadata.isNullable || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata) || columnMetadata.generationStrategy !== "uuid" && tableColumn.isGenerated !== columnMetadata.isGenerated;
        });
    }
    /**
     * Returns true if driver supports RETURNING / OUTPUT statement.
     */ isReturningSqlSupported() {
        return false;
    }
    /**
     * Returns true if driver supports uuid values generation on its own.
     */ isUUIDGenerationSupported() {
        return false;
    }
    /**
     * Returns true if driver supports fulltext indices.
     */ isFullTextColumnTypeSupported() {
        return true;
    }
    /**
     * Creates an escaped parameter.
     */ createParameter(parameterName, index) {
        return "?";
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Loads all driver dependencies.
     */ loadDependencies() {
        const DataApiDriver = this.options.driver || PlatformTools_1.PlatformTools.load("typeorm-aurora-data-api-driver");
        this.DataApiDriver = DataApiDriver;
        // Driver uses rollup for publishing, which has issues when using typeorm in combination with webpack
        // See https://github.com/webpack/webpack/issues/4742#issuecomment-295556787
        this.DataApiDriver = this.DataApiDriver.default || this.DataApiDriver;
    }
    /**
     * Creates a new connection pool for a given database credentials.
     */ createConnectionOptions(options, credentials) {
        credentials = Object.assign({}, credentials, DriverUtils_1.DriverUtils.buildDriverOptions(credentials)); // todo: do it better way
        // build connection options for the driver
        return Object.assign({}, {
            resourceArn: options.resourceArn,
            secretArn: options.secretArn,
            database: options.database,
            region: options.region,
            type: options.type
        }, {
            host: credentials.host,
            user: credentials.username,
            password: credentials.password,
            database: credentials.database,
            port: credentials.port,
            ssl: options.ssl
        }, options.extra || {});
    }
    /**
     * Creates a new connection pool for a given database credentials.
     */ async createPool(connectionOptions) {
        return {};
    }
    /**
     * Attaches all required base handlers to a database connection, such as the unhandled error handler.
     */ prepareDbConnection(connection) {
        const { logger } = this.connection;
        /**
         * Attaching an error handler to connection errors is essential, as, otherwise, errors raised will go unhandled and
         * cause the hosting app to crash.
         */ if (connection.listeners("error").length === 0) {
            connection.on("error", (error)=>logger.log("warn", `MySQL connection raised an error. ${error}`));
        }
        return connection;
    }
    /**
     * Checks if "DEFAULT" values in the column metadata and in the database are equal.
     */ compareDefaultValues(columnMetadataValue, databaseValue) {
        if (typeof columnMetadataValue === "string" && typeof databaseValue === "string") {
            // we need to cut out "'" because in mysql we can understand returned value is a string or a function
            // as result compare cannot understand if default is really changed or not
            columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, "");
            databaseValue = databaseValue.replace(/^'+|'+$/g, "");
        }
        return columnMetadataValue === databaseValue;
    }
    /**
     * Escapes a given comment.
     */ escapeComment(comment) {
        if (!comment) return comment;
        comment = comment.replace(/\u0000/g, ""); // Null bytes aren't allowed in comments
        return comment;
    }
}
exports.AuroraMysqlDriver = AuroraMysqlDriver; //# sourceMappingURL=AuroraMysqlDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/aurora-postgres/AuroraPostgresQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AuroraPostgresQueryRunner = void 0;
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const TransactionNotStartedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TransactionNotStartedError.js [app-route] (ecmascript)");
const PostgresQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/postgres/PostgresQueryRunner.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
class PostgresQueryRunnerWrapper extends PostgresQueryRunner_1.PostgresQueryRunner {
    constructor(driver, mode){
        super(driver, mode);
    }
}
/**
 * Runs queries on a single postgres database connection.
 */ class AuroraPostgresQueryRunner extends PostgresQueryRunnerWrapper {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver, client, mode){
        super(driver, mode);
        this.client = client;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates/uses database connection from the connection pool to perform further operations.
     * Returns obtained database connection.
     */ connect() {
        if (this.databaseConnection) return Promise.resolve(this.databaseConnection);
        if (this.databaseConnectionPromise) return this.databaseConnectionPromise;
        if (this.mode === "slave" && this.driver.isReplicated) {
            this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(([connection, release])=>{
                this.driver.connectedQueryRunners.push(this);
                this.databaseConnection = connection;
                this.releaseCallback = release;
                return this.databaseConnection;
            });
        } else {
            // master
            this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(([connection, release])=>{
                this.driver.connectedQueryRunners.push(this);
                this.databaseConnection = connection;
                this.releaseCallback = release;
                return this.databaseConnection;
            });
        }
        return this.databaseConnectionPromise;
    }
    /**
     * Starts transaction on the current connection.
     */ async startTransaction(isolationLevel) {
        this.isTransactionActive = true;
        try {
            await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
            this.isTransactionActive = false;
            throw err;
        }
        if (this.transactionDepth === 0) {
            await this.client.startTransaction();
        } else {
            await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);
        }
        this.transactionDepth += 1;
        await this.broadcaster.broadcast("AfterTransactionStart");
    }
    /**
     * Commits transaction.
     * Error will be thrown if transaction was not started.
     */ async commitTransaction() {
        if (!this.isTransactionActive) throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        if (this.transactionDepth > 1) {
            await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
            await this.client.commitTransaction();
            this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionCommit");
    }
    /**
     * Rollbacks transaction.
     * Error will be thrown if transaction was not started.
     */ async rollbackTransaction() {
        if (!this.isTransactionActive) throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        if (this.transactionDepth > 1) {
            await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);
        } else {
            await this.client.rollbackTransaction();
            this.isTransactionActive = false;
        }
        this.transactionDepth -= 1;
        await this.broadcaster.broadcast("AfterTransactionRollback");
    }
    /**
     * Executes a given SQL query.
     */ async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const raw = await this.client.query(query, parameters);
        const result = new QueryResult_1.QueryResult();
        result.raw = raw;
        if (raw?.hasOwnProperty("records") && Array.isArray(raw.records)) {
            result.records = raw.records;
        }
        if (raw?.hasOwnProperty("numberOfRecordsUpdated")) {
            result.affected = raw.numberOfRecordsUpdated;
        }
        if (!useStructuredResult) {
            return result.raw;
        }
        return result;
    }
    /**
     * Change table comment.
     */ changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`aurora-postgres driver does not support change comment.`);
    }
}
exports.AuroraPostgresQueryRunner = AuroraPostgresQueryRunner; //# sourceMappingURL=AuroraPostgresQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/aurora-postgres/AuroraPostgresDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AuroraPostgresDriver = void 0;
const PostgresDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/postgres/PostgresDriver.js [app-route] (ecmascript)");
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const AuroraPostgresQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/aurora-postgres/AuroraPostgresQueryRunner.js [app-route] (ecmascript)");
const ApplyValueTransformers_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
class PostgresWrapper extends PostgresDriver_1.PostgresDriver {
}
class AuroraPostgresDriver extends PostgresWrapper {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        super();
        /**
         * Represent transaction support by this driver
         */ this.transactionSupport = "nested";
        this.connection = connection;
        this.options = connection.options;
        this.isReplicated = false;
        // load data-api package
        this.loadDependencies();
        this.client = new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters)=>this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions);
        this.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).database;
    }
    // -------------------------------------------------------------------------
    // Public Implemented Methods
    // -------------------------------------------------------------------------
    /**
     * Performs connection to the database.
     * Based on pooling options, it can either create connection immediately,
     * either create a pool and create connection when needed.
     */ async connect() {}
    /**
     * Closes connection with database.
     */ async disconnect() {}
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        return new AuroraPostgresQueryRunner_1.AuroraPostgresQueryRunner(this, new this.DataApiDriver(this.options.region, this.options.secretArn, this.options.resourceArn, this.options.database, (query, parameters)=>this.connection.logger.logQuery(query, parameters), this.options.serviceConfigOptions, this.options.formatOptions), mode);
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type and metadata.
     */ preparePersistentValue(value, columnMetadata) {
        if (this.options.formatOptions && this.options.formatOptions.castParameters === false) {
            return super.preparePersistentValue(value, columnMetadata);
        }
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        return this.client.preparePersistentValue(value, columnMetadata);
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type and metadata.
     */ prepareHydratedValue(value, columnMetadata) {
        if (this.options.formatOptions && this.options.formatOptions.castParameters === false) {
            return super.prepareHydratedValue(value, columnMetadata);
        }
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return this.client.prepareHydratedValue(value, columnMetadata);
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * If driver dependency is not given explicitly, then try to load it via "require".
     */ loadDependencies() {
        const driver = this.options.driver || PlatformTools_1.PlatformTools.load("typeorm-aurora-data-api-driver");
        const { pg } = driver;
        this.DataApiDriver = pg;
    }
    /**
     * Executes given query.
     */ executeQuery(connection, query) {
        return this.connection.query(query);
    }
    /**
     * Makes any action after connection (e.g. create extensions in Postgres driver).
     */ async afterConnect() {
        const extensionsMetadata = await this.checkMetadataForExtensions();
        if (extensionsMetadata.hasExtensions) {
            await this.enableExtensions(extensionsMetadata, this.connection);
        }
        return Promise.resolve();
    }
}
exports.AuroraPostgresDriver = AuroraPostgresDriver; //# sourceMappingURL=AuroraPostgresDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/better-sqlite3/BetterSqlite3QueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BetterSqlite3QueryRunner = void 0;
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const QueryFailedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)");
const AbstractSqliteQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
/**
 * Runs queries on a single sqlite database connection.
 *
 * Does not support compose primary keys with autoincrement field.
 * todo: need to throw exception for this case.
 */ class BetterSqlite3QueryRunner extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver){
        super();
        this.stmtCache = new Map();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
        if (typeof this.driver.options.statementCacheSize === "number") {
            this.cacheSize = this.driver.options.statementCacheSize;
        } else {
            this.cacheSize = 100;
        }
    }
    async getStmt(query) {
        if (this.cacheSize > 0) {
            let stmt = this.stmtCache.get(query);
            if (!stmt) {
                const databaseConnection = await this.connect();
                stmt = databaseConnection.prepare(query);
                this.stmtCache.set(query, stmt);
                while(this.stmtCache.size > this.cacheSize){
                    // since es6 map keeps the insertion order,
                    // it comes to be FIFO cache
                    const key = this.stmtCache.keys().next().value;
                    this.stmtCache.delete(key);
                }
            }
            return stmt;
        } else {
            const databaseConnection = await this.connect();
            return databaseConnection.prepare(query);
        }
    }
    /**
     * Called before migrations are run.
     */ async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
    }
    /**
     * Called after migrations are run.
     */ async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
    }
    /**
     * Executes a given SQL query.
     */ async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const connection = this.driver.connection;
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        this.driver.connection.logger.logQuery(query, parameters, this);
        this.broadcaster.broadcastBeforeQueryEvent(broadcasterResult, query, parameters);
        const queryStartTime = Date.now();
        const stmt = await this.getStmt(query);
        try {
            const result = new QueryResult_1.QueryResult();
            if (stmt.reader) {
                const raw = stmt.all.apply(stmt, parameters);
                result.raw = raw;
                if (Array.isArray(raw)) {
                    result.records = raw;
                }
            } else {
                const raw = stmt.run.apply(stmt, parameters);
                result.affected = raw.changes;
                result.raw = raw.lastInsertRowid;
            }
            // log slow queries if maxQueryExecution time is set
            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
            const queryEndTime = Date.now();
            const queryExecutionTime = queryEndTime - queryStartTime;
            if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, result.raw, undefined);
            if (!useStructuredResult) {
                return result.raw;
            }
            return result;
        } catch (err) {
            connection.logger.logQueryError(err, query, parameters, this);
            throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    async loadTableRecords(tablePath, tableOrIndex) {
        const [database, tableName] = this.splitTablePath(tablePath);
        const res = await this.query(`SELECT ${database ? `'${database}'` : null} as database, * FROM ${this.escapePath(`${database ? `${database}.` : ""}sqlite_master`)} WHERE "type" = '${tableOrIndex}' AND "${tableOrIndex === "table" ? "name" : "tbl_name"}" IN ('${tableName}')`);
        return res;
    }
    async loadPragmaRecords(tablePath, pragma) {
        const [database, tableName] = this.splitTablePath(tablePath);
        const res = await this.query(`PRAGMA ${database ? `"${database}".` : ""}${pragma}("${tableName}")`);
        return res;
    }
}
exports.BetterSqlite3QueryRunner = BetterSqlite3QueryRunner; //# sourceMappingURL=BetterSqlite3QueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/better-sqlite3/BetterSqlite3Driver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BetterSqlite3Driver = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const promises_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/fs/promises [external] (fs/promises, cjs)"));
const path_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const AbstractSqliteDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteDriver.js [app-route] (ecmascript)");
const BetterSqlite3QueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/better-sqlite3/BetterSqlite3QueryRunner.js [app-route] (ecmascript)");
const PathUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/PathUtils.js [app-route] (ecmascript)");
/**
 * Organizes communication with sqlite DBMS.
 */ class BetterSqlite3Driver extends AbstractSqliteDriver_1.AbstractSqliteDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        super(connection);
        this.connection = connection;
        this.options = connection.options;
        this.database = this.options.database;
        // load sqlite package
        this.loadDependencies();
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Closes connection with database.
     */ async disconnect() {
        this.queryRunner = undefined;
        this.databaseConnection.close();
    }
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        if (!this.queryRunner) this.queryRunner = new BetterSqlite3QueryRunner_1.BetterSqlite3QueryRunner(this);
        return this.queryRunner;
    }
    normalizeType(column) {
        if (column.type === Buffer) {
            return "blob";
        }
        return super.normalizeType(column);
    }
    async afterConnect() {
        return this.attachDatabases();
    }
    /**
     * For SQLite, the database may be added in the decorator metadata. It will be a filepath to a database file.
     */ buildTableName(tableName, _schema, database) {
        if (!database) return tableName;
        if (this.getAttachedDatabaseHandleByRelativePath(database)) return `${this.getAttachedDatabaseHandleByRelativePath(database)}.${tableName}`;
        if (database === this.options.database) return tableName;
        // we use the decorated name as supplied when deriving attach handle (ideally without non-portable absolute path)
        const identifierHash = (0, PathUtils_1.filepathToName)(database);
        // decorated name will be assumed relative to main database file when non absolute. Paths supplied as absolute won't be portable
        const absFilepath = (0, PathUtils_1.isAbsolute)(database) ? database : path_1.default.join(this.getMainDatabasePath(), database);
        this.attachedDatabases[database] = {
            attachFilepathAbsolute: absFilepath,
            attachFilepathRelative: database,
            attachHandle: identifierHash
        };
        return `${identifierHash}.${tableName}`;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates connection with the database.
     */ async createDatabaseConnection() {
        // not to create database directory if is in memory
        if (this.options.database !== ":memory:") await this.createDatabaseDirectory(path_1.default.dirname(this.options.database));
        const { database, readonly = false, fileMustExist = false, timeout = 5000, verbose = null, nativeBinding = null, prepareDatabase } = this.options;
        const databaseConnection = this.sqlite(database, {
            readonly,
            fileMustExist,
            timeout,
            verbose,
            nativeBinding
        });
        // in the options, if encryption key for SQLCipher is setted.
        // Must invoke key pragma before trying to do any other interaction with the database.
        if (this.options.key) {
            databaseConnection.exec(`PRAGMA key = ${JSON.stringify(this.options.key)}`);
        }
        // function to run before a database is used in typeorm.
        if (typeof prepareDatabase === "function") {
            prepareDatabase(databaseConnection);
        }
        // we need to enable foreign keys in sqlite to make sure all foreign key related features
        // working properly. this also makes onDelete to work with sqlite.
        databaseConnection.exec(`PRAGMA foreign_keys = ON`);
        // turn on WAL mode to enhance performance
        if (this.options.enableWAL) {
            databaseConnection.exec(`PRAGMA journal_mode = WAL`);
        }
        return databaseConnection;
    }
    /**
     * If driver dependency is not given explicitly, then try to load it via "require".
     */ loadDependencies() {
        try {
            const sqlite = this.options.driver || PlatformTools_1.PlatformTools.load("better-sqlite3");
            this.sqlite = sqlite;
        } catch (e) {
            throw new error_1.DriverPackageNotInstalledError("SQLite", "better-sqlite3");
        }
    }
    /**
     * Auto creates database directory if it does not exist.
     */ async createDatabaseDirectory(dbPath) {
        await promises_1.default.mkdir(dbPath, {
            recursive: true
        });
    }
    /**
     * Performs the attaching of the database files. The attachedDatabase should have been populated during calls to #buildTableName
     * during EntityMetadata production (see EntityMetadata#buildTablePath)
     *
     * https://sqlite.org/lang_attach.html
     */ async attachDatabases() {
        // @todo - possibly check number of databases (but unqueriable at runtime sadly) - https://www.sqlite.org/limits.html#max_attached
        for await (const { attachHandle, attachFilepathAbsolute } of Object.values(this.attachedDatabases)){
            await this.createDatabaseDirectory(path_1.default.dirname(attachFilepathAbsolute));
            await this.connection.query(`ATTACH "${attachFilepathAbsolute}" AS "${attachHandle}"`);
        }
    }
    getMainDatabasePath() {
        const optionsDb = this.options.database;
        return path_1.default.dirname((0, PathUtils_1.isAbsolute)(optionsDb) ? optionsDb : path_1.default.join(this.options.baseDirectory, optionsDb));
    }
}
exports.BetterSqlite3Driver = BetterSqlite3Driver; //# sourceMappingURL=BetterSqlite3Driver.js.map
}}),
"[project]/node_modules/typeorm/driver/capacitor/CapacitorQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CapacitorQueryRunner = void 0;
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const QueryFailedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)");
const AbstractSqliteQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
/**
 * Runs queries on a single sqlite database connection.
 */ class CapacitorQueryRunner extends AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver){
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
    }
    /**
     * Called before migrations are run.
     */ async beforeMigration() {
        await this.query(`PRAGMA foreign_keys = OFF`);
    }
    /**
     * Called after migrations are run.
     */ async afterMigration() {
        await this.query(`PRAGMA foreign_keys = ON`);
    }
    async executeSet(set) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        return databaseConnection.executeSet(set, false);
    }
    /**
     * Executes a given SQL query.
     */ async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        const databaseConnection = await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        const command = query.substring(0, query.indexOf(" ") !== -1 ? query.indexOf(" ") : undefined);
        try {
            let raw;
            if ([
                "BEGIN",
                "ROLLBACK",
                "COMMIT",
                "CREATE",
                "ALTER",
                "DROP"
            ].indexOf(command) !== -1) {
                raw = await databaseConnection.execute(query, false);
            } else if ([
                "INSERT",
                "UPDATE",
                "DELETE"
            ].indexOf(command) !== -1) {
                raw = await databaseConnection.run(query, parameters, false);
            } else {
                raw = await databaseConnection.query(query, parameters || []);
            }
            const result = new QueryResult_1.QueryResult();
            if (raw?.hasOwnProperty("values")) {
                result.raw = raw.values;
                result.records = raw.values;
            }
            if (raw?.hasOwnProperty("changes")) {
                result.affected = raw.changes.changes;
                result.raw = raw.changes.lastId || raw.changes.changes;
            }
            if (!useStructuredResult) {
                return result.raw;
            }
            return result;
        } catch (err) {
            this.driver.connection.logger.logQueryError(err, query, parameters, this);
            throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Parametrizes given object of values. Used to create column=value queries.
     */ parametrize(objectLiteral) {
        return Object.keys(objectLiteral).map((key)=>`"${key}"` + "=?");
    }
}
exports.CapacitorQueryRunner = CapacitorQueryRunner; //# sourceMappingURL=CapacitorQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/capacitor/CapacitorDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CapacitorDriver = void 0;
const AbstractSqliteDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite-abstract/AbstractSqliteDriver.js [app-route] (ecmascript)");
const CapacitorQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/capacitor/CapacitorQueryRunner.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
class CapacitorDriver extends AbstractSqliteDriver_1.AbstractSqliteDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        super(connection);
        this.database = this.options.database;
        this.driver = this.options.driver;
        // load sqlite package
        this.sqlite = this.options.driver;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Performs connection to the database.
     */ async connect() {
        this.databaseConnection = this.createDatabaseConnection();
        await this.databaseConnection;
    }
    /**
     * Closes connection with database.
     */ async disconnect() {
        this.queryRunner = undefined;
        const databaseConnection = await this.databaseConnection;
        return databaseConnection.close().then(()=>{
            this.databaseConnection = undefined;
        });
    }
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        if (!this.queryRunner) this.queryRunner = new CapacitorQueryRunner_1.CapacitorQueryRunner(this);
        return this.queryRunner;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates connection with the database.
     */ async createDatabaseConnection() {
        const databaseMode = this.options.mode || "no-encryption";
        const isDatabaseEncryted = databaseMode !== "no-encryption";
        const databaseVersion = typeof this.options.version === "undefined" ? 1 : this.options.version;
        const connection = await this.sqlite.createConnection(this.options.database, isDatabaseEncryted, databaseMode, databaseVersion);
        await connection.open();
        // we need to enable foreign keys in sqlite to make sure all foreign key related features
        // working properly. this also makes onDelete to work with sqlite.
        await connection.execute(`PRAGMA foreign_keys = ON`);
        if (this.options.journalMode && [
            "DELETE",
            "TRUNCATE",
            "PERSIST",
            "MEMORY",
            "WAL",
            "OFF"
        ].indexOf(this.options.journalMode) !== -1) {
            await connection.execute(`PRAGMA journal_mode = ${this.options.journalMode}`);
        }
        return connection;
    }
    loadDependencies() {
        this.sqlite = this.driver;
        if (!this.driver) {
            throw new error_1.DriverPackageNotInstalledError("Capacitor", "@capacitor-community/sqlite");
        }
    }
}
exports.CapacitorDriver = CapacitorDriver; //# sourceMappingURL=CapacitorDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/spanner/SpannerQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpannerQueryRunner = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const QueryFailedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)");
const QueryRunnerAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)");
const TransactionNotStartedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TransactionNotStartedError.js [app-route] (ecmascript)");
const BaseQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/BaseQueryRunner.js [app-route] (ecmascript)");
const QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
const Table_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/Table.js [app-route] (ecmascript)");
const TableCheck_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableCheck.js [app-route] (ecmascript)");
const TableColumn_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableColumn.js [app-route] (ecmascript)");
const TableForeignKey_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableForeignKey.js [app-route] (ecmascript)");
const TableIndex_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableIndex.js [app-route] (ecmascript)");
const TableUnique_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableUnique.js [app-route] (ecmascript)");
const View_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/view/View.js [app-route] (ecmascript)");
const Broadcaster_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const Query_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/Query.js [app-route] (ecmascript)");
const MetadataTableType_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/types/MetadataTableType.js [app-route] (ecmascript)");
/**
 * Runs queries on a single postgres database connection.
 */ class SpannerQueryRunner extends BaseQueryRunner_1.BaseQueryRunner {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(driver, mode){
        super();
        this.driver = driver;
        this.connection = driver.connection;
        this.mode = mode;
        this.broadcaster = new Broadcaster_1.Broadcaster(this);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates/uses database connection from the connection pool to perform further operations.
     * Returns obtained database connection.
     */ async connect() {
        if (this.session) {
            return Promise.resolve(this.session);
        }
        const [session] = await this.driver.instanceDatabase.createSession({});
        this.session = session;
        this.sessionTransaction = await session.transaction();
        return this.session;
    }
    /**
     * Releases used database connection.
     * You cannot use query runner methods once its released.
     */ async release() {
        this.isReleased = true;
        if (this.session) {
            await this.session.delete();
        }
        this.session = undefined;
        return Promise.resolve();
    }
    /**
     * Starts transaction.
     */ async startTransaction(isolationLevel) {
        this.isTransactionActive = true;
        try {
            await this.broadcaster.broadcast("BeforeTransactionStart");
        } catch (err) {
            this.isTransactionActive = false;
            throw err;
        }
        await this.connect();
        await this.sessionTransaction.begin();
        this.connection.logger.logQuery("START TRANSACTION");
        await this.broadcaster.broadcast("AfterTransactionStart");
    }
    /**
     * Commits transaction.
     * Error will be thrown if transaction was not started.
     */ async commitTransaction() {
        if (!this.isTransactionActive || !this.sessionTransaction) throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionCommit");
        await this.sessionTransaction.commit();
        this.connection.logger.logQuery("COMMIT");
        this.isTransactionActive = false;
        await this.broadcaster.broadcast("AfterTransactionCommit");
    }
    /**
     * Rollbacks transaction.
     * Error will be thrown if transaction was not started.
     */ async rollbackTransaction() {
        if (!this.isTransactionActive || !this.sessionTransaction) throw new TransactionNotStartedError_1.TransactionNotStartedError();
        await this.broadcaster.broadcast("BeforeTransactionRollback");
        await this.sessionTransaction.rollback();
        this.connection.logger.logQuery("ROLLBACK");
        this.isTransactionActive = false;
        await this.broadcaster.broadcast("AfterTransactionRollback");
    }
    /**
     * Executes a given SQL query.
     */ async query(query, parameters, useStructuredResult = false) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        await this.connect();
        this.driver.connection.logger.logQuery(query, parameters, this);
        await this.broadcaster.broadcast("BeforeQuery", query, parameters);
        const broadcasterResult = new BroadcasterResult_1.BroadcasterResult();
        try {
            const queryStartTime = Date.now();
            let rawResult = undefined;
            const isSelect = query.startsWith("SELECT");
            const executor = isSelect && !this.isTransactionActive ? this.driver.instanceDatabase : this.sessionTransaction;
            if (!this.isTransactionActive && !isSelect) {
                await this.sessionTransaction.begin();
            }
            try {
                rawResult = await executor.run({
                    sql: query,
                    params: parameters ? parameters.reduce((params, value, index)=>{
                        params["param" + index] = value;
                        return params;
                    }, {}) : undefined,
                    json: true
                });
                if (!this.isTransactionActive && !isSelect) {
                    await this.sessionTransaction.commit();
                }
            } catch (error) {
                try {
                    // we throw original error even if rollback thrown an error
                    if (!this.isTransactionActive && !isSelect) await this.sessionTransaction.rollback();
                } catch (rollbackError) {}
                throw error;
            }
            // log slow queries if maxQueryExecution time is set
            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
            const queryEndTime = Date.now();
            const queryExecutionTime = queryEndTime - queryStartTime;
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, true, queryExecutionTime, rawResult, undefined);
            if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
            const result = new QueryResult_1.QueryResult();
            result.raw = rawResult;
            result.records = rawResult ? rawResult[0] : [];
            if (rawResult && rawResult[1] && rawResult[1].rowCountExact) {
                result.affected = parseInt(rawResult[1].rowCountExact);
            }
            if (!useStructuredResult) {
                return result.records;
            }
            return result;
        } catch (err) {
            this.driver.connection.logger.logQueryError(err, query, parameters, this);
            this.broadcaster.broadcastAfterQueryEvent(broadcasterResult, query, parameters, false, undefined, undefined, err);
            throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        } finally{
            await broadcasterResult.wait();
        }
    }
    /**
     * Update database schema.
     * Used for creating/altering/dropping tables, columns, indexes, etc.
     *
     * DDL changing queries should be executed by `updateSchema()` method.
     */ async updateDDL(query, parameters) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        this.driver.connection.logger.logQuery(query, parameters, this);
        try {
            const queryStartTime = Date.now();
            const [operation] = await this.driver.instanceDatabase.updateSchema(query);
            await operation.promise();
            // log slow queries if maxQueryExecution time is set
            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;
            const queryEndTime = Date.now();
            const queryExecutionTime = queryEndTime - queryStartTime;
            if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
        } catch (err) {
            this.driver.connection.logger.logQueryError(err, query, parameters, this);
            throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        }
    }
    /**
     * Returns raw data stream.
     */ async stream(query, parameters, onEnd, onError) {
        if (this.isReleased) throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
        try {
            this.driver.connection.logger.logQuery(query, parameters, this);
            const request = {
                sql: query,
                params: parameters ? parameters.reduce((params, value, index)=>{
                    params["param" + index] = value;
                    return params;
                }, {}) : undefined,
                json: true
            };
            const stream = this.driver.instanceDatabase.runStream(request);
            if (onEnd) {
                stream.on("end", onEnd);
            }
            if (onError) {
                stream.on("error", onError);
            }
            return stream;
        } catch (err) {
            this.driver.connection.logger.logQueryError(err, query, parameters, this);
            throw new QueryFailedError_1.QueryFailedError(query, parameters, err);
        }
    }
    /**
     * Returns all available database names including system databases.
     */ async getDatabases() {
        return Promise.resolve([]);
    }
    /**
     * Returns all available schema names including system schemas.
     * If database parameter specified, returns schemas of that database.
     */ async getSchemas(database) {
        return Promise.resolve([]);
    }
    /**
     * Checks if database with the given name exist.
     */ async hasDatabase(database) {
        throw new error_1.TypeORMError(`Check database queries are not supported by Spanner driver.`);
    }
    /**
     * Loads currently using database
     */ async getCurrentDatabase() {
        throw new error_1.TypeORMError(`Check database queries are not supported by Spanner driver.`);
    }
    /**
     * Checks if schema with the given name exist.
     */ async hasSchema(schema) {
        const result = await this.query(`SELECT * FROM "information_schema"."schemata" WHERE "schema_name" = '${schema}'`);
        return result.length ? true : false;
    }
    /**
     * Loads currently using database schema
     */ async getCurrentSchema() {
        throw new error_1.TypeORMError(`Check schema queries are not supported by Spanner driver.`);
    }
    /**
     * Checks if table with the given name exist in the database.
     */ async hasTable(tableOrName) {
        const tableName = tableOrName instanceof Table_1.Table ? tableOrName.name : tableOrName;
        const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`TABLES\` ` + `WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_TYPE\` = 'BASE TABLE' ` + `AND \`TABLE_NAME\` = '${tableName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
    }
    /**
     * Checks if column with the given name exist in the given table.
     */ async hasColumn(tableOrName, columnName) {
        const tableName = tableOrName instanceof Table_1.Table ? tableOrName.name : tableOrName;
        const sql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` ` + `WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' ` + `AND \`TABLE_NAME\` = '${tableName}' AND \`COLUMN_NAME\` = '${columnName}'`;
        const result = await this.query(sql);
        return result.length ? true : false;
    }
    /**
     * Creates a new database.
     * Note: Spanner does not support database creation inside a transaction block.
     */ async createDatabase(database, ifNotExist) {
        if (ifNotExist) {
            const databaseAlreadyExists = await this.hasDatabase(database);
            if (databaseAlreadyExists) return Promise.resolve();
        }
        const up = `CREATE DATABASE "${database}"`;
        const down = `DROP DATABASE "${database}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
    }
    /**
     * Drops database.
     * Note: Spanner does not support database dropping inside a transaction block.
     */ async dropDatabase(database, ifExist) {
        const up = ifExist ? `DROP DATABASE IF EXISTS "${database}"` : `DROP DATABASE "${database}"`;
        const down = `CREATE DATABASE "${database}"`;
        await this.executeQueries(new Query_1.Query(up), new Query_1.Query(down));
    }
    /**
     * Creates a new table schema.
     */ async createSchema(schemaPath, ifNotExist) {
        return Promise.resolve();
    }
    /**
     * Drops table schema.
     */ async dropSchema(schemaPath, ifExist, isCascade) {
        return Promise.resolve();
    }
    /**
     * Creates a new table.
     */ async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {
        if (ifNotExist) {
            const isTableExist = await this.hasTable(table);
            if (isTableExist) return Promise.resolve();
        }
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createTableSql(table, createForeignKeys));
        downQueries.push(this.dropTableSql(table));
        // if createForeignKeys is true, we must drop created foreign keys in down query.
        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.
        if (createForeignKeys) table.foreignKeys.forEach((foreignKey)=>downQueries.push(this.dropForeignKeySql(table, foreignKey)));
        if (createIndices) {
            table.indices.forEach((index)=>{
                // new index may be passed without name. In this case we generate index name manually.
                if (!index.name) index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
                upQueries.push(this.createIndexSql(table, index));
                downQueries.push(this.dropIndexSql(table, index));
            });
        }
        // if table has column with generated type, we must add the expression to the metadata table
        const generatedColumns = table.columns.filter((column)=>column.generatedType && column.asExpression);
        for (const column of generatedColumns){
            const insertQuery = this.insertTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            upQueries.push(insertQuery);
            downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Drops the table.
     */ async dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {
        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need
        // to perform drop queries for foreign keys and indices.
        if (ifExist) {
            const isTableExist = await this.hasTable(target);
            if (!isTableExist) return Promise.resolve();
        }
        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.
        const createForeignKeys = dropForeignKeys;
        const tablePath = this.getTablePath(target);
        const table = await this.getCachedTable(tablePath);
        const upQueries = [];
        const downQueries = [];
        if (dropIndices) {
            table.indices.forEach((index)=>{
                upQueries.push(this.dropIndexSql(table, index));
                downQueries.push(this.createIndexSql(table, index));
            });
        }
        if (dropForeignKeys) table.foreignKeys.forEach((foreignKey)=>upQueries.push(this.dropForeignKeySql(table, foreignKey)));
        upQueries.push(this.dropTableSql(table));
        downQueries.push(this.createTableSql(table, createForeignKeys));
        // if table had columns with generated type, we must remove the expression from the metadata table
        const generatedColumns = table.columns.filter((column)=>column.generatedType && column.asExpression);
        for (const column of generatedColumns){
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            const insertQuery = this.insertTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            upQueries.push(deleteQuery);
            downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Creates a new view.
     */ async createView(view) {
        const upQueries = [];
        const downQueries = [];
        upQueries.push(this.createViewSql(view));
        upQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.dropViewSql(view));
        downQueries.push(await this.deleteViewDefinitionSql(view));
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Drops the view.
     */ async dropView(target) {
        const viewName = target instanceof View_1.View ? target.name : target;
        const view = await this.getCachedView(viewName);
        const upQueries = [];
        const downQueries = [];
        upQueries.push(await this.deleteViewDefinitionSql(view));
        upQueries.push(this.dropViewSql(view));
        downQueries.push(await this.insertViewDefinitionSql(view));
        downQueries.push(this.createViewSql(view));
        await this.executeQueries(upQueries, downQueries);
    }
    /**
     * Renames the given table.
     */ async renameTable(oldTableOrName, newTableName) {
        throw new error_1.TypeORMError(`Rename table queries are not supported by Spanner driver.`);
    }
    /**
     * Creates a new column from the column in the table.
     */ async addColumn(tableOrName, column) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN ${this.driver.escape(column.name)}`));
        // create column index
        const columnIndex = clonedTable.indices.find((index)=>index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
            upQueries.push(this.createIndexSql(table, columnIndex));
            downQueries.push(this.dropIndexSql(table, columnIndex));
        } else if (column.isUnique) {
            const uniqueIndex = new TableIndex_1.TableIndex({
                name: this.connection.namingStrategy.indexName(table, [
                    column.name
                ]),
                columnNames: [
                    column.name
                ],
                isUnique: true
            });
            clonedTable.indices.push(uniqueIndex);
            clonedTable.uniques.push(new TableUnique_1.TableUnique({
                name: uniqueIndex.name,
                columnNames: uniqueIndex.columnNames
            }));
            upQueries.push(this.createIndexSql(table, uniqueIndex));
            downQueries.push(this.dropIndexSql(table, uniqueIndex));
        }
        if (column.generatedType && column.asExpression) {
            const insertQuery = this.insertTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            upQueries.push(insertQuery);
            downQueries.push(deleteQuery);
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.addColumn(column);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Creates a new columns from the column in the table.
     */ async addColumns(tableOrName, columns) {
        for (const column of columns){
            await this.addColumn(tableOrName, column);
        }
    }
    /**
     * Renames column in the given table.
     */ async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        const oldColumn = oldTableColumnOrName instanceof TableColumn_1.TableColumn ? oldTableColumnOrName : table.columns.find((c)=>c.name === oldTableColumnOrName);
        if (!oldColumn) throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        let newColumn;
        if (newTableColumnOrName instanceof TableColumn_1.TableColumn) {
            newColumn = newTableColumnOrName;
        } else {
            newColumn = oldColumn.clone();
            newColumn.name = newTableColumnOrName;
        }
        return this.changeColumn(table, oldColumn, newColumn);
    }
    /**
     * Changes a column in the table.
     */ async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        let clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        const oldColumn = oldTableColumnOrName instanceof TableColumn_1.TableColumn ? oldTableColumnOrName : table.columns.find((column)=>column.name === oldTableColumnOrName);
        if (!oldColumn) throw new error_1.TypeORMError(`Column "${oldTableColumnOrName}" was not found in the "${table.name}" table.`);
        if (oldColumn.name !== newColumn.name || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.isArray !== newColumn.isArray || oldColumn.generatedType !== newColumn.generatedType || oldColumn.asExpression !== newColumn.asExpression) {
            // To avoid data conversion, we just recreate column
            await this.dropColumn(table, oldColumn);
            await this.addColumn(table, newColumn);
            // update cloned table
            clonedTable = table.clone();
        } else {
            if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {
                upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(newColumn)}`));
                downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${newColumn.name}" TYPE ${this.driver.createFullType(oldColumn)}`));
            }
            if (oldColumn.isNullable !== newColumn.isNullable) {
                if (newColumn.isNullable) {
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
                } else {
                    upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" SET NOT NULL`));
                    downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN "${oldColumn.name}" DROP NOT NULL`));
                }
            }
            if (newColumn.isUnique !== oldColumn.isUnique) {
                if (newColumn.isUnique === true) {
                    const uniqueIndex = new TableIndex_1.TableIndex({
                        name: this.connection.namingStrategy.indexName(table, [
                            newColumn.name
                        ]),
                        columnNames: [
                            newColumn.name
                        ],
                        isUnique: true
                    });
                    clonedTable.indices.push(uniqueIndex);
                    clonedTable.uniques.push(new TableUnique_1.TableUnique({
                        name: uniqueIndex.name,
                        columnNames: uniqueIndex.columnNames
                    }));
                    upQueries.push(this.createIndexSql(table, uniqueIndex));
                    downQueries.push(this.dropIndexSql(table, uniqueIndex));
                } else {
                    const uniqueIndex = clonedTable.indices.find((index)=>{
                        return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find((columnName)=>columnName === newColumn.name);
                    });
                    clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);
                    const tableUnique = clonedTable.uniques.find((unique)=>unique.name === uniqueIndex.name);
                    clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);
                    upQueries.push(this.dropIndexSql(table, uniqueIndex));
                    downQueries.push(this.createIndexSql(table, uniqueIndex));
                }
            }
        }
        await this.executeQueries(upQueries, downQueries);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Changes a column in the table.
     */ async changeColumns(tableOrName, changedColumns) {
        for (const { oldColumn, newColumn } of changedColumns){
            await this.changeColumn(tableOrName, oldColumn, newColumn);
        }
    }
    /**
     * Drops column in the table.
     */ async dropColumn(tableOrName, columnOrName) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        const column = columnOrName instanceof TableColumn_1.TableColumn ? columnOrName : table.findColumnByName(columnOrName);
        if (!column) throw new error_1.TypeORMError(`Column "${columnOrName}" was not found in table "${table.name}"`);
        const clonedTable = table.clone();
        const upQueries = [];
        const downQueries = [];
        // drop column index
        const columnIndex = clonedTable.indices.find((index)=>index.columnNames.length === 1 && index.columnNames[0] === column.name);
        if (columnIndex) {
            clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);
            upQueries.push(this.dropIndexSql(table, columnIndex));
            downQueries.push(this.createIndexSql(table, columnIndex));
        }
        // drop column check
        const columnCheck = clonedTable.checks.find((check)=>!!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);
        if (columnCheck) {
            clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);
            upQueries.push(this.dropCheckConstraintSql(table, columnCheck));
            downQueries.push(this.createCheckConstraintSql(table, columnCheck));
        }
        upQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN ${this.driver.escape(column.name)}`));
        downQueries.push(new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));
        if (column.generatedType && column.asExpression) {
            const deleteQuery = this.deleteTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name
            });
            const insertQuery = this.insertTypeormMetadataSql({
                table: table.name,
                type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                name: column.name,
                value: column.asExpression
            });
            upQueries.push(deleteQuery);
            downQueries.push(insertQuery);
        }
        await this.executeQueries(upQueries, downQueries);
        clonedTable.removeColumn(column);
        this.replaceCachedTable(table, clonedTable);
    }
    /**
     * Drops the columns in the table.
     */ async dropColumns(tableOrName, columns) {
        for (const column of columns){
            await this.dropColumn(tableOrName, column);
        }
    }
    /**
     * Creates a new primary key.
     *
     * Not supported in Spanner.
     * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns
     */ async createPrimaryKey(tableOrName, columnNames) {
        throw new Error("The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.");
    }
    /**
     * Updates composite primary keys.
     */ async updatePrimaryKeys(tableOrName, columns) {
        throw new Error("The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.");
    }
    /**
     * Creates a new primary key.
     *
     * Not supported in Spanner.
     * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns
     */ async dropPrimaryKey(tableOrName) {
        throw new Error("The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.");
    }
    /**
     * Creates new unique constraint.
     */ async createUniqueConstraint(tableOrName, uniqueConstraint) {
        throw new error_1.TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);
    }
    /**
     * Creates new unique constraints.
     */ async createUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);
    }
    /**
     * Drops unique constraint.
     */ async dropUniqueConstraint(tableOrName, uniqueOrName) {
        throw new error_1.TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);
    }
    /**
     * Drops unique constraints.
     */ async dropUniqueConstraints(tableOrName, uniqueConstraints) {
        throw new error_1.TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);
    }
    /**
     * Creates new check constraint.
     */ async createCheckConstraint(tableOrName, checkConstraint) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        // new check constraint may be passed without name. In this case we generate unique name manually.
        if (!checkConstraint.name) checkConstraint.name = this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);
        const up = this.createCheckConstraintSql(table, checkConstraint);
        const down = this.dropCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.addCheckConstraint(checkConstraint);
    }
    /**
     * Creates new check constraints.
     */ async createCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint)=>this.createCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
    }
    /**
     * Drops check constraint.
     */ async dropCheckConstraint(tableOrName, checkOrName) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        const checkConstraint = checkOrName instanceof TableCheck_1.TableCheck ? checkOrName : table.checks.find((c)=>c.name === checkOrName);
        if (!checkConstraint) throw new error_1.TypeORMError(`Supplied check constraint was not found in table ${table.name}`);
        const up = this.dropCheckConstraintSql(table, checkConstraint);
        const down = this.createCheckConstraintSql(table, checkConstraint);
        await this.executeQueries(up, down);
        table.removeCheckConstraint(checkConstraint);
    }
    /**
     * Drops check constraints.
     */ async dropCheckConstraints(tableOrName, checkConstraints) {
        const promises = checkConstraints.map((checkConstraint)=>this.dropCheckConstraint(tableOrName, checkConstraint));
        await Promise.all(promises);
    }
    /**
     * Creates new exclusion constraint.
     */ async createExclusionConstraint(tableOrName, exclusionConstraint) {
        throw new error_1.TypeORMError(`Spanner does not support exclusion constraints.`);
    }
    /**
     * Creates new exclusion constraints.
     */ async createExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Spanner does not support exclusion constraints.`);
    }
    /**
     * Drops exclusion constraint.
     */ async dropExclusionConstraint(tableOrName, exclusionOrName) {
        throw new error_1.TypeORMError(`Spanner does not support exclusion constraints.`);
    }
    /**
     * Drops exclusion constraints.
     */ async dropExclusionConstraints(tableOrName, exclusionConstraints) {
        throw new error_1.TypeORMError(`Spanner does not support exclusion constraints.`);
    }
    /**
     * Creates a new foreign key.
     */ async createForeignKey(tableOrName, foreignKey) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        // new FK may be passed without name. In this case we generate FK name manually.
        if (!foreignKey.name) foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);
        const up = this.createForeignKeySql(table, foreignKey);
        const down = this.dropForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.addForeignKey(foreignKey);
    }
    /**
     * Creates a new foreign keys.
     */ async createForeignKeys(tableOrName, foreignKeys) {
        for (const foreignKey of foreignKeys){
            await this.createForeignKey(tableOrName, foreignKey);
        }
    }
    /**
     * Drops a foreign key from the table.
     */ async dropForeignKey(tableOrName, foreignKeyOrName) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        const foreignKey = foreignKeyOrName instanceof TableForeignKey_1.TableForeignKey ? foreignKeyOrName : table.foreignKeys.find((fk)=>fk.name === foreignKeyOrName);
        if (!foreignKey) throw new error_1.TypeORMError(`Supplied foreign key was not found in table ${table.name}`);
        const up = this.dropForeignKeySql(table, foreignKey);
        const down = this.createForeignKeySql(table, foreignKey);
        await this.executeQueries(up, down);
        table.removeForeignKey(foreignKey);
    }
    /**
     * Drops a foreign keys from the table.
     */ async dropForeignKeys(tableOrName, foreignKeys) {
        for (const foreignKey of foreignKeys){
            await this.dropForeignKey(tableOrName, foreignKey);
        }
    }
    /**
     * Creates a new index.
     */ async createIndex(tableOrName, index) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        // new index may be passed without name. In this case we generate index name manually.
        if (!index.name) index.name = this.generateIndexName(table, index);
        const up = this.createIndexSql(table, index);
        const down = this.dropIndexSql(table, index);
        await this.executeQueries(up, down);
        table.addIndex(index);
    }
    /**
     * Creates a new indices
     */ async createIndices(tableOrName, indices) {
        for (const index of indices){
            await this.createIndex(tableOrName, index);
        }
    }
    /**
     * Drops an index from the table.
     */ async dropIndex(tableOrName, indexOrName) {
        const table = tableOrName instanceof Table_1.Table ? tableOrName : await this.getCachedTable(tableOrName);
        const index = indexOrName instanceof TableIndex_1.TableIndex ? indexOrName : table.indices.find((i)=>i.name === indexOrName);
        if (!index) throw new error_1.TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);
        // new index may be passed without name. In this case we generate index name manually.
        if (!index.name) index.name = this.generateIndexName(table, index);
        const up = this.dropIndexSql(table, index);
        const down = this.createIndexSql(table, index);
        await this.executeQueries(up, down);
        table.removeIndex(index);
    }
    /**
     * Drops an indices from the table.
     */ async dropIndices(tableOrName, indices) {
        for (const index of indices){
            await this.dropIndex(tableOrName, index);
        }
    }
    /**
     * Clears all table contents.
     * Spanner does not support TRUNCATE TABLE statement, so we use DELETE FROM.
     */ async clearTable(tableName) {
        await this.query(`DELETE FROM ${this.escapePath(tableName)} WHERE true`);
    }
    /**
     * Removes all tables from the currently connected database.
     */ async clearDatabase() {
        // drop index queries
        const selectIndexDropsQuery = `SELECT concat('DROP INDEX \`', INDEX_NAME, '\`') AS \`query\` ` + `FROM \`INFORMATION_SCHEMA\`.\`INDEXES\` ` + `WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`INDEX_TYPE\` = 'INDEX' AND \`SPANNER_IS_MANAGED\` = false`;
        const dropIndexQueries = await this.query(selectIndexDropsQuery);
        // drop foreign key queries
        const selectFKDropsQuery = `SELECT concat('ALTER TABLE \`', TABLE_NAME, '\`', ' DROP CONSTRAINT \`', CONSTRAINT_NAME, '\`') AS \`query\` ` + `FROM \`INFORMATION_SCHEMA\`.\`TABLE_CONSTRAINTS\` ` + `WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`CONSTRAINT_TYPE\` = 'FOREIGN KEY'`;
        const dropFKQueries = await this.query(selectFKDropsQuery);
        // drop view queries
        // const selectViewDropsQuery = `SELECT concat('DROP VIEW \`', TABLE_NAME, '\`') AS \`query\` FROM \`INFORMATION_SCHEMA\`.\`VIEWS\``
        // const dropViewQueries: ObjectLiteral[] = await this.query(
        //     selectViewDropsQuery,
        // )
        // drop table queries
        const dropTablesQuery = `SELECT concat('DROP TABLE \`', TABLE_NAME, '\`') AS \`query\` ` + `FROM \`INFORMATION_SCHEMA\`.\`TABLES\` ` + `WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_TYPE\` = 'BASE TABLE'`;
        const dropTableQueries = await this.query(dropTablesQuery);
        if (!dropIndexQueries.length && !dropFKQueries.length && // !dropViewQueries.length &&
        !dropTableQueries.length) return;
        const isAnotherTransactionActive = this.isTransactionActive;
        if (!isAnotherTransactionActive) await this.startTransaction();
        try {
            for (const query of dropIndexQueries){
                await this.updateDDL(query["query"]);
            }
            for (const query of dropFKQueries){
                await this.updateDDL(query["query"]);
            }
            // for (let query of dropViewQueries) {
            //     await this.updateDDL(query["query"])
            // }
            for (const query of dropTableQueries){
                await this.updateDDL(query["query"]);
            }
            await this.commitTransaction();
        } catch (error) {
            try {
                // we throw original error even if rollback thrown an error
                if (!isAnotherTransactionActive) await this.rollbackTransaction();
            } catch (rollbackError) {}
            throw error;
        }
    }
    // -------------------------------------------------------------------------
    // Override Methods
    // -------------------------------------------------------------------------
    /**
     * Executes up sql queries.
     */ async executeMemoryUpSql() {
        for (const { query, parameters } of this.sqlInMemory.upQueries){
            if (this.isDMLQuery(query)) {
                await this.query(query, parameters);
            } else {
                await this.updateDDL(query, parameters);
            }
        }
    }
    /**
     * Executes down sql queries.
     */ async executeMemoryDownSql() {
        for (const { query, parameters } of this.sqlInMemory.downQueries.reverse()){
            if (this.isDMLQuery(query)) {
                await this.query(query, parameters);
            } else {
                await this.updateDDL(query, parameters);
            }
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    async loadViews(viewNames) {
        // const hasTable = await this.hasTable(this.getTypeormMetadataTableName())
        // if (!hasTable) {
        //     return []
        // }
        //
        // if (!viewNames) {
        //     viewNames = []
        // }
        //
        // const escapedViewNames = viewNames
        //     .map((viewName) => `'${viewName}'`)
        //     .join(", ")
        //
        // const query =
        //     `SELECT \`T\`.*, \`V\`.\`VIEW_DEFINITION\` FROM ${this.escapePath(
        //         this.getTypeormMetadataTableName(),
        //     )} \`T\` ` +
        //     `INNER JOIN \`INFORMATION_SCHEMA\`.\`VIEWS\` \`V\` ON \`V\`.\`TABLE_NAME\` = \`T\`.\`NAME\` ` +
        //     `WHERE \`T\`.\`TYPE\` = '${MetadataTableType.VIEW}' ${
        //         viewNames.length
        //             ? ` AND \`T\`.\`NAME\` IN (${escapedViewNames})`
        //             : ""
        //     }`
        // const dbViews = await this.query(query)
        // return dbViews.map((dbView: any) => {
        //     const view = new View()
        //     view.database = dbView["NAME"]
        //     view.name = this.driver.buildTableName(dbView["NAME"])
        //     view.expression = dbView["NAME"]
        //     return view
        // })
        return Promise.resolve([]);
    }
    /**
     * Loads all tables (with given names) from the database and creates a Table from them.
     */ async loadTables(tableNames) {
        if (tableNames && tableNames.length === 0) {
            return [];
        }
        const dbTables = [];
        if (!tableNames || !tableNames.length) {
            // Since we don't have any of this data we have to do a scan
            const tablesSql = `SELECT \`TABLE_NAME\` ` + `FROM \`INFORMATION_SCHEMA\`.\`TABLES\` ` + `WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_TYPE\` = 'BASE TABLE'`;
            dbTables.push(...await this.query(tablesSql));
        } else {
            const tablesSql = `SELECT \`TABLE_NAME\` ` + `FROM \`INFORMATION_SCHEMA\`.\`TABLES\` ` + `WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_TYPE\` = 'BASE TABLE' ` + `AND \`TABLE_NAME\` IN (${tableNames.map((tableName)=>`'${tableName}'`).join(", ")})`;
            dbTables.push(...await this.query(tablesSql));
        }
        // if tables were not found in the db, no need to proceed
        if (!dbTables.length) return [];
        const loadedTableNames = dbTables.map((dbTable)=>`'${dbTable.TABLE_NAME}'`).join(", ");
        const columnsSql = `SELECT * FROM \`INFORMATION_SCHEMA\`.\`COLUMNS\` WHERE \`TABLE_CATALOG\` = '' AND \`TABLE_SCHEMA\` = '' AND \`TABLE_NAME\` IN (${loadedTableNames})`;
        const primaryKeySql = `SELECT \`KCU\`.\`TABLE_NAME\`, \`KCU\`.\`COLUMN_NAME\` ` + `FROM \`INFORMATION_SCHEMA\`.\`TABLE_CONSTRAINTS\` \`TC\` ` + `INNER JOIN \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` \`KCU\` ON \`KCU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` ` + `WHERE \`TC\`.\`TABLE_CATALOG\` = '' AND \`TC\`.\`TABLE_SCHEMA\` = '' AND \`TC\`.\`CONSTRAINT_TYPE\` = 'PRIMARY KEY' ` + `AND \`TC\`.\`TABLE_NAME\` IN (${loadedTableNames})`;
        const indicesSql = `SELECT \`I\`.\`TABLE_NAME\`, \`I\`.\`INDEX_NAME\`, \`I\`.\`IS_UNIQUE\`, \`I\`.\`IS_NULL_FILTERED\`, \`IC\`.\`COLUMN_NAME\` ` + `FROM \`INFORMATION_SCHEMA\`.\`INDEXES\` \`I\` ` + `INNER JOIN \`INFORMATION_SCHEMA\`.\`INDEX_COLUMNS\` \`IC\` ON \`IC\`.\`INDEX_NAME\` = \`I\`.\`INDEX_NAME\` ` + `AND \`IC\`.\`TABLE_NAME\` = \`I\`.\`TABLE_NAME\` ` + `WHERE \`I\`.\`TABLE_CATALOG\` = '' AND \`I\`.\`TABLE_SCHEMA\` = '' AND \`I\`.\`TABLE_NAME\` IN (${loadedTableNames}) ` + `AND \`I\`.\`INDEX_TYPE\` = 'INDEX' AND \`I\`.\`SPANNER_IS_MANAGED\` = false`;
        const checksSql = `SELECT \`TC\`.\`TABLE_NAME\`, \`TC\`.\`CONSTRAINT_NAME\`, \`CC\`.\`CHECK_CLAUSE\`, \`CCU\`.\`COLUMN_NAME\`` + `FROM \`INFORMATION_SCHEMA\`.\`TABLE_CONSTRAINTS\` \`TC\` ` + `INNER JOIN \`INFORMATION_SCHEMA\`.\`CONSTRAINT_COLUMN_USAGE\` \`CCU\` ON \`CCU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` ` + `INNER JOIN \`INFORMATION_SCHEMA\`.\`CHECK_CONSTRAINTS\` \`CC\` ON \`CC\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` ` + `WHERE \`TC\`.\`TABLE_CATALOG\` = '' AND \`TC\`.\`TABLE_SCHEMA\` = '' AND \`TC\`.\`CONSTRAINT_TYPE\` = 'CHECK' ` + `AND \`TC\`.\`TABLE_NAME\` IN (${loadedTableNames}) AND \`TC\`.\`CONSTRAINT_NAME\` NOT LIKE 'CK_IS_NOT_NULL%'`;
        const foreignKeysSql = `SELECT \`TC\`.\`TABLE_NAME\`, \`TC\`.\`CONSTRAINT_NAME\`, \`KCU\`.\`COLUMN_NAME\`, ` + `\`CTU\`.\`TABLE_NAME\` AS \`REFERENCED_TABLE_NAME\`, \`CCU\`.\`COLUMN_NAME\` AS \`REFERENCED_COLUMN_NAME\`, ` + `\`RC\`.\`UPDATE_RULE\`, \`RC\`.\`DELETE_RULE\` ` + `FROM \`INFORMATION_SCHEMA\`.\`TABLE_CONSTRAINTS\` \`TC\` ` + `INNER JOIN \`INFORMATION_SCHEMA\`.\`KEY_COLUMN_USAGE\` \`KCU\` ON \`KCU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` ` + `INNER JOIN \`INFORMATION_SCHEMA\`.\`CONSTRAINT_TABLE_USAGE\` \`CTU\` ON \`CTU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` ` + `INNER JOIN \`INFORMATION_SCHEMA\`.\`REFERENTIAL_CONSTRAINTS\` \`RC\` ON \`RC\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` ` + `INNER JOIN \`INFORMATION_SCHEMA\`.\`CONSTRAINT_COLUMN_USAGE\` \`CCU\` ON \`CCU\`.\`CONSTRAINT_NAME\` = \`TC\`.\`CONSTRAINT_NAME\` ` + `WHERE \`TC\`.\`TABLE_CATALOG\` = '' AND \`TC\`.\`TABLE_SCHEMA\` = '' AND \`TC\`.\`CONSTRAINT_TYPE\` = 'FOREIGN KEY' ` + `AND \`TC\`.\`TABLE_NAME\` IN (${loadedTableNames})`;
        const [dbColumns, dbPrimaryKeys, dbIndices, dbChecks, dbForeignKeys] = await Promise.all([
            this.query(columnsSql),
            this.query(primaryKeySql),
            this.query(indicesSql),
            this.query(checksSql),
            this.query(foreignKeysSql)
        ]);
        // create tables for loaded tables
        return Promise.all(dbTables.map(async (dbTable)=>{
            const table = new Table_1.Table();
            table.name = this.driver.buildTableName(dbTable["TABLE_NAME"]);
            // create columns from the loaded columns
            table.columns = await Promise.all(dbColumns.filter((dbColumn)=>dbColumn["TABLE_NAME"] === dbTable["TABLE_NAME"]).map(async (dbColumn)=>{
                const columnUniqueIndices = dbIndices.filter((dbIndex)=>{
                    return dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"] && dbIndex["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] && dbIndex["IS_UNIQUE"] === true;
                });
                const tableMetadata = this.connection.entityMetadatas.find((metadata)=>this.getTablePath(table) === this.getTablePath(metadata));
                const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some((index)=>{
                    return columnUniqueIndices.some((uniqueIndex)=>{
                        return index.name === uniqueIndex["INDEX_NAME"] && index.synchronize === false;
                    });
                });
                const isConstraintComposite = columnUniqueIndices.every((uniqueIndex)=>{
                    return dbIndices.some((dbIndex)=>dbIndex["INDEX_NAME"] === uniqueIndex["INDEX_NAME"] && dbIndex["COLUMN_NAME"] !== dbColumn["COLUMN_NAME"]);
                });
                const tableColumn = new TableColumn_1.TableColumn();
                tableColumn.name = dbColumn["COLUMN_NAME"];
                let fullType = dbColumn["SPANNER_TYPE"].toLowerCase();
                if (fullType.indexOf("array") !== -1) {
                    tableColumn.isArray = true;
                    fullType = fullType.substring(fullType.indexOf("<") + 1, fullType.indexOf(">"));
                }
                if (fullType.indexOf("(") !== -1) {
                    tableColumn.type = fullType.substring(0, fullType.indexOf("("));
                } else {
                    tableColumn.type = fullType;
                }
                if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {
                    tableColumn.length = fullType.substring(fullType.indexOf("(") + 1, fullType.indexOf(")"));
                }
                if (dbColumn["IS_GENERATED"] === "ALWAYS") {
                    tableColumn.asExpression = dbColumn["GENERATION_EXPRESSION"];
                    tableColumn.generatedType = "STORED";
                    // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.
                    const asExpressionQuery = this.selectTypeormMetadataSql({
                        table: dbTable["TABLE_NAME"],
                        type: MetadataTableType_1.MetadataTableType.GENERATED_COLUMN,
                        name: tableColumn.name
                    });
                    const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);
                    if (results[0] && results[0].value) {
                        tableColumn.asExpression = results[0].value;
                    } else {
                        tableColumn.asExpression = "";
                    }
                }
                tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;
                tableColumn.isNullable = dbColumn["IS_NULLABLE"] === "YES";
                tableColumn.isPrimary = dbPrimaryKeys.some((dbPrimaryKey)=>{
                    return dbPrimaryKey["TABLE_NAME"] === dbColumn["TABLE_NAME"] && dbPrimaryKey["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
                });
                return tableColumn;
            }));
            const tableForeignKeys = dbForeignKeys.filter((dbForeignKey)=>{
                return dbForeignKey["TABLE_NAME"] === dbTable["TABLE_NAME"];
            });
            table.foreignKeys = OrmUtils_1.OrmUtils.uniq(tableForeignKeys, (dbForeignKey)=>dbForeignKey["CONSTRAINT_NAME"]).map((dbForeignKey)=>{
                const foreignKeys = tableForeignKeys.filter((dbFk)=>dbFk["CONSTRAINT_NAME"] === dbForeignKey["CONSTRAINT_NAME"]);
                return new TableForeignKey_1.TableForeignKey({
                    name: dbForeignKey["CONSTRAINT_NAME"],
                    columnNames: OrmUtils_1.OrmUtils.uniq(foreignKeys.map((dbFk)=>dbFk["COLUMN_NAME"])),
                    referencedDatabase: dbForeignKey["REFERENCED_TABLE_SCHEMA"],
                    referencedTableName: dbForeignKey["REFERENCED_TABLE_NAME"],
                    referencedColumnNames: OrmUtils_1.OrmUtils.uniq(foreignKeys.map((dbFk)=>dbFk["REFERENCED_COLUMN_NAME"])),
                    onDelete: dbForeignKey["DELETE_RULE"],
                    onUpdate: dbForeignKey["UPDATE_RULE"]
                });
            });
            const tableIndices = dbIndices.filter((dbIndex)=>dbIndex["TABLE_NAME"] === dbTable["TABLE_NAME"]);
            table.indices = OrmUtils_1.OrmUtils.uniq(tableIndices, (dbIndex)=>dbIndex["INDEX_NAME"]).map((constraint)=>{
                const indices = tableIndices.filter((index)=>{
                    return index["INDEX_NAME"] === constraint["INDEX_NAME"];
                });
                return new TableIndex_1.TableIndex({
                    table: table,
                    name: constraint["INDEX_NAME"],
                    columnNames: indices.map((i)=>i["COLUMN_NAME"]),
                    isUnique: constraint["IS_UNIQUE"],
                    isNullFiltered: constraint["IS_NULL_FILTERED"]
                });
            });
            const tableChecks = dbChecks.filter((dbCheck)=>dbCheck["TABLE_NAME"] === dbTable["TABLE_NAME"]);
            table.checks = OrmUtils_1.OrmUtils.uniq(tableChecks, (dbIndex)=>dbIndex["CONSTRAINT_NAME"]).map((constraint)=>{
                const checks = tableChecks.filter((dbC)=>dbC["CONSTRAINT_NAME"] === constraint["CONSTRAINT_NAME"]);
                return new TableCheck_1.TableCheck({
                    name: constraint["CONSTRAINT_NAME"],
                    columnNames: checks.map((c)=>c["COLUMN_NAME"]),
                    expression: constraint["CHECK_CLAUSE"]
                });
            });
            return table;
        }));
    }
    /**
     * Builds create table sql.
     */ createTableSql(table, createForeignKeys) {
        const columnDefinitions = table.columns.map((column)=>this.buildCreateColumnSql(column)).join(", ");
        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;
        // we create unique indexes instead of unique constraints, because Spanner does not have unique constraints.
        // if we mark column as Unique, it means that we create UNIQUE INDEX.
        table.columns.filter((column)=>column.isUnique).forEach((column)=>{
            const isUniqueIndexExist = table.indices.some((index)=>{
                return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;
            });
            const isUniqueConstraintExist = table.uniques.some((unique)=>{
                return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;
            });
            if (!isUniqueIndexExist && !isUniqueConstraintExist) table.indices.push(new TableIndex_1.TableIndex({
                name: this.connection.namingStrategy.uniqueConstraintName(table, [
                    column.name
                ]),
                columnNames: [
                    column.name
                ],
                isUnique: true
            }));
        });
        // as Spanner does not have unique constraints, we must create table indices from table uniques and mark them as unique.
        if (table.uniques.length > 0) {
            table.uniques.forEach((unique)=>{
                const uniqueExist = table.indices.some((index)=>index.name === unique.name);
                if (!uniqueExist) {
                    table.indices.push(new TableIndex_1.TableIndex({
                        name: unique.name,
                        columnNames: unique.columnNames,
                        isUnique: true
                    }));
                }
            });
        }
        if (table.checks.length > 0) {
            const checksSql = table.checks.map((check)=>{
                const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);
                return `CONSTRAINT \`${checkName}\` CHECK (${check.expression})`;
            }).join(", ");
            sql += `, ${checksSql}`;
        }
        if (table.foreignKeys.length > 0 && createForeignKeys) {
            const foreignKeysSql = table.foreignKeys.map((fk)=>{
                const columnNames = fk.columnNames.map((columnName)=>`\`${columnName}\``).join(", ");
                if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);
                const referencedColumnNames = fk.referencedColumnNames.map((columnName)=>`\`${columnName}\``).join(", ");
                return `CONSTRAINT \`${fk.name}\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;
            }).join(", ");
            sql += `, ${foreignKeysSql}`;
        }
        sql += `)`;
        const primaryColumns = table.columns.filter((column)=>column.isPrimary);
        if (primaryColumns.length > 0) {
            const columnNames = primaryColumns.map((column)=>this.driver.escape(column.name)).join(", ");
            sql += ` PRIMARY KEY (${columnNames})`;
        }
        return new Query_1.Query(sql);
    }
    /**
     * Builds drop table sql.
     */ dropTableSql(tableOrPath) {
        return new Query_1.Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);
    }
    createViewSql(view) {
        const materializedClause = view.materialized ? "MATERIALIZED " : "";
        const viewName = this.escapePath(view);
        const expression = typeof view.expression === "string" ? view.expression : view.expression(this.connection).getQuery();
        return new Query_1.Query(`CREATE ${materializedClause}VIEW ${viewName} SQL SECURITY INVOKER AS ${expression}`);
    }
    async insertViewDefinitionSql(view) {
        const { schema, tableName: name } = this.driver.parseTableName(view);
        const type = view.materialized ? MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW : MetadataTableType_1.MetadataTableType.VIEW;
        const expression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
        return this.insertTypeormMetadataSql({
            type,
            schema,
            name,
            value: expression
        });
    }
    /**
     * Builds drop view sql.
     */ dropViewSql(view) {
        const materializedClause = view.materialized ? "MATERIALIZED " : "";
        return new Query_1.Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);
    }
    /**
     * Builds remove view sql.
     */ async deleteViewDefinitionSql(view) {
        const { schema, tableName: name } = this.driver.parseTableName(view);
        const type = view.materialized ? MetadataTableType_1.MetadataTableType.MATERIALIZED_VIEW : MetadataTableType_1.MetadataTableType.VIEW;
        return this.deleteTypeormMetadataSql({
            type,
            schema,
            name
        });
    }
    /**
     * Builds create index sql.
     */ createIndexSql(table, index) {
        const columns = index.columnNames.map((columnName)=>this.driver.escape(columnName)).join(", ");
        let indexType = "";
        if (index.isUnique) indexType += "UNIQUE ";
        if (index.isNullFiltered) indexType += "NULL_FILTERED ";
        return new Query_1.Query(`CREATE ${indexType}INDEX \`${index.name}\` ON ${this.escapePath(table)} (${columns})`);
    }
    /**
     * Builds drop index sql.
     */ dropIndexSql(table, indexOrName) {
        const indexName = indexOrName instanceof TableIndex_1.TableIndex ? indexOrName.name : indexOrName;
        return new Query_1.Query(`DROP INDEX \`${indexName}\``);
    }
    /**
     * Builds create check constraint sql.
     */ createCheckConstraintSql(table, checkConstraint) {
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \`${checkConstraint.name}\` CHECK (${checkConstraint.expression})`);
    }
    /**
     * Builds drop check constraint sql.
     */ dropCheckConstraintSql(table, checkOrName) {
        const checkName = checkOrName instanceof TableCheck_1.TableCheck ? checkOrName.name : checkOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \`${checkName}\``);
    }
    /**
     * Builds create foreign key sql.
     */ createForeignKeySql(table, foreignKey) {
        const columnNames = foreignKey.columnNames.map((column)=>this.driver.escape(column)).join(", ");
        const referencedColumnNames = foreignKey.referencedColumnNames.map((column)=>this.driver.escape(column)).join(",");
        const sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \`${foreignKey.name}\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))} (${referencedColumnNames})`;
        return new Query_1.Query(sql);
    }
    /**
     * Builds drop foreign key sql.
     */ dropForeignKeySql(table, foreignKeyOrName) {
        const foreignKeyName = foreignKeyOrName instanceof TableForeignKey_1.TableForeignKey ? foreignKeyOrName.name : foreignKeyOrName;
        return new Query_1.Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \`${foreignKeyName}\``);
    }
    /**
     * Escapes given table or view path.
     */ escapePath(target) {
        const { tableName } = this.driver.parseTableName(target);
        return `\`${tableName}\``;
    }
    /**
     * Builds a part of query to create/change a column.
     */ buildCreateColumnSql(column) {
        let c = `${this.driver.escape(column.name)} ${this.connection.driver.createFullType(column)}`;
        // Spanner supports only STORED generated column type
        if (column.generatedType === "STORED" && column.asExpression) {
            c += ` AS (${column.asExpression}) STORED`;
        } else {
            if (!column.isNullable) c += " NOT NULL";
        }
        return c;
    }
    /**
     * Executes sql used special for schema build.
     */ async executeQueries(upQueries, downQueries) {
        if (upQueries instanceof Query_1.Query) upQueries = [
            upQueries
        ];
        if (downQueries instanceof Query_1.Query) downQueries = [
            downQueries
        ];
        this.sqlInMemory.upQueries.push(...upQueries);
        this.sqlInMemory.downQueries.push(...downQueries);
        // if sql-in-memory mode is enabled then simply store sql in memory and return
        if (this.sqlMemoryMode === true) return Promise.resolve();
        for (const { query, parameters } of upQueries){
            if (this.isDMLQuery(query)) {
                await this.query(query, parameters);
            } else {
                await this.updateDDL(query, parameters);
            }
        }
    }
    isDMLQuery(query) {
        return query.startsWith("INSERT") || query.startsWith("UPDATE") || query.startsWith("DELETE");
    }
    /**
     * Change table comment.
     */ changeTableComment(tableOrName, comment) {
        throw new error_1.TypeORMError(`spanner driver does not support change table comment.`);
    }
}
exports.SpannerQueryRunner = SpannerQueryRunner; //# sourceMappingURL=SpannerQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/driver/spanner/SpannerDriver.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpannerDriver = void 0;
const DriverPackageNotInstalledError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/DriverPackageNotInstalledError.js [app-route] (ecmascript)");
const SpannerQueryRunner_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/spanner/SpannerQueryRunner.js [app-route] (ecmascript)");
const DateUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/DateUtils.js [app-route] (ecmascript)");
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const RdbmsSchemaBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/RdbmsSchemaBuilder.js [app-route] (ecmascript)");
const EntityMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/EntityMetadata.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const ApplyValueTransformers_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)");
const Table_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/Table.js [app-route] (ecmascript)");
const View_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/view/View.js [app-route] (ecmascript)");
const TableForeignKey_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableForeignKey.js [app-route] (ecmascript)");
/**
 * Organizes communication with Spanner DBMS.
 */ class SpannerDriver {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        /**
         * Indicates if replication is enabled.
         */ this.isReplicated = false;
        /**
         * Indicates if tree tables are supported by this driver.
         */ this.treeSupport = true;
        /**
         * Represent transaction support by this driver
         */ this.transactionSupport = "none";
        /**
         * Gets list of supported column data types by a driver.
         *
         * @see https://cloud.google.com/spanner/docs/reference/standard-sql/data-types
         */ this.supportedDataTypes = [
            "bool",
            "int64",
            "float64",
            "numeric",
            "string",
            "json",
            "bytes",
            "date",
            "timestamp",
            "array"
        ];
        /**
         * Returns type of upsert supported by driver if any
         */ this.supportedUpsertTypes = [];
        /**
         * Gets list of spatial column data types.
         */ this.spatialTypes = [];
        /**
         * Gets list of column data types that support length by a driver.
         */ this.withLengthColumnTypes = [
            "string",
            "bytes"
        ];
        /**
         * Gets list of column data types that support length by a driver.
         */ this.withWidthColumnTypes = [];
        /**
         * Gets list of column data types that support precision by a driver.
         */ this.withPrecisionColumnTypes = [];
        /**
         * Gets list of column data types that supports scale by a driver.
         */ this.withScaleColumnTypes = [];
        /**
         * ORM has special columns and we need to know what database column types should be for those columns.
         * Column types are driver dependant.
         */ this.mappedDataTypes = {
            createDate: "timestamp",
            createDateDefault: "",
            updateDate: "timestamp",
            updateDateDefault: "",
            deleteDate: "timestamp",
            deleteDateNullable: true,
            version: "int64",
            treeLevel: "int64",
            migrationId: "int64",
            migrationName: "string",
            migrationTimestamp: "int64",
            cacheId: "string",
            cacheIdentifier: "string",
            cacheTime: "int64",
            cacheDuration: "int64",
            cacheQuery: "string",
            cacheResult: "string",
            metadataType: "string",
            metadataDatabase: "string",
            metadataSchema: "string",
            metadataTable: "string",
            metadataName: "string",
            metadataValue: "string"
        };
        /**
         * The prefix used for the parameters
         */ this.parametersPrefix = "@param";
        /**
         * Default values of length, precision and scale depends on column data type.
         * Used in the cases when length/precision/scale is not specified by user.
         */ this.dataTypeDefaults = {};
        /**
         * Max length allowed by MySQL for aliases.
         * @see https://dev.mysql.com/doc/refman/5.5/en/identifiers.html
         */ this.maxAliasLength = 63;
        this.cteCapabilities = {
            enabled: true
        };
        this.connection = connection;
        this.options = connection.options;
        this.isReplicated = this.options.replication ? true : false;
        // load mysql package
        this.loadDependencies();
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Performs connection to the database.
     */ async connect() {
        this.instance = this.spanner.instance(this.options.instanceId);
        this.instanceDatabase = this.instance.database(this.options.databaseId);
    }
    /**
     * Makes any action after connection (e.g. create extensions in Postgres driver).
     */ afterConnect() {
        return Promise.resolve();
    }
    /**
     * Closes connection with the database.
     */ async disconnect() {
        this.instanceDatabase.close();
    }
    /**
     * Creates a schema builder used to build and sync a schema.
     */ createSchemaBuilder() {
        return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
    }
    /**
     * Creates a query runner used to execute database queries.
     */ createQueryRunner(mode) {
        return new SpannerQueryRunner_1.SpannerQueryRunner(this, mode);
    }
    /**
     * Replaces parameters in the given sql with special escaping character
     * and an array of parameter names to be passed to a query.
     */ escapeQueryWithParameters(sql, parameters, nativeParameters) {
        const escapedParameters = Object.keys(nativeParameters).map((key)=>nativeParameters[key]);
        if (!parameters || !Object.keys(parameters).length) return [
            sql,
            escapedParameters
        ];
        const parameterIndexMap = new Map();
        sql = sql.replace(/:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key)=>{
            if (!parameters.hasOwnProperty(key)) {
                return full;
            }
            if (parameterIndexMap.has(key)) {
                return this.parametersPrefix + parameterIndexMap.get(key);
            }
            const value = parameters[key];
            if (value === null) {
                return full;
            }
            if (isArray) {
                return value.map((v)=>{
                    escapedParameters.push(v);
                    return this.createParameter(key, escapedParameters.length - 1);
                }).join(", ");
            }
            if (value instanceof Function) {
                return value();
            }
            escapedParameters.push(value);
            parameterIndexMap.set(key, escapedParameters.length - 1);
            return this.createParameter(key, escapedParameters.length - 1);
        }); // todo: make replace only in value statements, otherwise problems
        sql = sql.replace(/([ ]+)?=([ ]+)?:(\.\.\.)?([A-Za-z0-9_.]+)/g, (full, emptySpaceBefore, emptySpaceAfter, isArray, key)=>{
            if (!parameters.hasOwnProperty(key)) {
                return full;
            }
            const value = parameters[key];
            if (value === null) {
                return " IS NULL";
            }
            return full;
        });
        return [
            sql,
            escapedParameters
        ];
    }
    /**
     * Escapes a column name.
     */ escape(columnName) {
        return `\`${columnName}\``;
    }
    /**
     * Build full table name with database name, schema name and table name.
     * E.g. myDB.mySchema.myTable
     */ buildTableName(tableName, schema, database) {
        const tablePath = [
            tableName
        ];
        if (database) {
            tablePath.unshift(database);
        }
        return tablePath.join(".");
    }
    /**
     * Parse a target table name or other types and return a normalized table definition.
     */ parseTableName(target) {
        const driverDatabase = this.database;
        const driverSchema = undefined;
        if (target instanceof Table_1.Table || target instanceof View_1.View) {
            const parsed = this.parseTableName(target.name);
            return {
                database: target.database || parsed.database || driverDatabase,
                schema: target.schema || parsed.schema || driverSchema,
                tableName: parsed.tableName
            };
        }
        if (target instanceof TableForeignKey_1.TableForeignKey) {
            const parsed = this.parseTableName(target.referencedTableName);
            return {
                database: target.referencedDatabase || parsed.database || driverDatabase,
                schema: target.referencedSchema || parsed.schema || driverSchema,
                tableName: parsed.tableName
            };
        }
        if (target instanceof EntityMetadata_1.EntityMetadata) {
            // EntityMetadata tableName is never a path
            return {
                database: target.database || driverDatabase,
                schema: target.schema || driverSchema,
                tableName: target.tableName
            };
        }
        const parts = target.split(".");
        return {
            database: (parts.length > 1 ? parts[0] : undefined) || driverDatabase,
            schema: driverSchema,
            tableName: parts.length > 1 ? parts[1] : parts[0]
        };
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type and metadata.
     */ preparePersistentValue(value, columnMetadata) {
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(columnMetadata.transformer, value);
        if (value === null || value === undefined) return value;
        if (columnMetadata.type === "numeric") {
            const lib = this.options.driver || PlatformTools_1.PlatformTools.load("spanner");
            return lib.Spanner.numeric(value.toString());
        } else if (columnMetadata.type === "date") {
            return DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "json") {
            return value;
        } else if (columnMetadata.type === "timestamp" || columnMetadata.type === Date) {
            return DateUtils_1.DateUtils.mixedDateToDate(value);
        }
        return value;
    }
    /**
     * Prepares given value to a value to be persisted, based on its column type or metadata.
     */ prepareHydratedValue(value, columnMetadata) {
        if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;
        if (columnMetadata.type === Boolean || columnMetadata.type === "bool") {
            value = value ? true : false;
        } else if (columnMetadata.type === "timestamp" || columnMetadata.type === Date) {
            value = new Date(value);
        } else if (columnMetadata.type === "numeric") {
            value = value.value;
        } else if (columnMetadata.type === "date") {
            value = DateUtils_1.DateUtils.mixedDateToDateString(value);
        } else if (columnMetadata.type === "json") {
            value = typeof value === "string" ? JSON.parse(value) : value;
        } else if (columnMetadata.type === Number) {
            // convert to number if number
            value = !isNaN(+value) ? parseInt(value) : value;
        }
        if (columnMetadata.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);
        return value;
    }
    /**
     * Creates a database type from a given column metadata.
     */ normalizeType(column) {
        if (column.type === Number) {
            return "int64";
        } else if (column.type === String || column.type === "uuid") {
            return "string";
        } else if (column.type === Date) {
            return "timestamp";
        } else if (column.type === Buffer) {
            return "bytes";
        } else if (column.type === Boolean) {
            return "bool";
        } else {
            return column.type || "";
        }
    }
    /**
     * Normalizes "default" value of the column.
     *
     * Spanner does not support default values.
     */ normalizeDefault(columnMetadata) {
        return columnMetadata.default === "" ? `"${columnMetadata.default}"` : `${columnMetadata.default}`;
    }
    /**
     * Normalizes "isUnique" value of the column.
     */ normalizeIsUnique(column) {
        return column.entityMetadata.indices.some((idx)=>idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);
    }
    /**
     * Returns default column lengths, which is required on column creation.
     */ getColumnLength(column) {
        if (column.length) return column.length.toString();
        if (column.generationStrategy === "uuid") return "36";
        switch(column.type){
            case String:
            case "string":
            case "bytes":
                return "max";
            default:
                return "";
        }
    }
    /**
     * Creates column type definition including length, precision and scale
     */ createFullType(column) {
        let type = column.type;
        // used 'getColumnLength()' method, because Spanner requires column length for `string` and `bytes` data types
        if (this.getColumnLength(column)) {
            type += `(${this.getColumnLength(column)})`;
        } else if (column.width) {
            type += `(${column.width})`;
        } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {
            type += `(${column.precision},${column.scale})`;
        } else if (column.precision !== null && column.precision !== undefined) {
            type += `(${column.precision})`;
        }
        if (column.isArray) type = `array<${type}>`;
        return type;
    }
    /**
     * Obtains a new database connection to a master server.
     * Used for replication.
     * If replication is not setup then returns default connection's database connection.
     */ obtainMasterConnection() {
        return this.instanceDatabase;
    }
    /**
     * Obtains a new database connection to a slave server.
     * Used for replication.
     * If replication is not setup then returns master (default) connection's database connection.
     */ obtainSlaveConnection() {
        return this.instanceDatabase;
    }
    /**
     * Creates generated map of values generated or returned by database after INSERT query.
     */ createGeneratedMap(metadata, insertResult, entityIndex) {
        if (!insertResult) {
            return undefined;
        }
        if (insertResult.insertId === undefined) {
            return Object.keys(insertResult).reduce((map, key)=>{
                const column = metadata.findColumnWithDatabaseName(key);
                if (column) {
                    OrmUtils_1.OrmUtils.mergeDeep(map, column.createValueMap(insertResult[key]));
                // OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column))); // TODO: probably should be like there, but fails on enums, fix later
                }
                return map;
            }, {});
        }
        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn)=>{
            let value;
            if (generatedColumn.generationStrategy === "increment" && insertResult.insertId) {
                // NOTE: When multiple rows is inserted by a single INSERT statement,
                // `insertId` is the value generated for the first inserted row only.
                value = insertResult.insertId + entityIndex;
            // } else if (generatedColumn.generationStrategy === "uuid") {
            //     console.log("getting db value:", generatedColumn.databaseName);
            //     value = generatedColumn.getEntityValue(uuidMap);
            }
            return OrmUtils_1.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
        }, {});
        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;
    }
    /**
     * Differentiate columns of this table and columns from the given column metadatas columns
     * and returns only changed.
     */ findChangedColumns(tableColumns, columnMetadatas) {
        return columnMetadatas.filter((columnMetadata)=>{
            const tableColumn = tableColumns.find((c)=>c.name === columnMetadata.databaseName);
            if (!tableColumn) return false; // we don't need new columns, we only need exist and changed
            const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== this.getColumnLength(columnMetadata) || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.isPrimary !== columnMetadata.isPrimary || !this.compareNullableValues(columnMetadata, tableColumn) || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata);
            // DEBUG SECTION
            // if (isColumnChanged) {
            //     console.log("table:", columnMetadata.entityMetadata.tableName)
            //     console.log(
            //         "name:",
            //         tableColumn.name,
            //         columnMetadata.databaseName,
            //     )
            //     console.log(
            //         "type:",
            //         tableColumn.type,
            //         this.normalizeType(columnMetadata),
            //     )
            //     console.log(
            //         "length:",
            //         tableColumn.length,
            //         this.getColumnLength(columnMetadata),
            //     )
            //     console.log(
            //         "asExpression:",
            //         tableColumn.asExpression,
            //         columnMetadata.asExpression,
            //     )
            //     console.log(
            //         "generatedType:",
            //         tableColumn.generatedType,
            //         columnMetadata.generatedType,
            //     )
            //     console.log(
            //         "isPrimary:",
            //         tableColumn.isPrimary,
            //         columnMetadata.isPrimary,
            //     )
            //     console.log(
            //         "isNullable:",
            //         tableColumn.isNullable,
            //         columnMetadata.isNullable,
            //     )
            //     console.log(
            //         "isUnique:",
            //         tableColumn.isUnique,
            //         this.normalizeIsUnique(columnMetadata),
            //     )
            //     console.log("==========================================")
            // }
            return isColumnChanged;
        });
    }
    /**
     * Returns true if driver supports RETURNING / OUTPUT statement.
     */ isReturningSqlSupported() {
        return true;
    }
    /**
     * Returns true if driver supports uuid values generation on its own.
     */ isUUIDGenerationSupported() {
        return true;
    }
    /**
     * Returns true if driver supports fulltext indices.
     */ isFullTextColumnTypeSupported() {
        return false;
    }
    /**
     * Creates an escaped parameter.
     */ createParameter(parameterName, index) {
        return this.parametersPrefix + index;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Loads all driver dependencies.
     */ loadDependencies() {
        try {
            const lib = this.options.driver || PlatformTools_1.PlatformTools.load("spanner");
            this.spanner = new lib.Spanner({
                projectId: this.options.projectId
            });
        } catch (e) {
            console.error(e);
            throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Spanner", "@google-cloud/spanner");
        }
    }
    compareNullableValues(columnMetadata, tableColumn) {
        // Spanner does not support NULL/NOT NULL expressions for generated columns
        if (columnMetadata.generatedType) {
            return true;
        }
        return columnMetadata.isNullable === tableColumn.isNullable;
    }
    /**
     * Checks if "DEFAULT" values in the column metadata and in the database are equal.
     */ compareDefaultValues(columnMetadataValue, databaseValue) {
        if (typeof columnMetadataValue === "string" && typeof databaseValue === "string") {
            // we need to cut out "'" because in mysql we can understand returned value is a string or a function
            // as result compare cannot understand if default is really changed or not
            columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, "");
            databaseValue = databaseValue.replace(/^'+|'+$/g, "");
        }
        return columnMetadataValue === databaseValue;
    }
    /**
     * If parameter is a datetime function, e.g. "CURRENT_TIMESTAMP", normalizes it.
     * Otherwise returns original input.
     */ normalizeDatetimeFunction(value) {
        if (!value) return value;
        // check if input is datetime function
        const isDatetimeFunction = value.toUpperCase().indexOf("CURRENT_TIMESTAMP") !== -1 || value.toUpperCase().indexOf("NOW") !== -1;
        if (isDatetimeFunction) {
            // extract precision, e.g. "(3)"
            const precision = value.match(/\(\d+\)/);
            return precision ? `CURRENT_TIMESTAMP${precision[0]}` : "CURRENT_TIMESTAMP";
        } else {
            return value;
        }
    }
    /**
     * Escapes a given comment.
     */ escapeComment(comment) {
        if (!comment) return comment;
        comment = comment.replace(/\u0000/g, ""); // Null bytes aren't allowed in comments
        return comment;
    }
}
exports.SpannerDriver = SpannerDriver; //# sourceMappingURL=SpannerDriver.js.map
}}),
"[project]/node_modules/typeorm/driver/DriverFactory.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DriverFactory = void 0;
const MissingDriverError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/MissingDriverError.js [app-route] (ecmascript)");
const CockroachDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/cockroachdb/CockroachDriver.js [app-route] (ecmascript)");
const MongoDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/mongodb/MongoDriver.js [app-route] (ecmascript)");
const SqlServerDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlserver/SqlServerDriver.js [app-route] (ecmascript)");
const OracleDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/oracle/OracleDriver.js [app-route] (ecmascript)");
const SqliteDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlite/SqliteDriver.js [app-route] (ecmascript)");
const CordovaDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/cordova/CordovaDriver.js [app-route] (ecmascript)");
const ReactNativeDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/react-native/ReactNativeDriver.js [app-route] (ecmascript)");
const NativescriptDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/nativescript/NativescriptDriver.js [app-route] (ecmascript)");
const SqljsDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqljs/SqljsDriver.js [app-route] (ecmascript)");
const MysqlDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/mysql/MysqlDriver.js [app-route] (ecmascript)");
const PostgresDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/postgres/PostgresDriver.js [app-route] (ecmascript)");
const ExpoDriverFactory_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/expo/ExpoDriverFactory.js [app-route] (ecmascript)");
const AuroraMysqlDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/aurora-mysql/AuroraMysqlDriver.js [app-route] (ecmascript)");
const AuroraPostgresDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/aurora-postgres/AuroraPostgresDriver.js [app-route] (ecmascript)");
const SapDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sap/SapDriver.js [app-route] (ecmascript)");
const BetterSqlite3Driver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/better-sqlite3/BetterSqlite3Driver.js [app-route] (ecmascript)");
const CapacitorDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/capacitor/CapacitorDriver.js [app-route] (ecmascript)");
const SpannerDriver_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/spanner/SpannerDriver.js [app-route] (ecmascript)");
/**
 * Helps to create drivers.
 */ class DriverFactory {
    /**
     * Creates a new driver depend on a given connection's driver type.
     */ create(connection) {
        const { type } = connection.options;
        switch(type){
            case "mysql":
                return new MysqlDriver_1.MysqlDriver(connection);
            case "postgres":
                return new PostgresDriver_1.PostgresDriver(connection);
            case "cockroachdb":
                return new CockroachDriver_1.CockroachDriver(connection);
            case "sap":
                return new SapDriver_1.SapDriver(connection);
            case "mariadb":
                return new MysqlDriver_1.MysqlDriver(connection);
            case "sqlite":
                return new SqliteDriver_1.SqliteDriver(connection);
            case "better-sqlite3":
                return new BetterSqlite3Driver_1.BetterSqlite3Driver(connection);
            case "cordova":
                return new CordovaDriver_1.CordovaDriver(connection);
            case "nativescript":
                return new NativescriptDriver_1.NativescriptDriver(connection);
            case "react-native":
                return new ReactNativeDriver_1.ReactNativeDriver(connection);
            case "sqljs":
                return new SqljsDriver_1.SqljsDriver(connection);
            case "oracle":
                return new OracleDriver_1.OracleDriver(connection);
            case "mssql":
                return new SqlServerDriver_1.SqlServerDriver(connection);
            case "mongodb":
                return new MongoDriver_1.MongoDriver(connection);
            case "expo":
                return new ExpoDriverFactory_1.ExpoDriverFactory(connection).create();
            case "aurora-mysql":
                return new AuroraMysqlDriver_1.AuroraMysqlDriver(connection);
            case "aurora-postgres":
                return new AuroraPostgresDriver_1.AuroraPostgresDriver(connection);
            case "capacitor":
                return new CapacitorDriver_1.CapacitorDriver(connection);
            case "spanner":
                return new SpannerDriver_1.SpannerDriver(connection);
            default:
                throw new MissingDriverError_1.MissingDriverError(type, [
                    "aurora-mysql",
                    "aurora-postgres",
                    "better-sqlite3",
                    "capacitor",
                    "cockroachdb",
                    "cordova",
                    "expo",
                    "mariadb",
                    "mongodb",
                    "mssql",
                    "mysql",
                    "nativescript",
                    "oracle",
                    "postgres",
                    "react-native",
                    "sap",
                    "sqlite",
                    "sqljs",
                    "spanner"
                ]);
        }
    }
}
exports.DriverFactory = DriverFactory; //# sourceMappingURL=DriverFactory.js.map
}}),

};

//# sourceMappingURL=node_modules_typeorm_driver_61d54b0f._.js.map