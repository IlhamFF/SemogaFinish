{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"file":"Alias.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/Alias.ts"],"sourcesContent":["import { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { TypeORMError } from \"../error\"\n\n/**\n */\nexport class Alias {\n    type: \"from\" | \"select\" | \"join\" | \"other\" // todo: make something with \"other\"\n\n    name: string\n\n    /**\n     * Table on which this alias is applied.\n     * Used only for aliases which select custom tables.\n     */\n    tablePath?: string\n\n    /**\n     * If this alias is for sub query.\n     */\n    subQuery?: string\n\n    constructor(alias?: Alias) {\n        ObjectUtils.assign(this, alias || {})\n    }\n\n    private _metadata?: EntityMetadata\n\n    get target(): Function | string {\n        return this.metadata.target\n    }\n\n    get hasMetadata(): boolean {\n        return !!this._metadata\n    }\n\n    set metadata(metadata: EntityMetadata) {\n        this._metadata = metadata\n    }\n\n    get metadata(): EntityMetadata {\n        if (!this._metadata)\n            throw new TypeORMError(\n                `Cannot get entity metadata for the given alias \"${this.name}\"`,\n            )\n\n        return this._metadata\n    }\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA,+CAAiD;AACjD,MAAA,8BAAuC;AAEvC;GACG,CACH,MAAa,KAAK;IAgBd,YAAY,KAAa,CAAA;QACrB,cAAA,WAAW,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,IAAI,CAAA,CAAE,CAAC,CAAA;IACzC,CAAC;IAID,IAAI,MAAM,GAAA;QACN,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAA;IAC/B,CAAC;IAED,IAAI,WAAW,GAAA;QACX,OAAO,CAAC,CAAC,IAAI,CAAC,SAAS,CAAA;IAC3B,CAAC;IAED,IAAI,QAAQ,CAAC,QAAwB,EAAA;QACjC,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAA;IAC7B,CAAC;IAED,IAAI,QAAQ,GAAA;QACR,IAAI,CAAC,IAAI,CAAC,SAAS,EACf,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,gDAAA,EAAmD,IAAI,CAAC,IAAI,CAAA,CAAA,CAAG,CAClE,CAAA;QAEL,OAAO,IAAI,CAAC,SAAS,CAAA;IACzB,CAAC;CACJ;AA1CD,QAAA,KAAA,GAAA,MA0CC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"file":"QueryBuilderUtils.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/QueryBuilderUtils.ts"],"sourcesContent":["/**\n * Helper utility functions for QueryBuilder.\n */\nexport class QueryBuilderUtils {\n    /**\n     * Checks if given value is a string representation of alias property,\n     * e.g. \"post.category\" or \"post.id\".\n     */\n    static isAliasProperty(str: any): str is string {\n        // alias property must be a string and must have a dot separator\n        if (typeof str !== \"string\" || str.indexOf(\".\") === -1) return false\n\n        // extra alias and its property relation\n        const [aliasName, propertyName] = str.split(\".\") // todo: what about relations in embedded?\n        if (!aliasName || !propertyName) return false\n\n        // alias and property must be represented in a special format\n        // const aliasNameRegexp = /^[a-zA-Z0-9_-]+$/;\n        // if (!aliasNameRegexp.test(aliasName) || !aliasNameRegexp.test(propertyName))\n        //     return false;\n        // make sure string is not a subquery\n        if (str.indexOf(\"(\") !== -1 || str.indexOf(\")\") !== -1) return false\n\n        return true\n    }\n}\n"],"names":[],"mappings":";;;;;AAAA;;GAEG,CACH,MAAa,iBAAiB;IAC1B;;;OAGG,CACH,MAAM,CAAC,eAAe,CAAC,GAAQ,EAAA;QAC3B,gEAAgE;QAChE,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,KAAK,CAAA;QAEpE,wCAAwC;QACxC,MAAM,CAAC,SAAS,EAAE,YAAY,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA,CAAC,0CAA0C;QAC3F,IAAI,CAAC,SAAS,IAAI,CAAC,YAAY,EAAE,OAAO,KAAK,CAAA;QAE7C,6DAA6D;QAC7D,8CAA8C;QAC9C,+EAA+E;QAC/E,oBAAoB;QACpB,qCAAqC;QACrC,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,KAAK,CAAA;QAEpE,OAAO,IAAI,CAAA;IACf,CAAC;CACJ;AAtBD,QAAA,iBAAA,GAAA,kBAsBC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"file":"JoinAttribute.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/JoinAttribute.ts"],"sourcesContent":["import { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { QueryBuilderUtils } from \"./QueryBuilderUtils\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { Alias } from \"./Alias\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { TypeORMError } from \"../error\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Stores all join attributes which will be used to build a JOIN query.\n */\nexport class JoinAttribute {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Join direction.\n     */\n    direction: \"LEFT\" | \"INNER\"\n\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias: Alias\n\n    /**\n     * Joined table, entity target, or relation in \"post.category\" format.\n     */\n    entityOrProperty: Function | string\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    condition?: string\n\n    /**\n     * Property + alias of the object where to joined data should be mapped.\n     */\n    mapToProperty?: string\n\n    /**\n     * Indicates if user maps one or many objects from the join.\n     */\n    isMappingMany?: boolean\n\n    /**\n     * Useful when the joined expression is a custom query to support mapping.\n     */\n    mapAsEntity?: Function | string\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        private connection: DataSource,\n        private queryExpressionMap: QueryExpressionMap,\n        joinAttribute?: JoinAttribute,\n    ) {\n        if (joinAttribute) {\n            ObjectUtils.assign(this, joinAttribute)\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    get isMany(): boolean {\n        if (this.isMappingMany !== undefined) return this.isMappingMany\n\n        if (this.relation)\n            return this.relation.isManyToMany || this.relation.isOneToMany\n\n        return false\n    }\n\n    isSelectedCache: boolean\n    isSelectedEvaluated: boolean = false\n    /**\n     * Indicates if this join is selected.\n     */\n    get isSelected(): boolean {\n        if (!this.isSelectedEvaluated) {\n            const getValue = () => {\n                for (const select of this.queryExpressionMap.selects) {\n                    if (select.selection === this.alias.name) return true\n\n                    if (\n                        this.metadata &&\n                        !!this.metadata.columns.find(\n                            (column) =>\n                                select.selection ===\n                                this.alias.name + \".\" + column.propertyPath,\n                        )\n                    )\n                        return true\n                }\n\n                return false\n            }\n            this.isSelectedCache = getValue()\n            this.isSelectedEvaluated = true\n        }\n        return this.isSelectedCache\n    }\n\n    /**\n     * Name of the table which we should join.\n     */\n    get tablePath(): string {\n        return this.metadata\n            ? this.metadata.tablePath\n            : (this.entityOrProperty as string)\n    }\n\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias(): string | undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n            return undefined\n\n        return this.entityOrProperty.substr(\n            0,\n            this.entityOrProperty.indexOf(\".\"),\n        )\n    }\n\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationPropertyPath(): string | undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n            return undefined\n\n        return this.entityOrProperty.substr(\n            this.entityOrProperty.indexOf(\".\") + 1,\n        )\n    }\n\n    relationCache: RelationMetadata | undefined\n    relationEvaluated: boolean = false\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     * Relation can be undefined if entityOrProperty is regular entity or custom table.\n     */\n    get relation(): RelationMetadata | undefined {\n        if (!this.relationEvaluated) {\n            const getValue = () => {\n                if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n                    return undefined\n\n                const relationOwnerSelection =\n                    this.queryExpressionMap.findAliasByName(this.parentAlias!)\n                let relation =\n                    relationOwnerSelection.metadata.findRelationWithPropertyPath(\n                        this.relationPropertyPath!,\n                    )\n\n                if (relation) {\n                    return relation\n                }\n\n                if (relationOwnerSelection.metadata.parentEntityMetadata) {\n                    relation =\n                        relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(\n                            this.relationPropertyPath!,\n                        )\n                    if (relation) {\n                        return relation\n                    }\n                }\n\n                throw new TypeORMError(\n                    `Relation with property path ${this.relationPropertyPath} in entity was not found.`,\n                )\n            }\n            this.relationCache = getValue.bind(this)()\n            this.relationEvaluated = true\n        }\n        return this.relationCache\n    }\n\n    /**\n     * Metadata of the joined entity.\n     * If table without entity was joined, then it will return undefined.\n     */\n    get metadata(): EntityMetadata | undefined {\n        // entityOrProperty is relation, e.g. \"post.category\"\n        if (this.relation) return this.relation.inverseEntityMetadata\n\n        // entityOrProperty is Entity class\n        if (this.connection.hasMetadata(this.entityOrProperty))\n            return this.connection.getMetadata(this.entityOrProperty)\n\n        // Overriden mapping entity provided for leftJoinAndMapOne with custom query builder\n        if (this.mapAsEntity && this.connection.hasMetadata(this.mapAsEntity)) {\n            return this.connection.getMetadata(this.mapAsEntity)\n        }\n\n        return undefined\n\n        /*if (typeof this.entityOrProperty === \"string\") { // entityOrProperty is a custom table\n\n            // first try to find entity with such name, this is needed when entity does not have a target class,\n            // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)\n            const metadata = this.connection.entityMetadatas.find(metadata => metadata.name === this.entityOrProperty);\n            if (metadata)\n                return metadata;\n\n            // check if we have entity with such table name, and use its metadata if found\n            return this.connection.entityMetadatas.find(metadata => metadata.tableName === this.entityOrProperty);\n        }*/\n    }\n\n    /**\n     * Generates alias of junction table, whose ids we get.\n     */\n    get junctionAlias(): string {\n        if (!this.relation) {\n            throw new TypeORMError(\n                `Cannot get junction table for join without relation.`,\n            )\n        }\n        if (typeof this.entityOrProperty !== \"string\") {\n            throw new TypeORMError(`Junction property is not defined.`)\n        }\n\n        const aliasProperty = this.entityOrProperty.substr(\n            0,\n            this.entityOrProperty.indexOf(\".\"),\n        )\n\n        if (this.relation.isOwning) {\n            return DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                aliasProperty,\n                this.alias.name,\n            )\n        } else {\n            return DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                this.alias.name,\n                aliasProperty,\n            )\n        }\n    }\n\n    get mapToPropertyParentAlias(): string | undefined {\n        if (!this.mapToProperty) return undefined\n\n        return this.mapToProperty!.split(\".\")[0]\n    }\n\n    get mapToPropertyPropertyName(): string | undefined {\n        if (!this.mapToProperty) return undefined\n\n        return this.mapToProperty!.split(\".\")[1]\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 224, "column": 0}, "map": {"version":3,"file":"RelationIdAttribute.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/relation-id/RelationIdAttribute.ts"],"sourcesContent":["import { RelationMetadata } from \"../../metadata/RelationMetadata\"\nimport { QueryBuilderUtils } from \"../QueryBuilderUtils\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { QueryExpressionMap } from \"../QueryExpressionMap\"\nimport { SelectQueryBuilder } from \"../SelectQueryBuilder\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\nimport { TypeORMError } from \"../../error/TypeORMError\"\n\n/**\n * Stores all join relation id attributes which will be used to build a JOIN query.\n */\nexport class RelationIdAttribute {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias?: string\n\n    /**\n     * Name of relation.\n     */\n    relationName: string\n\n    /**\n     * Property + alias of the object where to joined data should be mapped.\n     */\n    mapToProperty: string\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    queryBuilderFactory?: (\n        qb: SelectQueryBuilder<any>,\n    ) => SelectQueryBuilder<any>\n\n    /**\n     * Indicates if relation id should NOT be loaded as id map.\n     */\n    disableMixedMap = false\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        private queryExpressionMap: QueryExpressionMap,\n        relationIdAttribute?: Partial<RelationIdAttribute>,\n    ) {\n        ObjectUtils.assign(this, relationIdAttribute || {})\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    get joinInverseSideMetadata(): EntityMetadata {\n        return this.relation.inverseEntityMetadata\n    }\n\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias(): string {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value must be a string representation of alias property`,\n            )\n\n        return this.relationName.substr(0, this.relationName.indexOf(\".\"))\n    }\n\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationPropertyPath(): string {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value must be a string representation of alias property`,\n            )\n\n        return this.relationName.substr(this.relationName.indexOf(\".\") + 1)\n    }\n\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relation(): RelationMetadata {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value must be a string representation of alias property`,\n            )\n\n        const relationOwnerSelection = this.queryExpressionMap.findAliasByName(\n            this.parentAlias!,\n        )\n        const relation =\n            relationOwnerSelection.metadata.findRelationWithPropertyPath(\n                this.relationPropertyPath!,\n            )\n        if (!relation)\n            throw new TypeORMError(\n                `Relation with property path ${this.relationPropertyPath} in entity was not found.`,\n            )\n        return relation\n    }\n\n    /**\n     * Generates alias of junction table, whose ids we get.\n     */\n    get junctionAlias(): string {\n        const [parentAlias, relationProperty] = this.relationName.split(\".\")\n        return parentAlias + \"_\" + relationProperty + \"_rid\"\n    }\n\n    /**\n     * Metadata of the joined entity.\n     * If extra condition without entity was joined, then it will return undefined.\n     */\n    get junctionMetadata(): EntityMetadata {\n        return this.relation.junctionEntityMetadata!\n    }\n\n    get mapToPropertyParentAlias(): string {\n        return this.mapToProperty.substr(0, this.mapToProperty.indexOf(\".\"))\n    }\n\n    get mapToPropertyPropertyPath(): string {\n        return this.mapToProperty.substr(this.mapToProperty.indexOf(\".\") + 1)\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 306, "column": 0}, "map": {"version":3,"file":"RelationCountAttribute.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/relation-count/RelationCountAttribute.ts"],"sourcesContent":["import { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { QueryBuilderUtils } from \"../QueryBuilderUtils\"\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\nimport { QueryExpressionMap } from \"../QueryExpressionMap\"\nimport { SelectQueryBuilder } from \"../SelectQueryBuilder\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\nimport { TypeORMError } from \"../../error/TypeORMError\"\n\nexport class RelationCountAttribute {\n    /**\n     * Alias of the joined (destination) table.\n     */\n    alias?: string\n\n    /**\n     * Name of relation.\n     */\n    relationName: string\n\n    /**\n     * Property + alias of the object where to joined data should be mapped.\n     */\n    mapToProperty: string\n\n    /**\n     * Extra condition applied to \"ON\" section of join.\n     */\n    queryBuilderFactory?: (\n        qb: SelectQueryBuilder<any>,\n    ) => SelectQueryBuilder<any>\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        private expressionMap: QueryExpressionMap,\n        relationCountAttribute?: Partial<RelationCountAttribute>,\n    ) {\n        ObjectUtils.assign(this, relationCountAttribute || {})\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    get joinInverseSideMetadata(): EntityMetadata {\n        return this.relation.inverseEntityMetadata\n    }\n\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias(): string {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value must be a string representation of alias property`,\n            )\n\n        return this.relationName.split(\".\")[0]\n    }\n\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationProperty(): string | undefined {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value is a string representation of alias property`,\n            )\n\n        return this.relationName.split(\".\")[1]\n    }\n\n    get junctionAlias(): string {\n        const [parentAlias, relationProperty] = this.relationName.split(\".\")\n        return parentAlias + \"_\" + relationProperty + \"_rc\"\n    }\n\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relation(): RelationMetadata {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value is a string representation of alias property`,\n            )\n\n        const [parentAlias, propertyPath] = this.relationName.split(\".\")\n        const relationOwnerSelection =\n            this.expressionMap.findAliasByName(parentAlias)\n        const relation =\n            relationOwnerSelection.metadata.findRelationWithPropertyPath(\n                propertyPath,\n            )\n        if (!relation)\n            throw new TypeORMError(\n                `Relation with property path ${propertyPath} in entity was not found.`,\n            )\n        return relation\n    }\n\n    /**\n     * Metadata of the joined entity.\n     * If table without entity was joined, then it will return undefined.\n     */\n    get metadata(): EntityMetadata {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(\n                `Given value is a string representation of alias property`,\n            )\n\n        const parentAlias = this.relationName.split(\".\")[0]\n        const selection = this.expressionMap.findAliasByName(parentAlias)\n        return selection.metadata\n    }\n\n    get mapToPropertyPropertyName(): string {\n        return this.mapToProperty!.split(\".\")[1]\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"file":"QueryExpressionMap.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/QueryExpressionMap.ts"],"sourcesContent":["import { Alias } from \"./Alias\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { JoinAttribute } from \"./JoinAttribute\"\nimport { QueryBuilder } from \"./QueryBuilder\"\nimport { QueryBuilderCteOptions } from \"./QueryBuilderCte\"\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\"\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { SelectQuery } from \"./SelectQuery\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { SelectQueryBuilderOption } from \"./SelectQueryBuilderOption\"\nimport { TypeORMError } from \"../error\"\nimport { WhereClause } from \"./WhereClause\"\nimport { UpsertType } from \"../driver/types/UpsertType\"\nimport { CockroachConnectionOptions } from \"../driver/cockroachdb/CockroachConnectionOptions\"\n\n/**\n * Contains all properties of the QueryBuilder that needs to be build a final query.\n */\nexport class QueryExpressionMap {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Strategy to load relations.\n     */\n    relationLoadStrategy: \"join\" | \"query\" = \"join\"\n\n    /**\n     * Indicates if QueryBuilder used to select entities and not a raw results.\n     */\n    queryEntity: boolean = false\n\n    /**\n     * Main alias is a main selection object selected by QueryBuilder.\n     */\n    mainAlias?: Alias\n\n    /**\n     * All aliases (including main alias) used in the query.\n     */\n    aliases: Alias[] = []\n\n    /**\n     * Represents query type. QueryBuilder is able to build SELECT, UPDATE and DELETE queries.\n     */\n    queryType:\n        | \"select\"\n        | \"update\"\n        | \"delete\"\n        | \"insert\"\n        | \"relation\"\n        | \"soft-delete\"\n        | \"restore\" = \"select\"\n\n    /**\n     * Data needs to be SELECT-ed.\n     */\n    selects: SelectQuery[] = []\n\n    /**\n     * Max execution time in millisecond.\n     */\n    maxExecutionTime: number = 0\n\n    /**\n     * Whether SELECT is DISTINCT.\n     */\n    selectDistinct: boolean = false\n\n    /**\n     * SELECT DISTINCT ON query (postgres).\n     */\n    selectDistinctOn: string[] = []\n\n    /**\n     * FROM-s to be selected.\n     */\n    // froms: { target: string, alias: string }[] = [];\n\n    /**\n     * If update query was used, it needs \"update set\" - properties which will be updated by this query.\n     * If insert query was used, it needs \"insert set\" - values that needs to be inserted.\n     */\n    valuesSet?: ObjectLiteral | ObjectLiteral[]\n\n    /**\n     * Optional returning (or output) clause for insert, update or delete queries.\n     */\n    returning: string | string[]\n\n    /**\n     * Extra returning columns to be added to the returning statement if driver supports it.\n     */\n    extraReturningColumns: ColumnMetadata[] = []\n\n    /**\n     * Optional on conflict statement used in insertion query in postgres.\n     */\n    onConflict: string = \"\"\n\n    /**\n     * Optional on ignore statement used in insertion query in databases.\n     */\n    onIgnore: boolean = false\n\n    /**\n     * Optional on update statement used in insertion query in databases.\n     */\n    onUpdate: {\n        conflict?: string | string[]\n        columns?: string[]\n        overwrite?: string[]\n        skipUpdateIfNoValuesChanged?: boolean\n        indexPredicate?: string\n        upsertType?: UpsertType\n    }\n\n    /**\n     * JOIN queries.\n     */\n    joinAttributes: JoinAttribute[] = []\n\n    /**\n     * RelationId queries.\n     */\n    relationIdAttributes: RelationIdAttribute[] = []\n\n    /**\n     * Relation count queries.\n     */\n    relationCountAttributes: RelationCountAttribute[] = []\n\n    /**\n     * WHERE queries.\n     */\n    wheres: WhereClause[] = []\n\n    /**\n     * HAVING queries.\n     */\n    havings: { type: \"simple\" | \"and\" | \"or\"; condition: string }[] = []\n\n    /**\n     * ORDER BY queries.\n     */\n    orderBys: OrderByCondition = {}\n\n    /**\n     * GROUP BY queries.\n     */\n    groupBys: string[] = []\n\n    /**\n     * LIMIT query.\n     */\n    limit?: number\n\n    /**\n     * OFFSET query.\n     */\n    offset?: number\n\n    /**\n     * Number of rows to skip of result using pagination.\n     */\n    skip?: number\n\n    /**\n     * Number of rows to take using pagination.\n     */\n    take?: number\n\n    /**\n     * Use certain index for the query.\n     *\n     * SELECT * FROM table_name USE INDEX (col1_index, col2_index) WHERE col1=1 AND col2=2 AND col3=3;\n     */\n    useIndex?: string\n\n    /**\n     * Locking mode.\n     */\n    lockMode?:\n        | \"optimistic\"\n        | \"pessimistic_read\"\n        | \"pessimistic_write\"\n        | \"dirty_read\"\n        /*\n            \"pessimistic_partial_write\" and \"pessimistic_write_or_fail\" are deprecated and\n            will be removed in a future version.\n\n            Use onLocked instead.\n         */\n        | \"pessimistic_partial_write\"\n        | \"pessimistic_write_or_fail\"\n        | \"for_no_key_update\"\n        | \"for_key_share\"\n\n    /**\n     * Current version of the entity, used for locking.\n     */\n    lockVersion?: number | Date\n\n    /**\n     * Tables to be specified in the \"FOR UPDATE OF\" clause, referred by their alias\n     */\n    lockTables?: string[]\n\n    /**\n     * Modify behavior when encountering locked rows. NOWAIT or SKIP LOCKED\n     */\n    onLocked?: \"nowait\" | \"skip_locked\"\n\n    /**\n     * Indicates if soft-deleted rows should be included in entity result.\n     * By default the soft-deleted rows are not included.\n     */\n    withDeleted: boolean = false\n\n    /**\n     * Parameters used to be escaped in final query.\n     */\n    parameters: ObjectLiteral = {}\n\n    /**\n     * Indicates if alias, table names and column names will be escaped by driver, or not.\n     *\n     * todo: rename to isQuotingDisabled, also think if it should be named \"escaping\"\n     */\n    disableEscaping: boolean = true\n\n    /**\n     * Indicates if virtual columns should be included in entity result.\n     *\n     * todo: what to do with it? is it properly used? what about persistence?\n     */\n    enableRelationIdValues: boolean = false\n\n    /**\n     * Extra where condition appended to the end of original where conditions with AND keyword.\n     * Original condition will be wrapped into brackets.\n     */\n    extraAppendedAndWhereCondition: string = \"\"\n\n    /**\n     * Indicates if query builder creates a subquery.\n     */\n    subQuery: boolean = false\n\n    /**\n     * Indicates if property names are prefixed with alias names during property replacement.\n     * By default this is enabled, however we need this because aliases are not supported in UPDATE and DELETE queries,\n     * but user can use them in WHERE expressions.\n     */\n    aliasNamePrefixingEnabled: boolean = true\n\n    /**\n     * Indicates if query result cache is enabled or not.\n     * It is undefined by default to avoid overriding the `alwaysEnabled` config\n     */\n    cache?: boolean\n\n    /**\n     * Time in milliseconds in which cache will expire.\n     * If not set then global caching time will be used.\n     */\n    cacheDuration: number\n\n    /**\n     * Cache id.\n     * Used to identifier your cache queries.\n     */\n    cacheId: string\n\n    /**\n     * Options that define QueryBuilder behaviour.\n     */\n    options: SelectQueryBuilderOption[] = []\n\n    /**\n     * Property path of relation to work with.\n     * Used in relational query builder.\n     */\n    relationPropertyPath: string\n\n    /**\n     * Entity (target) which relations will be updated.\n     */\n    of: any | any[]\n\n    /**\n     * List of columns where data should be inserted.\n     * Used in INSERT query.\n     */\n    insertColumns: string[] = []\n\n    /**\n     * Used if user wants to update or delete a specific entities.\n     */\n    whereEntities: ObjectLiteral[] = []\n\n    /**\n     * Indicates if entity must be updated after insertion / updation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     */\n    updateEntity: boolean = true\n\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     */\n    callListeners: boolean = true\n\n    /**\n     * Indicates if query must be wrapped into transaction.\n     */\n    useTransaction: boolean = false\n\n    /**\n     * Indicates if query should be time travel query\n     * https://www.cockroachlabs.com/docs/stable/as-of-system-time.html\n     */\n    timeTravel?: boolean | string\n\n    /**\n     * Extra parameters.\n     *\n     * @deprecated Use standard parameters instead\n     */\n    nativeParameters: ObjectLiteral = {}\n\n    /**\n     * Query Comment to include extra information for debugging or other purposes.\n     */\n    comment?: string\n\n    /**\n     * Items from an entity that have been locally generated & are recorded here for later use.\n     * Examples include the UUID generation when the database does not natively support it.\n     * These are included in the entity index order.\n     */\n    locallyGenerated: { [key: number]: ObjectLiteral } = {}\n\n    commonTableExpressions: {\n        queryBuilder: QueryBuilder<any> | string\n        alias: string\n        options: QueryBuilderCteOptions\n    }[] = []\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: DataSource) {\n        if (connection.options.relationLoadStrategy) {\n            this.relationLoadStrategy = connection.options.relationLoadStrategy\n        }\n\n        this.timeTravel =\n            (connection.options as CockroachConnectionOptions)\n                ?.timeTravelQueries || false\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Get all ORDER BY queries - if order by is specified by user then it uses them,\n     * otherwise it uses default entity order by if it was set.\n     */\n    get allOrderBys() {\n        if (\n            !Object.keys(this.orderBys).length &&\n            this.mainAlias!.hasMetadata &&\n            this.options.indexOf(\"disable-global-order\") === -1\n        ) {\n            const entityOrderBy = this.mainAlias!.metadata.orderBy || {}\n            return Object.keys(entityOrderBy).reduce((orderBy, key) => {\n                orderBy[this.mainAlias!.name + \".\" + key] = entityOrderBy[key]\n                return orderBy\n            }, {} as OrderByCondition)\n        }\n\n        return this.orderBys\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a main alias and adds it to the current expression map.\n     */\n    setMainAlias(alias: Alias): Alias {\n        // if main alias is already set then remove it from the array\n        // if (this.mainAlias)\n        //     this.aliases.splice(this.aliases.indexOf(this.mainAlias));\n\n        // set new main alias\n        this.mainAlias = alias\n\n        return alias\n    }\n\n    /**\n     * Creates a new alias and adds it to the current expression map.\n     */\n    createAlias(options: {\n        type: \"from\" | \"select\" | \"join\" | \"other\"\n        name?: string\n        target?: Function | string\n        tablePath?: string\n        subQuery?: string\n        metadata?: EntityMetadata\n    }): Alias {\n        let aliasName = options.name\n        if (!aliasName && options.tablePath) aliasName = options.tablePath\n        if (!aliasName && typeof options.target === \"function\")\n            aliasName = options.target.name\n        if (!aliasName && typeof options.target === \"string\")\n            aliasName = options.target\n\n        const alias = new Alias()\n        alias.type = options.type\n        if (aliasName) alias.name = aliasName\n        if (options.metadata) alias.metadata = options.metadata\n        if (options.target && !alias.hasMetadata)\n            alias.metadata = this.connection.getMetadata(options.target)\n        if (options.tablePath) alias.tablePath = options.tablePath\n        if (options.subQuery) alias.subQuery = options.subQuery\n\n        this.aliases.push(alias)\n        return alias\n    }\n\n    /**\n     * Finds alias with the given name.\n     * If alias was not found it throw an exception.\n     */\n    findAliasByName(aliasName: string): Alias {\n        const alias = this.aliases.find((alias) => alias.name === aliasName)\n        if (!alias)\n            throw new TypeORMError(\n                `\"${aliasName}\" alias was not found. Maybe you forgot to join it?`,\n            )\n\n        return alias\n    }\n\n    findColumnByAliasExpression(\n        aliasExpression: string,\n    ): ColumnMetadata | undefined {\n        const [aliasName, propertyPath] = aliasExpression.split(\".\")\n        const alias = this.findAliasByName(aliasName)\n        return alias.metadata.findColumnWithPropertyName(propertyPath)\n    }\n\n    /**\n     * Gets relation metadata of the relation this query builder works with.\n     *\n     * todo: add proper exceptions\n     */\n    get relationMetadata(): RelationMetadata {\n        if (!this.mainAlias)\n            throw new TypeORMError(`Entity to work with is not specified!`) // todo: better message\n\n        const relationMetadata =\n            this.mainAlias.metadata.findRelationWithPropertyPath(\n                this.relationPropertyPath,\n            )\n        if (!relationMetadata)\n            throw new TypeORMError(\n                `Relation ${this.relationPropertyPath} was not found in entity ${this.mainAlias.name}`,\n            ) // todo: better message\n\n        return relationMetadata\n    }\n\n    /**\n     * Copies all properties of the current QueryExpressionMap into a new one.\n     * Useful when QueryBuilder needs to create a copy of itself.\n     */\n    clone(): QueryExpressionMap {\n        const map = new QueryExpressionMap(this.connection)\n        map.queryType = this.queryType\n        map.selects = this.selects.map((select) => select)\n        map.maxExecutionTime = this.maxExecutionTime\n        map.selectDistinct = this.selectDistinct\n        map.selectDistinctOn = this.selectDistinctOn\n        this.aliases.forEach((alias) => map.aliases.push(new Alias(alias)))\n        map.relationLoadStrategy = this.relationLoadStrategy\n        map.mainAlias = this.mainAlias\n        map.valuesSet = this.valuesSet\n        map.returning = this.returning\n        map.onConflict = this.onConflict\n        map.onIgnore = this.onIgnore\n        map.onUpdate = this.onUpdate\n        map.joinAttributes = this.joinAttributes.map(\n            (join) => new JoinAttribute(this.connection, this, join),\n        )\n        map.relationIdAttributes = this.relationIdAttributes.map(\n            (relationId) => new RelationIdAttribute(this, relationId),\n        )\n        map.relationCountAttributes = this.relationCountAttributes.map(\n            (relationCount) => new RelationCountAttribute(this, relationCount),\n        )\n        map.wheres = this.wheres.map((where) => ({ ...where }))\n        map.havings = this.havings.map((having) => ({ ...having }))\n        map.orderBys = Object.assign({}, this.orderBys)\n        map.groupBys = this.groupBys.map((groupBy) => groupBy)\n        map.limit = this.limit\n        map.offset = this.offset\n        map.skip = this.skip\n        map.take = this.take\n        map.lockMode = this.lockMode\n        map.onLocked = this.onLocked\n        map.lockVersion = this.lockVersion\n        map.lockTables = this.lockTables\n        map.withDeleted = this.withDeleted\n        map.parameters = Object.assign({}, this.parameters)\n        map.disableEscaping = this.disableEscaping\n        map.enableRelationIdValues = this.enableRelationIdValues\n        map.extraAppendedAndWhereCondition = this.extraAppendedAndWhereCondition\n        map.subQuery = this.subQuery\n        map.aliasNamePrefixingEnabled = this.aliasNamePrefixingEnabled\n        map.cache = this.cache\n        map.cacheId = this.cacheId\n        map.cacheDuration = this.cacheDuration\n        map.relationPropertyPath = this.relationPropertyPath\n        map.of = this.of\n        map.insertColumns = this.insertColumns\n        map.whereEntities = this.whereEntities\n        map.updateEntity = this.updateEntity\n        map.callListeners = this.callListeners\n        map.useTransaction = this.useTransaction\n        map.timeTravel = this.timeTravel\n        map.nativeParameters = Object.assign({}, this.nativeParameters)\n        map.comment = this.comment\n        map.commonTableExpressions = this.commonTableExpressions.map(\n            (cteOptions) => ({\n                alias: cteOptions.alias,\n                queryBuilder:\n                    typeof cteOptions.queryBuilder === \"string\"\n                        ? cteOptions.queryBuilder\n                        : cteOptions.queryBuilder.clone(),\n                options: cteOptions.options,\n            }),\n        )\n        return map\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 662, "column": 0}, "map": {"version":3,"file":"Brackets.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/Brackets.ts"],"sourcesContent":["import { WhereExpressionBuilder } from \"./WhereExpressionBuilder\"\n\n/**\n * Syntax sugar.\n * Allows to use brackets in WHERE expressions for better syntax.\n */\nexport class Brackets {\n    readonly \"@instanceof\" = Symbol.for(\"Brackets\")\n\n    /**\n     * WHERE expression that will be taken into brackets.\n     */\n    whereFactory: (qb: WhereExpressionBuilder) => any\n\n    /**\n     * Given WHERE query builder that will build a WHERE expression that will be taken into brackets.\n     */\n    constructor(whereFactory: (qb: WhereExpressionBuilder) => any) {\n        this.whereFactory = whereFactory\n    }\n}\n"],"names":[],"mappings":";;;;;AAEA;;;GAGG,CACH,MAAa,QAAQ;IAQjB;;OAEG,CACH,YAAY,YAAiD,CAAA;QAVpD,IAAA,CAAA,cAAa,GAAG,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,CAAA;QAW3C,IAAI,CAAC,YAAY,GAAG,YAAY,CAAA;IACpC,CAAC;CACJ;AAdD,QAAA,QAAA,GAAA,SAcC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 684, "column": 0}, "map": {"version":3,"file":"QueryBuilder.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/QueryBuilder.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { QueryBuilderCteOptions } from \"./QueryBuilderCte\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { SelectQueryBuilder } from \"./SelectQueryBuilder\"\nimport { UpdateQueryBuilder } from \"./UpdateQueryBuilder\"\nimport { DeleteQueryBuilder } from \"./DeleteQueryBuilder\"\nimport { SoftDeleteQueryBuilder } from \"./SoftDeleteQueryBuilder\"\nimport { InsertQueryBuilder } from \"./InsertQueryBuilder\"\nimport { RelationQueryBuilder } from \"./RelationQueryBuilder\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { Alias } from \"./Alias\"\nimport { Brackets } from \"./Brackets\"\nimport { QueryDeepPartialEntity } from \"./QueryPartialEntity\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { FindOperator } from \"../find-options/FindOperator\"\nimport { In } from \"../find-options/operator/In\"\nimport { TypeORMError } from \"../error\"\nimport { WhereClause, WhereClauseCondition } from \"./WhereClause\"\nimport { NotBrackets } from \"./NotBrackets\"\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\nimport { ReturningType } from \"../driver/Driver\"\nimport { OracleDriver } from \"../driver/oracle/OracleDriver\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\nimport { escapeRegExp } from \"../util/escapeRegExp\"\n\n// todo: completely cover query builder with tests\n// todo: entityOrProperty can be target name. implement proper behaviour if it is.\n// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)\n// todo: fix problem with long aliases eg getMaxIdentifierLength\n// todo: fix replacing in .select(\"COUNT(post.id) AS cnt\") statement\n// todo: implement joinAlways in relations and relationId\n// todo: finish partial selection\n// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...\n// todo: implement @Select decorator\n// todo: add select and map functions\n\n// todo: implement relation/entity loading and setting them into properties within a separate query\n// .loadAndMap(\"post.categories\", \"post.categories\", qb => ...)\n// .loadAndMap(\"post.categories\", Category, qb => ...)\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport abstract class QueryBuilder<Entity extends ObjectLiteral> {\n    readonly \"@instanceof\" = Symbol.for(\"QueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Connection on which QueryBuilder was created.\n     */\n    readonly connection: DataSource\n\n    /**\n     * Contains all properties of the QueryBuilder that needs to be build a final query.\n     */\n    readonly expressionMap: QueryExpressionMap\n\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Query runner used to execute query builder query.\n     */\n    protected queryRunner?: QueryRunner\n\n    /**\n     * If QueryBuilder was created in a subquery mode then its parent QueryBuilder (who created subquery) will be stored here.\n     */\n    protected parentQueryBuilder: QueryBuilder<any>\n\n    /**\n     * Memo to help keep place of current parameter index for `createParameter`\n     */\n    private parameterIndex = 0\n\n    /**\n     * Contains all registered query builder classes.\n     */\n    private static queryBuilderRegistry: Record<string, any> = {}\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(queryBuilder: QueryBuilder<any>)\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(connection: DataSource, queryRunner?: QueryRunner)\n\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(\n        connectionOrQueryBuilder: DataSource | QueryBuilder<any>,\n        queryRunner?: QueryRunner,\n    ) {\n        if (InstanceChecker.isDataSource(connectionOrQueryBuilder)) {\n            this.connection = connectionOrQueryBuilder\n            this.queryRunner = queryRunner\n            this.expressionMap = new QueryExpressionMap(this.connection)\n        } else {\n            this.connection = connectionOrQueryBuilder.connection\n            this.queryRunner = connectionOrQueryBuilder.queryRunner\n            this.expressionMap = connectionOrQueryBuilder.expressionMap.clone()\n        }\n    }\n\n    static registerQueryBuilderClass(name: string, factory: any) {\n        QueryBuilder.queryBuilderRegistry[name] = factory\n    }\n\n    // -------------------------------------------------------------------------\n    // Abstract Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    abstract getQuery(): string\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets the main alias string used in this query builder.\n     */\n    get alias(): string {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(`Main alias is not set`) // todo: better exception\n\n        return this.expressionMap.mainAlias.name\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(): SelectQueryBuilder<Entity>\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection: string,\n        selectionAliasName?: string,\n    ): SelectQueryBuilder<Entity>\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string[]): SelectQueryBuilder<Entity>\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection?: string | string[],\n        selectionAliasName?: string,\n    ): SelectQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"select\"\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map((selection) => ({\n                selection: selection,\n            }))\n        } else if (selection) {\n            this.expressionMap.selects = [\n                { selection: selection, aliasName: selectionAliasName },\n            ]\n        }\n\n        if (InstanceChecker.isSelectQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"SelectQueryBuilder\"](this)\n    }\n\n    /**\n     * Creates INSERT query.\n     */\n    insert(): InsertQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"insert\"\n\n        if (InstanceChecker.isInsertQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"InsertQueryBuilder\"](this)\n    }\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(): UpdateQueryBuilder<Entity>\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(\n        updateSet: QueryDeepPartialEntity<Entity>,\n    ): UpdateQueryBuilder<Entity>\n\n    /**\n     * Creates UPDATE query for the given entity and applies given update values.\n     */\n    update<Entity extends ObjectLiteral>(\n        entity: EntityTarget<Entity>,\n        updateSet?: QueryDeepPartialEntity<Entity>,\n    ): UpdateQueryBuilder<Entity>\n\n    /**\n     * Creates UPDATE query for the given table name and applies given update values.\n     */\n    update(\n        tableName: string,\n        updateSet?: QueryDeepPartialEntity<Entity>,\n    ): UpdateQueryBuilder<Entity>\n\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(\n        entityOrTableNameUpdateSet?: EntityTarget<any> | ObjectLiteral,\n        maybeUpdateSet?: ObjectLiteral,\n    ): UpdateQueryBuilder<any> {\n        const updateSet = maybeUpdateSet\n            ? maybeUpdateSet\n            : (entityOrTableNameUpdateSet as ObjectLiteral | undefined)\n        entityOrTableNameUpdateSet = InstanceChecker.isEntitySchema(\n            entityOrTableNameUpdateSet,\n        )\n            ? entityOrTableNameUpdateSet.options.name\n            : entityOrTableNameUpdateSet\n\n        if (\n            typeof entityOrTableNameUpdateSet === \"function\" ||\n            typeof entityOrTableNameUpdateSet === \"string\"\n        ) {\n            const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet)\n            this.expressionMap.setMainAlias(mainAlias)\n        }\n\n        this.expressionMap.queryType = \"update\"\n        this.expressionMap.valuesSet = updateSet\n\n        if (InstanceChecker.isUpdateQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"UpdateQueryBuilder\"](this)\n    }\n\n    /**\n     * Creates DELETE query.\n     */\n    delete(): DeleteQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"delete\"\n\n        if (InstanceChecker.isDeleteQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"DeleteQueryBuilder\"](this)\n    }\n\n    softDelete(): SoftDeleteQueryBuilder<any> {\n        this.expressionMap.queryType = \"soft-delete\"\n\n        if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"SoftDeleteQueryBuilder\"](this)\n    }\n\n    restore(): SoftDeleteQueryBuilder<any> {\n        this.expressionMap.queryType = \"restore\"\n\n        if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"SoftDeleteQueryBuilder\"](this)\n    }\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation(propertyPath: string): RelationQueryBuilder<Entity>\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        propertyPath: string,\n    ): RelationQueryBuilder<T>\n\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation(\n        entityTargetOrPropertyPath: Function | string,\n        maybePropertyPath?: string,\n    ): RelationQueryBuilder<Entity> {\n        const entityTarget =\n            arguments.length === 2 ? entityTargetOrPropertyPath : undefined\n        const propertyPath =\n            arguments.length === 2\n                ? (maybePropertyPath as string)\n                : (entityTargetOrPropertyPath as string)\n\n        this.expressionMap.queryType = \"relation\"\n        this.expressionMap.relationPropertyPath = propertyPath\n\n        if (entityTarget) {\n            const mainAlias = this.createFromAlias(entityTarget)\n            this.expressionMap.setMainAlias(mainAlias)\n        }\n\n        if (InstanceChecker.isRelationQueryBuilder(this)) return this as any\n\n        return QueryBuilder.queryBuilderRegistry[\"RelationQueryBuilder\"](this)\n    }\n\n    /**\n     * Checks if given relation exists in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(target: EntityTarget<T>, relation: string): boolean\n\n    /**\n     * Checks if given relations exist in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(target: EntityTarget<T>, relation: string[]): boolean\n\n    /**\n     * Checks if given relation or relations exist in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation<T>(\n        target: EntityTarget<T>,\n        relation: string | string[],\n    ): boolean {\n        const entityMetadata = this.connection.getMetadata(target)\n        const relations = Array.isArray(relation) ? relation : [relation]\n        return relations.every((relation) => {\n            return !!entityMetadata.findRelationWithPropertyPath(relation)\n        })\n    }\n\n    /**\n     * Check the existence of a parameter for this query builder.\n     */\n    hasParameter(key: string): boolean {\n        return (\n            this.parentQueryBuilder?.hasParameter(key) ||\n            key in this.expressionMap.parameters\n        )\n    }\n\n    /**\n     * Sets parameter name and its value.\n     *\n     * The key for this parameter may contain numbers, letters, underscores, or periods.\n     */\n    setParameter(key: string, value: any): this {\n        if (typeof value === \"function\") {\n            throw new TypeORMError(\n                `Function parameter isn't supported in the parameters. Please check \"${key}\" parameter.`,\n            )\n        }\n\n        if (!key.match(/^([A-Za-z0-9_.]+)$/)) {\n            throw new TypeORMError(\n                \"QueryBuilder parameter keys may only contain numbers, letters, underscores, or periods.\",\n            )\n        }\n\n        if (this.parentQueryBuilder) {\n            this.parentQueryBuilder.setParameter(key, value)\n        }\n\n        this.expressionMap.parameters[key] = value\n        return this\n    }\n\n    /**\n     * Adds all parameters from the given object.\n     */\n    setParameters(parameters: ObjectLiteral): this {\n        for (const [key, value] of Object.entries(parameters)) {\n            this.setParameter(key, value)\n        }\n\n        return this\n    }\n\n    protected createParameter(value: any): string {\n        let parameterName\n\n        do {\n            parameterName = `orm_param_${this.parameterIndex++}`\n        } while (this.hasParameter(parameterName))\n\n        this.setParameter(parameterName, value)\n\n        return `:${parameterName}`\n    }\n\n    /**\n     * Adds native parameters from the given object.\n     *\n     * @deprecated Use `setParameters` instead\n     */\n    setNativeParameters(parameters: ObjectLiteral): this {\n        // set parent query builder parameters as well in sub-query mode\n        if (this.parentQueryBuilder) {\n            this.parentQueryBuilder.setNativeParameters(parameters)\n        }\n\n        Object.keys(parameters).forEach((key) => {\n            this.expressionMap.nativeParameters[key] = parameters[key]\n        })\n        return this\n    }\n\n    /**\n     * Gets all parameters.\n     */\n    getParameters(): ObjectLiteral {\n        const parameters: ObjectLiteral = Object.assign(\n            {},\n            this.expressionMap.parameters,\n        )\n\n        // add discriminator column parameter if it exist\n        if (\n            this.expressionMap.mainAlias &&\n            this.expressionMap.mainAlias.hasMetadata\n        ) {\n            const metadata = this.expressionMap.mainAlias!.metadata\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n                const values = metadata.childEntityMetadatas\n                    .filter(\n                        (childMetadata) => childMetadata.discriminatorColumn,\n                    )\n                    .map((childMetadata) => childMetadata.discriminatorValue)\n                values.push(metadata.discriminatorValue)\n                parameters[\"discriminatorColumnValues\"] = values\n            }\n        }\n\n        return parameters\n    }\n\n    /**\n     * Prints sql to stdout using console.log.\n     */\n    printSql(): this {\n        // TODO rename to logSql()\n        const [query, parameters] = this.getQueryAndParameters()\n        this.connection.logger.logQuery(query, parameters)\n        return this\n    }\n\n    /**\n     * Gets generated sql that will be executed.\n     * Parameters in the query are escaped for the currently used driver.\n     */\n    getSql(): string {\n        return this.getQueryAndParameters()[0]\n    }\n\n    /**\n     * Gets query to be executed with all parameters used in it.\n     */\n    getQueryAndParameters(): [string, any[]] {\n        // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values\n        const query = this.getQuery()\n        const parameters = this.getParameters()\n        return this.connection.driver.escapeQueryWithParameters(\n            query,\n            parameters,\n            this.expressionMap.nativeParameters,\n        )\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<any> {\n        const [sql, parameters] = this.getQueryAndParameters()\n        const queryRunner = this.obtainQueryRunner()\n        try {\n            return await queryRunner.query(sql, parameters) // await is needed here because we are using finally\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    /**\n     * Creates a completely new query builder.\n     * Uses same query runner as current QueryBuilder.\n     */\n    createQueryBuilder(queryRunner?: QueryRunner): this {\n        return new (this.constructor as any)(\n            this.connection,\n            queryRunner ?? this.queryRunner,\n        )\n    }\n\n    /**\n     * Clones query builder as it is.\n     * Note: it uses new query runner, if you want query builder that uses exactly same query runner,\n     * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)\n     * where queryBuilder is cloned QueryBuilder.\n     */\n    clone(): this {\n        return new (this.constructor as any)(this)\n    }\n\n    /**\n     * Includes a Query comment in the query builder.  This is helpful for debugging purposes,\n     * such as finding a specific query in the database server's logs, or for categorization using\n     * an APM product.\n     */\n    comment(comment: string): this {\n        this.expressionMap.comment = comment\n        return this\n    }\n\n    /**\n     * Disables escaping.\n     */\n    disableEscaping(): this {\n        this.expressionMap.disableEscaping = false\n        return this\n    }\n\n    /**\n     * Escapes table name, column name or alias name using current database's escaping character.\n     */\n    escape(name: string): string {\n        if (!this.expressionMap.disableEscaping) return name\n        return this.connection.driver.escape(name)\n    }\n\n    /**\n     * Sets or overrides query builder's QueryRunner.\n     */\n    setQueryRunner(queryRunner: QueryRunner): this {\n        this.queryRunner = queryRunner\n        return this\n    }\n\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     * Enabled by default.\n     */\n    callListeners(enabled: boolean): this {\n        this.expressionMap.callListeners = enabled\n        return this\n    }\n\n    /**\n     * If set to true the query will be wrapped into a transaction.\n     */\n    useTransaction(enabled: boolean): this {\n        this.expressionMap.useTransaction = enabled\n        return this\n    }\n\n    /**\n     * Adds CTE to query\n     */\n    addCommonTableExpression(\n        queryBuilder: QueryBuilder<any> | string,\n        alias: string,\n        options?: QueryBuilderCteOptions,\n    ): this {\n        this.expressionMap.commonTableExpressions.push({\n            queryBuilder,\n            alias,\n            options: options || {},\n        })\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets escaped table name with schema name if SqlServer driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    protected getTableName(tablePath: string): string {\n        return tablePath\n            .split(\".\")\n            .map((i) => {\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n                if (i === \"\") return i\n                return this.escape(i)\n            })\n            .join(\".\")\n    }\n\n    /**\n     * Gets name of the table where insert should be performed.\n     */\n    protected getMainTableName(): string {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(\n                `Entity where values should be inserted is not specified. Call \"qb.into(entity)\" method to specify it.`,\n            )\n\n        if (this.expressionMap.mainAlias.hasMetadata)\n            return this.expressionMap.mainAlias.metadata.tablePath\n\n        return this.expressionMap.mainAlias.tablePath!\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    protected createFromAlias(\n        entityTarget:\n            | EntityTarget<any>\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName?: string,\n    ): Alias {\n        // if table has a metadata then find it to properly escape its properties\n        // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);\n        if (this.connection.hasMetadata(entityTarget)) {\n            const metadata = this.connection.getMetadata(entityTarget)\n\n            return this.expressionMap.createAlias({\n                type: \"from\",\n                name: aliasName,\n                metadata: this.connection.getMetadata(entityTarget),\n                tablePath: metadata.tablePath,\n            })\n        } else {\n            if (typeof entityTarget === \"string\") {\n                const isSubquery =\n                    entityTarget.substr(0, 1) === \"(\" &&\n                    entityTarget.substr(-1) === \")\"\n\n                return this.expressionMap.createAlias({\n                    type: \"from\",\n                    name: aliasName,\n                    tablePath: !isSubquery\n                        ? (entityTarget as string)\n                        : undefined,\n                    subQuery: isSubquery ? entityTarget : undefined,\n                })\n            }\n\n            const subQueryBuilder: SelectQueryBuilder<any> = (\n                entityTarget as any\n            )((this as any as SelectQueryBuilder<any>).subQuery())\n            this.setParameters(subQueryBuilder.getParameters())\n            const subquery = subQueryBuilder.getQuery()\n\n            return this.expressionMap.createAlias({\n                type: \"from\",\n                name: aliasName,\n                subQuery: subquery,\n            })\n        }\n    }\n\n    /**\n     * @deprecated this way of replace property names is too slow.\n     *  Instead, we'll replace property names at the end - once query is build.\n     */\n    protected replacePropertyNames(statement: string) {\n        return statement\n    }\n\n    /**\n     * Replaces all entity's propertyName to name in the given SQL string.\n     */\n    protected replacePropertyNamesForTheWholeQuery(statement: string) {\n        const replacements: { [key: string]: { [key: string]: string } } = {}\n\n        for (const alias of this.expressionMap.aliases) {\n            if (!alias.hasMetadata) continue\n            const replaceAliasNamePrefix =\n                this.expressionMap.aliasNamePrefixingEnabled && alias.name\n                    ? `${alias.name}.`\n                    : \"\"\n\n            if (!replacements[replaceAliasNamePrefix]) {\n                replacements[replaceAliasNamePrefix] = {}\n            }\n\n            // Insert & overwrite the replacements from least to most relevant in our replacements object.\n            // To do this we iterate and overwrite in the order of relevance.\n            // Least to Most Relevant:\n            // * Relation Property Path to first join column key\n            // * Relation Property Path + Column Path\n            // * Column Database Name\n            // * Column Property Name\n            // * Column Property Path\n\n            for (const relation of alias.metadata.relations) {\n                if (relation.joinColumns.length > 0)\n                    replacements[replaceAliasNamePrefix][\n                        relation.propertyPath\n                    ] = relation.joinColumns[0].databaseName\n            }\n\n            for (const relation of alias.metadata.relations) {\n                const allColumns = [\n                    ...relation.joinColumns,\n                    ...relation.inverseJoinColumns,\n                ]\n                for (const joinColumn of allColumns) {\n                    const propertyKey = `${relation.propertyPath}.${\n                        joinColumn.referencedColumn!.propertyPath\n                    }`\n                    replacements[replaceAliasNamePrefix][propertyKey] =\n                        joinColumn.databaseName\n                }\n            }\n\n            for (const column of alias.metadata.columns) {\n                replacements[replaceAliasNamePrefix][column.databaseName] =\n                    column.databaseName\n            }\n\n            for (const column of alias.metadata.columns) {\n                replacements[replaceAliasNamePrefix][column.propertyName] =\n                    column.databaseName\n            }\n\n            for (const column of alias.metadata.columns) {\n                replacements[replaceAliasNamePrefix][column.propertyPath] =\n                    column.databaseName\n            }\n        }\n\n        const replacementKeys = Object.keys(replacements)\n        const replaceAliasNamePrefixes = replacementKeys\n            .map((key) => escapeRegExp(key))\n            .join(\"|\")\n\n        if (replacementKeys.length > 0) {\n            statement = statement.replace(\n                new RegExp(\n                    // Avoid a lookbehind here since it's not well supported\n                    `([ =(]|^.{0})` + // any of ' =(' or start of line\n                        // followed by our prefix, e.g. 'tablename.' or ''\n                        `${\n                            replaceAliasNamePrefixes\n                                ? \"(\" + replaceAliasNamePrefixes + \")\"\n                                : \"\"\n                        }([^ =(),]+)` + // a possible property name: sequence of anything but ' =(),'\n                        // terminated by ' =),' or end of line\n                        `(?=[ =),]|.{0}$)`,\n                    \"gm\",\n                ),\n                (...matches) => {\n                    let match: string, pre: string, p: string\n                    if (replaceAliasNamePrefixes) {\n                        match = matches[0]\n                        pre = matches[1]\n                        p = matches[3]\n\n                        if (replacements[matches[2]][p]) {\n                            return `${pre}${this.escape(\n                                matches[2].substring(0, matches[2].length - 1),\n                            )}.${this.escape(replacements[matches[2]][p])}`\n                        }\n                    } else {\n                        match = matches[0]\n                        pre = matches[1]\n                        p = matches[2]\n\n                        if (replacements[\"\"][p]) {\n                            return `${pre}${this.escape(replacements[\"\"][p])}`\n                        }\n                    }\n                    return match\n                },\n            )\n        }\n\n        return statement\n    }\n\n    protected createComment(): string {\n        if (!this.expressionMap.comment) {\n            return \"\"\n        }\n\n        // ANSI SQL 2003 support C style comments - comments that start with `/*` and end with `*/`\n        // In some dialects query nesting is available - but not all.  Because of this, we'll need\n        // to scrub \"ending\" characters from the SQL but otherwise we can leave everything else\n        // as-is and it should be valid.\n\n        return `/* ${this.expressionMap.comment.replace(/\\*\\//g, \"\")} */ `\n    }\n\n    /**\n     * Time travel queries for CockroachDB\n     */\n    protected createTimeTravelQuery(): string {\n        if (\n            this.expressionMap.queryType === \"select\" &&\n            this.expressionMap.timeTravel\n        ) {\n            return ` AS OF SYSTEM TIME ${this.expressionMap.timeTravel}`\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"WHERE\" expression.\n     */\n    protected createWhereExpression() {\n        const conditionsArray = []\n\n        const whereExpression = this.createWhereClausesExpression(\n            this.expressionMap.wheres,\n        )\n\n        if (whereExpression.length > 0 && whereExpression !== \"1=1\") {\n            conditionsArray.push(this.replacePropertyNames(whereExpression))\n        }\n\n        if (this.expressionMap.mainAlias!.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias!.metadata\n            // Adds the global condition of \"non-deleted\" for the entity with delete date columns in select query.\n            if (\n                this.expressionMap.queryType === \"select\" &&\n                !this.expressionMap.withDeleted &&\n                metadata.deleteDateColumn\n            ) {\n                const column = this.expressionMap.aliasNamePrefixingEnabled\n                    ? this.expressionMap.mainAlias!.name +\n                      \".\" +\n                      metadata.deleteDateColumn.propertyName\n                    : metadata.deleteDateColumn.propertyName\n\n                const condition = `${this.replacePropertyNames(column)} IS NULL`\n                conditionsArray.push(condition)\n            }\n\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n                const column = this.expressionMap.aliasNamePrefixingEnabled\n                    ? this.expressionMap.mainAlias!.name +\n                      \".\" +\n                      metadata.discriminatorColumn.databaseName\n                    : metadata.discriminatorColumn.databaseName\n\n                const condition = `${this.replacePropertyNames(\n                    column,\n                )} IN (:...discriminatorColumnValues)`\n                conditionsArray.push(condition)\n            }\n        }\n\n        if (this.expressionMap.extraAppendedAndWhereCondition) {\n            const condition = this.replacePropertyNames(\n                this.expressionMap.extraAppendedAndWhereCondition,\n            )\n            conditionsArray.push(condition)\n        }\n\n        let condition = \"\"\n\n        // time travel\n        condition += this.createTimeTravelQuery()\n\n        if (!conditionsArray.length) {\n            condition += \"\"\n        } else if (conditionsArray.length === 1) {\n            condition += ` WHERE ${conditionsArray[0]}`\n        } else {\n            condition += ` WHERE ( ${conditionsArray.join(\" ) AND ( \")} )`\n        }\n\n        return condition\n    }\n\n    /**\n     * Creates \"RETURNING\" / \"OUTPUT\" expression.\n     */\n    protected createReturningExpression(returningType: ReturningType): string {\n        const columns = this.getReturningColumns()\n        const driver = this.connection.driver\n\n        // also add columns we must auto-return to perform entity updation\n        // if user gave his own returning\n        if (\n            typeof this.expressionMap.returning !== \"string\" &&\n            this.expressionMap.extraReturningColumns.length > 0 &&\n            driver.isReturningSqlSupported(returningType)\n        ) {\n            columns.push(\n                ...this.expressionMap.extraReturningColumns.filter((column) => {\n                    return columns.indexOf(column) === -1\n                }),\n            )\n        }\n\n        if (columns.length) {\n            let columnsExpression = columns\n                .map((column) => {\n                    const name = this.escape(column.databaseName)\n                    if (driver.options.type === \"mssql\") {\n                        if (\n                            this.expressionMap.queryType === \"insert\" ||\n                            this.expressionMap.queryType === \"update\" ||\n                            this.expressionMap.queryType === \"soft-delete\" ||\n                            this.expressionMap.queryType === \"restore\"\n                        ) {\n                            return \"INSERTED.\" + name\n                        } else {\n                            return (\n                                this.escape(this.getMainTableName()) +\n                                \".\" +\n                                name\n                            )\n                        }\n                    } else {\n                        return name\n                    }\n                })\n                .join(\", \")\n\n            if (driver.options.type === \"oracle\") {\n                columnsExpression +=\n                    \" INTO \" +\n                    columns\n                        .map((column) => {\n                            return this.createParameter({\n                                type: (\n                                    driver as OracleDriver\n                                ).columnTypeToNativeParameter(column.type),\n                                dir: (driver as OracleDriver).oracle.BIND_OUT,\n                            })\n                        })\n                        .join(\", \")\n            }\n\n            if (driver.options.type === \"mssql\") {\n                if (\n                    this.expressionMap.queryType === \"insert\" ||\n                    this.expressionMap.queryType === \"update\"\n                ) {\n                    columnsExpression += \" INTO @OutputTable\"\n                }\n            }\n\n            return columnsExpression\n        } else if (typeof this.expressionMap.returning === \"string\") {\n            return this.expressionMap.returning\n        }\n\n        return \"\"\n    }\n\n    /**\n     * If returning / output cause is set to array of column names,\n     * then this method will return all column metadatas of those column names.\n     */\n    protected getReturningColumns(): ColumnMetadata[] {\n        const columns: ColumnMetadata[] = []\n        if (Array.isArray(this.expressionMap.returning)) {\n            ;(this.expressionMap.returning as string[]).forEach(\n                (columnName) => {\n                    if (this.expressionMap.mainAlias!.hasMetadata) {\n                        columns.push(\n                            ...this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(\n                                columnName,\n                            ),\n                        )\n                    }\n                },\n            )\n        }\n        return columns\n    }\n\n    protected createWhereClausesExpression(clauses: WhereClause[]): string {\n        return clauses\n            .map((clause, index) => {\n                const expression = this.createWhereConditionExpression(\n                    clause.condition,\n                )\n\n                switch (clause.type) {\n                    case \"and\":\n                        return (\n                            (index > 0 ? \"AND \" : \"\") +\n                            `${\n                                this.connection.options.isolateWhereStatements\n                                    ? \"(\"\n                                    : \"\"\n                            }${expression}${\n                                this.connection.options.isolateWhereStatements\n                                    ? \")\"\n                                    : \"\"\n                            }`\n                        )\n                    case \"or\":\n                        return (\n                            (index > 0 ? \"OR \" : \"\") +\n                            `${\n                                this.connection.options.isolateWhereStatements\n                                    ? \"(\"\n                                    : \"\"\n                            }${expression}${\n                                this.connection.options.isolateWhereStatements\n                                    ? \")\"\n                                    : \"\"\n                            }`\n                        )\n                }\n\n                return expression\n            })\n            .join(\" \")\n            .trim()\n    }\n\n    /**\n     * Computes given where argument - transforms to a where string all forms it can take.\n     */\n    protected createWhereConditionExpression(\n        condition: WhereClauseCondition,\n        alwaysWrap: boolean = false,\n    ): string {\n        if (typeof condition === \"string\") return condition\n\n        if (Array.isArray(condition)) {\n            if (condition.length === 0) {\n                return \"1=1\"\n            }\n\n            // In the future we should probably remove this entire condition\n            // but for now to prevent any breaking changes it exists.\n            if (condition.length === 1 && !alwaysWrap) {\n                return this.createWhereClausesExpression(condition)\n            }\n\n            return \"(\" + this.createWhereClausesExpression(condition) + \")\"\n        }\n\n        const { driver } = this.connection\n\n        switch (condition.operator) {\n            case \"lessThan\":\n                return `${condition.parameters[0]} < ${condition.parameters[1]}`\n            case \"lessThanOrEqual\":\n                return `${condition.parameters[0]} <= ${condition.parameters[1]}`\n            case \"arrayContains\":\n                return `${condition.parameters[0]} @> ${condition.parameters[1]}`\n            case \"jsonContains\":\n                return `${condition.parameters[0]} ::jsonb @> ${condition.parameters[1]}`\n            case \"arrayContainedBy\":\n                return `${condition.parameters[0]} <@ ${condition.parameters[1]}`\n            case \"arrayOverlap\":\n                return `${condition.parameters[0]} && ${condition.parameters[1]}`\n            case \"moreThan\":\n                return `${condition.parameters[0]} > ${condition.parameters[1]}`\n            case \"moreThanOrEqual\":\n                return `${condition.parameters[0]} >= ${condition.parameters[1]}`\n            case \"notEqual\":\n                return `${condition.parameters[0]} != ${condition.parameters[1]}`\n            case \"equal\":\n                return `${condition.parameters[0]} = ${condition.parameters[1]}`\n            case \"ilike\":\n                if (\n                    driver.options.type === \"postgres\" ||\n                    driver.options.type === \"cockroachdb\"\n                ) {\n                    return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`\n                }\n\n                return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`\n            case \"like\":\n                return `${condition.parameters[0]} LIKE ${condition.parameters[1]}`\n            case \"between\":\n                return `${condition.parameters[0]} BETWEEN ${condition.parameters[1]} AND ${condition.parameters[2]}`\n            case \"in\":\n                if (condition.parameters.length <= 1) {\n                    return \"0=1\"\n                }\n                return `${condition.parameters[0]} IN (${condition.parameters\n                    .slice(1)\n                    .join(\", \")})`\n            case \"any\":\n                if (driver.options.type === \"cockroachdb\") {\n                    return `${condition.parameters[0]}::STRING = ANY(${condition.parameters[1]}::STRING[])`\n                }\n\n                return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`\n            case \"isNull\":\n                return `${condition.parameters[0]} IS NULL`\n\n            case \"not\":\n                return `NOT(${this.createWhereConditionExpression(\n                    condition.condition,\n                )})`\n            case \"brackets\":\n                return `${this.createWhereConditionExpression(\n                    condition.condition,\n                    true,\n                )}`\n            case \"and\":\n                return \"(\" + condition.parameters.join(\" AND \") + \")\"\n            case \"or\":\n                return \"(\" + condition.parameters.join(\" OR \") + \")\"\n        }\n\n        throw new TypeError(\n            `Unsupported FindOperator ${FindOperator.constructor.name}`,\n        )\n    }\n\n    protected createCteExpression(): string {\n        if (!this.hasCommonTableExpressions()) {\n            return \"\"\n        }\n        const databaseRequireRecusiveHint =\n            this.connection.driver.cteCapabilities.requiresRecursiveHint\n\n        const cteStrings = this.expressionMap.commonTableExpressions.map(\n            (cte) => {\n                let cteBodyExpression =\n                    typeof cte.queryBuilder === \"string\" ? cte.queryBuilder : \"\"\n                if (typeof cte.queryBuilder !== \"string\") {\n                    if (cte.queryBuilder.hasCommonTableExpressions()) {\n                        throw new TypeORMError(\n                            `Nested CTEs aren't supported (CTE: ${cte.alias})`,\n                        )\n                    }\n                    cteBodyExpression = cte.queryBuilder.getQuery()\n                    if (\n                        !this.connection.driver.cteCapabilities.writable &&\n                        !InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)\n                    ) {\n                        throw new TypeORMError(\n                            `Only select queries are supported in CTEs in ${this.connection.options.type} (CTE: ${cte.alias})`,\n                        )\n                    }\n                    this.setParameters(cte.queryBuilder.getParameters())\n                }\n                let cteHeader = this.escape(cte.alias)\n                if (cte.options.columnNames) {\n                    const escapedColumnNames = cte.options.columnNames.map(\n                        (column) => this.escape(column),\n                    )\n                    if (\n                        InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)\n                    ) {\n                        if (\n                            cte.queryBuilder.expressionMap.selects.length &&\n                            cte.options.columnNames.length !==\n                                cte.queryBuilder.expressionMap.selects.length\n                        ) {\n                            throw new TypeORMError(\n                                `cte.options.columnNames length (${cte.options.columnNames.length}) doesn't match subquery select list length ${cte.queryBuilder.expressionMap.selects.length} (CTE: ${cte.alias})`,\n                            )\n                        }\n                    }\n                    cteHeader += `(${escapedColumnNames.join(\", \")})`\n                }\n                const recursiveClause =\n                    cte.options.recursive && databaseRequireRecusiveHint\n                        ? \"RECURSIVE\"\n                        : \"\"\n                let materializeClause = \"\"\n                if (\n                    this.connection.driver.cteCapabilities.materializedHint &&\n                    cte.options.materialized !== undefined\n                ) {\n                    materializeClause = cte.options.materialized\n                        ? \"MATERIALIZED\"\n                        : \"NOT MATERIALIZED\"\n                }\n\n                return [\n                    recursiveClause,\n                    cteHeader,\n                    \"AS\",\n                    materializeClause,\n                    `(${cteBodyExpression})`,\n                ]\n                    .filter(Boolean)\n                    .join(\" \")\n            },\n        )\n\n        return \"WITH \" + cteStrings.join(\", \") + \" \"\n    }\n\n    /**\n     * Creates \"WHERE\" condition for an in-ids condition.\n     */\n    protected getWhereInIdsCondition(\n        ids: any | any[],\n    ): ObjectLiteral | Brackets {\n        const metadata = this.expressionMap.mainAlias!.metadata\n        const normalized = (Array.isArray(ids) ? ids : [ids]).map((id) =>\n            metadata.ensureEntityIdMap(id),\n        )\n\n        // using in(...ids) for single primary key entities\n        if (!metadata.hasMultiplePrimaryKeys) {\n            const primaryColumn = metadata.primaryColumns[0]\n\n            // getEntityValue will try to transform `In`, it is a bug\n            // todo: remove this transformer check after #2390 is fixed\n            // This also fails for embedded & relation, so until that is fixed skip it.\n            if (\n                !primaryColumn.transformer &&\n                !primaryColumn.relationMetadata &&\n                !primaryColumn.embeddedMetadata\n            ) {\n                return {\n                    [primaryColumn.propertyName]: In(\n                        normalized.map((id) =>\n                            primaryColumn.getEntityValue(id, false),\n                        ),\n                    ),\n                }\n            }\n        }\n\n        return new Brackets((qb) => {\n            for (const data of normalized) {\n                qb.orWhere(new Brackets((qb) => qb.where(data)))\n            }\n        })\n    }\n\n    protected getExistsCondition(subQuery: any): [string, any[]] {\n        const query = subQuery\n            .clone()\n            .orderBy()\n            .groupBy()\n            .offset(undefined)\n            .limit(undefined)\n            .skip(undefined)\n            .take(undefined)\n            .select(\"1\")\n            .setOption(\"disable-global-order\")\n\n        return [`EXISTS (${query.getQuery()})`, query.getParameters()]\n    }\n\n    private findColumnsForPropertyPath(\n        propertyPath: string,\n    ): [Alias, string[], ColumnMetadata[]] {\n        // Make a helper to iterate the entity & relations?\n        // Use that to set the correct alias?  Or the other way around?\n\n        // Start with the main alias with our property paths\n        let alias = this.expressionMap.mainAlias\n        const root: string[] = []\n        const propertyPathParts = propertyPath.split(\".\")\n\n        while (propertyPathParts.length > 1) {\n            const part = propertyPathParts[0]\n\n            if (!alias?.hasMetadata) {\n                // If there's no metadata, we're wasting our time\n                // and can't actually look any of this up.\n                break\n            }\n\n            if (alias.metadata.hasEmbeddedWithPropertyPath(part)) {\n                // If this is an embedded then we should combine the two as part of our lookup.\n                // Instead of just breaking, we keep going with this in case there's an embedded/relation\n                // inside an embedded.\n                propertyPathParts.unshift(\n                    `${propertyPathParts.shift()}.${propertyPathParts.shift()}`,\n                )\n                continue\n            }\n\n            if (alias.metadata.hasRelationWithPropertyPath(part)) {\n                // If this is a relation then we should find the aliases\n                // that match the relation & then continue further down\n                // the property path\n                const joinAttr = this.expressionMap.joinAttributes.find(\n                    (joinAttr) => joinAttr.relationPropertyPath === part,\n                )\n\n                if (!joinAttr?.alias) {\n                    const fullRelationPath =\n                        root.length > 0 ? `${root.join(\".\")}.${part}` : part\n                    throw new Error(\n                        `Cannot find alias for relation at ${fullRelationPath}`,\n                    )\n                }\n\n                alias = joinAttr.alias\n                root.push(...part.split(\".\"))\n                propertyPathParts.shift()\n                continue\n            }\n\n            break\n        }\n\n        if (!alias) {\n            throw new Error(`Cannot find alias for property ${propertyPath}`)\n        }\n\n        // Remaining parts are combined back and used to find the actual property path\n        const aliasPropertyPath = propertyPathParts.join(\".\")\n\n        const columns =\n            alias.metadata.findColumnsWithPropertyPath(aliasPropertyPath)\n\n        if (!columns.length) {\n            throw new EntityPropertyNotFoundError(propertyPath, alias.metadata)\n        }\n\n        return [alias, root, columns]\n    }\n\n    /**\n     * Creates a property paths for a given ObjectLiteral.\n     */\n    protected createPropertyPath(\n        metadata: EntityMetadata,\n        entity: ObjectLiteral,\n        prefix: string = \"\",\n    ) {\n        const paths: string[] = []\n\n        for (const key of Object.keys(entity)) {\n            const path = prefix ? `${prefix}.${key}` : key\n\n            // There's times where we don't actually want to traverse deeper.\n            // If the value is a `FindOperator`, or null, or not an object, then we don't, for example.\n            if (\n                entity[key] === null ||\n                typeof entity[key] !== \"object\" ||\n                InstanceChecker.isFindOperator(entity[key])\n            ) {\n                paths.push(path)\n                continue\n            }\n\n            if (metadata.hasEmbeddedWithPropertyPath(path)) {\n                const subPaths = this.createPropertyPath(\n                    metadata,\n                    entity[key],\n                    path,\n                )\n                paths.push(...subPaths)\n                continue\n            }\n\n            if (metadata.hasRelationWithPropertyPath(path)) {\n                const relation = metadata.findRelationWithPropertyPath(path)!\n\n                // There's also cases where we don't want to return back all of the properties.\n                // These handles the situation where someone passes the model & we don't need to make\n                // a HUGE `where` to uniquely look up the entity.\n\n                // In the case of a *-to-one, there's only ever one possible entity on the other side\n                // so if the join columns are all defined we can return just the relation itself\n                // because it will fetch only the join columns and do the lookup.\n                if (\n                    relation.relationType === \"one-to-one\" ||\n                    relation.relationType === \"many-to-one\"\n                ) {\n                    const joinColumns = relation.joinColumns\n                        .map((j) => j.referencedColumn)\n                        .filter((j): j is ColumnMetadata => !!j)\n\n                    const hasAllJoinColumns =\n                        joinColumns.length > 0 &&\n                        joinColumns.every((column) =>\n                            column.getEntityValue(entity[key], false),\n                        )\n\n                    if (hasAllJoinColumns) {\n                        paths.push(path)\n                        continue\n                    }\n                }\n\n                if (\n                    relation.relationType === \"one-to-many\" ||\n                    relation.relationType === \"many-to-many\"\n                ) {\n                    throw new Error(\n                        `Cannot query across ${relation.relationType} for property ${path}`,\n                    )\n                }\n\n                // For any other case, if the `entity[key]` contains all of the primary keys we can do a\n                // lookup via these.  We don't need to look up via any other values 'cause these are\n                // the unique primary keys.\n                // This handles the situation where someone passes the model & we don't need to make\n                // a HUGE where.\n                const primaryColumns =\n                    relation.inverseEntityMetadata.primaryColumns\n                const hasAllPrimaryKeys =\n                    primaryColumns.length > 0 &&\n                    primaryColumns.every((column) =>\n                        column.getEntityValue(entity[key], false),\n                    )\n\n                if (hasAllPrimaryKeys) {\n                    const subPaths = primaryColumns.map(\n                        (column) => `${path}.${column.propertyPath}`,\n                    )\n                    paths.push(...subPaths)\n                    continue\n                }\n\n                // If nothing else, just return every property that's being passed to us.\n                const subPaths = this.createPropertyPath(\n                    relation.inverseEntityMetadata,\n                    entity[key],\n                ).map((p) => `${path}.${p}`)\n                paths.push(...subPaths)\n                continue\n            }\n\n            paths.push(path)\n        }\n\n        return paths\n    }\n\n    protected *getPredicates(where: ObjectLiteral) {\n        if (this.expressionMap.mainAlias!.hasMetadata) {\n            const propertyPaths = this.createPropertyPath(\n                this.expressionMap.mainAlias!.metadata,\n                where,\n            )\n\n            for (const propertyPath of propertyPaths) {\n                const [alias, aliasPropertyPath, columns] =\n                    this.findColumnsForPropertyPath(propertyPath)\n\n                for (const column of columns) {\n                    let containedWhere = where\n\n                    for (const part of aliasPropertyPath) {\n                        if (!containedWhere || !(part in containedWhere)) {\n                            containedWhere = {}\n                            break\n                        }\n\n                        containedWhere = containedWhere[part]\n                    }\n\n                    // Use the correct alias & the property path from the column\n                    const aliasPath = this.expressionMap\n                        .aliasNamePrefixingEnabled\n                        ? `${alias.name}.${column.propertyPath}`\n                        : column.propertyPath\n\n                    const parameterValue = column.getEntityValue(\n                        containedWhere,\n                        true,\n                    )\n\n                    yield [aliasPath, parameterValue]\n                }\n            }\n        } else {\n            for (const key of Object.keys(where)) {\n                const parameterValue = where[key]\n                const aliasPath = this.expressionMap.aliasNamePrefixingEnabled\n                    ? `${this.alias}.${key}`\n                    : key\n\n                yield [aliasPath, parameterValue]\n            }\n        }\n    }\n\n    protected getWherePredicateCondition(\n        aliasPath: string,\n        parameterValue: any,\n    ): WhereClauseCondition {\n        if (InstanceChecker.isFindOperator(parameterValue)) {\n            const parameters: any[] = []\n            if (parameterValue.useParameter) {\n                if (parameterValue.objectLiteralParameters) {\n                    this.setParameters(parameterValue.objectLiteralParameters)\n                } else if (parameterValue.multipleParameters) {\n                    for (const v of parameterValue.value) {\n                        parameters.push(this.createParameter(v))\n                    }\n                } else {\n                    parameters.push(this.createParameter(parameterValue.value))\n                }\n            }\n\n            if (parameterValue.type === \"raw\") {\n                if (parameterValue.getSql) {\n                    return parameterValue.getSql(aliasPath)\n                } else {\n                    return {\n                        operator: \"equal\",\n                        parameters: [aliasPath, parameterValue.value],\n                    }\n                }\n            } else if (parameterValue.type === \"not\") {\n                if (parameterValue.child) {\n                    return {\n                        operator: parameterValue.type,\n                        condition: this.getWherePredicateCondition(\n                            aliasPath,\n                            parameterValue.child,\n                        ),\n                    }\n                } else {\n                    return {\n                        operator: \"notEqual\",\n                        parameters: [aliasPath, ...parameters],\n                    }\n                }\n            } else if (parameterValue.type === \"and\") {\n                const values: FindOperator<any>[] = parameterValue.value\n\n                return {\n                    operator: parameterValue.type,\n                    parameters: values.map((operator) =>\n                        this.createWhereConditionExpression(\n                            this.getWherePredicateCondition(\n                                aliasPath,\n                                operator,\n                            ),\n                        ),\n                    ),\n                }\n            } else if (parameterValue.type === \"or\") {\n                const values: FindOperator<any>[] = parameterValue.value\n\n                return {\n                    operator: parameterValue.type,\n                    parameters: values.map((operator) =>\n                        this.createWhereConditionExpression(\n                            this.getWherePredicateCondition(\n                                aliasPath,\n                                operator,\n                            ),\n                        ),\n                    ),\n                }\n            } else {\n                return {\n                    operator: parameterValue.type,\n                    parameters: [aliasPath, ...parameters],\n                }\n            }\n            // } else if (parameterValue === null) {\n            //     return {\n            //         operator: \"isNull\",\n            //         parameters: [\n            //             aliasPath,\n            //         ]\n            //     };\n        } else {\n            return {\n                operator: \"equal\",\n                parameters: [aliasPath, this.createParameter(parameterValue)],\n            }\n        }\n    }\n\n    protected getWhereCondition(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | NotBrackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n    ): WhereClauseCondition {\n        if (typeof where === \"string\") {\n            return where\n        }\n\n        if (InstanceChecker.isBrackets(where)) {\n            const whereQueryBuilder = this.createQueryBuilder()\n\n            whereQueryBuilder.parentQueryBuilder = this\n\n            whereQueryBuilder.expressionMap.mainAlias =\n                this.expressionMap.mainAlias\n            whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled =\n                this.expressionMap.aliasNamePrefixingEnabled\n            whereQueryBuilder.expressionMap.parameters =\n                this.expressionMap.parameters\n            whereQueryBuilder.expressionMap.nativeParameters =\n                this.expressionMap.nativeParameters\n\n            whereQueryBuilder.expressionMap.wheres = []\n\n            where.whereFactory(whereQueryBuilder as any)\n\n            return {\n                operator: InstanceChecker.isNotBrackets(where)\n                    ? \"not\"\n                    : \"brackets\",\n                condition: whereQueryBuilder.expressionMap.wheres,\n            }\n        }\n\n        if (typeof where === \"function\") {\n            return where(this)\n        }\n\n        const wheres: ObjectLiteral[] = Array.isArray(where) ? where : [where]\n        const clauses: WhereClause[] = []\n\n        for (const where of wheres) {\n            const conditions: WhereClauseCondition = []\n\n            // Filter the conditions and set up the parameter values\n            for (const [aliasPath, parameterValue] of this.getPredicates(\n                where,\n            )) {\n                conditions.push({\n                    type: \"and\",\n                    condition: this.getWherePredicateCondition(\n                        aliasPath,\n                        parameterValue,\n                    ),\n                })\n            }\n\n            clauses.push({ type: \"or\", condition: conditions })\n        }\n\n        if (clauses.length === 1) {\n            return clauses[0].condition\n        }\n\n        return clauses\n    }\n\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    protected obtainQueryRunner() {\n        return this.queryRunner || this.connection.createQueryRunner()\n    }\n\n    protected hasCommonTableExpressions(): boolean {\n        return this.expressionMap.commonTableExpressions.length > 0\n    }\n}\n"],"names":[],"mappings":";;;;;AAIA,MAAA,uDAAyD;AASzD,MAAA,mCAAqC;AAIrC,MAAA,yDAA2D;AAC3D,MAAA,8CAAgD;AAChD,MAAA,8BAAuC;AAGvC,MAAA,gFAAkF;AAGlF,MAAA,uDAAyD;AACzD,MAAA,iDAAmD;AAEnD,kDAAkD;AAClD,kFAAkF;AAClF,sGAAsG;AACtG,gEAAgE;AAChE,oEAAoE;AACpE,yDAAyD;AACzD,iCAAiC;AACjC,2GAA2G;AAC3G,oCAAoC;AACpC,qCAAqC;AAErC,mGAAmG;AACnG,+DAA+D;AAC/D,sDAAsD;AAEtD;;GAEG,CACH,MAAsB,YAAY;IAuD9B;;OAEG,CACH,YACI,wBAAwD,EACxD,WAAyB,CAAA;QA3DpB,IAAA,CAAA,cAAa,GAAG,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,CAAA;QA8BnD;;WAEG,CACK,IAAA,CAAA,cAAc,GAAG,CAAC,CAAA;QA4BtB,IAAI,kBAAA,eAAe,CAAC,YAAY,CAAC,wBAAwB,CAAC,EAAE,CAAC;YACzD,IAAI,CAAC,UAAU,GAAG,wBAAwB,CAAA;YAC1C,IAAI,CAAC,WAAW,GAAG,WAAW,CAAA;YAC9B,IAAI,CAAC,aAAa,GAAG,IAAI,qBAAA,kBAAkB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAA;QAChE,CAAC,MAAM,CAAC;YACJ,IAAI,CAAC,UAAU,GAAG,wBAAwB,CAAC,UAAU,CAAA;YACrD,IAAI,CAAC,WAAW,GAAG,wBAAwB,CAAC,WAAW,CAAA;YACvD,IAAI,CAAC,aAAa,GAAG,wBAAwB,CAAC,aAAa,CAAC,KAAK,EAAE,CAAA;QACvE,CAAC;IACL,CAAC;IAED,MAAM,CAAC,yBAAyB,CAAC,IAAY,EAAE,OAAY,EAAA;QACvD,YAAY,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,OAAO,CAAA;IACrD,CAAC;IAWD,4EAA4E;IAC5E,YAAY;IACZ,4EAA4E;IAE5E;;OAEG,CACH,IAAI,KAAK,GAAA;QACL,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,EAC7B,MAAM,IAAI,QAAA,YAAY,CAAC,CAAA,qBAAA,CAAuB,CAAC,CAAA,CAAC,yBAAyB;QAE7E,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI,CAAA;IAC5C,CAAC;IA2BD;;;OAGG,CACH,MAAM,CACF,SAA6B,EAC7B,kBAA2B,EAAA;QAE3B,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,QAAQ,CAAA;QACvC,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC;YAC3B,IAAI,CAAC,aAAa,CAAC,OAAO,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC,SAAS,EAAE,CAAG,CAAD,AAAE;oBACvD,SAAS,EAAE,SAAS;iBACvB,CAAC,CAAC,CAAA;QACP,CAAC,MAAM,IAAI,SAAS,EAAE,CAAC;YACnB,IAAI,CAAC,aAAa,CAAC,OAAO,GAAG;gBACzB;oBAAE,SAAS,EAAE,SAAS;oBAAE,SAAS,EAAE,kBAAkB;gBAAA,CAAE;aAC1D,CAAA;QACL,CAAC;QAED,IAAI,kBAAA,eAAe,CAAC,oBAAoB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW,CAAA;QAElE,OAAO,YAAY,CAAC,oBAAoB,CAAC,oBAAoB,CAAC,CAAC,IAAI,CAAC,CAAA;IACxE,CAAC;IAED;;OAEG,CACH,MAAM,GAAA;QACF,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,QAAQ,CAAA;QAEvC,IAAI,kBAAA,eAAe,CAAC,oBAAoB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW,CAAA;QAElE,OAAO,YAAY,CAAC,oBAAoB,CAAC,oBAAoB,CAAC,CAAC,IAAI,CAAC,CAAA;IACxE,CAAC;IA8BD;;OAEG,CACH,MAAM,CACF,0BAA8D,EAC9D,cAA8B,EAAA;QAE9B,MAAM,SAAS,GAAG,cAAc,GAC1B,cAAc,GACb,0BAAwD,CAAA;QAC/D,0BAA0B,GAAG,kBAAA,eAAe,CAAC,cAAc,CACvD,0BAA0B,CAC7B,GACK,0BAA0B,CAAC,OAAO,CAAC,IAAI,GACvC,0BAA0B,CAAA;QAEhC,IACI,OAAO,0BAA0B,KAAK,UAAU,IAChD,OAAO,0BAA0B,KAAK,QAAQ,EAChD,CAAC;YACC,MAAM,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,0BAA0B,CAAC,CAAA;YAClE,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,SAAS,CAAC,CAAA;QAC9C,CAAC;QAED,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,QAAQ,CAAA;QACvC,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,SAAS,CAAA;QAExC,IAAI,kBAAA,eAAe,CAAC,oBAAoB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW,CAAA;QAElE,OAAO,YAAY,CAAC,oBAAoB,CAAC,oBAAoB,CAAC,CAAC,IAAI,CAAC,CAAA;IACxE,CAAC;IAED;;OAEG,CACH,MAAM,GAAA;QACF,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,QAAQ,CAAA;QAEvC,IAAI,kBAAA,eAAe,CAAC,oBAAoB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW,CAAA;QAElE,OAAO,YAAY,CAAC,oBAAoB,CAAC,oBAAoB,CAAC,CAAC,IAAI,CAAC,CAAA;IACxE,CAAC;IAED,UAAU,GAAA;QACN,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,aAAa,CAAA;QAE5C,IAAI,kBAAA,eAAe,CAAC,wBAAwB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW,CAAA;QAEtE,OAAO,YAAY,CAAC,oBAAoB,CAAC,wBAAwB,CAAC,CAAC,IAAI,CAAC,CAAA;IAC5E,CAAC;IAED,OAAO,GAAA;QACH,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,SAAS,CAAA;QAExC,IAAI,kBAAA,eAAe,CAAC,wBAAwB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW,CAAA;QAEtE,OAAO,YAAY,CAAC,oBAAoB,CAAC,wBAAwB,CAAC,CAAC,IAAI,CAAC,CAAA;IAC5E,CAAC;IAeD;;OAEG,CACH,QAAQ,CACJ,0BAA6C,EAC7C,iBAA0B,EAAA;QAE1B,MAAM,YAAY,GACd,SAAS,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,0BAA0B,CAAC,CAAC,CAAC,SAAS,CAAA;QACnE,MAAM,YAAY,GACd,SAAS,CAAC,MAAM,KAAK,CAAC,GACf,iBAA4B,GAC5B,0BAAqC,CAAA;QAEhD,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,UAAU,CAAA;QACzC,IAAI,CAAC,aAAa,CAAC,oBAAoB,GAAG,YAAY,CAAA;QAEtD,IAAI,YAAY,EAAE,CAAC;YACf,MAAM,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,CAAA;YACpD,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,SAAS,CAAC,CAAA;QAC9C,CAAC;QAED,IAAI,kBAAA,eAAe,CAAC,sBAAsB,CAAC,IAAI,CAAC,EAAE,OAAO,IAAW,CAAA;QAEpE,OAAO,YAAY,CAAC,oBAAoB,CAAC,sBAAsB,CAAC,CAAC,IAAI,CAAC,CAAA;IAC1E,CAAC;IAkBD;;;;;OAKG,CACH,WAAW,CACP,MAAuB,EACvB,QAA2B,EAAA;QAE3B,MAAM,cAAc,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,MAAM,CAAC,CAAA;QAC1D,MAAM,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YAAC,QAAQ;SAAC,CAAA;QACjE,OAAO,SAAS,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE,EAAE;YAChC,OAAO,CAAC,CAAC,cAAc,CAAC,4BAA4B,CAAC,QAAQ,CAAC,CAAA;QAClE,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;OAEG,CACH,YAAY,CAAC,GAAW,EAAA;QACpB,OACI,AADG,IACC,CAAC,kBAAkB,EAAE,YAAY,CAAC,GAAG,CAAC,IAC1C,GAAG,IAAI,IAAI,CAAC,aAAa,CAAC,UAAU,CACvC,CAAA;IACL,CAAC;IAED;;;;OAIG,CACH,YAAY,CAAC,GAAW,EAAE,KAAU,EAAA;QAChC,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE,CAAC;YAC9B,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,oEAAA,EAAuE,GAAG,CAAA,YAAA,CAAc,CAC3F,CAAA;QACL,CAAC;QAED,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,oBAAoB,CAAC,EAAE,CAAC;YACnC,MAAM,IAAI,QAAA,YAAY,CAClB,yFAAyF,CAC5F,CAAA;QACL,CAAC;QAED,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1B,IAAI,CAAC,kBAAkB,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;QACpD,CAAC;QAED,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,KAAK,CAAA;QAC1C,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,aAAa,CAAC,UAAyB,EAAA;QACnC,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAE,CAAC;YACpD,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;QACjC,CAAC;QAED,OAAO,IAAI,CAAA;IACf,CAAC;IAES,eAAe,CAAC,KAAU,EAAA;QAChC,IAAI,aAAa,CAAA;QAEjB,GAAG,CAAC;YACA,aAAa,GAAG,CAAA,UAAA,EAAa,IAAI,CAAC,cAAc,EAAE,EAAE,CAAA;QACxD,CAAC,OAAQ,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC,CAAC;QAE1C,IAAI,CAAC,YAAY,CAAC,aAAa,EAAE,KAAK,CAAC,CAAA;QAEvC,OAAO,CAAA,CAAA,EAAI,aAAa,EAAE,CAAA;IAC9B,CAAC;IAED;;;;OAIG,CACH,mBAAmB,CAAC,UAAyB,EAAA;QACzC,gEAAgE;QAChE,IAAI,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC1B,IAAI,CAAC,kBAAkB,CAAC,mBAAmB,CAAC,UAAU,CAAC,CAAA;QAC3D,CAAC;QAED,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;YACpC,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC,GAAG,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,CAAA;QAC9D,CAAC,CAAC,CAAA;QACF,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,aAAa,GAAA;QACT,MAAM,UAAU,GAAkB,MAAM,CAAC,MAAM,CAC3C,CAAA,CAAE,EACF,IAAI,CAAC,aAAa,CAAC,UAAU,CAChC,CAAA;QAED,iDAAiD;QACjD,IACI,IAAI,CAAC,aAAa,CAAC,SAAS,IAC5B,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,WAAW,EAC1C,CAAC;YACC,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,CAAA;YACvD,IAAI,QAAQ,CAAC,mBAAmB,IAAI,QAAQ,CAAC,oBAAoB,EAAE,CAAC;gBAChE,MAAM,MAAM,GAAG,QAAQ,CAAC,oBAAoB,CACvC,MAAM,CACH,CAAC,aAAa,EAAE,CAAG,CAAD,YAAc,CAAC,mBAAmB,CACvD,CACA,GAAG,CAAC,CAAC,aAAa,EAAE,CAAG,CAAD,YAAc,CAAC,kBAAkB,CAAC,CAAA;gBAC7D,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,kBAAkB,CAAC,CAAA;gBACxC,UAAU,CAAC,2BAA2B,CAAC,GAAG,MAAM,CAAA;YACpD,CAAC;QACL,CAAC;QAED,OAAO,UAAU,CAAA;IACrB,CAAC;IAED;;OAEG,CACH,QAAQ,GAAA;QACJ,0BAA0B;QAC1B,MAAM,CAAC,KAAK,EAAE,UAAU,CAAC,GAAG,IAAI,CAAC,qBAAqB,EAAE,CAAA;QACxD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,UAAU,CAAC,CAAA;QAClD,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;OAGG,CACH,MAAM,GAAA;QACF,OAAO,IAAI,CAAC,qBAAqB,EAAE,CAAC,CAAC,CAAC,CAAA;IAC1C,CAAC;IAED;;OAEG,CACH,qBAAqB,GAAA;QACjB,iHAAiH;QACjH,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAA;QAC7B,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE,CAAA;QACvC,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,yBAAyB,CACnD,KAAK,EACL,UAAU,EACV,IAAI,CAAC,aAAa,CAAC,gBAAgB,CACtC,CAAA;IACL,CAAC;IAED;;OAEG,CACH,KAAK,CAAC,OAAO,GAAA;QACT,MAAM,CAAC,GAAG,EAAE,UAAU,CAAC,GAAG,IAAI,CAAC,qBAAqB,EAAE,CAAA;QACtD,MAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAA;QAC5C,IAAI,CAAC;YACD,OAAO,MAAM,WAAW,CAAC,KAAK,CAAC,GAAG,EAAE,UAAU,CAAC,CAAA,CAAC,oDAAoD;QACxG,CAAC,QAAS,CAAC;YACP,IAAI,WAAW,KAAK,IAAI,CAAC,WAAW,EAAE,CAAC;gBACnC,wCAAwC;gBACxC,MAAM,WAAW,CAAC,OAAO,EAAE,CAAA;YAC/B,CAAC;QACL,CAAC;IACL,CAAC;IAED;;;OAGG,CACH,kBAAkB,CAAC,WAAyB,EAAA;QACxC,OAAO,IAAK,IAAI,CAAC,WAAmB,CAChC,IAAI,CAAC,UAAU,EACf,WAAW,IAAI,IAAI,CAAC,WAAW,CAClC,CAAA;IACL,CAAC;IAED;;;;;OAKG,CACH,KAAK,GAAA;QACD,OAAO,IAAK,IAAI,CAAC,WAAmB,CAAC,IAAI,CAAC,CAAA;IAC9C,CAAC;IAED;;;;OAIG,CACH,OAAO,CAAC,OAAe,EAAA;QACnB,IAAI,CAAC,aAAa,CAAC,OAAO,GAAG,OAAO,CAAA;QACpC,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,eAAe,GAAA;QACX,IAAI,CAAC,aAAa,CAAC,eAAe,GAAG,KAAK,CAAA;QAC1C,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,MAAM,CAAC,IAAY,EAAA;QACf,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,eAAe,EAAE,OAAO,IAAI,CAAA;QACpD,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IAC9C,CAAC;IAED;;OAEG,CACH,cAAc,CAAC,WAAwB,EAAA;QACnC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAA;QAC9B,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;OAGG,CACH,aAAa,CAAC,OAAgB,EAAA;QAC1B,IAAI,CAAC,aAAa,CAAC,aAAa,GAAG,OAAO,CAAA;QAC1C,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,cAAc,CAAC,OAAgB,EAAA;QAC3B,IAAI,CAAC,aAAa,CAAC,cAAc,GAAG,OAAO,CAAA;QAC3C,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,wBAAwB,CACpB,YAAwC,EACxC,KAAa,EACb,OAAgC,EAAA;QAEhC,IAAI,CAAC,aAAa,CAAC,sBAAsB,CAAC,IAAI,CAAC;YAC3C,YAAY;YACZ,KAAK;YACL,OAAO,EAAE,OAAO,IAAI,CAAA,CAAE;SACzB,CAAC,CAAA;QACF,OAAO,IAAI,CAAA;IACf,CAAC;IAED,4EAA4E;IAC5E,oBAAoB;IACpB,4EAA4E;IAE5E;;;OAGG,CACO,YAAY,CAAC,SAAiB,EAAA;QACpC,OAAO,SAAS,CACX,KAAK,CAAC,GAAG,CAAC,CACV,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;YACP,sMAAsM;YACtM,IAAI,CAAC,KAAK,EAAE,EAAE,OAAO,CAAC,CAAA;YACtB,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAA;QACzB,CAAC,CAAC,CACD,IAAI,CAAC,GAAG,CAAC,CAAA;IAClB,CAAC;IAED;;OAEG,CACO,gBAAgB,GAAA;QACtB,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,EAC7B,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,qGAAA,CAAuG,CAC1G,CAAA;QAEL,IAAI,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,WAAW,EACxC,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAC,SAAS,CAAA;QAE1D,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,SAAU,CAAA;IAClD,CAAC;IAED;;;OAGG,CACO,eAAe,CACrB,YAEgE,EAChE,SAAkB,EAAA;QAElB,yEAAyE;QACzE,uGAAuG;QACvG,IAAI,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,YAAY,CAAC,EAAE,CAAC;YAC5C,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,YAAY,CAAC,CAAA;YAE1D,OAAO,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;gBAClC,IAAI,EAAE,MAAM;gBACZ,IAAI,EAAE,SAAS;gBACf,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,YAAY,CAAC;gBACnD,SAAS,EAAE,QAAQ,CAAC,SAAS;aAChC,CAAC,CAAA;QACN,CAAC,MAAM,CAAC;YACJ,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE,CAAC;gBACnC,MAAM,UAAU,GACZ,YAAY,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,IACjC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAA;gBAEnC,OAAO,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;oBAClC,IAAI,EAAE,MAAM;oBACZ,IAAI,EAAE,SAAS;oBACf,SAAS,EAAE,CAAC,UAAU,GACf,YAAuB,GACxB,SAAS;oBACf,QAAQ,EAAE,UAAU,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS;iBAClD,CAAC,CAAA;YACN,CAAC;YAED,MAAM,eAAe,GACjB,YACH,CAAE,IAAuC,CAAC,QAAQ,EAAE,CAAC,CAAA;YACtD,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,aAAa,EAAE,CAAC,CAAA;YACnD,MAAM,QAAQ,GAAG,eAAe,CAAC,QAAQ,EAAE,CAAA;YAE3C,OAAO,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;gBAClC,IAAI,EAAE,MAAM;gBACZ,IAAI,EAAE,SAAS;gBACf,QAAQ,EAAE,QAAQ;aACrB,CAAC,CAAA;QACN,CAAC;IACL,CAAC;IAED;;;OAGG,CACO,oBAAoB,CAAC,SAAiB,EAAA;QAC5C,OAAO,SAAS,CAAA;IACpB,CAAC;IAED;;OAEG,CACO,oCAAoC,CAAC,SAAiB,EAAA;QAC5D,MAAM,YAAY,GAAiD,CAAA,CAAE,CAAA;QAErE,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,aAAa,CAAC,OAAO,CAAE,CAAC;YAC7C,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,SAAQ;YAChC,MAAM,sBAAsB,GACxB,IAAI,CAAC,aAAa,CAAC,yBAAyB,IAAI,KAAK,CAAC,IAAI,GACpD,GAAG,KAAK,CAAC,IAAI,CAAA,CAAA,CAAG,GAChB,EAAE,CAAA;YAEZ,IAAI,CAAC,YAAY,CAAC,sBAAsB,CAAC,EAAE,CAAC;gBACxC,YAAY,CAAC,sBAAsB,CAAC,GAAG,CAAA,CAAE,CAAA;YAC7C,CAAC;YAED,8FAA8F;YAC9F,iEAAiE;YACjE,0BAA0B;YAC1B,oDAAoD;YACpD,yCAAyC;YACzC,yBAAyB;YACzB,yBAAyB;YACzB,yBAAyB;YAEzB,KAAK,MAAM,QAAQ,IAAI,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAE,CAAC;gBAC9C,IAAI,QAAQ,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,EAC/B,YAAY,CAAC,sBAAsB,CAAC,CAChC,QAAQ,CAAC,YAAY,CACxB,GAAG,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,YAAY,CAAA;YAChD,CAAC;YAED,KAAK,MAAM,QAAQ,IAAI,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAE,CAAC;gBAC9C,MAAM,UAAU,GAAG;uBACZ,QAAQ,CAAC,WAAW;uBACpB,QAAQ,CAAC,kBAAkB;iBACjC,CAAA;gBACD,KAAK,MAAM,UAAU,IAAI,UAAU,CAAE,CAAC;oBAClC,MAAM,WAAW,GAAG,GAAG,QAAQ,CAAC,YAAY,CAAA,CAAA,EACxC,UAAU,CAAC,gBAAiB,CAAC,YACjC,EAAE,CAAA;oBACF,YAAY,CAAC,sBAAsB,CAAC,CAAC,WAAW,CAAC,GAC7C,UAAU,CAAC,YAAY,CAAA;gBAC/B,CAAC;YACL,CAAC;YAED,KAAK,MAAM,MAAM,IAAI,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAE,CAAC;gBAC1C,YAAY,CAAC,sBAAsB,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,GACrD,MAAM,CAAC,YAAY,CAAA;YAC3B,CAAC;YAED,KAAK,MAAM,MAAM,IAAI,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAE,CAAC;gBAC1C,YAAY,CAAC,sBAAsB,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,GACrD,MAAM,CAAC,YAAY,CAAA;YAC3B,CAAC;YAED,KAAK,MAAM,MAAM,IAAI,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAE,CAAC;gBAC1C,YAAY,CAAC,sBAAsB,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,GACrD,MAAM,CAAC,YAAY,CAAA;YAC3B,CAAC;QACL,CAAC;QAED,MAAM,eAAe,GAAG,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAA;QACjD,MAAM,wBAAwB,GAAG,eAAe,CAC3C,GAAG,CAAC,CAAC,GAAG,EAAE,CAAG,CAAD,AAAC,GAAA,eAAA,YAAY,EAAC,GAAG,CAAC,CAAC,CAC/B,IAAI,CAAC,GAAG,CAAC,CAAA;QAEd,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC7B,SAAS,GAAG,SAAS,CAAC,OAAO,CACzB,IAAI,MAAM,CACN,wDAAwD;YACxD,CAAA,aAAA,CAAe,GAAG,gCAAgC;YAC9C,kDAAkD;YAClD,GACI,wBAAwB,GAClB,GAAG,GAAG,wBAAwB,GAAG,GAAG,GACpC,EACV,CAAA,WAAA,CAAa,GAAG,6DAA6D;YAC7E,sCAAsC;YACtC,CAAA,gBAAA,CAAkB,EACtB,IAAI,CACP,EACD,CAAC,GAAG,OAAO,EAAE,EAAE;gBACX,IAAI,KAAa,EAAE,GAAW,EAAE,CAAS,CAAA;gBACzC,IAAI,wBAAwB,EAAE,CAAC;oBAC3B,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAA;oBAClB,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,CAAA;oBAChB,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAA;oBAEd,IAAI,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;wBAC9B,OAAO,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,CACvB,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CACjD,CAAA,CAAA,EAAI,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAA;oBACnD,CAAC;gBACL,CAAC,MAAM,CAAC;oBACJ,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAA;oBAClB,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,CAAA;oBAChB,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAA;oBAEd,IAAI,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;wBACtB,OAAO,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAA;oBACtD,CAAC;gBACL,CAAC;gBACD,OAAO,KAAK,CAAA;YAChB,CAAC,CACJ,CAAA;QACL,CAAC;QAED,OAAO,SAAS,CAAA;IACpB,CAAC;IAES,aAAa,GAAA;QACnB,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC;YAC9B,OAAO,EAAE,CAAA;QACb,CAAC;QAED,2FAA2F;QAC3F,0FAA0F;QAC1F,uFAAuF;QACvF,gCAAgC;QAEhC,OAAO,CAAA,GAAA,EAAM,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAA,IAAA,CAAM,CAAA;IACtE,CAAC;IAED;;OAEG,CACO,qBAAqB,GAAA;QAC3B,IACI,IAAI,CAAC,aAAa,CAAC,SAAS,KAAK,QAAQ,IACzC,IAAI,CAAC,aAAa,CAAC,UAAU,EAC/B,CAAC;YACC,OAAO,CAAA,mBAAA,EAAsB,IAAI,CAAC,aAAa,CAAC,UAAU,EAAE,CAAA;QAChE,CAAC;QAED,OAAO,EAAE,CAAA;IACb,CAAC;IAED;;OAEG,CACO,qBAAqB,GAAA;QAC3B,MAAM,eAAe,GAAG,EAAE,CAAA;QAE1B,MAAM,eAAe,GAAG,IAAI,CAAC,4BAA4B,CACrD,IAAI,CAAC,aAAa,CAAC,MAAM,CAC5B,CAAA;QAED,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,IAAI,eAAe,KAAK,KAAK,EAAE,CAAC;YAC1D,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,eAAe,CAAC,CAAC,CAAA;QACpE,CAAC;QAED,IAAI,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,WAAW,EAAE,CAAC;YAC5C,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,CAAA;YACvD,sGAAsG;YACtG,IACI,IAAI,CAAC,aAAa,CAAC,SAAS,KAAK,QAAQ,IACzC,CAAC,IAAI,CAAC,aAAa,CAAC,WAAW,IAC/B,QAAQ,CAAC,gBAAgB,EAC3B,CAAC;gBACC,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,yBAAyB,GACrD,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,GAClC,GAAG,GACH,QAAQ,CAAC,gBAAgB,CAAC,YAAY,GACtC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CAAA;gBAE5C,MAAM,SAAS,GAAG,GAAG,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAA,QAAA,CAAU,CAAA;gBAChE,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;YACnC,CAAC;YAED,IAAI,QAAQ,CAAC,mBAAmB,IAAI,QAAQ,CAAC,oBAAoB,EAAE,CAAC;gBAChE,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,yBAAyB,GACrD,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,GAClC,GAAG,GACH,QAAQ,CAAC,mBAAmB,CAAC,YAAY,GACzC,QAAQ,CAAC,mBAAmB,CAAC,YAAY,CAAA;gBAE/C,MAAM,SAAS,GAAG,GAAG,IAAI,CAAC,oBAAoB,CAC1C,MAAM,CACT,CAAA,mCAAA,CAAqC,CAAA;gBACtC,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;YACnC,CAAC;QACL,CAAC;QAED,IAAI,IAAI,CAAC,aAAa,CAAC,8BAA8B,EAAE,CAAC;YACpD,MAAM,SAAS,GAAG,IAAI,CAAC,oBAAoB,CACvC,IAAI,CAAC,aAAa,CAAC,8BAA8B,CACpD,CAAA;YACD,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;QACnC,CAAC;QAED,IAAI,SAAS,GAAG,EAAE,CAAA;QAElB,cAAc;QACd,SAAS,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAA;QAEzC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC;YAC1B,SAAS,IAAI,EAAE,CAAA;QACnB,CAAC,MAAM,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACtC,SAAS,IAAI,CAAA,OAAA,EAAU,eAAe,CAAC,CAAC,CAAC,EAAE,CAAA;QAC/C,CAAC,MAAM,CAAC;YACJ,SAAS,IAAI,CAAA,SAAA,EAAY,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA,EAAA,CAAI,CAAA;QAClE,CAAC;QAED,OAAO,SAAS,CAAA;IACpB,CAAC;IAED;;OAEG,CACO,yBAAyB,CAAC,aAA4B,EAAA;QAC5D,MAAM,OAAO,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAA;QAC1C,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAA;QAErC,kEAAkE;QAClE,iCAAiC;QACjC,IACI,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,KAAK,QAAQ,IAChD,IAAI,CAAC,aAAa,CAAC,qBAAqB,CAAC,MAAM,GAAG,CAAC,IACnD,MAAM,CAAC,uBAAuB,CAAC,aAAa,CAAC,EAC/C,CAAC;YACC,OAAO,CAAC,IAAI,CACR,GAAG,IAAI,CAAC,aAAa,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE;gBAC1D,OAAO,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAA;YACzC,CAAC,CAAC,CACL,CAAA;QACL,CAAC;QAED,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;YACjB,IAAI,iBAAiB,GAAG,OAAO,CAC1B,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE;gBACZ,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA;gBAC7C,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;oBAClC,IACI,IAAI,CAAC,aAAa,CAAC,SAAS,KAAK,QAAQ,IACzC,IAAI,CAAC,aAAa,CAAC,SAAS,KAAK,QAAQ,IACzC,IAAI,CAAC,aAAa,CAAC,SAAS,KAAK,aAAa,IAC9C,IAAI,CAAC,aAAa,CAAC,SAAS,KAAK,SAAS,EAC5C,CAAC;wBACC,OAAO,WAAW,GAAG,IAAI,CAAA;oBAC7B,CAAC,MAAM,CAAC;wBACJ,OAAO,AACH,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,gBAAgB,EAAE,CAAC,GACpC,GAAG,GACH,IAAI,CACP,CAAA;oBACL,CAAC;gBACL,CAAC,MAAM,CAAC;oBACJ,OAAO,IAAI,CAAA;gBACf,CAAC;YACL,CAAC,CAAC,CACD,IAAI,CAAC,IAAI,CAAC,CAAA;YAEf,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;gBACnC,iBAAiB,IACb,QAAQ,GACR,OAAO,CACF,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE;oBACZ,OAAO,IAAI,CAAC,eAAe,CAAC;wBACxB,IAAI,EACA,MACH,CAAC,2BAA2B,CAAC,MAAM,CAAC,IAAI,CAAC;wBAC1C,GAAG,EAAG,MAAuB,CAAC,MAAM,CAAC,QAAQ;qBAChD,CAAC,CAAA;gBACN,CAAC,CAAC,CACD,IAAI,CAAC,IAAI,CAAC,CAAA;YACvB,CAAC;YAED,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;gBAClC,IACI,IAAI,CAAC,aAAa,CAAC,SAAS,KAAK,QAAQ,IACzC,IAAI,CAAC,aAAa,CAAC,SAAS,KAAK,QAAQ,EAC3C,CAAC;oBACC,iBAAiB,IAAI,oBAAoB,CAAA;gBAC7C,CAAC;YACL,CAAC;YAED,OAAO,iBAAiB,CAAA;QAC5B,CAAC,MAAM,IAAI,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,KAAK,QAAQ,EAAE,CAAC;YAC1D,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAA;QACvC,CAAC;QAED,OAAO,EAAE,CAAA;IACb,CAAC;IAED;;;OAGG,CACO,mBAAmB,GAAA;QACzB,MAAM,OAAO,GAAqB,EAAE,CAAA;QACpC,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,CAAC;;YAC5C,IAAI,CAAC,aAAa,CAAC,SAAsB,CAAC,OAAO,CAC/C,CAAC,UAAU,EAAE,EAAE;gBACX,IAAI,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,WAAW,EAAE,CAAC;oBAC5C,OAAO,CAAC,IAAI,CACR,GAAG,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,CAAC,2BAA2B,CACjE,UAAU,CACb,CACJ,CAAA;gBACL,CAAC;YACL,CAAC,CACJ,CAAA;QACL,CAAC;QACD,OAAO,OAAO,CAAA;IAClB,CAAC;IAES,4BAA4B,CAAC,OAAsB,EAAA;QACzD,OAAO,OAAO,CACT,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YACnB,MAAM,UAAU,GAAG,IAAI,CAAC,8BAA8B,CAClD,MAAM,CAAC,SAAS,CACnB,CAAA;YAED,OAAQ,MAAM,CAAC,IAAI,EAAE,CAAC;gBAClB,KAAK,KAAK;oBACN,OAAO,AACH,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,GACzB,GACI,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,sBAAsB,GACxC,GAAG,GACH,EACV,GAAG,UAAU,GACT,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,sBAAsB,GACxC,GAAG,GACH,EACV,EAAE,CACL,CAAA;gBACL,KAAK,IAAI;oBACL,OACI,AADG,CACF,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,GACxB,GACI,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,sBAAsB,GACxC,GAAG,GACH,EACV,GAAG,UAAU,GACT,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,sBAAsB,GACxC,GAAG,GACH,EACV,EAAE,CACL,CAAA;YACT,CAAC;YAED,OAAO,UAAU,CAAA;QACrB,CAAC,CAAC,CACD,IAAI,CAAC,GAAG,CAAC,CACT,IAAI,EAAE,CAAA;IACf,CAAC;IAED;;OAEG,CACO,8BAA8B,CACpC,SAA+B,EAC/B,aAAsB,KAAK,EAAA;QAE3B,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE,OAAO,SAAS,CAAA;QAEnD,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC;YAC3B,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBACzB,OAAO,KAAK,CAAA;YAChB,CAAC;YAED,gEAAgE;YAChE,yDAAyD;YACzD,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC;gBACxC,OAAO,IAAI,CAAC,4BAA4B,CAAC,SAAS,CAAC,CAAA;YACvD,CAAC;YAED,OAAO,GAAG,GAAG,IAAI,CAAC,4BAA4B,CAAC,SAAS,CAAC,GAAG,GAAG,CAAA;QACnE,CAAC;QAED,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAA;QAElC,OAAQ,SAAS,CAAC,QAAQ,EAAE,CAAC;YACzB,KAAK,UAAU;gBACX,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,GAAA,EAAM,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;YACpE,KAAK,iBAAiB;gBAClB,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,IAAA,EAAO,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;YACrE,KAAK,eAAe;gBAChB,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,IAAA,EAAO,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;YACrE,KAAK,cAAc;gBACf,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,YAAA,EAAe,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;YAC7E,KAAK,kBAAkB;gBACnB,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,IAAA,EAAO,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;YACrE,KAAK,cAAc;gBACf,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,IAAA,EAAO,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;YACrE,KAAK,UAAU;gBACX,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,GAAA,EAAM,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;YACpE,KAAK,iBAAiB;gBAClB,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,IAAA,EAAO,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;YACrE,KAAK,UAAU;gBACX,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,IAAA,EAAO,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;YACrE,KAAK,OAAO;gBACR,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,GAAA,EAAM,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;YACpE,KAAK,OAAO;gBACR,IACI,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,UAAU,IAClC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,aAAa,EACvC,CAAC;oBACC,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,OAAA,EAAU,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;gBACxE,CAAC;gBAED,OAAO,CAAA,MAAA,EAAS,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,aAAA,EAAgB,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,CAAA,CAAG,CAAA;YACrF,KAAK,MAAM;gBACP,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,MAAA,EAAS,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;YACvE,KAAK,SAAS;gBACV,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,SAAA,EAAY,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,KAAA,EAAQ,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAA;YACzG,KAAK,IAAI;gBACL,IAAI,SAAS,CAAC,UAAU,CAAC,MAAM,IAAI,CAAC,EAAE,CAAC;oBACnC,OAAO,KAAK,CAAA;gBAChB,CAAC;gBACD,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,KAAA,EAAQ,SAAS,CAAC,UAAU,CACxD,KAAK,CAAC,CAAC,CAAC,CACR,IAAI,CAAC,IAAI,CAAC,CAAA,CAAA,CAAG,CAAA;YACtB,KAAK,KAAK;gBACN,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,aAAa,EAAE,CAAC;oBACxC,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,eAAA,EAAkB,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,WAAA,CAAa,CAAA;gBAC3F,CAAC;gBAED,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,OAAA,EAAU,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,CAAA,CAAG,CAAA;YACzE,KAAK,QAAQ;gBACT,OAAO,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA,QAAA,CAAU,CAAA;YAE/C,KAAK,KAAK;gBACN,OAAO,CAAA,IAAA,EAAO,IAAI,CAAC,8BAA8B,CAC7C,SAAS,CAAC,SAAS,CACtB,CAAA,CAAA,CAAG,CAAA;YACR,KAAK,UAAU;gBACX,OAAO,GAAG,IAAI,CAAC,8BAA8B,CACzC,SAAS,CAAC,SAAS,EACnB,IAAI,CACP,EAAE,CAAA;YACP,KAAK,KAAK;gBACN,OAAO,GAAG,GAAG,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,GAAG,CAAA;YACzD,KAAK,IAAI;gBACL,OAAO,GAAG,GAAG,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG,CAAA;QAC5D,CAAC;QAED,MAAM,IAAI,SAAS,CACf,CAAA,yBAAA,EAA4B,eAAA,YAAY,CAAC,WAAW,CAAC,IAAI,EAAE,CAC9D,CAAA;IACL,CAAC;IAES,mBAAmB,GAAA;QACzB,IAAI,CAAC,IAAI,CAAC,yBAAyB,EAAE,EAAE,CAAC;YACpC,OAAO,EAAE,CAAA;QACb,CAAC;QACD,MAAM,2BAA2B,GAC7B,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,qBAAqB,CAAA;QAEhE,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,sBAAsB,CAAC,GAAG,CAC5D,CAAC,GAAG,EAAE,EAAE;YACJ,IAAI,iBAAiB,GACjB,OAAO,GAAG,CAAC,YAAY,KAAK,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,CAAA;YAChE,IAAI,OAAO,GAAG,CAAC,YAAY,KAAK,QAAQ,EAAE,CAAC;gBACvC,IAAI,GAAG,CAAC,YAAY,CAAC,yBAAyB,EAAE,EAAE,CAAC;oBAC/C,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,mCAAA,EAAsC,GAAG,CAAC,KAAK,CAAA,CAAA,CAAG,CACrD,CAAA;gBACL,CAAC;gBACD,iBAAiB,GAAG,GAAG,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAA;gBAC/C,IACI,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,QAAQ,IAChD,CAAC,kBAAA,eAAe,CAAC,oBAAoB,CAAC,GAAG,CAAC,YAAY,CAAC,EACzD,CAAC;oBACC,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,6CAAA,EAAgD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAA,OAAA,EAAU,GAAG,CAAC,KAAK,CAAA,CAAA,CAAG,CACrG,CAAA;gBACL,CAAC;gBACD,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,YAAY,CAAC,aAAa,EAAE,CAAC,CAAA;YACxD,CAAC;YACD,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAA;YACtC,IAAI,GAAG,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;gBAC1B,MAAM,kBAAkB,GAAG,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,CAClD,CAAC,MAAM,EAAE,CAAG,CAAD,GAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAClC,CAAA;gBACD,IACI,kBAAA,eAAe,CAAC,oBAAoB,CAAC,GAAG,CAAC,YAAY,CAAC,EACxD,CAAC;oBACC,IACI,GAAG,CAAC,YAAY,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,IAC7C,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,MAAM,KAC1B,GAAG,CAAC,YAAY,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,EACnD,CAAC;wBACC,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,gCAAA,EAAmC,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,MAAM,CAAA,4CAAA,EAA+C,GAAG,CAAC,YAAY,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,CAAA,OAAA,EAAU,GAAG,CAAC,KAAK,CAAA,CAAA,CAAG,CACtL,CAAA;oBACL,CAAC;gBACL,CAAC;gBACD,SAAS,IAAI,CAAA,CAAA,EAAI,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,CAAA,CAAG,CAAA;YACrD,CAAC;YACD,MAAM,eAAe,GACjB,GAAG,CAAC,OAAO,CAAC,SAAS,IAAI,2BAA2B,GAC9C,WAAW,GACX,EAAE,CAAA;YACZ,IAAI,iBAAiB,GAAG,EAAE,CAAA;YAC1B,IACI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,eAAe,CAAC,gBAAgB,IACvD,GAAG,CAAC,OAAO,CAAC,YAAY,KAAK,SAAS,EACxC,CAAC;gBACC,iBAAiB,GAAG,GAAG,CAAC,OAAO,CAAC,YAAY,GACtC,cAAc,GACd,kBAAkB,CAAA;YAC5B,CAAC;YAED,OAAO;gBACH,eAAe;gBACf,SAAS;gBACT,IAAI;gBACJ,iBAAiB;gBACjB,CAAA,CAAA,EAAI,iBAAiB,CAAA,CAAA,CAAG;aAC3B,CACI,MAAM,CAAC,OAAO,CAAC,CACf,IAAI,CAAC,GAAG,CAAC,CAAA;QAClB,CAAC,CACJ,CAAA;QAED,OAAO,OAAO,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAA;IAChD,CAAC;IAED;;OAEG,CACO,sBAAsB,CAC5B,GAAgB,EAAA;QAEhB,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,CAAA;QACvD,MAAM,UAAU,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAAC,GAAG;SAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAC3D,CAD6D,OACrD,CAAC,iBAAiB,CAAC,EAAE,CAAC,CACjC,CAAA;QAED,mDAAmD;QACnD,IAAI,CAAC,QAAQ,CAAC,sBAAsB,EAAE,CAAC;YACnC,MAAM,aAAa,GAAG,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,CAAA;YAEhD,yDAAyD;YACzD,2DAA2D;YAC3D,2EAA2E;YAC3E,IACI,CAAC,aAAa,CAAC,WAAW,IAC1B,CAAC,aAAa,CAAC,gBAAgB,IAC/B,CAAC,aAAa,CAAC,gBAAgB,EACjC,CAAC;gBACC,OAAO;oBACH,CAAC,aAAa,CAAC,YAAY,CAAC,EAAE,CAAA,GAAA,KAAA,EAAE,EAC5B,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAChB,CADkB,YACL,CAAC,cAAc,CAAC,EAAE,EAAE,KAAK,CAAC,CAC1C,CACJ;iBACJ,CAAA;YACL,CAAC;QACL,CAAC;QAED,OAAO,IAAI,WAAA,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE;YACvB,KAAK,MAAM,IAAI,IAAI,UAAU,CAAE,CAAC;gBAC5B,EAAE,CAAC,OAAO,CAAC,IAAI,WAAA,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAG,CAAD,CAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;YACpD,CAAC;QACL,CAAC,CAAC,CAAA;IACN,CAAC;IAES,kBAAkB,CAAC,QAAa,EAAA;QACtC,MAAM,KAAK,GAAG,QAAQ,CACjB,KAAK,EAAE,CACP,OAAO,EAAE,CACT,OAAO,EAAE,CACT,MAAM,CAAC,SAAS,CAAC,CACjB,KAAK,CAAC,SAAS,CAAC,CAChB,IAAI,CAAC,SAAS,CAAC,CACf,IAAI,CAAC,SAAS,CAAC,CACf,MAAM,CAAC,GAAG,CAAC,CACX,SAAS,CAAC,sBAAsB,CAAC,CAAA;QAEtC,OAAO;YAAC,CAAA,QAAA,EAAW,KAAK,CAAC,QAAQ,EAAE,CAAA,CAAA,CAAG;YAAE,KAAK,CAAC,aAAa,EAAE;SAAC,CAAA;IAClE,CAAC;IAEO,0BAA0B,CAC9B,YAAoB,EAAA;QAEpB,mDAAmD;QACnD,+DAA+D;QAE/D,oDAAoD;QACpD,IAAI,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,CAAA;QACxC,MAAM,IAAI,GAAa,EAAE,CAAA;QACzB,MAAM,iBAAiB,GAAG,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;QAEjD,MAAO,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAE,CAAC;YAClC,MAAM,IAAI,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAA;YAEjC,IAAI,CAAC,KAAK,EAAE,WAAW,EAAE,CAAC;gBAGtB,MAAK;YACT,CAAC;YAED,IAAI,KAAK,CAAC,QAAQ,CAAC,2BAA2B,CAAC,IAAI,CAAC,EAAE,CAAC;gBACnD,+EAA+E;gBAC/E,yFAAyF;gBACzF,sBAAsB;gBACtB,iBAAiB,CAAC,OAAO,CACrB,GAAG,iBAAiB,CAAC,KAAK,EAAE,CAAA,CAAA,EAAI,iBAAiB,CAAC,KAAK,EAAE,EAAE,CAC9D,CAAA;gBACD,SAAQ;YACZ,CAAC;YAED,IAAI,KAAK,CAAC,QAAQ,CAAC,2BAA2B,CAAC,IAAI,CAAC,EAAE,CAAC;gBACnD,wDAAwD;gBACxD,uDAAuD;gBACvD,oBAAoB;gBACpB,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,IAAI,CACnD,CAAC,QAAQ,EAAE,CAAG,CAAD,OAAS,CAAC,oBAAoB,KAAK,IAAI,CACvD,CAAA;gBAED,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,CAAC;oBACnB,MAAM,gBAAgB,GAClB,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA,CAAA,EAAI,IAAI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAA;oBACxD,MAAM,IAAI,KAAK,CACX,CAAA,kCAAA,EAAqC,gBAAgB,EAAE,CAC1D,CAAA;gBACL,CAAC;gBAED,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAA;gBACtB,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAA;gBAC7B,iBAAiB,CAAC,KAAK,EAAE,CAAA;gBACzB,SAAQ;YACZ,CAAC;YAED,MAAK;QACT,CAAC;QAED,IAAI,CAAC,KAAK,EAAE,CAAC;YACT,MAAM,IAAI,KAAK,CAAC,CAAA,+BAAA,EAAkC,YAAY,EAAE,CAAC,CAAA;QACrE,CAAC;QAED,8EAA8E;QAC9E,MAAM,iBAAiB,GAAG,iBAAiB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;QAErD,MAAM,OAAO,GACT,KAAK,CAAC,QAAQ,CAAC,2BAA2B,CAAC,iBAAiB,CAAC,CAAA;QAEjE,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;YAClB,MAAM,IAAI,8BAAA,2BAA2B,CAAC,YAAY,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAA;QACvE,CAAC;QAED,OAAO;YAAC,KAAK;YAAE,IAAI;YAAE,OAAO;SAAC,CAAA;IACjC,CAAC;IAED;;OAEG,CACO,kBAAkB,CACxB,QAAwB,EACxB,MAAqB,EACrB,SAAiB,EAAE,EAAA;QAEnB,MAAM,KAAK,GAAa,EAAE,CAAA;QAE1B,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAE,CAAC;YACpC,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAA,CAAA,EAAI,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAA;YAE9C,iEAAiE;YACjE,2FAA2F;YAC3F,IACI,MAAM,CAAC,GAAG,CAAC,KAAK,IAAI,IACpB,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,QAAQ,IAC/B,kBAAA,eAAe,CAAC,cAAc,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAC7C,CAAC;gBACC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;gBAChB,SAAQ;YACZ,CAAC;YAED,IAAI,QAAQ,CAAC,2BAA2B,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC7C,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CACpC,QAAQ,EACR,MAAM,CAAC,GAAG,CAAC,EACX,IAAI,CACP,CAAA;gBACD,KAAK,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,CAAA;gBACvB,SAAQ;YACZ,CAAC;YAED,IAAI,QAAQ,CAAC,2BAA2B,CAAC,IAAI,CAAC,EAAE,CAAC;gBAC7C,MAAM,QAAQ,GAAG,QAAQ,CAAC,4BAA4B,CAAC,IAAI,CAAE,CAAA;gBAE7D,+EAA+E;gBAC/E,qFAAqF;gBACrF,iDAAiD;gBAEjD,qFAAqF;gBACrF,gFAAgF;gBAChF,iEAAiE;gBACjE,IACI,QAAQ,CAAC,YAAY,KAAK,YAAY,IACtC,QAAQ,CAAC,YAAY,KAAK,aAAa,EACzC,CAAC;oBACC,MAAM,WAAW,GAAG,QAAQ,CAAC,WAAW,CACnC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,gBAAgB,CAAC,CAC9B,MAAM,CAAC,CAAC,CAAC,EAAuB,CAAG,CAAD,AAAE,CAAC,CAAC,CAAC,CAAA;oBAE5C,MAAM,iBAAiB,GACnB,WAAW,CAAC,MAAM,GAAG,CAAC,IACtB,WAAW,CAAC,KAAK,CAAC,CAAC,MAAM,EAAE,CACvB,CADyB,KACnB,CAAC,cAAc,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAC5C,CAAA;oBAEL,IAAI,iBAAiB,EAAE,CAAC;wBACpB,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;wBAChB,SAAQ;oBACZ,CAAC;gBACL,CAAC;gBAED,IACI,QAAQ,CAAC,YAAY,KAAK,aAAa,IACvC,QAAQ,CAAC,YAAY,KAAK,cAAc,EAC1C,CAAC;oBACC,MAAM,IAAI,KAAK,CACX,CAAA,oBAAA,EAAuB,QAAQ,CAAC,YAAY,CAAA,cAAA,EAAiB,IAAI,EAAE,CACtE,CAAA;gBACL,CAAC;gBAED,wFAAwF;gBACxF,oFAAoF;gBACpF,2BAA2B;gBAC3B,oFAAoF;gBACpF,gBAAgB;gBAChB,MAAM,cAAc,GAChB,QAAQ,CAAC,qBAAqB,CAAC,cAAc,CAAA;gBACjD,MAAM,iBAAiB,GACnB,cAAc,CAAC,MAAM,GAAG,CAAC,IACzB,cAAc,CAAC,KAAK,CAAC,CAAC,MAAM,EAAE,CAC1B,CAD4B,KACtB,CAAC,cAAc,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAC5C,CAAA;gBAEL,IAAI,iBAAiB,EAAE,CAAC;oBACpB,MAAM,QAAQ,GAAG,cAAc,CAAC,GAAG,CAC/B,CAAC,MAAM,EAAE,CAAG,CAAD,EAAI,IAAI,CAAA,CAAA,EAAI,MAAM,CAAC,YAAY,EAAE,CAC/C,CAAA;oBACD,KAAK,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,CAAA;oBACvB,SAAQ;gBACZ,CAAC;gBAED,yEAAyE;gBACzE,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CACpC,QAAQ,CAAC,qBAAqB,EAC9B,MAAM,CAAC,GAAG,CAAC,CACd,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,EAAI,IAAI,CAAA,CAAA,EAAI,CAAC,EAAE,CAAC,CAAA;gBAC5B,KAAK,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,CAAA;gBACvB,SAAQ;YACZ,CAAC;YAED,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;QACpB,CAAC;QAED,OAAO,KAAK,CAAA;IAChB,CAAC;IAES,CAAC,aAAa,CAAC,KAAoB,EAAA;QACzC,IAAI,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,WAAW,EAAE,CAAC;YAC5C,MAAM,aAAa,GAAG,IAAI,CAAC,kBAAkB,CACzC,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,EACtC,KAAK,CACR,CAAA;YAED,KAAK,MAAM,YAAY,IAAI,aAAa,CAAE,CAAC;gBACvC,MAAM,CAAC,KAAK,EAAE,iBAAiB,EAAE,OAAO,CAAC,GACrC,IAAI,CAAC,0BAA0B,CAAC,YAAY,CAAC,CAAA;gBAEjD,KAAK,MAAM,MAAM,IAAI,OAAO,CAAE,CAAC;oBAC3B,IAAI,cAAc,GAAG,KAAK,CAAA;oBAE1B,KAAK,MAAM,IAAI,IAAI,iBAAiB,CAAE,CAAC;wBACnC,IAAI,CAAC,cAAc,IAAI,CAAC,CAAC,IAAI,IAAI,cAAc,CAAC,EAAE,CAAC;4BAC/C,cAAc,GAAG,CAAA,CAAE,CAAA;4BACnB,MAAK;wBACT,CAAC;wBAED,cAAc,GAAG,cAAc,CAAC,IAAI,CAAC,CAAA;oBACzC,CAAC;oBAED,4DAA4D;oBAC5D,MAAM,SAAS,GAAG,IAAI,CAAC,aAAa,CAC/B,yBAAyB,GACxB,GAAG,KAAK,CAAC,IAAI,CAAA,CAAA,EAAI,MAAM,CAAC,YAAY,EAAE,GACtC,MAAM,CAAC,YAAY,CAAA;oBAEzB,MAAM,cAAc,GAAG,MAAM,CAAC,cAAc,CACxC,cAAc,EACd,IAAI,CACP,CAAA;oBAED,MAAM;wBAAC,SAAS;wBAAE,cAAc;qBAAC,CAAA;gBACrC,CAAC;YACL,CAAC;QACL,CAAC,MAAM,CAAC;YACJ,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAE,CAAC;gBACnC,MAAM,cAAc,GAAG,KAAK,CAAC,GAAG,CAAC,CAAA;gBACjC,MAAM,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,yBAAyB,GACxD,GAAG,IAAI,CAAC,KAAK,CAAA,CAAA,EAAI,GAAG,EAAE,GACtB,GAAG,CAAA;gBAET,MAAM;oBAAC,SAAS;oBAAE,cAAc;iBAAC,CAAA;YACrC,CAAC;QACL,CAAC;IACL,CAAC;IAES,0BAA0B,CAChC,SAAiB,EACjB,cAAmB,EAAA;QAEnB,IAAI,kBAAA,eAAe,CAAC,cAAc,CAAC,cAAc,CAAC,EAAE,CAAC;YACjD,MAAM,UAAU,GAAU,EAAE,CAAA;YAC5B,IAAI,cAAc,CAAC,YAAY,EAAE,CAAC;gBAC9B,IAAI,cAAc,CAAC,uBAAuB,EAAE,CAAC;oBACzC,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,uBAAuB,CAAC,CAAA;gBAC9D,CAAC,MAAM,IAAI,cAAc,CAAC,kBAAkB,EAAE,CAAC;oBAC3C,KAAK,MAAM,CAAC,IAAI,cAAc,CAAC,KAAK,CAAE,CAAC;wBACnC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAA;oBAC5C,CAAC;gBACL,CAAC,MAAM,CAAC;oBACJ,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAA;gBAC/D,CAAC;YACL,CAAC;YAED,IAAI,cAAc,CAAC,IAAI,KAAK,KAAK,EAAE,CAAC;gBAChC,IAAI,cAAc,CAAC,MAAM,EAAE,CAAC;oBACxB,OAAO,cAAc,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;gBAC3C,CAAC,MAAM,CAAC;oBACJ,OAAO;wBACH,QAAQ,EAAE,OAAO;wBACjB,UAAU,EAAE;4BAAC,SAAS;4BAAE,cAAc,CAAC,KAAK;yBAAC;qBAChD,CAAA;gBACL,CAAC;YACL,CAAC,MAAM,IAAI,cAAc,CAAC,IAAI,KAAK,KAAK,EAAE,CAAC;gBACvC,IAAI,cAAc,CAAC,KAAK,EAAE,CAAC;oBACvB,OAAO;wBACH,QAAQ,EAAE,cAAc,CAAC,IAAI;wBAC7B,SAAS,EAAE,IAAI,CAAC,0BAA0B,CACtC,SAAS,EACT,cAAc,CAAC,KAAK,CACvB;qBACJ,CAAA;gBACL,CAAC,MAAM,CAAC;oBACJ,OAAO;wBACH,QAAQ,EAAE,UAAU;wBACpB,UAAU,EAAE;4BAAC,SAAS,EAAE;+BAAG,UAAU;yBAAC;qBACzC,CAAA;gBACL,CAAC;YACL,CAAC,MAAM,IAAI,cAAc,CAAC,IAAI,KAAK,KAAK,EAAE,CAAC;gBACvC,MAAM,MAAM,GAAwB,cAAc,CAAC,KAAK,CAAA;gBAExD,OAAO;oBACH,QAAQ,EAAE,cAAc,CAAC,IAAI;oBAC7B,UAAU,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAC9B,CADgC,GAC5B,CAAC,8BAA8B,CAC/B,IAAI,CAAC,0BAA0B,CAC3B,SAAS,EACT,QAAQ,CACX,CACJ,CACJ;iBACJ,CAAA;YACL,CAAC,MAAM,IAAI,cAAc,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC;gBACtC,MAAM,MAAM,GAAwB,cAAc,CAAC,KAAK,CAAA;gBAExD,OAAO;oBACH,QAAQ,EAAE,cAAc,CAAC,IAAI;oBAC7B,UAAU,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAC9B,CADgC,GAC5B,CAAC,8BAA8B,CAC/B,IAAI,CAAC,0BAA0B,CAC3B,SAAS,EACT,QAAQ,CACX,CACJ,CACJ;iBACJ,CAAA;YACL,CAAC,MAAM,CAAC;gBACJ,OAAO;oBACH,QAAQ,EAAE,cAAc,CAAC,IAAI;oBAC7B,UAAU,EAAE;wBAAC,SAAS,EAAE;2BAAG,UAAU;qBAAC;iBACzC,CAAA;YACL,CAAC;QACD,wCAAwC;QACxC,eAAe;QACf,8BAA8B;QAC9B,wBAAwB;QACxB,yBAAyB;QACzB,YAAY;QACZ,SAAS;QACb,CAAC,MAAM,CAAC;YACJ,OAAO;gBACH,QAAQ,EAAE,OAAO;gBACjB,UAAU,EAAE;oBAAC,SAAS;oBAAE,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC;iBAAC;aAChE,CAAA;QACL,CAAC;IACL,CAAC;IAES,iBAAiB,CACvB,KAMqB,EAAA;QAErB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;YAC5B,OAAO,KAAK,CAAA;QAChB,CAAC;QAED,IAAI,kBAAA,eAAe,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;YACpC,MAAM,iBAAiB,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAA;YAEnD,iBAAiB,CAAC,kBAAkB,GAAG,IAAI,CAAA;YAE3C,iBAAiB,CAAC,aAAa,CAAC,SAAS,GACrC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAA;YAChC,iBAAiB,CAAC,aAAa,CAAC,yBAAyB,GACrD,IAAI,CAAC,aAAa,CAAC,yBAAyB,CAAA;YAChD,iBAAiB,CAAC,aAAa,CAAC,UAAU,GACtC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAA;YACjC,iBAAiB,CAAC,aAAa,CAAC,gBAAgB,GAC5C,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAA;YAEvC,iBAAiB,CAAC,aAAa,CAAC,MAAM,GAAG,EAAE,CAAA;YAE3C,KAAK,CAAC,YAAY,CAAC,iBAAwB,CAAC,CAAA;YAE5C,OAAO;gBACH,QAAQ,EAAE,kBAAA,eAAe,CAAC,aAAa,CAAC,KAAK,CAAC,GACxC,KAAK,GACL,UAAU;gBAChB,SAAS,EAAE,iBAAiB,CAAC,aAAa,CAAC,MAAM;aACpD,CAAA;QACL,CAAC;QAED,IAAI,OAAO,KAAK,KAAK,UAAU,EAAE,CAAC;YAC9B,OAAO,KAAK,CAAC,IAAI,CAAC,CAAA;QACtB,CAAC;QAED,MAAM,MAAM,GAAoB,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YAAC,KAAK;SAAC,CAAA;QACtE,MAAM,OAAO,GAAkB,EAAE,CAAA;QAEjC,KAAK,MAAM,KAAK,IAAI,MAAM,CAAE,CAAC;YACzB,MAAM,UAAU,GAAyB,EAAE,CAAA;YAE3C,wDAAwD;YACxD,KAAK,MAAM,CAAC,SAAS,EAAE,cAAc,CAAC,IAAI,IAAI,CAAC,aAAa,CACxD,KAAK,CACR,CAAE,CAAC;gBACA,UAAU,CAAC,IAAI,CAAC;oBACZ,IAAI,EAAE,KAAK;oBACX,SAAS,EAAE,IAAI,CAAC,0BAA0B,CACtC,SAAS,EACT,cAAc,CACjB;iBACJ,CAAC,CAAA;YACN,CAAC;YAED,OAAO,CAAC,IAAI,CAAC;gBAAE,IAAI,EAAE,IAAI;gBAAE,SAAS,EAAE,UAAU;YAAA,CAAE,CAAC,CAAA;QACvD,CAAC;QAED,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACvB,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAA;QAC/B,CAAC;QAED,OAAO,OAAO,CAAA;IAClB,CAAC;IAED;;OAEG,CACO,iBAAiB,GAAA;QACvB,OAAO,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,UAAU,CAAC,iBAAiB,EAAE,CAAA;IAClE,CAAC;IAES,yBAAyB,GAAA;QAC/B,OAAO,IAAI,CAAC,aAAa,CAAC,sBAAsB,CAAC,MAAM,GAAG,CAAC,CAAA;IAC/D,CAAC;;AAjmDL,QAAA,YAAA,GAAA,aAkmDC;AA9jDG;;GAEG,CACY,aAAA,oBAAoB,GAAwB,CAAA,CAAxB,AAA0B,CAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1677, "column": 0}, "map": {"version":3,"file":"DeleteResult.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/result/DeleteResult.ts"],"sourcesContent":["import { QueryResult } from \"../../query-runner/QueryResult\"\n\n/**\n * Result object returned by DeleteQueryBuilder execution.\n */\nexport class DeleteResult {\n    static from(queryResult: QueryResult) {\n        const result = new this()\n\n        result.raw = queryResult.records\n        result.affected = queryResult.affected\n\n        return result\n    }\n\n    /**\n     * Raw SQL result returned by executed query.\n     */\n    raw: any\n\n    /**\n     * Number of affected rows/documents\n     * Not all drivers support this\n     */\n    affected?: number | null\n}\n"],"names":[],"mappings":";;;;;AAEA;;GAEG,CACH,MAAa,YAAY;IACrB,MAAM,CAAC,IAAI,CAAC,WAAwB,EAAA;QAChC,MAAM,MAAM,GAAG,IAAI,IAAI,EAAE,CAAA;QAEzB,MAAM,CAAC,GAAG,GAAG,WAAW,CAAC,OAAO,CAAA;QAChC,MAAM,CAAC,QAAQ,GAAG,WAAW,CAAC,QAAQ,CAAA;QAEtC,OAAO,MAAM,CAAA;IACjB,CAAC;CAYJ;AApBD,QAAA,YAAA,GAAA,aAoBC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1698, "column": 0}, "map": {"version":3,"file":"DeleteQueryBuilder.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/DeleteQueryBuilder.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { WhereExpressionBuilder } from \"./WhereExpressionBuilder\"\nimport { Brackets } from \"./Brackets\"\nimport { DeleteResult } from \"./result/DeleteResult\"\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class DeleteQueryBuilder<Entity extends ObjectLiteral>\n    extends QueryBuilder<Entity>\n    implements WhereExpressionBuilder\n{\n    readonly \"@instanceof\" = Symbol.for(\"DeleteQueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        connectionOrQueryBuilder: DataSource | QueryBuilder<any>,\n        queryRunner?: QueryRunner,\n    ) {\n        super(connectionOrQueryBuilder as any, queryRunner)\n        this.expressionMap.aliasNamePrefixingEnabled = false\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment()\n        sql += this.createCteExpression()\n        sql += this.createDeleteExpression()\n        return this.replacePropertyNamesForTheWholeQuery(sql.trim())\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<DeleteResult> {\n        const [sql, parameters] = this.getQueryAndParameters()\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            // call before deletion methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                await queryRunner.broadcaster.broadcast(\n                    \"BeforeRemove\",\n                    this.expressionMap.mainAlias!.metadata,\n                )\n            }\n\n            // execute query\n            const queryResult = await queryRunner.query(sql, parameters, true)\n            const deleteResult = DeleteResult.from(queryResult)\n\n            // call after deletion methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                await queryRunner.broadcaster.broadcast(\n                    \"AfterRemove\",\n                    this.expressionMap.mainAlias!.metadata,\n                )\n            }\n\n            // close transaction if we started it\n            if (transactionStartedByUs) await queryRunner.commitTransaction()\n\n            return deleteResult\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        aliasName?: string,\n    ): DeleteQueryBuilder<T> {\n        entityTarget = InstanceChecker.isEntitySchema(entityTarget)\n            ? entityTarget.options.name\n            : entityTarget\n        const mainAlias = this.createFromAlias(entityTarget, aliasName)\n        this.expressionMap.setMainAlias(mainAlias)\n        return this as any as DeleteQueryBuilder<T>\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(\n        where:\n            | Brackets\n            | string\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres = [] // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.getWhereCondition(where)\n        if (condition)\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ]\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(\n        where:\n            | Brackets\n            | string\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(\n        where:\n            | Brackets\n            | string\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Sets WHERE condition in the query builder with a condition for the given ids.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     */\n    whereInIds(ids: any | any[]): this {\n        return this.where(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    andWhereInIds(ids: any | any[]): this {\n        return this.andWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     */\n    orWhereInIds(ids: any | any[]): this {\n        return this.orWhere(this.getWhereInIdsCondition(ids))\n    }\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    output(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    output(output: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this {\n        return this.returning(output)\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    returning(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    returning(returning: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this {\n        // not all databases support returning/output cause\n        if (!this.connection.driver.isReturningSqlSupported(\"delete\")) {\n            throw new ReturningStatementNotSupportedError()\n        }\n\n        this.expressionMap.returning = returning\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates DELETE express used to perform query.\n     */\n    protected createDeleteExpression() {\n        const tableName = this.getTableName(this.getMainTableName())\n        const whereExpression = this.createWhereExpression()\n        const returningExpression = this.createReturningExpression(\"delete\")\n\n        if (returningExpression === \"\") {\n            return `DELETE FROM ${tableName}${whereExpression}`\n        }\n        if (this.connection.driver.options.type === \"mssql\") {\n            return `DELETE FROM ${tableName} OUTPUT ${returningExpression}${whereExpression}`\n        }\n        if (this.connection.driver.options.type === \"spanner\") {\n            return `DELETE FROM ${tableName}${whereExpression} THEN RETURN ${returningExpression}`\n        }\n        return `DELETE FROM ${tableName}${whereExpression} RETURNING ${returningExpression}`\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1880, "column": 0}, "map": {"version":3,"file":"InsertResult.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/result/InsertResult.ts"],"sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\n\n/**\n * Result object returned by InsertQueryBuilder execution.\n */\nexport class InsertResult {\n    static from(queryResult: QueryResult) {\n        const result = new this()\n        result.raw = queryResult.raw\n        return result\n    }\n\n    /**\n     * Contains inserted entity id.\n     * Has entity-like structure (not just column database name and values).\n     */\n    identifiers: ObjectLiteral[] = []\n\n    /**\n     * Generated values returned by a database.\n     * Has entity-like structure (not just column database name and values).\n     */\n    generatedMaps: ObjectLiteral[] = []\n\n    /**\n     * Raw SQL result returned by executed query.\n     */\n    raw: any\n}\n"],"names":[],"mappings":";;;;;AAGA;;GAEG,CACH,MAAa,YAAY;IAAzB,aAAA;QAOI;;;WAGG,CACH,IAAA,CAAA,WAAW,GAAoB,EAAE,CAAA;QAEjC;;;WAGG,CACH,IAAA,CAAA,aAAa,GAAoB,EAAE,CAAA;IAMvC,CAAC;IAtBG,MAAM,CAAC,IAAI,CAAC,WAAwB,EAAA;QAChC,MAAM,MAAM,GAAG,IAAI,IAAI,EAAE,CAAA;QACzB,MAAM,CAAC,GAAG,GAAG,WAAW,CAAC,GAAG,CAAA;QAC5B,OAAO,MAAM,CAAA;IACjB,CAAC;CAkBJ;AAvBD,QAAA,YAAA,GAAA,aAuBC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1910, "column": 0}, "map": {"version":3,"file":"ReturningResultsEntityUpdator.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/ReturningResultsEntityUpdator.ts"],"sourcesContent":["import { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { UpdateResult } from \"./result/UpdateResult\"\nimport { InsertResult } from \"./result/InsertResult\"\nimport { TypeORMError } from \"../error\"\n\n/**\n * Updates entity with returning results in the entity insert and update operations.\n */\nexport class ReturningResultsEntityUpdator {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected queryRunner: QueryRunner,\n        protected expressionMap: QueryExpressionMap,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Updates entities with a special columns after updation query execution.\n     */\n    async update(\n        updateResult: UpdateResult,\n        entities: ObjectLiteral[],\n    ): Promise<void> {\n        const metadata = this.expressionMap.mainAlias!.metadata\n\n        await Promise.all(\n            entities.map(async (entity, entityIndex) => {\n                // if database supports returning/output statement then we already should have updating values in the raw data returned by insert query\n                if (\n                    this.queryRunner.connection.driver.isReturningSqlSupported(\n                        \"update\",\n                    )\n                ) {\n                    if (\n                        this.queryRunner.connection.driver.options.type ===\n                            \"oracle\" &&\n                        Array.isArray(updateResult.raw) &&\n                        this.expressionMap.extraReturningColumns.length > 0\n                    ) {\n                        updateResult.raw = updateResult.raw.reduce(\n                            (newRaw, rawItem, rawItemIndex) => {\n                                newRaw[\n                                    this.expressionMap.extraReturningColumns[\n                                        rawItemIndex\n                                    ].databaseName\n                                ] = rawItem[0]\n                                return newRaw\n                            },\n                            {} as ObjectLiteral,\n                        )\n                    }\n                    const result = Array.isArray(updateResult.raw)\n                        ? updateResult.raw[entityIndex]\n                        : updateResult.raw\n                    const returningColumns =\n                        this.queryRunner.connection.driver.createGeneratedMap(\n                            metadata,\n                            result,\n                        )\n                    if (returningColumns) {\n                        this.queryRunner.manager.merge(\n                            metadata.target as any,\n                            entity,\n                            returningColumns,\n                        )\n                        updateResult.generatedMaps.push(returningColumns)\n                    }\n                } else {\n                    // for driver which do not support returning/output statement we need to perform separate query and load what we need\n                    const updationColumns =\n                        this.expressionMap.extraReturningColumns\n                    if (updationColumns.length > 0) {\n                        // get entity id by which we will get needed data\n                        const entityId =\n                            this.expressionMap.mainAlias!.metadata.getEntityIdMap(\n                                entity,\n                            )\n                        if (!entityId)\n                            throw new TypeORMError(\n                                `Cannot update entity because entity id is not set in the entity.`,\n                            )\n\n                        // execute query to get needed data\n                        const loadedReturningColumns =\n                            (await this.queryRunner.manager\n                                .createQueryBuilder()\n                                .select(\n                                    metadata.primaryColumns.map(\n                                        (column) =>\n                                            metadata.targetName +\n                                            \".\" +\n                                            column.propertyPath,\n                                    ),\n                                )\n                                .addSelect(\n                                    updationColumns.map(\n                                        (column) =>\n                                            metadata.targetName +\n                                            \".\" +\n                                            column.propertyPath,\n                                    ),\n                                )\n                                .from(metadata.target, metadata.targetName)\n                                .where(entityId)\n                                .withDeleted()\n                                .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process\n                                .getOne()) as any\n\n                        if (loadedReturningColumns) {\n                            this.queryRunner.manager.merge(\n                                metadata.target as any,\n                                entity,\n                                loadedReturningColumns,\n                            )\n                            updateResult.generatedMaps.push(\n                                loadedReturningColumns,\n                            )\n                        }\n                    }\n                }\n            }),\n        )\n    }\n\n    /**\n     * Updates entities with a special columns after insertion query execution.\n     */\n    async insert(\n        insertResult: InsertResult,\n        entities: ObjectLiteral[],\n    ): Promise<void> {\n        const metadata = this.expressionMap.mainAlias!.metadata\n        let insertionColumns = metadata.getInsertionReturningColumns()\n\n        // to prevent extra select SQL execution for databases not supporting RETURNING\n        // in the case if we have generated column and it's value returned by underlying driver\n        // we remove this column from the insertionColumns list\n        const needToCheckGenerated =\n            this.queryRunner.connection.driver.isReturningSqlSupported(\"insert\")\n        insertionColumns = insertionColumns.filter((column) => {\n            if (!column.isGenerated) return true\n            return needToCheckGenerated === true\n        })\n\n        const generatedMaps = entities.map((entity, entityIndex) => {\n            if (\n                Array.isArray(insertResult.raw) &&\n                this.expressionMap.extraReturningColumns.length > 0\n            ) {\n                if (\n                    this.queryRunner.connection.driver.options.type === \"oracle\"\n                ) {\n                    insertResult.raw = insertResult.raw.reduce(\n                        (newRaw, rawItem, rawItemIndex) => {\n                            newRaw[\n                                this.expressionMap.extraReturningColumns[\n                                    rawItemIndex\n                                ].databaseName\n                            ] = rawItem[0]\n                            return newRaw\n                        },\n                        {} as ObjectLiteral,\n                    )\n                } else if (\n                    this.queryRunner.connection.driver.options.type ===\n                    \"spanner\"\n                ) {\n                    insertResult.raw = insertResult.raw[0]\n                }\n            }\n\n            // get all values generated by a database for us\n            const result = Array.isArray(insertResult.raw)\n                ? insertResult.raw[entityIndex]\n                : insertResult.raw\n\n            const generatedMap =\n                this.queryRunner.connection.driver.createGeneratedMap(\n                    metadata,\n                    result,\n                    entityIndex,\n                    entities.length,\n                ) || {}\n\n            if (entityIndex in this.expressionMap.locallyGenerated) {\n                this.queryRunner.manager.merge(\n                    metadata.target as any,\n                    generatedMap,\n                    this.expressionMap.locallyGenerated[entityIndex],\n                )\n            }\n\n            this.queryRunner.manager.merge(\n                metadata.target as any,\n                entity,\n                generatedMap,\n            )\n\n            return generatedMap\n        })\n\n        // for postgres and mssql we use returning/output statement to get values of inserted default and generated values\n        // for other drivers we have to re-select this data from the database\n        if (\n            insertionColumns.length > 0 &&\n            !this.queryRunner.connection.driver.isReturningSqlSupported(\n                \"insert\",\n            )\n        ) {\n            const entityIds = entities.map((entity) => {\n                const entityId = metadata.getEntityIdMap(entity)!\n\n                // We have to check for an empty `entityId` - if we don't, the query against the database\n                // effectively drops the `where` clause entirely and the first record will be returned -\n                // not what we want at all.\n                if (!entityId)\n                    throw new TypeORMError(\n                        `Cannot update entity because entity id is not set in the entity.`,\n                    )\n\n                return entityId\n            })\n\n            // to select just inserted entities we need a criteria to select by.\n            // for newly inserted entities in drivers which do not support returning statement\n            // row identifier can only be an increment column\n            // (since its the only thing that can be generated by those databases)\n            // or (and) other primary key which is defined by a user and inserted value has it\n\n            const returningResult: any = await this.queryRunner.manager\n                .createQueryBuilder()\n                .select(\n                    metadata.primaryColumns.map(\n                        (column) =>\n                            metadata.targetName + \".\" + column.propertyPath,\n                    ),\n                )\n                .addSelect(\n                    insertionColumns.map(\n                        (column) =>\n                            metadata.targetName + \".\" + column.propertyPath,\n                    ),\n                )\n                .from(metadata.target, metadata.targetName)\n                .where(entityIds)\n                .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process\n                .getMany()\n\n            entities.forEach((entity, entityIndex) => {\n                this.queryRunner.manager.merge(\n                    metadata.target as any,\n                    generatedMaps[entityIndex],\n                    returningResult[entityIndex],\n                )\n\n                this.queryRunner.manager.merge(\n                    metadata.target as any,\n                    entity,\n                    returningResult[entityIndex],\n                )\n            })\n        }\n\n        entities.forEach((entity, entityIndex) => {\n            const entityId = metadata.getEntityIdMap(entity)!\n            insertResult.identifiers.push(entityId)\n            insertResult.generatedMaps.push(generatedMaps[entityIndex])\n        })\n    }\n\n    /**\n     * Columns we need to be returned from the database when we update entity.\n     */\n    getUpdationReturningColumns(): ColumnMetadata[] {\n        return this.expressionMap.mainAlias!.metadata.columns.filter(\n            (column) => {\n                return (\n                    column.asExpression !== undefined ||\n                    column.isUpdateDate ||\n                    column.isVersion\n                )\n            },\n        )\n    }\n\n    /**\n     * Columns we need to be returned from the database when we soft delete and restore entity.\n     */\n    getSoftDeletionReturningColumns(): ColumnMetadata[] {\n        return this.expressionMap.mainAlias!.metadata.columns.filter(\n            (column) => {\n                return (\n                    column.asExpression !== undefined ||\n                    column.isUpdateDate ||\n                    column.isVersion ||\n                    column.isDeleteDate\n                )\n            },\n        )\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2049, "column": 0}, "map": {"version":3,"file":"InsertQueryBuilder.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/InsertQueryBuilder.ts"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { AuroraMysqlDriver } from \"../driver/aurora-mysql/AuroraMysqlDriver\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\"\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\"\nimport { TypeORMError } from \"../error\"\nimport { InsertValuesMissingError } from \"../error/InsertValuesMissingError\"\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { InsertOrUpdateOptions } from \"./InsertOrUpdateOptions\"\nimport { QueryBuilder } from \"./QueryBuilder\"\nimport { QueryDeepPartialEntity } from \"./QueryPartialEntity\"\nimport { InsertResult } from \"./result/InsertResult\"\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\"\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class InsertQueryBuilder<\n    Entity extends ObjectLiteral,\n> extends QueryBuilder<Entity> {\n    readonly \"@instanceof\" = Symbol.for(\"InsertQueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment()\n        sql += this.createCteExpression()\n        sql += this.createInsertExpression()\n        return this.replacePropertyNamesForTheWholeQuery(sql.trim())\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<InsertResult> {\n        // console.time(\".value sets\");\n        const valueSets: ObjectLiteral[] = this.getValueSets()\n        // console.timeEnd(\".value sets\");\n\n        // If user passed empty array of entities then we don't need to do\n        // anything.\n        //\n        // Fixes GitHub issues #3111 and #5734. If we were to let this through\n        // we would run into problems downstream, like subscribers getting\n        // invoked with the empty array where they expect an entity, and SQL\n        // queries with an empty VALUES clause.\n        if (valueSets.length === 0) return new InsertResult()\n\n        // console.time(\"QueryBuilder.execute\");\n        // console.time(\".database stuff\");\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            // console.timeEnd(\".database stuff\");\n\n            // call before insertion methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                const broadcastResult = new BroadcasterResult()\n                valueSets.forEach((valueSet) => {\n                    queryRunner.broadcaster.broadcastBeforeInsertEvent(\n                        broadcastResult,\n                        this.expressionMap.mainAlias!.metadata,\n                        valueSet,\n                    )\n                })\n                await broadcastResult.wait()\n            }\n\n            let declareSql: string | null = null\n            let selectOutputSql: string | null = null\n\n            // if update entity mode is enabled we may need extra columns for the returning statement\n            // console.time(\".prepare returning statement\");\n            const returningResultsEntityUpdator =\n                new ReturningResultsEntityUpdator(\n                    queryRunner,\n                    this.expressionMap,\n                )\n\n            const returningColumns: ColumnMetadata[] = []\n\n            if (\n                Array.isArray(this.expressionMap.returning) &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                for (const columnPath of this.expressionMap.returning) {\n                    returningColumns.push(\n                        ...this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(\n                            columnPath,\n                        ),\n                    )\n                }\n            }\n\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                if (\n                    !(\n                        valueSets.length > 1 &&\n                        this.connection.driver.options.type === \"oracle\"\n                    )\n                ) {\n                    this.expressionMap.extraReturningColumns =\n                        this.expressionMap.mainAlias!.metadata.getInsertionReturningColumns()\n                }\n\n                returningColumns.push(\n                    ...this.expressionMap.extraReturningColumns.filter(\n                        (c) => !returningColumns.includes(c),\n                    ),\n                )\n            }\n\n            if (\n                returningColumns.length > 0 &&\n                this.connection.driver.options.type === \"mssql\"\n            ) {\n                declareSql = (\n                    this.connection.driver as SqlServerDriver\n                ).buildTableVariableDeclaration(\n                    \"@OutputTable\",\n                    returningColumns,\n                )\n                selectOutputSql = `SELECT * FROM @OutputTable`\n            }\n            // console.timeEnd(\".prepare returning statement\");\n\n            // execute query\n            // console.time(\".getting query and parameters\");\n            const [insertSql, parameters] = this.getQueryAndParameters()\n            // console.timeEnd(\".getting query and parameters\");\n\n            // console.time(\".query execution by database\");\n            const statements = [declareSql, insertSql, selectOutputSql]\n            const sql = statements.filter((s) => s != null).join(\";\\n\\n\")\n\n            const queryResult = await queryRunner.query(sql, parameters, true)\n\n            const insertResult = InsertResult.from(queryResult)\n\n            // console.timeEnd(\".query execution by database\");\n\n            // load returning results and set them to the entity if entity updation is enabled\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                // console.time(\".updating entity\");\n                await returningResultsEntityUpdator.insert(\n                    insertResult,\n                    valueSets,\n                )\n                // console.timeEnd(\".updating entity\");\n            }\n\n            // call after insertion methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                const broadcastResult = new BroadcasterResult()\n                valueSets.forEach((valueSet) => {\n                    queryRunner.broadcaster.broadcastAfterInsertEvent(\n                        broadcastResult,\n                        this.expressionMap.mainAlias!.metadata,\n                        valueSet,\n                    )\n                })\n                await broadcastResult.wait()\n            }\n\n            // close transaction if we started it\n            // console.time(\".commit\");\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n            // console.timeEnd(\".commit\");\n\n            return insertResult\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            // console.time(\".releasing connection\");\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n            // console.timeEnd(\".releasing connection\");\n            // console.timeEnd(\"QueryBuilder.execute\");\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Specifies INTO which entity's table insertion will be executed.\n     */\n    into<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        columns?: string[],\n    ): InsertQueryBuilder<T> {\n        entityTarget = InstanceChecker.isEntitySchema(entityTarget)\n            ? entityTarget.options.name\n            : entityTarget\n        const mainAlias = this.createFromAlias(entityTarget)\n        this.expressionMap.setMainAlias(mainAlias)\n        this.expressionMap.insertColumns = columns || []\n        return this as any as InsertQueryBuilder<T>\n    }\n\n    /**\n     * Values needs to be inserted into table.\n     */\n    values(\n        values:\n            | QueryDeepPartialEntity<Entity>\n            | QueryDeepPartialEntity<Entity>[],\n    ): this {\n        this.expressionMap.valuesSet = values\n        return this\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    output(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    output(output: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this {\n        return this.returning(output)\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    returning(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    returning(returning: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this {\n        // not all databases support returning/output cause\n        if (!this.connection.driver.isReturningSqlSupported(\"insert\")) {\n            throw new ReturningStatementNotSupportedError()\n        }\n\n        this.expressionMap.returning = returning\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after insertion operations.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    updateEntity(enabled: boolean): this {\n        this.expressionMap.updateEntity = enabled\n        return this\n    }\n\n    /**\n     * Adds additional ON CONFLICT statement supported in postgres and cockroach.\n     *\n     * @deprecated Use `orIgnore` or `orUpdate`\n     */\n    onConflict(statement: string): this {\n        this.expressionMap.onConflict = statement\n        return this\n    }\n\n    /**\n     * Adds additional ignore statement supported in databases.\n     */\n    orIgnore(statement: string | boolean = true): this {\n        this.expressionMap.onIgnore = !!statement\n        return this\n    }\n\n    /**\n     * @deprecated\n     *\n     * `.orUpdate({ columns: [ \"is_updated\" ] }).setParameter(\"is_updated\", value)`\n     *\n     * is now `.orUpdate([\"is_updated\"])`\n     *\n     * `.orUpdate({ conflict_target: ['date'], overwrite: ['title'] })`\n     *\n     * is now `.orUpdate(['title'], ['date'])`\n     *\n     */\n    orUpdate(statement?: {\n        columns?: string[]\n        overwrite?: string[]\n        conflict_target?: string | string[]\n    }): this\n\n    orUpdate(\n        overwrite: string[],\n        conflictTarget?: string | string[],\n        orUpdateOptions?: InsertOrUpdateOptions,\n    ): this\n\n    /**\n     * Adds additional update statement supported in databases.\n     */\n    orUpdate(\n        statementOrOverwrite?:\n            | {\n                  columns?: string[]\n                  overwrite?: string[]\n                  conflict_target?: string | string[]\n              }\n            | string[],\n        conflictTarget?: string | string[],\n        orUpdateOptions?: InsertOrUpdateOptions,\n    ): this {\n        if (!Array.isArray(statementOrOverwrite)) {\n            this.expressionMap.onUpdate = {\n                conflict: statementOrOverwrite?.conflict_target,\n                columns: statementOrOverwrite?.columns,\n                overwrite: statementOrOverwrite?.overwrite,\n                skipUpdateIfNoValuesChanged:\n                    orUpdateOptions?.skipUpdateIfNoValuesChanged,\n                upsertType: orUpdateOptions?.upsertType,\n            }\n            return this\n        }\n\n        this.expressionMap.onUpdate = {\n            overwrite: statementOrOverwrite,\n            conflict: conflictTarget,\n            skipUpdateIfNoValuesChanged:\n                orUpdateOptions?.skipUpdateIfNoValuesChanged,\n            indexPredicate: orUpdateOptions?.indexPredicate,\n            upsertType: orUpdateOptions?.upsertType,\n        }\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates INSERT express used to perform insert query.\n     */\n    protected createInsertExpression() {\n        const tableName = this.getTableName(this.getMainTableName())\n        const valuesExpression = this.createValuesExpression() // its important to get values before returning expression because oracle rely on native parameters and ordering of them is important\n        const returningExpression =\n            this.connection.driver.options.type === \"oracle\" &&\n            this.getValueSets().length > 1\n                ? null\n                : this.createReturningExpression(\"insert\") // oracle doesnt support returning with multi-row insert\n        const columnsExpression = this.createColumnNamesExpression()\n        let query = \"INSERT \"\n\n        if (this.expressionMap.onUpdate?.upsertType === \"primary-key\") {\n            query = \"UPSERT \"\n        }\n\n        if (\n            DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\"\n        ) {\n            query += `${this.expressionMap.onIgnore ? \" IGNORE \" : \"\"}`\n        }\n\n        query += `INTO ${tableName}`\n\n        if (\n            this.alias !== this.getMainTableName() &&\n            DriverUtils.isPostgresFamily(this.connection.driver)\n        ) {\n            query += ` AS \"${this.alias}\"`\n        }\n\n        // add columns expression\n        if (columnsExpression) {\n            query += `(${columnsExpression})`\n        } else {\n            if (\n                !valuesExpression &&\n                (DriverUtils.isMySQLFamily(this.connection.driver) ||\n                    this.connection.driver.options.type === \"aurora-mysql\")\n            )\n                // special syntax for mysql DEFAULT VALUES insertion\n                query += \"()\"\n        }\n\n        // add OUTPUT expression\n        if (\n            returningExpression &&\n            this.connection.driver.options.type === \"mssql\"\n        ) {\n            query += ` OUTPUT ${returningExpression}`\n        }\n\n        // add VALUES expression\n        if (valuesExpression) {\n            if (\n                (this.connection.driver.options.type === \"oracle\" ||\n                    this.connection.driver.options.type === \"sap\") &&\n                this.getValueSets().length > 1\n            ) {\n                query += ` ${valuesExpression}`\n            } else {\n                query += ` VALUES ${valuesExpression}`\n            }\n        } else {\n            if (\n                DriverUtils.isMySQLFamily(this.connection.driver) ||\n                this.connection.driver.options.type === \"aurora-mysql\"\n            ) {\n                // special syntax for mysql DEFAULT VALUES insertion\n                query += \" VALUES ()\"\n            } else {\n                query += ` DEFAULT VALUES`\n            }\n        }\n        if (this.expressionMap.onUpdate?.upsertType !== \"primary-key\") {\n            if (\n                this.connection.driver.supportedUpsertTypes.includes(\n                    \"on-conflict-do-update\",\n                )\n            ) {\n                if (this.expressionMap.onIgnore) {\n                    query += \" ON CONFLICT DO NOTHING \"\n                } else if (this.expressionMap.onConflict) {\n                    query += ` ON CONFLICT ${this.expressionMap.onConflict} `\n                } else if (this.expressionMap.onUpdate) {\n                    const {\n                        overwrite,\n                        columns,\n                        conflict,\n                        skipUpdateIfNoValuesChanged,\n                        indexPredicate,\n                    } = this.expressionMap.onUpdate\n\n                    let conflictTarget = \"ON CONFLICT\"\n\n                    if (Array.isArray(conflict)) {\n                        conflictTarget += ` ( ${conflict\n                            .map((column) => this.escape(column))\n                            .join(\", \")} )`\n                        if (\n                            indexPredicate &&\n                            !DriverUtils.isPostgresFamily(\n                                this.connection.driver,\n                            )\n                        ) {\n                            throw new TypeORMError(\n                                `indexPredicate option is not supported by the current database driver`,\n                            )\n                        }\n                        if (\n                            indexPredicate &&\n                            DriverUtils.isPostgresFamily(this.connection.driver)\n                        ) {\n                            conflictTarget += ` WHERE ( ${indexPredicate} )`\n                        }\n                    } else if (conflict) {\n                        conflictTarget += ` ON CONSTRAINT ${this.escape(\n                            conflict,\n                        )}`\n                    }\n\n                    const updatePart: string[] = []\n\n                    if (Array.isArray(overwrite)) {\n                        updatePart.push(\n                            ...overwrite.map(\n                                (column) =>\n                                    `${this.escape(\n                                        column,\n                                    )} = EXCLUDED.${this.escape(column)}`,\n                            ),\n                        )\n                    } else if (columns) {\n                        updatePart.push(\n                            ...columns.map(\n                                (column) =>\n                                    `${this.escape(column)} = :${column}`,\n                            ),\n                        )\n                    }\n\n                    if (updatePart.length > 0) {\n                        query += ` ${conflictTarget} DO UPDATE SET `\n\n                        updatePart.push(\n                            ...this.expressionMap\n                                .mainAlias!.metadata.columns.filter(\n                                    (column) =>\n                                        column.isUpdateDate &&\n                                        !overwrite?.includes(\n                                            column.databaseName,\n                                        ) &&\n                                        !(\n                                            (this.connection.driver.options\n                                                .type === \"oracle\" &&\n                                                this.getValueSets().length >\n                                                    1) ||\n                                            DriverUtils.isSQLiteFamily(\n                                                this.connection.driver,\n                                            ) ||\n                                            this.connection.driver.options\n                                                .type === \"sap\" ||\n                                            this.connection.driver.options\n                                                .type === \"spanner\"\n                                        ),\n                                )\n                                .map(\n                                    (column) =>\n                                        `${this.escape(\n                                            column.databaseName,\n                                        )} = DEFAULT`,\n                                ),\n                        )\n\n                        query += updatePart.join(\", \")\n                    }\n\n                    if (\n                        Array.isArray(overwrite) &&\n                        skipUpdateIfNoValuesChanged &&\n                        DriverUtils.isPostgresFamily(this.connection.driver)\n                    ) {\n                        query += ` WHERE (`\n                        query += overwrite\n                            .map(\n                                (column) =>\n                                    `${this.escape(this.alias)}.${this.escape(\n                                        column,\n                                    )} IS DISTINCT FROM EXCLUDED.${this.escape(\n                                        column,\n                                    )}`,\n                            )\n                            .join(\" OR \")\n                        query += \") \"\n                    }\n                }\n            } else if (\n                this.connection.driver.supportedUpsertTypes.includes(\n                    \"on-duplicate-key-update\",\n                )\n            ) {\n                if (this.expressionMap.onUpdate) {\n                    const { overwrite, columns } = this.expressionMap.onUpdate\n\n                    if (Array.isArray(overwrite)) {\n                        query += \" ON DUPLICATE KEY UPDATE \"\n                        query += overwrite\n                            .map(\n                                (column) =>\n                                    `${this.escape(\n                                        column,\n                                    )} = VALUES(${this.escape(column)})`,\n                            )\n                            .join(\", \")\n                        query += \" \"\n                    } else if (Array.isArray(columns)) {\n                        query += \" ON DUPLICATE KEY UPDATE \"\n                        query += columns\n                            .map(\n                                (column) =>\n                                    `${this.escape(column)} = :${column}`,\n                            )\n                            .join(\", \")\n                        query += \" \"\n                    }\n                }\n            } else {\n                if (this.expressionMap.onUpdate) {\n                    throw new TypeORMError(\n                        `onUpdate is not supported by the current database driver`,\n                    )\n                }\n            }\n        }\n\n        // add RETURNING expression\n        if (\n            returningExpression &&\n            (DriverUtils.isPostgresFamily(this.connection.driver) ||\n                this.connection.driver.options.type === \"oracle\" ||\n                this.connection.driver.options.type === \"cockroachdb\" ||\n                DriverUtils.isMySQLFamily(this.connection.driver))\n        ) {\n            query += ` RETURNING ${returningExpression}`\n        }\n\n        if (\n            returningExpression &&\n            this.connection.driver.options.type === \"spanner\"\n        ) {\n            query += ` THEN RETURN ${returningExpression}`\n        }\n\n        // Inserting a specific value for an auto-increment primary key in mssql requires enabling IDENTITY_INSERT\n        // IDENTITY_INSERT can only be enabled for tables where there is an IDENTITY column and only if there is a value to be inserted (i.e. supplying DEFAULT is prohibited if IDENTITY_INSERT is enabled)\n        if (\n            this.connection.driver.options.type === \"mssql\" &&\n            this.expressionMap.mainAlias!.hasMetadata &&\n            this.expressionMap\n                .mainAlias!.metadata.columns.filter((column) =>\n                    this.expressionMap.insertColumns.length > 0\n                        ? this.expressionMap.insertColumns.indexOf(\n                              column.propertyPath,\n                          ) !== -1\n                        : column.isInsert,\n                )\n                .some((column) =>\n                    this.isOverridingAutoIncrementBehavior(column),\n                )\n        ) {\n            query = `SET IDENTITY_INSERT ${tableName} ON; ${query}; SET IDENTITY_INSERT ${tableName} OFF`\n        }\n\n        return query\n    }\n\n    /**\n     * Gets list of columns where values must be inserted to.\n     */\n    protected getInsertedColumns(): ColumnMetadata[] {\n        if (!this.expressionMap.mainAlias!.hasMetadata) return []\n\n        return this.expressionMap.mainAlias!.metadata.columns.filter(\n            (column) => {\n                // if user specified list of columns he wants to insert to, then we filter only them\n                if (this.expressionMap.insertColumns.length)\n                    return (\n                        this.expressionMap.insertColumns.indexOf(\n                            column.propertyPath,\n                        ) !== -1\n                    )\n\n                // skip columns the user doesn't want included by default\n                if (!column.isInsert) {\n                    return false\n                }\n\n                // if user did not specified such list then return all columns except auto-increment one\n                // for Oracle we return auto-increment column as well because Oracle does not support DEFAULT VALUES expression\n                if (\n                    column.isGenerated &&\n                    column.generationStrategy === \"increment\" &&\n                    !(this.connection.driver.options.type === \"spanner\") &&\n                    !(this.connection.driver.options.type === \"oracle\") &&\n                    !DriverUtils.isSQLiteFamily(this.connection.driver) &&\n                    !DriverUtils.isMySQLFamily(this.connection.driver) &&\n                    !(this.connection.driver.options.type === \"aurora-mysql\") &&\n                    !(\n                        this.connection.driver.options.type === \"mssql\" &&\n                        this.isOverridingAutoIncrementBehavior(column)\n                    )\n                )\n                    return false\n\n                return true\n            },\n        )\n    }\n\n    /**\n     * Creates a columns string where values must be inserted to for INSERT INTO expression.\n     */\n    protected createColumnNamesExpression(): string {\n        const columns = this.getInsertedColumns()\n        if (columns.length > 0)\n            return columns\n                .map((column) => this.escape(column.databaseName))\n                .join(\", \")\n\n        // in the case if there are no insert columns specified and table without metadata used\n        // we get columns from the inserted value map, in the case if only one inserted map is specified\n        if (\n            !this.expressionMap.mainAlias!.hasMetadata &&\n            !this.expressionMap.insertColumns.length\n        ) {\n            const valueSets = this.getValueSets()\n            if (valueSets.length === 1)\n                return Object.keys(valueSets[0])\n                    .map((columnName) => this.escape(columnName))\n                    .join(\", \")\n        }\n\n        // get a table name and all column database names\n        return this.expressionMap.insertColumns\n            .map((columnName) => this.escape(columnName))\n            .join(\", \")\n    }\n\n    /**\n     * Creates list of values needs to be inserted in the VALUES expression.\n     */\n    protected createValuesExpression(): string {\n        const valueSets = this.getValueSets()\n        const columns = this.getInsertedColumns()\n\n        // if column metadatas are given then apply all necessary operations with values\n        if (columns.length > 0) {\n            let expression = \"\"\n            valueSets.forEach((valueSet, valueSetIndex) => {\n                columns.forEach((column, columnIndex) => {\n                    if (columnIndex === 0) {\n                        if (\n                            this.connection.driver.options.type === \"oracle\" &&\n                            valueSets.length > 1\n                        ) {\n                            expression += \" SELECT \"\n                        } else if (\n                            this.connection.driver.options.type === \"sap\" &&\n                            valueSets.length > 1\n                        ) {\n                            expression += \" SELECT \"\n                        } else {\n                            expression += \"(\"\n                        }\n                    }\n\n                    // extract real value from the entity\n                    let value = column.getEntityValue(valueSet)\n\n                    // if column is relational and value is an object then get real referenced column value from this object\n                    // for example column value is { question: { id: 1 } }, value will be equal to { id: 1 }\n                    // and we extract \"1\" from this object\n                    /*if (column.referencedColumn && value instanceof Object && !(typeof value === \"function\")) { // todo: check if we still need it since getEntityValue already has similar code\n                        value = column.referencedColumn.getEntityValue(value);\n                    }*/\n\n                    if (!(typeof value === \"function\")) {\n                        // make sure our value is normalized by a driver\n                        value = this.connection.driver.preparePersistentValue(\n                            value,\n                            column,\n                        )\n                    }\n\n                    // newly inserted entities always have a version equal to 1 (first version)\n                    // also, user-specified version must be empty\n                    if (column.isVersion && value === undefined) {\n                        expression += \"1\"\n\n                        // } else if (column.isNestedSetLeft) {\n                        //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n                        //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n                        //     const subQuery = `(SELECT c.max + 1 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n                        //     expression += subQuery;\n                        //\n                        // } else if (column.isNestedSetRight) {\n                        //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n                        //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n                        //     const subQuery = `(SELECT c.max + 2 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n                        //     expression += subQuery;\n                    } else if (column.isDiscriminator) {\n                        expression += this.createParameter(\n                            this.expressionMap.mainAlias!.metadata\n                                .discriminatorValue,\n                        )\n                        // return \"1\";\n\n                        // for create and update dates we insert current date\n                        // no, we don't do it because this constant is already in \"default\" value of the column\n                        // with extended timestamp functionality, like CURRENT_TIMESTAMP(6) for example\n                        // } else if (column.isCreateDate || column.isUpdateDate) {\n                        //     return \"CURRENT_TIMESTAMP\";\n\n                        // if column is generated uuid and database does not support its generation and custom generated value was not provided by a user - we generate a new uuid value for insertion\n                    } else if (\n                        column.isGenerated &&\n                        column.generationStrategy === \"uuid\" &&\n                        !this.connection.driver.isUUIDGenerationSupported() &&\n                        value === undefined\n                    ) {\n                        value = uuidv4()\n                        expression += this.createParameter(value)\n\n                        if (\n                            !(\n                                valueSetIndex in\n                                this.expressionMap.locallyGenerated\n                            )\n                        ) {\n                            this.expressionMap.locallyGenerated[valueSetIndex] =\n                                {}\n                        }\n                        column.setEntityValue(\n                            this.expressionMap.locallyGenerated[valueSetIndex],\n                            value,\n                        )\n\n                        // if value for this column was not provided then insert default value\n                    } else if (value === undefined) {\n                        if (\n                            (this.connection.driver.options.type === \"oracle\" &&\n                                valueSets.length > 1) ||\n                            DriverUtils.isSQLiteFamily(\n                                this.connection.driver,\n                            ) ||\n                            this.connection.driver.options.type === \"sap\" ||\n                            this.connection.driver.options.type === \"spanner\"\n                        ) {\n                            // unfortunately sqlite does not support DEFAULT expression in INSERT queries\n                            if (\n                                column.default !== undefined &&\n                                column.default !== null\n                            ) {\n                                // try to use default defined in the column\n                                expression +=\n                                    this.connection.driver.normalizeDefault(\n                                        column,\n                                    )\n                            } else if (\n                                this.connection.driver.options.type ===\n                                    \"spanner\" &&\n                                column.isGenerated &&\n                                column.generationStrategy === \"uuid\"\n                            ) {\n                                expression += \"GENERATE_UUID()\" // Produces a random universally unique identifier (UUID) as a STRING value.\n                            } else {\n                                expression += \"NULL\" // otherwise simply use NULL and pray if column is nullable\n                            }\n                        } else {\n                            expression += \"DEFAULT\"\n                        }\n                    } else if (\n                        value === null &&\n                        (this.connection.driver.options.type === \"spanner\" ||\n                            this.connection.driver.options.type === \"oracle\")\n                    ) {\n                        expression += \"NULL\"\n\n                        // support for SQL expressions in queries\n                    } else if (typeof value === \"function\") {\n                        expression += value()\n\n                        // just any other regular value\n                    } else {\n                        if (this.connection.driver.options.type === \"mssql\")\n                            value = (\n                                this.connection.driver as SqlServerDriver\n                            ).parametrizeValue(column, value)\n\n                        // we need to store array values in a special class to make sure parameter replacement will work correctly\n                        // if (value instanceof Array)\n                        //     value = new ArrayParameter(value);\n\n                        const paramName = this.createParameter(value)\n\n                        if (\n                            (DriverUtils.isMySQLFamily(\n                                this.connection.driver,\n                            ) ||\n                                this.connection.driver.options.type ===\n                                    \"aurora-mysql\") &&\n                            this.connection.driver.spatialTypes.indexOf(\n                                column.type,\n                            ) !== -1\n                        ) {\n                            const useLegacy = (\n                                this.connection.driver as\n                                    | MysqlDriver\n                                    | AuroraMysqlDriver\n                            ).options.legacySpatialSupport\n                            const geomFromText = useLegacy\n                                ? \"GeomFromText\"\n                                : \"ST_GeomFromText\"\n                            if (column.srid != null) {\n                                expression += `${geomFromText}(${paramName}, ${column.srid})`\n                            } else {\n                                expression += `${geomFromText}(${paramName})`\n                            }\n                        } else if (\n                            DriverUtils.isPostgresFamily(\n                                this.connection.driver,\n                            ) &&\n                            this.connection.driver.spatialTypes.indexOf(\n                                column.type,\n                            ) !== -1\n                        ) {\n                            if (column.srid != null) {\n                                expression += `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`\n                            } else {\n                                expression += `ST_GeomFromGeoJSON(${paramName})::${column.type}`\n                            }\n                        } else if (\n                            this.connection.driver.options.type === \"mssql\" &&\n                            this.connection.driver.spatialTypes.indexOf(\n                                column.type,\n                            ) !== -1\n                        ) {\n                            expression +=\n                                column.type +\n                                \"::STGeomFromText(\" +\n                                paramName +\n                                \", \" +\n                                (column.srid || \"0\") +\n                                \")\"\n                        } else {\n                            expression += paramName\n                        }\n                    }\n\n                    if (columnIndex === columns.length - 1) {\n                        if (valueSetIndex === valueSets.length - 1) {\n                            if (\n                                this.connection.driver.options.type ===\n                                    \"oracle\" &&\n                                valueSets.length > 1\n                            ) {\n                                expression += \" FROM DUAL \"\n                            } else if (\n                                this.connection.driver.options.type === \"sap\" &&\n                                valueSets.length > 1\n                            ) {\n                                expression += \" FROM dummy \"\n                            } else {\n                                expression += \")\"\n                            }\n                        } else {\n                            if (\n                                this.connection.driver.options.type ===\n                                    \"oracle\" &&\n                                valueSets.length > 1\n                            ) {\n                                expression += \" FROM DUAL UNION ALL \"\n                            } else if (\n                                this.connection.driver.options.type === \"sap\" &&\n                                valueSets.length > 1\n                            ) {\n                                expression += \" FROM dummy UNION ALL \"\n                            } else {\n                                expression += \"), \"\n                            }\n                        }\n                    } else {\n                        expression += \", \"\n                    }\n                })\n            })\n            if (expression === \"()\") return \"\"\n\n            return expression\n        } else {\n            // for tables without metadata\n            // get values needs to be inserted\n            let expression = \"\"\n\n            valueSets.forEach((valueSet, insertionIndex) => {\n                const columns = Object.keys(valueSet)\n                columns.forEach((columnName, columnIndex) => {\n                    if (columnIndex === 0) {\n                        expression += \"(\"\n                    }\n\n                    const value = valueSet[columnName]\n\n                    // support for SQL expressions in queries\n                    if (typeof value === \"function\") {\n                        expression += value()\n\n                        // if value for this column was not provided then insert default value\n                    } else if (value === undefined) {\n                        if (\n                            (this.connection.driver.options.type === \"oracle\" &&\n                                valueSets.length > 1) ||\n                            DriverUtils.isSQLiteFamily(\n                                this.connection.driver,\n                            ) ||\n                            this.connection.driver.options.type === \"sap\" ||\n                            this.connection.driver.options.type === \"spanner\"\n                        ) {\n                            expression += \"NULL\"\n                        } else {\n                            expression += \"DEFAULT\"\n                        }\n                    } else if (\n                        value === null &&\n                        this.connection.driver.options.type === \"spanner\"\n                    ) {\n                        // just any other regular value\n                    } else {\n                        expression += this.createParameter(value)\n                    }\n\n                    if (columnIndex === Object.keys(valueSet).length - 1) {\n                        if (insertionIndex === valueSets.length - 1) {\n                            expression += \")\"\n                        } else {\n                            expression += \"), \"\n                        }\n                    } else {\n                        expression += \", \"\n                    }\n                })\n            })\n            if (expression === \"()\") return \"\"\n            return expression\n        }\n    }\n\n    /**\n     * Gets array of values need to be inserted into the target table.\n     */\n    protected getValueSets(): ObjectLiteral[] {\n        if (Array.isArray(this.expressionMap.valuesSet))\n            return this.expressionMap.valuesSet\n\n        if (ObjectUtils.isObject(this.expressionMap.valuesSet))\n            return [this.expressionMap.valuesSet]\n\n        throw new InsertValuesMissingError()\n    }\n\n    /**\n     * Checks if column is an auto-generated primary key, but the current insertion specifies a value for it.\n     *\n     * @param column\n     */\n    protected isOverridingAutoIncrementBehavior(\n        column: ColumnMetadata,\n    ): boolean {\n        return (\n            column.isPrimary &&\n            column.isGenerated &&\n            column.generationStrategy === \"increment\" &&\n            this.getValueSets().some(\n                (valueSet) =>\n                    column.getEntityValue(valueSet) !== undefined &&\n                    column.getEntityValue(valueSet) !== null,\n            )\n        )\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2613, "column": 0}, "map": {"version":3,"file":"RelationUpdater.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/RelationUpdater.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { TypeORMError } from \"../error\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\n\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationUpdater {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected queryBuilder: QueryBuilder<any>,\n        protected expressionMap: QueryExpressionMap,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs set or add operation on a relation.\n     */\n    async update(value: any | any[]): Promise<void> {\n        const relation = this.expressionMap.relationMetadata\n\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            const updateSet = relation.joinColumns.reduce(\n                (updateSet, joinColumn) => {\n                    const relationValue = ObjectUtils.isObject(value)\n                        ? joinColumn.referencedColumn!.getEntityValue(value)\n                        : value\n                    joinColumn.setEntityValue(updateSet, relationValue)\n                    return updateSet\n                },\n                {} as any,\n            )\n\n            if (\n                !this.expressionMap.of ||\n                (Array.isArray(this.expressionMap.of) &&\n                    !this.expressionMap.of.length)\n            )\n                return\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.entityMetadata.target)\n                .set(updateSet)\n                .whereInIds(this.expressionMap.of)\n                .execute()\n        } else if (\n            (relation.isOneToOneNotOwner || relation.isOneToMany) &&\n            value === null\n        ) {\n            // we handle null a bit different way\n\n            const updateSet: ObjectLiteral = {}\n            relation.inverseRelation!.joinColumns.forEach((column) => {\n                updateSet[column.propertyName] = null\n            })\n\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of]\n            const parameters: ObjectLiteral = {}\n            const conditions: string[] = []\n            ofs.forEach((of, ofIndex) => {\n                relation.inverseRelation!.joinColumns.map(\n                    (column, columnIndex) => {\n                        const parameterName =\n                            \"joinColumn_\" + ofIndex + \"_\" + columnIndex\n                        parameters[parameterName] = ObjectUtils.isObject(of)\n                            ? column.referencedColumn!.getEntityValue(of)\n                            : of\n                        conditions.push(\n                            `${column.propertyPath} = :${parameterName}`,\n                        )\n                    },\n                )\n            })\n            const condition = conditions\n                .map((str) => \"(\" + str + \")\")\n                .join(\" OR \")\n            if (!condition) return\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .where(condition)\n                .setParameters(parameters)\n                .execute()\n        } else if (relation.isOneToOneNotOwner || relation.isOneToMany) {\n            if (Array.isArray(this.expressionMap.of))\n                throw new TypeORMError(\n                    `You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`,\n                )\n\n            const of = this.expressionMap.of\n            const updateSet = relation.inverseRelation!.joinColumns.reduce(\n                (updateSet, joinColumn) => {\n                    const relationValue = ObjectUtils.isObject(of)\n                        ? joinColumn.referencedColumn!.getEntityValue(of)\n                        : of\n                    joinColumn.setEntityValue(updateSet, relationValue)\n                    return updateSet\n                },\n                {} as any,\n            )\n\n            if (!value || (Array.isArray(value) && !value.length)) return\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .whereInIds(value)\n                .execute()\n        } else {\n            // many to many\n            const junctionMetadata = relation.junctionEntityMetadata!\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of]\n            const values = Array.isArray(value) ? value : [value]\n            const firstColumnValues = relation.isManyToManyOwner ? ofs : values\n            const secondColumnValues = relation.isManyToManyOwner ? values : ofs\n\n            const bulkInserted: ObjectLiteral[] = []\n            firstColumnValues.forEach((firstColumnVal) => {\n                secondColumnValues.forEach((secondColumnVal) => {\n                    const inserted: ObjectLiteral = {}\n                    junctionMetadata.ownerColumns.forEach((column) => {\n                        inserted[column.databaseName] = ObjectUtils.isObject(\n                            firstColumnVal,\n                        )\n                            ? column.referencedColumn!.getEntityValue(\n                                  firstColumnVal,\n                              )\n                            : firstColumnVal\n                    })\n                    junctionMetadata.inverseColumns.forEach((column) => {\n                        inserted[column.databaseName] = ObjectUtils.isObject(\n                            secondColumnVal,\n                        )\n                            ? column.referencedColumn!.getEntityValue(\n                                  secondColumnVal,\n                              )\n                            : secondColumnVal\n                    })\n                    bulkInserted.push(inserted)\n                })\n            })\n\n            if (!bulkInserted.length) return\n\n            if (\n                this.queryBuilder.connection.driver.options.type === \"oracle\" ||\n                this.queryBuilder.connection.driver.options.type === \"sap\"\n            ) {\n                await Promise.all(\n                    bulkInserted.map((value) => {\n                        return this.queryBuilder\n                            .createQueryBuilder()\n                            .insert()\n                            .into(junctionMetadata.tableName)\n                            .values(value)\n                            .execute()\n                    }),\n                )\n            } else {\n                await this.queryBuilder\n                    .createQueryBuilder()\n                    .insert()\n                    .into(junctionMetadata.tableName)\n                    .values(bulkInserted)\n                    .execute()\n            }\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2719, "column": 0}, "map": {"version":3,"file":"RelationRemover.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/RelationRemover.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\n\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationRemover {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected queryBuilder: QueryBuilder<any>,\n        protected expressionMap: QueryExpressionMap,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Performs remove operation on a relation.\n     */\n    async remove(value: any | any[]): Promise<void> {\n        const relation = this.expressionMap.relationMetadata\n\n        if (relation.isOneToMany) {\n            // if (this.expressionMap.of instanceof Array)\n            //     throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n\n            // DELETE FROM post WHERE post.categoryId = of AND post.id = id\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of]\n            const values = Array.isArray(value) ? value : [value]\n\n            const updateSet: ObjectLiteral = {}\n            relation.inverseRelation!.joinColumns.forEach((column) => {\n                updateSet[column.propertyName] = null\n            })\n\n            const parameters: ObjectLiteral = {}\n            const conditions: string[] = []\n            ofs.forEach((of, ofIndex) => {\n                conditions.push(\n                    ...values.map((value, valueIndex) => {\n                        return [\n                            ...relation.inverseRelation!.joinColumns.map(\n                                (column, columnIndex) => {\n                                    const parameterName =\n                                        \"joinColumn_\" +\n                                        ofIndex +\n                                        \"_\" +\n                                        valueIndex +\n                                        \"_\" +\n                                        columnIndex\n                                    parameters[parameterName] =\n                                        ObjectUtils.isObject(of)\n                                            ? column.referencedColumn!.getEntityValue(\n                                                  of,\n                                              )\n                                            : of\n                                    return `${column.propertyPath} = :${parameterName}`\n                                },\n                            ),\n                            ...relation.inverseRelation!.entityMetadata.primaryColumns.map(\n                                (column, columnIndex) => {\n                                    const parameterName =\n                                        \"primaryColumn_\" +\n                                        valueIndex +\n                                        \"_\" +\n                                        valueIndex +\n                                        \"_\" +\n                                        columnIndex\n                                    parameters[parameterName] =\n                                        ObjectUtils.isObject(value)\n                                            ? column.getEntityValue(value)\n                                            : value\n                                    return `${column.propertyPath} = :${parameterName}`\n                                },\n                            ),\n                        ].join(\" AND \")\n                    }),\n                )\n            })\n            const condition = conditions\n                .map((str) => \"(\" + str + \")\")\n                .join(\" OR \")\n            if (!condition) return\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .where(condition)\n                .setParameters(parameters)\n                .execute()\n        } else {\n            // many to many\n\n            const junctionMetadata = relation.junctionEntityMetadata!\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of]\n            const values = Array.isArray(value) ? value : [value]\n            const firstColumnValues = relation.isManyToManyOwner ? ofs : values\n            const secondColumnValues = relation.isManyToManyOwner ? values : ofs\n\n            const parameters: ObjectLiteral = {}\n            const conditions: string[] = []\n            firstColumnValues.forEach((firstColumnVal, firstColumnValIndex) => {\n                conditions.push(\n                    ...secondColumnValues.map(\n                        (secondColumnVal, secondColumnValIndex) => {\n                            return [\n                                ...junctionMetadata.ownerColumns.map(\n                                    (column, columnIndex) => {\n                                        const parameterName =\n                                            \"firstValue_\" +\n                                            firstColumnValIndex +\n                                            \"_\" +\n                                            secondColumnValIndex +\n                                            \"_\" +\n                                            columnIndex\n                                        parameters[parameterName] =\n                                            ObjectUtils.isObject(firstColumnVal)\n                                                ? column.referencedColumn!.getEntityValue(\n                                                      firstColumnVal,\n                                                  )\n                                                : firstColumnVal\n                                        return `${column.databaseName} = :${parameterName}`\n                                    },\n                                ),\n                                ...junctionMetadata.inverseColumns.map(\n                                    (column, columnIndex) => {\n                                        const parameterName =\n                                            \"secondValue_\" +\n                                            firstColumnValIndex +\n                                            \"_\" +\n                                            secondColumnValIndex +\n                                            \"_\" +\n                                            columnIndex\n                                        parameters[parameterName] =\n                                            ObjectUtils.isObject(\n                                                secondColumnVal,\n                                            )\n                                                ? column.referencedColumn!.getEntityValue(\n                                                      secondColumnVal,\n                                                  )\n                                                : secondColumnVal\n                                        return `${column.databaseName} = :${parameterName}`\n                                    },\n                                ),\n                            ].join(\" AND \")\n                        },\n                    ),\n                )\n            })\n            const condition = conditions\n                .map((str) => \"(\" + str + \")\")\n                .join(\" OR \")\n\n            await this.queryBuilder\n                .createQueryBuilder()\n                .delete()\n                .from(junctionMetadata.tableName)\n                .where(condition)\n                .setParameters(parameters)\n                .execute()\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2819, "column": 0}, "map": {"version":3,"file":"RelationQueryBuilder.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/RelationQueryBuilder.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { RelationUpdater } from \"./RelationUpdater\"\nimport { RelationRemover } from \"./RelationRemover\"\nimport { TypeORMError } from \"../error\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\n\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationQueryBuilder<\n    Entity extends ObjectLiteral,\n> extends QueryBuilder<Entity> {\n    readonly \"@instanceof\" = Symbol.for(\"RelationQueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        return \"\"\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Sets entity (target) which relations will be updated.\n     */\n    of(entity: any | any[]): this {\n        this.expressionMap.of = entity\n        return this\n    }\n\n    /**\n     * Sets entity relation's value.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Works only for many-to-one and one-to-one relations.\n     * For many-to-many and one-to-many relations use #add and #remove methods instead.\n     */\n    async set(value: any): Promise<void> {\n        const relation = this.expressionMap.relationMetadata\n\n        if (!this.expressionMap.of)\n            // todo: move this check before relation query builder creation?\n            throw new TypeORMError(\n                `Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`,\n            )\n\n        if (relation.isManyToMany || relation.isOneToMany)\n            throw new TypeORMError(\n                `Set operation is only supported for many-to-one and one-to-one relations. ` +\n                    `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` +\n                    `Use .add() method instead.`,\n            )\n\n        // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n        if (\n            relation.joinColumns &&\n            relation.joinColumns.length > 1 &&\n            (!ObjectUtils.isObject(value) ||\n                Object.keys(value).length < relation.joinColumns.length)\n        )\n            throw new TypeORMError(\n                `Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`,\n            )\n\n        const updater = new RelationUpdater(this, this.expressionMap)\n        return updater.update(value)\n    }\n\n    /**\n     * Adds (binds) given value to entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    async add(value: any | any[]): Promise<void> {\n        if (Array.isArray(value) && value.length === 0) return\n\n        const relation = this.expressionMap.relationMetadata\n\n        if (!this.expressionMap.of)\n            // todo: move this check before relation query builder creation?\n            throw new TypeORMError(\n                `Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`,\n            )\n\n        if (relation.isManyToOne || relation.isOneToOne)\n            throw new TypeORMError(\n                `Add operation is only supported for many-to-many and one-to-many relations. ` +\n                    `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` +\n                    `Use .set() method instead.`,\n            )\n\n        // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n        if (\n            relation.joinColumns &&\n            relation.joinColumns.length > 1 &&\n            (!ObjectUtils.isObject(value) ||\n                Object.keys(value).length < relation.joinColumns.length)\n        )\n            throw new TypeORMError(\n                `Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`,\n            )\n\n        const updater = new RelationUpdater(this, this.expressionMap)\n        return updater.update(value)\n    }\n\n    /**\n     * Removes (unbinds) given value from entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    async remove(value: any | any[]): Promise<void> {\n        if (Array.isArray(value) && value.length === 0) return\n\n        const relation = this.expressionMap.relationMetadata\n\n        if (!this.expressionMap.of)\n            // todo: move this check before relation query builder creation?\n            throw new TypeORMError(\n                `Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`,\n            )\n\n        if (relation.isManyToOne || relation.isOneToOne)\n            throw new TypeORMError(\n                `Add operation is only supported for many-to-many and one-to-many relations. ` +\n                    `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` +\n                    `Use .set(null) method instead.`,\n            )\n\n        const remover = new RelationRemover(this, this.expressionMap)\n        return remover.remove(value)\n    }\n\n    /**\n     * Adds (binds) and removes (unbinds) given values to/from entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    async addAndRemove(\n        added: any | any[],\n        removed: any | any[],\n    ): Promise<void> {\n        await this.remove(removed)\n        await this.add(added)\n    }\n\n    /**\n     * Gets entity's relation id.\n    async getId(): Promise<any> {\n\n    }*/\n\n    /**\n     * Gets entity's relation ids.\n    async getIds(): Promise<any[]> {\n        return [];\n    }*/\n\n    /**\n     * Loads a single entity (relational) from the relation.\n     * You can also provide id of relational entity to filter by.\n     */\n    async loadOne<T = any>(): Promise<T | undefined> {\n        return this.loadMany<T>().then((results) => results[0])\n    }\n\n    /**\n     * Loads many entities (relational) from the relation.\n     * You can also provide ids of relational entities to filter by.\n     */\n    async loadMany<T = any>(): Promise<T[]> {\n        let of = this.expressionMap.of\n        if (!ObjectUtils.isObject(of)) {\n            const metadata = this.expressionMap.mainAlias!.metadata\n            if (metadata.hasMultiplePrimaryKeys)\n                throw new TypeORMError(\n                    `Cannot load entity because only one primary key was specified, however entity contains multiple primary keys`,\n                )\n\n            of = metadata.primaryColumns[0].createValueMap(of)\n        }\n\n        return this.connection.relationLoader.load(\n            this.expressionMap.relationMetadata,\n            of,\n            this.queryRunner,\n        )\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2945, "column": 0}, "map": {"version":3,"file":"RawSqlResultsToEntityTransformer.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/transformer/RawSqlResultsToEntityTransformer.ts"],"sourcesContent":["import { Driver } from \"../../driver/Driver\"\nimport { RelationIdLoadResult } from \"../relation-id/RelationIdLoadResult\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { Alias } from \"../Alias\"\nimport { RelationCountLoadResult } from \"../relation-count/RelationCountLoadResult\"\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\nimport { QueryExpressionMap } from \"../QueryExpressionMap\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { QueryRunner } from \"../..\"\nimport { DriverUtils } from \"../../driver/DriverUtils\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\n\n/**\n * Transforms raw sql results returned from the database into entity object.\n * Entity is constructed based on its entity metadata.\n */\nexport class RawSqlResultsToEntityTransformer {\n    /**\n     * Contains a hashmap for every rawRelationIdResults given.\n     * In the hashmap you will find the idMaps of a result under the hash of this.hashEntityIds for the result.\n     */\n    private relationIdMaps: Array<{ [idHash: string]: any[] }>\n\n    private pojo: boolean\n    private selections: Set<string>\n    private aliasCache: Map<string, Map<string, string>>\n    private columnsCache: Map<\n        string,\n        Map<EntityMetadata, [string, ColumnMetadata][]>\n    >\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected expressionMap: QueryExpressionMap,\n        protected driver: Driver,\n        protected rawRelationIdResults: RelationIdLoadResult[],\n        protected rawRelationCountResults: RelationCountLoadResult[],\n        protected queryRunner?: QueryRunner,\n    ) {\n        this.pojo = this.expressionMap.options.includes(\"create-pojo\")\n        this.selections = new Set(\n            this.expressionMap.selects.map((s) => s.selection),\n        )\n        this.aliasCache = new Map()\n        this.columnsCache = new Map()\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    transform(rawResults: any[], alias: Alias): any[] {\n        const group = this.group(rawResults, alias)\n        const entities: any[] = []\n        for (const results of group.values()) {\n            const entity = this.transformRawResultsGroup(results, alias)\n            if (entity !== undefined) entities.push(entity)\n        }\n        return entities\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Build an alias from a name and column name.\n     */\n    protected buildAlias(aliasName: string, columnName: string) {\n        let aliases = this.aliasCache.get(aliasName)\n        if (!aliases) {\n            aliases = new Map()\n            this.aliasCache.set(aliasName, aliases)\n        }\n        let columnAlias = aliases.get(columnName)\n        if (!columnAlias) {\n            columnAlias = DriverUtils.buildAlias(\n                this.driver,\n                undefined,\n                aliasName,\n                columnName,\n            )\n            aliases.set(columnName, columnAlias)\n        }\n        return columnAlias\n    }\n\n    /**\n     * Groups given raw results by ids of given alias.\n     */\n    protected group(rawResults: any[], alias: Alias): Map<string, any[]> {\n        const map = new Map()\n        const keys: string[] = []\n        if (alias.metadata.tableType === \"view\") {\n            keys.push(\n                ...alias.metadata.columns.map((column) =>\n                    this.buildAlias(alias.name, column.databaseName),\n                ),\n            )\n        } else {\n            keys.push(\n                ...alias.metadata.primaryColumns.map((column) =>\n                    this.buildAlias(alias.name, column.databaseName),\n                ),\n            )\n        }\n        for (const rawResult of rawResults) {\n            const id = keys\n                .map((key) => {\n                    const keyValue = rawResult[key]\n\n                    if (Buffer.isBuffer(keyValue)) {\n                        return keyValue.toString(\"hex\")\n                    }\n\n                    if (ObjectUtils.isObject(keyValue)) {\n                        return JSON.stringify(keyValue)\n                    }\n\n                    return keyValue\n                })\n                .join(\"_\") // todo: check partial\n\n            const items = map.get(id)\n            if (!items) {\n                map.set(id, [rawResult])\n            } else {\n                items.push(rawResult)\n            }\n        }\n        return map\n    }\n\n    /**\n     * Transforms set of data results into single entity.\n     */\n    protected transformRawResultsGroup(\n        rawResults: any[],\n        alias: Alias,\n    ): ObjectLiteral | undefined {\n        // let hasColumns = false; // , hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false;\n        let metadata = alias.metadata\n\n        if (metadata.discriminatorColumn) {\n            const discriminatorValues = rawResults.map(\n                (result) =>\n                    result[\n                        this.buildAlias(\n                            alias.name,\n                            alias.metadata.discriminatorColumn!.databaseName,\n                        )\n                    ],\n            )\n            const discriminatorMetadata = metadata.childEntityMetadatas.find(\n                (childEntityMetadata) => {\n                    return (\n                        typeof discriminatorValues.find(\n                            (value) =>\n                                value ===\n                                childEntityMetadata.discriminatorValue,\n                        ) !== \"undefined\"\n                    )\n                },\n            )\n            if (discriminatorMetadata) metadata = discriminatorMetadata\n        }\n        const entity: any = metadata.create(this.queryRunner, {\n            fromDeserializer: true,\n            pojo: this.pojo,\n        })\n\n        // get value from columns selections and put them into newly created entity\n        const hasColumns = this.transformColumns(\n            rawResults,\n            alias,\n            entity,\n            metadata,\n        )\n        const hasRelations = this.transformJoins(\n            rawResults,\n            entity,\n            alias,\n            metadata,\n        )\n        const hasRelationIds = this.transformRelationIds(\n            rawResults,\n            alias,\n            entity,\n            metadata,\n        )\n        const hasRelationCounts = this.transformRelationCounts(\n            rawResults,\n            alias,\n            entity,\n        )\n\n        // if we have at least one selected column then return this entity\n        // since entity must have at least primary columns to be really selected and transformed into entity\n        if (hasColumns) return entity\n\n        // if we don't have any selected column we should not return entity,\n        // except for the case when entity only contain a primary column as a relation to another entity\n        // in this case its absolutely possible our entity to not have any columns except a single relation\n        const hasOnlyVirtualPrimaryColumns = metadata.primaryColumns.every(\n            (column) => column.isVirtual === true,\n        ) // todo: create metadata.hasOnlyVirtualPrimaryColumns\n        if (\n            hasOnlyVirtualPrimaryColumns &&\n            (hasRelations || hasRelationIds || hasRelationCounts)\n        )\n            return entity\n\n        return undefined\n    }\n\n    // get value from columns selections and put them into object\n    protected transformColumns(\n        rawResults: any[],\n        alias: Alias,\n        entity: ObjectLiteral,\n        metadata: EntityMetadata,\n    ): boolean {\n        let hasData = false\n        const result = rawResults[0]\n        for (const [key, column] of this.getColumnsToProcess(\n            alias.name,\n            metadata,\n        )) {\n            const value = result[key]\n\n            if (value === undefined) continue\n            // we don't mark it as has data because if we will have all nulls in our object - we don't need such object\n            else if (value !== null && !column.isVirtualProperty) hasData = true\n\n            column.setEntityValue(\n                entity,\n                this.driver.prepareHydratedValue(value, column),\n            )\n        }\n        return hasData\n    }\n\n    /**\n     * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity\n     */\n    protected transformJoins(\n        rawResults: any[],\n        entity: ObjectLiteral,\n        alias: Alias,\n        metadata: EntityMetadata,\n    ) {\n        let hasData = false\n\n        // let discriminatorValue: string = \"\";\n        // if (metadata.discriminatorColumn)\n        //     discriminatorValue = rawResults[0][this.buildAlias(alias.name, alias.metadata.discriminatorColumn!.databaseName)];\n\n        for (const join of this.expressionMap.joinAttributes) {\n            // todo: we have problem here - when inner joins are used without selects it still create empty array\n\n            // skip joins without metadata\n            if (!join.metadata) continue\n\n            // if simple left or inner join was performed without selection then we don't need to do anything\n            if (!join.isSelected) continue\n\n            // this check need to avoid setting properties than not belong to entity when single table inheritance used. (todo: check if we still need it)\n            // const metadata = metadata.childEntityMetadatas.find(childEntityMetadata => discriminatorValue === childEntityMetadata.discriminatorValue);\n            if (\n                join.relation &&\n                !metadata.relations.find(\n                    (relation) => relation === join.relation,\n                )\n            )\n                continue\n\n            // some checks to make sure this join is for current alias\n            if (join.mapToProperty) {\n                if (join.mapToPropertyParentAlias !== alias.name) continue\n            } else {\n                if (\n                    !join.relation ||\n                    join.parentAlias !== alias.name ||\n                    join.relationPropertyPath !== join.relation!.propertyPath\n                )\n                    continue\n            }\n\n            // transform joined data into entities\n            let result: any = this.transform(rawResults, join.alias)\n            result = !join.isMany ? result[0] : result\n            result = !join.isMany && result === undefined ? null : result // this is needed to make relations to return null when its joined but nothing was found in the database\n            // if nothing was joined then simply continue\n            if (result === undefined) continue\n\n            // if join was mapped to some property then save result to that property\n            if (join.mapToPropertyPropertyName) {\n                entity[join.mapToPropertyPropertyName] = result // todo: fix embeds\n            } else {\n                // otherwise set to relation\n                join.relation!.setEntityValue(entity, result)\n            }\n\n            hasData = true\n        }\n        return hasData\n    }\n\n    protected transformRelationIds(\n        rawSqlResults: any[],\n        alias: Alias,\n        entity: ObjectLiteral,\n        metadata: EntityMetadata,\n    ): boolean {\n        let hasData = false\n        for (const [\n            index,\n            rawRelationIdResult,\n        ] of this.rawRelationIdResults.entries()) {\n            if (\n                rawRelationIdResult.relationIdAttribute.parentAlias !==\n                alias.name\n            )\n                continue\n\n            const relation = rawRelationIdResult.relationIdAttribute.relation\n            const valueMap = this.createValueMapFromJoinColumns(\n                relation,\n                rawRelationIdResult.relationIdAttribute.parentAlias,\n                rawSqlResults,\n            )\n            if (valueMap === undefined || valueMap === null) {\n                continue\n            }\n\n            // prepare common data for this call\n            this.prepareDataForTransformRelationIds()\n\n            // Extract idMaps from prepared data by hash\n            const hash = this.hashEntityIds(relation, valueMap)\n            const idMaps = this.relationIdMaps[index][hash] || []\n\n            // Map data to properties\n            const properties =\n                rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(\n                    \".\",\n                )\n            const mapToProperty = (\n                properties: string[],\n                map: ObjectLiteral,\n                value: any,\n            ): any => {\n                const property = properties.shift()\n                if (property && properties.length === 0) {\n                    map[property] = value\n                    return map\n                }\n                if (property && properties.length > 0) {\n                    mapToProperty(properties, map[property], value)\n                } else {\n                    return map\n                }\n            }\n            if (relation.isOneToOne || relation.isManyToOne) {\n                if (idMaps[0] !== undefined) {\n                    mapToProperty(properties, entity, idMaps[0])\n                    hasData = true\n                }\n            } else {\n                mapToProperty(properties, entity, idMaps)\n                hasData = hasData || idMaps.length > 0\n            }\n        }\n\n        return hasData\n    }\n\n    protected transformRelationCounts(\n        rawSqlResults: any[],\n        alias: Alias,\n        entity: ObjectLiteral,\n    ): boolean {\n        let hasData = false\n        for (const rawRelationCountResult of this.rawRelationCountResults) {\n            if (\n                rawRelationCountResult.relationCountAttribute.parentAlias !==\n                alias.name\n            )\n                continue\n            const relation =\n                rawRelationCountResult.relationCountAttribute.relation\n            let referenceColumnName: string\n\n            if (relation.isOneToMany) {\n                referenceColumnName =\n                    relation.inverseRelation!.joinColumns[0].referencedColumn!\n                        .databaseName // todo: fix joinColumns[0]\n            } else {\n                referenceColumnName = relation.isOwning\n                    ? relation.joinColumns[0].referencedColumn!.databaseName\n                    : relation.inverseRelation!.joinColumns[0].referencedColumn!\n                          .databaseName\n            }\n\n            const referenceColumnValue =\n                rawSqlResults[0][\n                    this.buildAlias(alias.name, referenceColumnName)\n                ] // we use zero index since its grouped data // todo: selection with alias for entity columns wont work\n            if (\n                referenceColumnValue !== undefined &&\n                referenceColumnValue !== null\n            ) {\n                entity[\n                    rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName\n                ] = 0\n                for (const result of rawRelationCountResult.results) {\n                    if (result[\"parentId\"] !== referenceColumnValue) continue\n                    entity[\n                        rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName\n                    ] = parseInt(result[\"cnt\"])\n                    hasData = true\n                }\n            }\n        }\n\n        return hasData\n    }\n\n    private getColumnsToProcess(aliasName: string, metadata: EntityMetadata) {\n        let metadatas = this.columnsCache.get(aliasName)\n        if (!metadatas) {\n            metadatas = new Map()\n            this.columnsCache.set(aliasName, metadatas)\n        }\n        let columns = metadatas.get(metadata)\n        if (!columns) {\n            columns = metadata.columns\n                .filter(\n                    (column) =>\n                        !column.isVirtual &&\n                        // if user does not selected the whole entity or he used partial selection and does not select this particular column\n                        // then we don't add this column and its value into the entity\n                        (this.selections.has(aliasName) ||\n                            this.selections.has(\n                                `${aliasName}.${column.propertyPath}`,\n                            )) &&\n                        // if table inheritance is used make sure this column is not child's column\n                        !metadata.childEntityMetadatas.some(\n                            (childMetadata) =>\n                                childMetadata.target === column.target,\n                        ),\n                )\n                .map((column) => [\n                    this.buildAlias(aliasName, column.databaseName),\n                    column,\n                ])\n            metadatas.set(metadata, columns)\n        }\n        return columns\n    }\n\n    private createValueMapFromJoinColumns(\n        relation: RelationMetadata,\n        parentAlias: string,\n        rawSqlResults: any[],\n    ): ObjectLiteral {\n        let columns: ColumnMetadata[]\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.entityMetadata.primaryColumns.map(\n                (joinColumn) => joinColumn,\n            )\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation!.joinColumns.map(\n                (joinColumn) => joinColumn,\n            )\n        } else {\n            if (relation.isOwning) {\n                columns = relation.joinColumns.map((joinColumn) => joinColumn)\n            } else {\n                columns = relation.inverseRelation!.inverseJoinColumns.map(\n                    (joinColumn) => joinColumn,\n                )\n            }\n        }\n        return columns.reduce((valueMap, column) => {\n            for (const rawSqlResult of rawSqlResults) {\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\n                    valueMap[column.databaseName] =\n                        this.driver.prepareHydratedValue(\n                            rawSqlResult[\n                                this.buildAlias(\n                                    parentAlias,\n                                    column.databaseName,\n                                )\n                            ],\n                            column,\n                        )\n                } else {\n                    valueMap[column.databaseName] =\n                        this.driver.prepareHydratedValue(\n                            rawSqlResult[\n                                this.buildAlias(\n                                    parentAlias,\n                                    column.referencedColumn!.databaseName,\n                                )\n                            ],\n                            column.referencedColumn!,\n                        )\n                }\n            }\n            return valueMap\n        }, {} as ObjectLiteral)\n    }\n\n    private extractEntityPrimaryIds(\n        relation: RelationMetadata,\n        relationIdRawResult: any,\n    ) {\n        let columns: ColumnMetadata[]\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.entityMetadata.primaryColumns.map(\n                (joinColumn) => joinColumn,\n            )\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation!.joinColumns.map(\n                (joinColumn) => joinColumn,\n            )\n        } else {\n            if (relation.isOwning) {\n                columns = relation.joinColumns.map((joinColumn) => joinColumn)\n            } else {\n                columns = relation.inverseRelation!.inverseJoinColumns.map(\n                    (joinColumn) => joinColumn,\n                )\n            }\n        }\n        return columns.reduce((data, column) => {\n            data[column.databaseName] = relationIdRawResult[column.databaseName]\n            return data\n        }, {} as ObjectLiteral)\n    }\n\n    /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {\n        const virtualColumns = this.expressionMap.selects\n            .filter(select => select.virtual)\n            .map(select => select.selection.replace(alias.name + \".\", \"\"));\n\n        virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);\n    }*/\n\n    /** Prepare data to run #transformRelationIds, as a lot of result independent data is needed in every call */\n    private prepareDataForTransformRelationIds() {\n        // Return early if the relationIdMaps were already calculated\n        if (this.relationIdMaps) {\n            return\n        }\n\n        // Ensure this prepare function is only called once\n        this.relationIdMaps = this.rawRelationIdResults.map(\n            (rawRelationIdResult) => {\n                const relation =\n                    rawRelationIdResult.relationIdAttribute.relation\n\n                // Calculate column metadata\n                let columns: ColumnMetadata[]\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\n                    columns = relation.joinColumns\n                } else if (\n                    relation.isOneToMany ||\n                    relation.isOneToOneNotOwner\n                ) {\n                    columns = relation.inverseEntityMetadata.primaryColumns\n                } else {\n                    // ManyToMany\n                    if (relation.isOwning) {\n                        columns = relation.inverseJoinColumns\n                    } else {\n                        columns = relation.inverseRelation!.joinColumns\n                    }\n                }\n\n                // Calculate the idMaps for the rawRelationIdResult\n                return rawRelationIdResult.results.reduce((agg, result) => {\n                    let idMap = columns.reduce((idMap, column) => {\n                        let value = result[column.databaseName]\n                        if (\n                            relation.isOneToMany ||\n                            relation.isOneToOneNotOwner\n                        ) {\n                            if (\n                                column.isVirtual &&\n                                column.referencedColumn &&\n                                column.referencedColumn.propertyName !==\n                                    column.propertyName\n                            ) {\n                                // if column is a relation\n                                value =\n                                    column.referencedColumn.createValueMap(\n                                        value,\n                                    )\n                            }\n\n                            return OrmUtils.mergeDeep(\n                                idMap,\n                                column.createValueMap(value),\n                            )\n                        }\n                        if (\n                            !column.isPrimary &&\n                            column.referencedColumn!.referencedColumn\n                        ) {\n                            // if column is a relation\n                            value =\n                                column.referencedColumn!.referencedColumn!.createValueMap(\n                                    value,\n                                )\n                        }\n\n                        return OrmUtils.mergeDeep(\n                            idMap,\n                            column.referencedColumn!.createValueMap(value),\n                        )\n                    }, {} as ObjectLiteral)\n\n                    if (\n                        columns.length === 1 &&\n                        !rawRelationIdResult.relationIdAttribute.disableMixedMap\n                    ) {\n                        if (\n                            relation.isOneToMany ||\n                            relation.isOneToOneNotOwner\n                        ) {\n                            idMap = columns[0].getEntityValue(idMap)\n                        } else {\n                            idMap =\n                                columns[0].referencedColumn!.getEntityValue(\n                                    idMap,\n                                )\n                        }\n                    }\n\n                    // If an idMap is found, set it in the aggregator under the correct hash\n                    if (idMap !== undefined) {\n                        const hash = this.hashEntityIds(relation, result)\n\n                        if (agg[hash]) {\n                            agg[hash].push(idMap)\n                        } else {\n                            agg[hash] = [idMap]\n                        }\n                    }\n\n                    return agg\n                }, {})\n            },\n        )\n    }\n\n    /**\n     * Use a simple JSON.stringify to create a simple hash of the primary ids of an entity.\n     * As this.extractEntityPrimaryIds always creates the primary id object in the same order, if the same relation is\n     * given, a simple JSON.stringify should be enough to get a unique hash per entity!\n     */\n    private hashEntityIds(relation: RelationMetadata, data: ObjectLiteral) {\n        const entityPrimaryIds = this.extractEntityPrimaryIds(relation, data)\n        return JSON.stringify(entityPrimaryIds)\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3324, "column": 0}, "map": {"version":3,"file":"RelationIdLoader.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/relation-id/RelationIdLoader.ts"],"sourcesContent":["import { RelationIdAttribute } from \"./RelationIdAttribute\"\nimport { DataSource } from \"../../data-source/DataSource\"\nimport { RelationIdLoadResult } from \"./RelationIdLoadResult\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\nimport { DriverUtils } from \"../../driver/DriverUtils\"\nimport { TypeORMError } from \"../../error/TypeORMError\"\nimport { OrmUtils } from \"../../util/OrmUtils\"\n\nexport class RelationIdLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        protected queryRunner: QueryRunner | undefined,\n        protected relationIdAttributes: RelationIdAttribute[],\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async load(rawEntities: any[]): Promise<RelationIdLoadResult[]> {\n        const promises = this.relationIdAttributes.map(\n            async (relationIdAttr) => {\n                if (\n                    relationIdAttr.relation.isManyToOne ||\n                    relationIdAttr.relation.isOneToOneOwner\n                ) {\n                    // example: Post and Tag\n                    // loadRelationIdAndMap(\"post.tagId\", \"post.tag\")\n                    // we expect it to load id of tag\n\n                    if (relationIdAttr.queryBuilderFactory)\n                        throw new TypeORMError(\n                            \"Additional condition can not be used with ManyToOne or OneToOne owner relations.\",\n                        )\n\n                    const duplicates: { [duplicateKey: string]: boolean } = {}\n                    const results = rawEntities\n                        .map((rawEntity) => {\n                            const result: ObjectLiteral = {}\n                            const duplicateParts: Array<string> = []\n                            relationIdAttr.relation.joinColumns.forEach(\n                                (joinColumn) => {\n                                    result[joinColumn.databaseName] =\n                                        this.connection.driver.prepareHydratedValue(\n                                            rawEntity[\n                                                DriverUtils.buildAlias(\n                                                    this.connection.driver,\n                                                    undefined,\n                                                    relationIdAttr.parentAlias,\n                                                    joinColumn.databaseName,\n                                                )\n                                            ],\n                                            joinColumn.referencedColumn!,\n                                        )\n                                    const duplicatePart = `${\n                                        joinColumn.databaseName\n                                    }:${result[joinColumn.databaseName]}`\n                                    if (\n                                        duplicateParts.indexOf(\n                                            duplicatePart,\n                                        ) === -1\n                                    ) {\n                                        duplicateParts.push(duplicatePart)\n                                    }\n                                },\n                            )\n\n                            relationIdAttr.relation.entityMetadata.primaryColumns.forEach(\n                                (primaryColumn) => {\n                                    result[primaryColumn.databaseName] =\n                                        this.connection.driver.prepareHydratedValue(\n                                            rawEntity[\n                                                DriverUtils.buildAlias(\n                                                    this.connection.driver,\n                                                    undefined,\n                                                    relationIdAttr.parentAlias,\n                                                    primaryColumn.databaseName,\n                                                )\n                                            ],\n                                            primaryColumn,\n                                        )\n                                    const duplicatePart = `${\n                                        primaryColumn.databaseName\n                                    }:${result[primaryColumn.databaseName]}`\n                                    if (\n                                        duplicateParts.indexOf(\n                                            duplicatePart,\n                                        ) === -1\n                                    ) {\n                                        duplicateParts.push(duplicatePart)\n                                    }\n                                },\n                            )\n\n                            duplicateParts.sort()\n                            const duplicate = duplicateParts.join(\"::\")\n                            if (duplicates[duplicate]) {\n                                return null\n                            }\n                            duplicates[duplicate] = true\n                            return result\n                        })\n                        .filter((v) => v)\n\n                    return {\n                        relationIdAttribute: relationIdAttr,\n                        results: results,\n                    }\n                } else if (\n                    relationIdAttr.relation.isOneToMany ||\n                    relationIdAttr.relation.isOneToOneNotOwner\n                ) {\n                    // example: Post and Category\n                    // loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                    // we expect it to load array of category ids\n\n                    const relation = relationIdAttr.relation // \"post.categories\"\n                    const joinColumns = relation.isOwning\n                        ? relation.joinColumns\n                        : relation.inverseRelation!.joinColumns\n                    const table = relation.inverseEntityMetadata.target // category\n                    const tableName = relation.inverseEntityMetadata.tableName // category\n                    const tableAlias = relationIdAttr.alias || tableName // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n\n                    const duplicates: { [duplicateKey: string]: boolean } = {}\n                    const parameters: ObjectLiteral = {}\n                    const condition = rawEntities\n                        .map((rawEntity, index) => {\n                            const duplicateParts: Array<string> = []\n                            const parameterParts: ObjectLiteral = {}\n                            const queryPart = joinColumns\n                                .map((joinColumn) => {\n                                    const parameterName =\n                                        joinColumn.databaseName + index\n                                    const parameterValue =\n                                        rawEntity[\n                                            DriverUtils.buildAlias(\n                                                this.connection.driver,\n                                                undefined,\n                                                relationIdAttr.parentAlias,\n                                                joinColumn.referencedColumn!\n                                                    .databaseName,\n                                            )\n                                        ]\n                                    const duplicatePart = `${tableAlias}:${joinColumn.propertyPath}:${parameterValue}`\n                                    if (\n                                        duplicateParts.indexOf(\n                                            duplicatePart,\n                                        ) !== -1\n                                    ) {\n                                        return \"\"\n                                    }\n                                    duplicateParts.push(duplicatePart)\n                                    parameterParts[parameterName] =\n                                        parameterValue\n                                    return (\n                                        tableAlias +\n                                        \".\" +\n                                        joinColumn.propertyPath +\n                                        \" = :\" +\n                                        parameterName\n                                    )\n                                })\n                                .filter((v) => v)\n                                .join(\" AND \")\n                            duplicateParts.sort()\n                            const duplicate = duplicateParts.join(\"::\")\n                            if (duplicates[duplicate]) {\n                                return \"\"\n                            }\n                            duplicates[duplicate] = true\n                            Object.assign(parameters, parameterParts)\n                            return queryPart\n                        })\n                        .filter((v) => v)\n                        .map((condition) => \"(\" + condition + \")\")\n                        .join(\" OR \")\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (!condition)\n                        return {\n                            relationIdAttribute: relationIdAttr,\n                            results: [],\n                        }\n\n                    // generate query:\n                    // SELECT category.id, category.postId FROM category category ON category.postId = :postId\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner,\n                    )\n\n                    const columns = OrmUtils.uniq(\n                        [\n                            ...joinColumns,\n                            ...relation.inverseRelation!.entityMetadata\n                                .primaryColumns,\n                        ],\n                        (column) => column.propertyPath,\n                    )\n\n                    columns.forEach((joinColumn) => {\n                        qb.addSelect(\n                            tableAlias + \".\" + joinColumn.propertyPath,\n                            joinColumn.databaseName,\n                        )\n                    })\n\n                    qb.from(table, tableAlias)\n                        .where(\"(\" + condition + \")\") // need brackets because if we have additional condition and no brackets, it looks like (a = 1) OR (a = 2) AND b = 1, that is incorrect\n                        .setParameters(parameters)\n\n                    // apply condition (custom query builder factory)\n                    if (relationIdAttr.queryBuilderFactory)\n                        relationIdAttr.queryBuilderFactory(qb)\n\n                    const results = await qb.getRawMany()\n                    results.forEach((result) => {\n                        joinColumns.forEach((column) => {\n                            result[column.databaseName] =\n                                this.connection.driver.prepareHydratedValue(\n                                    result[column.databaseName],\n                                    column.referencedColumn!,\n                                )\n                        })\n                        relation.inverseRelation!.entityMetadata.primaryColumns.forEach(\n                            (column) => {\n                                result[column.databaseName] =\n                                    this.connection.driver.prepareHydratedValue(\n                                        result[column.databaseName],\n                                        column,\n                                    )\n                            },\n                        )\n                    })\n\n                    return {\n                        relationIdAttribute: relationIdAttr,\n                        results,\n                    }\n                } else {\n                    // many-to-many\n                    // example: Post and Category\n                    // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                    // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n                    // we expect it to load array of post ids\n\n                    const relation = relationIdAttr.relation\n                    const joinColumns = relation.isOwning\n                        ? relation.joinColumns\n                        : relation.inverseRelation!.inverseJoinColumns\n                    const inverseJoinColumns = relation.isOwning\n                        ? relation.inverseJoinColumns\n                        : relation.inverseRelation!.joinColumns\n                    const junctionAlias = relationIdAttr.junctionAlias\n                    const inverseSideTableName =\n                        relationIdAttr.joinInverseSideMetadata.tableName\n                    const inverseSideTableAlias =\n                        relationIdAttr.alias || inverseSideTableName\n                    const junctionTableName = relation.isOwning\n                        ? relation.junctionEntityMetadata!.tableName\n                        : relation.inverseRelation!.junctionEntityMetadata!\n                              .tableName\n\n                    const mappedColumns = rawEntities.map((rawEntity) => {\n                        return joinColumns.reduce((map, joinColumn) => {\n                            map[joinColumn.propertyPath] =\n                                rawEntity[\n                                    DriverUtils.buildAlias(\n                                        this.connection.driver,\n                                        undefined,\n                                        relationIdAttr.parentAlias,\n                                        joinColumn.referencedColumn!\n                                            .databaseName,\n                                    )\n                                ]\n                            return map\n                        }, {} as ObjectLiteral)\n                    })\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (mappedColumns.length === 0)\n                        return {\n                            relationIdAttribute: relationIdAttr,\n                            results: [],\n                        }\n\n                    const parameters: ObjectLiteral = {}\n                    const duplicates: { [duplicateKey: string]: boolean } = {}\n                    const joinColumnConditions = mappedColumns\n                        .map((mappedColumn, index) => {\n                            const duplicateParts: Array<string> = []\n                            const parameterParts: ObjectLiteral = {}\n                            const queryPart = Object.keys(mappedColumn)\n                                .map((key) => {\n                                    const parameterName = key + index\n                                    const parameterValue = mappedColumn[key]\n                                    const duplicatePart = `${junctionAlias}:${key}:${parameterValue}`\n                                    if (\n                                        duplicateParts.indexOf(\n                                            duplicatePart,\n                                        ) !== -1\n                                    ) {\n                                        return \"\"\n                                    }\n                                    duplicateParts.push(duplicatePart)\n                                    parameterParts[parameterName] =\n                                        parameterValue\n                                    return (\n                                        junctionAlias +\n                                        \".\" +\n                                        key +\n                                        \" = :\" +\n                                        parameterName\n                                    )\n                                })\n                                .filter((s) => s)\n                                .join(\" AND \")\n                            duplicateParts.sort()\n                            const duplicate = duplicateParts.join(\"::\")\n                            if (duplicates[duplicate]) {\n                                return \"\"\n                            }\n                            duplicates[duplicate] = true\n                            Object.assign(parameters, parameterParts)\n                            return queryPart\n                        })\n                        .filter((s) => s)\n\n                    const inverseJoinColumnCondition = inverseJoinColumns\n                        .map((joinColumn) => {\n                            return (\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath +\n                                \" = \" +\n                                inverseSideTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath\n                            )\n                        })\n                        .join(\" AND \")\n\n                    const condition = joinColumnConditions\n                        .map((condition) => {\n                            return (\n                                \"(\" +\n                                condition +\n                                \" AND \" +\n                                inverseJoinColumnCondition +\n                                \")\"\n                            )\n                        })\n                        .join(\" OR \")\n\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner,\n                    )\n\n                    inverseJoinColumns.forEach((joinColumn) => {\n                        qb.addSelect(\n                            junctionAlias + \".\" + joinColumn.propertyPath,\n                            joinColumn.databaseName,\n                        ).addOrderBy(\n                            junctionAlias + \".\" + joinColumn.propertyPath,\n                        )\n                    })\n\n                    joinColumns.forEach((joinColumn) => {\n                        qb.addSelect(\n                            junctionAlias + \".\" + joinColumn.propertyPath,\n                            joinColumn.databaseName,\n                        ).addOrderBy(\n                            junctionAlias + \".\" + joinColumn.propertyPath,\n                        )\n                    })\n\n                    qb.from(inverseSideTableName, inverseSideTableAlias)\n                        .innerJoin(junctionTableName, junctionAlias, condition)\n                        .setParameters(parameters)\n\n                    // apply condition (custom query builder factory)\n                    if (relationIdAttr.queryBuilderFactory)\n                        relationIdAttr.queryBuilderFactory(qb)\n\n                    const results = await qb.getRawMany()\n                    results.forEach((result) => {\n                        ;[...joinColumns, ...inverseJoinColumns].forEach(\n                            (column) => {\n                                result[column.databaseName] =\n                                    this.connection.driver.prepareHydratedValue(\n                                        result[column.databaseName],\n                                        column.referencedColumn!,\n                                    )\n                            },\n                        )\n                    })\n\n                    return {\n                        relationIdAttribute: relationIdAttr,\n                        results,\n                    }\n                }\n            },\n        )\n\n        return Promise.all(promises)\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3539, "column": 0}, "map": {"version":3,"file":"RelationIdLoader.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/RelationIdLoader.ts"],"sourcesContent":["import { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { SelectQueryBuilder } from \"./SelectQueryBuilder\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\n\n/**\n * Loads relation ids for the given entities.\n */\nexport class RelationIdLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        private connection: DataSource,\n        protected queryRunner?: QueryRunner | undefined,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation ids of the given entity or entities.\n     */\n    load(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        relatedEntityOrRelatedEntities?: ObjectLiteral | ObjectLiteral[],\n    ): Promise<any[]> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n        const relatedEntities = Array.isArray(relatedEntityOrRelatedEntities)\n            ? relatedEntityOrRelatedEntities\n            : relatedEntityOrRelatedEntities\n            ? [relatedEntityOrRelatedEntities]\n            : undefined\n\n        // load relation ids depend of relation type\n        if (relation.isManyToMany) {\n            return this.loadForManyToMany(relation, entities, relatedEntities)\n        } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n            return this.loadForManyToOneAndOneToOneOwner(\n                relation,\n                entities,\n                relatedEntities,\n            )\n        } else {\n            // if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            return this.loadForOneToManyAndOneToOneNotOwner(\n                relation,\n                entities,\n                relatedEntities,\n            )\n        }\n    }\n\n    /**\n     * Loads relation ids of the given entities and groups them into the object with parent and children.\n     *\n     * todo: extract this method?\n     */\n    async loadManyToManyRelationIdsAndGroup<\n        E1 extends ObjectLiteral,\n        E2 extends ObjectLiteral,\n    >(\n        relation: RelationMetadata,\n        entitiesOrEntities: E1 | E1[],\n        relatedEntityOrEntities?: E2 | E2[],\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<{ entity: E1; related?: E2 | E2[] }[]> {\n        // console.log(\"relation:\", relation.propertyName);\n        // console.log(\"entitiesOrEntities\", entitiesOrEntities);\n        const isMany = relation.isManyToMany || relation.isOneToMany\n        const entities: E1[] = Array.isArray(entitiesOrEntities)\n            ? entitiesOrEntities\n            : [entitiesOrEntities]\n\n        if (!relatedEntityOrEntities) {\n            relatedEntityOrEntities = await this.connection.relationLoader.load(\n                relation,\n                entitiesOrEntities,\n                this.queryRunner,\n                queryBuilder,\n            )\n            if (!relatedEntityOrEntities.length)\n                return entities.map((entity) => ({\n                    entity: entity,\n                    related: isMany ? [] : undefined,\n                }))\n        }\n        // const relationIds = await this.load(relation, relatedEntityOrEntities!, entitiesOrEntities);\n        const relationIds = await this.load(\n            relation,\n            entitiesOrEntities,\n            relatedEntityOrEntities,\n        )\n        // console.log(\"entities\", entities);\n        // console.log(\"relatedEntityOrEntities\", relatedEntityOrEntities);\n        // console.log(\"relationIds\", relationIds);\n\n        const relatedEntities: E2[] = Array.isArray(relatedEntityOrEntities)\n            ? relatedEntityOrEntities\n            : [relatedEntityOrEntities!]\n\n        let columns: ColumnMetadata[] = [],\n            inverseColumns: ColumnMetadata[] = []\n        if (relation.isManyToManyOwner) {\n            columns = relation.junctionEntityMetadata!.inverseColumns.map(\n                (column) => column.referencedColumn!,\n            )\n            inverseColumns = relation.junctionEntityMetadata!.ownerColumns.map(\n                (column) => column.referencedColumn!,\n            )\n        } else if (relation.isManyToManyNotOwner) {\n            columns = relation.junctionEntityMetadata!.ownerColumns.map(\n                (column) => column.referencedColumn!,\n            )\n            inverseColumns =\n                relation.junctionEntityMetadata!.inverseColumns.map(\n                    (column) => column.referencedColumn!,\n                )\n        } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.joinColumns.map(\n                (column) => column.referencedColumn!,\n            )\n            inverseColumns = relation.entityMetadata.primaryColumns\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation!.entityMetadata.primaryColumns\n            inverseColumns = relation.inverseRelation!.joinColumns.map(\n                (column) => column.referencedColumn!,\n            )\n        } else {\n        }\n\n        return entities.map((entity) => {\n            const group: { entity: E1; related?: E2 | E2[] } = {\n                entity: entity,\n                related: isMany ? [] : undefined,\n            }\n\n            const entityRelationIds = relationIds.filter((relationId) => {\n                return inverseColumns.every((column) => {\n                    return column.compareEntityValue(\n                        entity,\n                        relationId[\n                            column.entityMetadata.name +\n                                \"_\" +\n                                column.propertyAliasName\n                        ],\n                    )\n                })\n            })\n            if (!entityRelationIds.length) return group\n\n            relatedEntities.forEach((relatedEntity) => {\n                entityRelationIds.forEach((relationId) => {\n                    const relatedEntityMatched = columns.every((column) => {\n                        return column.compareEntityValue(\n                            relatedEntity,\n                            relationId[\n                                DriverUtils.buildAlias(\n                                    this.connection.driver,\n                                    undefined,\n                                    column.entityMetadata.name +\n                                        \"_\" +\n                                        relation.propertyPath.replace(\n                                            \".\",\n                                            \"_\",\n                                        ) +\n                                        \"_\" +\n                                        column.propertyPath.replace(\".\", \"_\"),\n                                )\n                            ],\n                        )\n                    })\n                    if (relatedEntityMatched) {\n                        if (isMany) {\n                            ;(group.related as E2[]).push(relatedEntity)\n                        } else {\n                            group.related = relatedEntity\n                        }\n                    }\n                })\n            })\n            return group\n        })\n    }\n\n    /**\n     * Loads relation ids of the given entities and maps them into the given entity property.\n     async loadManyToManyRelationIdsAndMap(\n     relation: RelationMetadata,\n     entityOrEntities: ObjectLiteral|ObjectLiteral[],\n     mapToEntityOrEntities: ObjectLiteral|ObjectLiteral[],\n     propertyName: string\n     ): Promise<void> {\n        const relationIds = await this.loadManyToManyRelationIds(relation, entityOrEntities, mapToEntityOrEntities);\n        const mapToEntities = mapToEntityOrEntities instanceof Array ? mapToEntityOrEntities : [mapToEntityOrEntities];\n        const junctionMetadata = relation.junctionEntityMetadata!;\n        const mainAlias = junctionMetadata.name;\n        const columns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n        const inverseColumns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n        mapToEntities.forEach(mapToEntity => {\n            mapToEntity[propertyName] = [];\n            relationIds.forEach(relationId => {\n                const match = inverseColumns.every(column => {\n                    return column.referencedColumn!.getEntityValue(mapToEntity) === relationId[mainAlias + \"_\" + column.propertyName];\n                });\n                if (match) {\n                    if (columns.length === 1) {\n                        mapToEntity[propertyName].push(relationId[mainAlias + \"_\" + columns[0].propertyName]);\n                    } else {\n                        const value = {};\n                        columns.forEach(column => {\n                            column.referencedColumn!.setEntityValue(value, relationId[mainAlias + \"_\" + column.propertyName]);\n                        });\n                        mapToEntity[propertyName].push(value);\n                    }\n                }\n            });\n        });\n    }*/\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation ids for the many-to-many relation.\n     */\n    protected loadForManyToMany(\n        relation: RelationMetadata,\n        entities: ObjectLiteral[],\n        relatedEntities?: ObjectLiteral[],\n    ) {\n        const junctionMetadata = relation.junctionEntityMetadata!\n        const mainAlias = junctionMetadata.name\n        const columns = relation.isOwning\n            ? junctionMetadata.ownerColumns\n            : junctionMetadata.inverseColumns\n        const inverseColumns = relation.isOwning\n            ? junctionMetadata.inverseColumns\n            : junctionMetadata.ownerColumns\n        const qb = this.connection.createQueryBuilder(this.queryRunner)\n\n        // select all columns from junction table\n        columns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                column.referencedColumn!.entityMetadata.name +\n                    \"_\" +\n                    column.referencedColumn!.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName)\n        })\n        inverseColumns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                column.referencedColumn!.entityMetadata.name +\n                    \"_\" +\n                    relation.propertyPath.replace(\".\", \"_\") +\n                    \"_\" +\n                    column.referencedColumn!.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName)\n        })\n\n        // add conditions for the given entities\n        let condition1 = \"\"\n        if (columns.length === 1) {\n            const values = entities.map((entity) =>\n                columns[0].referencedColumn!.getEntityValue(entity),\n            )\n            const areAllNumbers = values.every(\n                (value) => typeof value === \"number\",\n            )\n\n            if (areAllNumbers) {\n                condition1 = `${mainAlias}.${\n                    columns[0].propertyPath\n                } IN (${values.join(\", \")})`\n            } else {\n                qb.setParameter(\"values1\", values)\n                condition1 =\n                    mainAlias +\n                    \".\" +\n                    columns[0].propertyPath +\n                    \" IN (:...values1)\" // todo: use ANY for postgres\n            }\n        } else {\n            condition1 =\n                \"(\" +\n                entities\n                    .map((entity, entityIndex) => {\n                        return columns\n                            .map((column) => {\n                                const paramName =\n                                    \"entity1_\" +\n                                    entityIndex +\n                                    \"_\" +\n                                    column.propertyName\n                                qb.setParameter(\n                                    paramName,\n                                    column.referencedColumn!.getEntityValue(\n                                        entity,\n                                    ),\n                                )\n                                return (\n                                    mainAlias +\n                                    \".\" +\n                                    column.propertyPath +\n                                    \" = :\" +\n                                    paramName\n                                )\n                            })\n                            .join(\" AND \")\n                    })\n                    .map((condition) => \"(\" + condition + \")\")\n                    .join(\" OR \") +\n                \")\"\n        }\n\n        // add conditions for the given inverse entities\n        let condition2 = \"\"\n        if (relatedEntities) {\n            if (inverseColumns.length === 1) {\n                const values = relatedEntities.map((entity) =>\n                    inverseColumns[0].referencedColumn!.getEntityValue(entity),\n                )\n                const areAllNumbers = values.every(\n                    (value) => typeof value === \"number\",\n                )\n\n                if (areAllNumbers) {\n                    condition2 = `${mainAlias}.${\n                        inverseColumns[0].propertyPath\n                    } IN (${values.join(\", \")})`\n                } else {\n                    qb.setParameter(\"values2\", values)\n                    condition2 =\n                        mainAlias +\n                        \".\" +\n                        inverseColumns[0].propertyPath +\n                        \" IN (:...values2)\" // todo: use ANY for postgres\n                }\n            } else {\n                condition2 =\n                    \"(\" +\n                    relatedEntities\n                        .map((entity, entityIndex) => {\n                            return inverseColumns\n                                .map((column) => {\n                                    const paramName =\n                                        \"entity2_\" +\n                                        entityIndex +\n                                        \"_\" +\n                                        column.propertyName\n                                    qb.setParameter(\n                                        paramName,\n                                        column.referencedColumn!.getEntityValue(\n                                            entity,\n                                        ),\n                                    )\n                                    return (\n                                        mainAlias +\n                                        \".\" +\n                                        column.propertyPath +\n                                        \" = :\" +\n                                        paramName\n                                    )\n                                })\n                                .join(\" AND \")\n                        })\n                        .map((condition) => \"(\" + condition + \")\")\n                        .join(\" OR \") +\n                    \")\"\n            }\n        }\n\n        // qb.from(junctionMetadata.target, mainAlias)\n        //     .where(condition1 + (condition2 ? \" AND \" + condition2 : \"\"));\n        //\n        // // execute query\n        // const { values1, values2 } = qb.getParameters();\n        // console.log(`I can do it`, { values1, values2 });\n        // if (inverseColumns.length === 1 &&\n        //     columns.length === 1 &&\n        //     this.connection.driver instanceof SqliteDriver &&\n        //     (values1.length + values2.length) > 500 &&\n        //     values1.length === values2.length) {\n        //     console.log(`I can do it`);\n        //     return qb.getRawMany();\n        //\n        // } else {\n        //     return qb.getRawMany();\n        // }\n\n        // execute query\n        const condition = [condition1, condition2]\n            .filter((v) => v.length > 0)\n            .join(\" AND \")\n        return qb\n            .from(junctionMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany()\n    }\n\n    /**\n     * Loads relation ids for the many-to-one and one-to-one owner relations.\n     */\n    protected loadForManyToOneAndOneToOneOwner(\n        relation: RelationMetadata,\n        entities: ObjectLiteral[],\n        relatedEntities?: ObjectLiteral[],\n    ) {\n        const mainAlias = relation.entityMetadata.targetName\n\n        // console.log(\"entitiesx\", entities);\n        // console.log(\"relatedEntitiesx\", relatedEntities);\n        const hasAllJoinColumnsInEntity = relation.joinColumns.every(\n            (joinColumn) => {\n                return !!relation.entityMetadata.nonVirtualColumns.find(\n                    (column) => column === joinColumn,\n                )\n            },\n        )\n        if (relatedEntities && hasAllJoinColumnsInEntity) {\n            const relationIdMaps: ObjectLiteral[] = []\n            entities.forEach((entity) => {\n                const relationIdMap: ObjectLiteral = {}\n                relation.entityMetadata.primaryColumns.forEach(\n                    (primaryColumn) => {\n                        const key =\n                            primaryColumn.entityMetadata.name +\n                            \"_\" +\n                            primaryColumn.propertyPath.replace(\".\", \"_\")\n                        relationIdMap[key] =\n                            primaryColumn.getEntityValue(entity)\n                    },\n                )\n\n                relatedEntities.forEach((relatedEntity) => {\n                    relation.joinColumns.forEach((joinColumn) => {\n                        const entityColumnValue =\n                            joinColumn.getEntityValue(entity)\n                        const relatedEntityColumnValue =\n                            joinColumn.referencedColumn!.getEntityValue(\n                                relatedEntity,\n                            )\n                        if (\n                            entityColumnValue === undefined ||\n                            relatedEntityColumnValue === undefined\n                        )\n                            return\n\n                        if (entityColumnValue === relatedEntityColumnValue) {\n                            const key =\n                                joinColumn.referencedColumn!.entityMetadata\n                                    .name +\n                                \"_\" +\n                                relation.propertyPath.replace(\".\", \"_\") +\n                                \"_\" +\n                                joinColumn.referencedColumn!.propertyPath.replace(\n                                    \".\",\n                                    \"_\",\n                                )\n                            relationIdMap[key] = relatedEntityColumnValue\n                        }\n                    })\n                })\n                if (\n                    Object.keys(relationIdMap).length ===\n                    relation.entityMetadata.primaryColumns.length +\n                        relation.joinColumns.length\n                ) {\n                    relationIdMaps.push(relationIdMap)\n                }\n            })\n            // console.log(\"relationIdMap\", relationIdMaps);\n            // console.log(\"entities.length\", entities.length);\n            if (relationIdMaps.length === entities.length)\n                return Promise.resolve(relationIdMaps)\n        }\n\n        // select all columns we need\n        const qb = this.connection.createQueryBuilder(this.queryRunner)\n        relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                primaryColumn.entityMetadata.name +\n                    \"_\" +\n                    primaryColumn.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(\n                mainAlias + \".\" + primaryColumn.propertyPath,\n                columnName,\n            )\n        })\n        relation.joinColumns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                column.referencedColumn!.entityMetadata.name +\n                    \"_\" +\n                    relation.propertyPath.replace(\".\", \"_\") +\n                    \"_\" +\n                    column.referencedColumn!.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName)\n        })\n\n        // add condition for entities\n        let condition: string = \"\"\n        if (relation.entityMetadata.primaryColumns.length === 1) {\n            const values = entities.map((entity) =>\n                relation.entityMetadata.primaryColumns[0].getEntityValue(\n                    entity,\n                ),\n            )\n            const areAllNumbers = values.every(\n                (value) => typeof value === \"number\",\n            )\n\n            if (areAllNumbers) {\n                condition = `${mainAlias}.${\n                    relation.entityMetadata.primaryColumns[0].propertyPath\n                } IN (${values.join(\", \")})`\n            } else {\n                qb.setParameter(\"values\", values)\n                condition =\n                    mainAlias +\n                    \".\" +\n                    relation.entityMetadata.primaryColumns[0].propertyPath +\n                    \" IN (:...values)\" // todo: use ANY for postgres\n            }\n        } else {\n            condition = entities\n                .map((entity, entityIndex) => {\n                    return relation.entityMetadata.primaryColumns\n                        .map((column, columnIndex) => {\n                            const paramName =\n                                \"entity\" + entityIndex + \"_\" + columnIndex\n                            qb.setParameter(\n                                paramName,\n                                column.getEntityValue(entity),\n                            )\n                            return (\n                                mainAlias +\n                                \".\" +\n                                column.propertyPath +\n                                \" = :\" +\n                                paramName\n                            )\n                        })\n                        .join(\" AND \")\n                })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \")\n        }\n\n        // execute query\n        return qb\n            .from(relation.entityMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany()\n    }\n\n    /**\n     * Loads relation ids for the one-to-many and one-to-one not owner relations.\n     */\n    protected loadForOneToManyAndOneToOneNotOwner(\n        relation: RelationMetadata,\n        entities: ObjectLiteral[],\n        relatedEntities?: ObjectLiteral[],\n    ) {\n        const originalRelation = relation\n        relation = relation.inverseRelation!\n\n        if (\n            relation.entityMetadata.primaryColumns.length ===\n            relation.joinColumns.length\n        ) {\n            const sameReferencedColumns =\n                relation.entityMetadata.primaryColumns.every((column) => {\n                    return relation.joinColumns.indexOf(column) !== -1\n                })\n            if (sameReferencedColumns) {\n                return Promise.resolve(\n                    entities.map((entity) => {\n                        const result: ObjectLiteral = {}\n                        relation.joinColumns.forEach(function (joinColumn) {\n                            const value =\n                                joinColumn.referencedColumn!.getEntityValue(\n                                    entity,\n                                )\n                            const joinColumnName =\n                                joinColumn.referencedColumn!.entityMetadata\n                                    .name +\n                                \"_\" +\n                                joinColumn.referencedColumn!.propertyPath.replace(\n                                    \".\",\n                                    \"_\",\n                                )\n                            const primaryColumnName =\n                                joinColumn.entityMetadata.name +\n                                \"_\" +\n                                originalRelation.propertyPath.replace(\n                                    \".\",\n                                    \"_\",\n                                ) +\n                                \"_\" +\n                                joinColumn.propertyPath.replace(\".\", \"_\")\n                            result[joinColumnName] = value\n                            result[primaryColumnName] = value\n                        })\n                        return result\n                    }),\n                )\n            }\n        }\n\n        const mainAlias = relation.entityMetadata.targetName\n\n        // select all columns we need\n        const qb = this.connection.createQueryBuilder(this.queryRunner)\n        relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                primaryColumn.entityMetadata.name +\n                    \"_\" +\n                    originalRelation.propertyPath.replace(\".\", \"_\") +\n                    \"_\" +\n                    primaryColumn.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(\n                mainAlias + \".\" + primaryColumn.propertyPath,\n                columnName,\n            )\n        })\n        relation.joinColumns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(\n                this.connection.driver,\n                undefined,\n                column.referencedColumn!.entityMetadata.name +\n                    \"_\" +\n                    column.referencedColumn!.propertyPath.replace(\".\", \"_\"),\n            )\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName)\n        })\n\n        // add condition for entities\n        let condition: string = \"\"\n        if (relation.joinColumns.length === 1) {\n            const values = entities.map((entity) =>\n                relation.joinColumns[0].referencedColumn!.getEntityValue(\n                    entity,\n                ),\n            )\n            const areAllNumbers = values.every(\n                (value) => typeof value === \"number\",\n            )\n\n            if (areAllNumbers) {\n                condition = `${mainAlias}.${\n                    relation.joinColumns[0].propertyPath\n                } IN (${values.join(\", \")})`\n            } else {\n                qb.setParameter(\"values\", values)\n                condition =\n                    mainAlias +\n                    \".\" +\n                    relation.joinColumns[0].propertyPath +\n                    \" IN (:...values)\" // todo: use ANY for postgres\n            }\n        } else {\n            condition = entities\n                .map((entity, entityIndex) => {\n                    return relation.joinColumns\n                        .map((joinColumn, joinColumnIndex) => {\n                            const paramName =\n                                \"entity\" + entityIndex + \"_\" + joinColumnIndex\n                            qb.setParameter(\n                                paramName,\n                                joinColumn.referencedColumn!.getEntityValue(\n                                    entity,\n                                ),\n                            )\n                            return (\n                                mainAlias +\n                                \".\" +\n                                joinColumn.propertyPath +\n                                \" = :\" +\n                                paramName\n                            )\n                        })\n                        .join(\" AND \")\n                })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \")\n        }\n\n        // execute query\n        return qb\n            .from(relation.entityMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany()\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3898, "column": 0}, "map": {"version":3,"file":"RelationIdMetadataToAttributeTransformer.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/relation-id/RelationIdMetadataToAttributeTransformer.ts"],"sourcesContent":["import { RelationIdAttribute } from \"./RelationIdAttribute\"\nimport { QueryExpressionMap } from \"../QueryExpressionMap\"\nimport { RelationIdMetadata } from \"../../metadata/RelationIdMetadata\"\n\nexport class RelationIdMetadataToAttributeTransformer {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected expressionMap: QueryExpressionMap) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform() {\n        // by example:\n        // post has relation id:\n        // @RelationId(post => post.categories) categoryIds\n        // category has relation id\n        // @RelationId(category => category.images) imageIds\n        // we load post and join category\n        // we expect post.categoryIds and post.category.imageIds to have relation ids\n\n        // first create relation id attributes for all relation id metadatas of the main selected object (post from example)\n        if (this.expressionMap.mainAlias) {\n            this.expressionMap.mainAlias.metadata.relationIds.forEach(\n                (relationId) => {\n                    const attribute = this.metadataToAttribute(\n                        this.expressionMap.mainAlias!.name,\n                        relationId,\n                    )\n                    this.expressionMap.relationIdAttributes.push(attribute)\n                },\n            )\n        }\n\n        // second create relation id attributes for all relation id metadatas of all joined objects (category from example)\n        this.expressionMap.joinAttributes.forEach((join) => {\n            // ensure this join has a metadata, because relation id can only work for real orm entities\n            if (!join.metadata || join.metadata.isJunction) return\n\n            join.metadata.relationIds.forEach((relationId) => {\n                const attribute = this.metadataToAttribute(\n                    join.alias.name,\n                    relationId,\n                )\n                this.expressionMap.relationIdAttributes.push(attribute)\n            })\n        })\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private metadataToAttribute(\n        parentAliasName: string,\n        relationId: RelationIdMetadata,\n    ): RelationIdAttribute {\n        return new RelationIdAttribute(this.expressionMap, {\n            relationName:\n                parentAliasName + \".\" + relationId.relation.propertyName, // category.images\n            mapToProperty: parentAliasName + \".\" + relationId.propertyName, // category.imageIds\n            alias: relationId.alias,\n            queryBuilderFactory: relationId.queryBuilderFactory,\n        })\n    }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,yDAA2D;AAI3D,MAAa,wCAAwC;IACjD,4EAA4E;IAC5E,cAAc;IACd,4EAA4E;IAE5E,YAAsB,aAAiC,CAAA;QAAjC,IAAA,CAAA,aAAa,GAAb,aAAa,CAAoB;IAAG,CAAC;IAE3D,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E,SAAS,GAAA;QACL,cAAc;QACd,wBAAwB;QACxB,mDAAmD;QACnD,2BAA2B;QAC3B,oDAAoD;QACpD,iCAAiC;QACjC,6EAA6E;QAE7E,oHAAoH;QACpH,IAAI,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,CAAC;YAC/B,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,CAAC,OAAO,CACrD,CAAC,UAAU,EAAE,EAAE;gBACX,MAAM,SAAS,GAAG,IAAI,CAAC,mBAAmB,CACtC,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,EAClC,UAAU,CACb,CAAA;gBACD,IAAI,CAAC,aAAa,CAAC,oBAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;YAC3D,CAAC,CACJ,CAAA;QACL,CAAC;QAED,mHAAmH;QACnH,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YAC/C,2FAA2F;YAC3F,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,OAAM;YAEtD,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,EAAE;gBAC7C,MAAM,SAAS,GAAG,IAAI,CAAC,mBAAmB,CACtC,IAAI,CAAC,KAAK,CAAC,IAAI,EACf,UAAU,CACb,CAAA;gBACD,IAAI,CAAC,aAAa,CAAC,oBAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;YAC3D,CAAC,CAAC,CAAA;QACN,CAAC,CAAC,CAAA;IACN,CAAC;IAED,4EAA4E;IAC5E,kBAAkB;IAClB,4EAA4E;IAEpE,mBAAmB,CACvB,eAAuB,EACvB,UAA8B,EAAA;QAE9B,OAAO,IAAI,sBAAA,mBAAmB,CAAC,IAAI,CAAC,aAAa,EAAE;YAC/C,YAAY,EACR,eAAe,GAAG,GAAG,GAAG,UAAU,CAAC,QAAQ,CAAC,YAAY,EAAE,kBAAkB;YAChF,aAAa,EAAE,eAAe,GAAG,GAAG,GAAG,UAAU,CAAC,YAAY,EAAE,oBAAoB;YACpF,KAAK,EAAE,UAAU,CAAC,KAAK;YACvB,mBAAmB,EAAE,UAAU,CAAC,mBAAmB;SACtD,CAAC,CAAA;IACN,CAAC;CACJ;AAhED,QAAA,wCAAA,GAAA,yCAgEC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3957, "column": 0}, "map": {"version":3,"file":"RelationCountLoader.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/relation-count/RelationCountLoader.ts"],"sourcesContent":["import { ColumnMetadata } from \"../../metadata/ColumnMetadata\"\nimport { DataSource } from \"../../data-source/DataSource\"\nimport { RelationCountAttribute } from \"./RelationCountAttribute\"\nimport { RelationCountLoadResult } from \"./RelationCountLoadResult\"\nimport { QueryRunner } from \"../../query-runner/QueryRunner\"\n\nexport class RelationCountLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        protected connection: DataSource,\n        protected queryRunner: QueryRunner | undefined,\n        protected relationCountAttributes: RelationCountAttribute[],\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async load(rawEntities: any[]): Promise<RelationCountLoadResult[]> {\n        const onlyUnique = (value: any, index: number, self: any) => {\n            return self.indexOf(value) === index\n        }\n\n        const promises = this.relationCountAttributes.map(\n            async (relationCountAttr) => {\n                if (relationCountAttr.relation.isOneToMany) {\n                    // example: Post and Category\n                    // loadRelationCountAndMap(\"post.categoryCount\", \"post.categories\")\n                    // we expect it to load array of post ids\n\n                    // todo(dima): fix issues wit multiple primary keys and remove joinColumns[0]\n                    const relation = relationCountAttr.relation // \"category.posts\"\n                    const inverseRelation = relation.inverseRelation! // \"post.category\"\n                    const referenceColumnName =\n                        inverseRelation.joinColumns[0].referencedColumn!\n                            .propertyName // post id\n                    const inverseSideTable =\n                        relation.inverseEntityMetadata.target // Post\n                    const inverseSideTableName =\n                        relation.inverseEntityMetadata.tableName // post\n                    const inverseSideTableAlias =\n                        relationCountAttr.alias || inverseSideTableName // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n                    const inverseSidePropertyName = inverseRelation.propertyName // \"category\" from \"post.category\"\n\n                    let referenceColumnValues = rawEntities\n                        .map(\n                            (rawEntity) =>\n                                rawEntity[\n                                    relationCountAttr.parentAlias +\n                                        \"_\" +\n                                        referenceColumnName\n                                ],\n                        )\n                        .filter((value) => !!value)\n                    referenceColumnValues =\n                        referenceColumnValues.filter(onlyUnique)\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (referenceColumnValues.length === 0)\n                        return {\n                            relationCountAttribute: relationCountAttr,\n                            results: [],\n                        }\n\n                    // generate query:\n                    // SELECT category.post as parentId, COUNT(*) AS cnt FROM category category WHERE category.post IN (1, 2) GROUP BY category.post\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner,\n                    )\n                    qb.select(\n                        inverseSideTableAlias + \".\" + inverseSidePropertyName,\n                        \"parentId\",\n                    )\n                        .addSelect(\"COUNT(*)\", \"cnt\")\n                        .from(inverseSideTable, inverseSideTableAlias)\n                        .where(\n                            inverseSideTableAlias +\n                                \".\" +\n                                inverseSidePropertyName +\n                                \" IN (:...ids)\",\n                        )\n                        .addGroupBy(\n                            inverseSideTableAlias +\n                                \".\" +\n                                inverseSidePropertyName,\n                        )\n                        .setParameter(\"ids\", referenceColumnValues)\n\n                    // apply condition (custom query builder factory)\n                    if (relationCountAttr.queryBuilderFactory)\n                        relationCountAttr.queryBuilderFactory(qb)\n\n                    return {\n                        relationCountAttribute: relationCountAttr,\n                        results: await qb.getRawMany(),\n                    }\n                } else {\n                    // example: Post and Category\n                    // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                    // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n                    // we expect it to load array of post ids\n\n                    let joinTableColumnName: string\n                    let inverseJoinColumnName: string\n                    let firstJunctionColumn: ColumnMetadata\n                    let secondJunctionColumn: ColumnMetadata\n\n                    if (relationCountAttr.relation.isOwning) {\n                        // todo fix joinColumns[0] and inverseJoinColumns[0].\n                        joinTableColumnName =\n                            relationCountAttr.relation.joinColumns[0]\n                                .referencedColumn!.databaseName\n                        inverseJoinColumnName =\n                            relationCountAttr.relation.inverseJoinColumns[0]\n                                .referencedColumn!.databaseName\n                        firstJunctionColumn =\n                            relationCountAttr.relation.junctionEntityMetadata!\n                                .columns[0]\n                        secondJunctionColumn =\n                            relationCountAttr.relation.junctionEntityMetadata!\n                                .columns[1]\n                    } else {\n                        joinTableColumnName =\n                            relationCountAttr.relation.inverseRelation!\n                                .inverseJoinColumns[0].referencedColumn!\n                                .databaseName\n                        inverseJoinColumnName =\n                            relationCountAttr.relation.inverseRelation!\n                                .joinColumns[0].referencedColumn!.databaseName\n                        firstJunctionColumn =\n                            relationCountAttr.relation.junctionEntityMetadata!\n                                .columns[1]\n                        secondJunctionColumn =\n                            relationCountAttr.relation.junctionEntityMetadata!\n                                .columns[0]\n                    }\n\n                    let referenceColumnValues = rawEntities\n                        .map(\n                            (rawEntity) =>\n                                rawEntity[\n                                    relationCountAttr.parentAlias +\n                                        \"_\" +\n                                        joinTableColumnName\n                                ],\n                        )\n                        .filter((value) => !!value)\n                    referenceColumnValues =\n                        referenceColumnValues.filter(onlyUnique)\n\n                    // ensure we won't perform redundant queries for joined data which was not found in selection\n                    // example: if post.category was not found in db then no need to execute query for category.imageIds\n                    if (referenceColumnValues.length === 0)\n                        return {\n                            relationCountAttribute: relationCountAttr,\n                            results: [],\n                        }\n\n                    const junctionAlias = relationCountAttr.junctionAlias\n                    const inverseSideTableName =\n                        relationCountAttr.joinInverseSideMetadata.tableName\n                    const inverseSideTableAlias =\n                        relationCountAttr.alias || inverseSideTableName\n                    const junctionTableName =\n                        relationCountAttr.relation.junctionEntityMetadata!\n                            .tableName\n\n                    const condition =\n                        junctionAlias +\n                        \".\" +\n                        firstJunctionColumn.propertyName +\n                        \" IN (\" +\n                        referenceColumnValues.map((vals) =>\n                            isNaN(vals) ? \"'\" + vals + \"'\" : vals,\n                        ) +\n                        \")\" +\n                        \" AND \" +\n                        junctionAlias +\n                        \".\" +\n                        secondJunctionColumn.propertyName +\n                        \" = \" +\n                        inverseSideTableAlias +\n                        \".\" +\n                        inverseJoinColumnName\n\n                    const qb = this.connection.createQueryBuilder(\n                        this.queryRunner,\n                    )\n                    qb.select(\n                        junctionAlias + \".\" + firstJunctionColumn.propertyName,\n                        \"parentId\",\n                    )\n                        .addSelect(\n                            \"COUNT(\" +\n                                qb.escape(inverseSideTableAlias) +\n                                \".\" +\n                                qb.escape(inverseJoinColumnName) +\n                                \")\",\n                            \"cnt\",\n                        )\n                        .from(inverseSideTableName, inverseSideTableAlias)\n                        .innerJoin(junctionTableName, junctionAlias, condition)\n                        .addGroupBy(\n                            junctionAlias +\n                                \".\" +\n                                firstJunctionColumn.propertyName,\n                        )\n\n                    // apply condition (custom query builder factory)\n                    if (relationCountAttr.queryBuilderFactory)\n                        relationCountAttr.queryBuilderFactory(qb)\n\n                    return {\n                        relationCountAttribute: relationCountAttr,\n                        results: await qb.getRawMany(),\n                    }\n                }\n            },\n        )\n\n        return Promise.all(promises)\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4062, "column": 0}, "map": {"version":3,"file":"RelationCountMetadataToAttributeTransformer.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/relation-count/RelationCountMetadataToAttributeTransformer.ts"],"sourcesContent":["import { QueryExpressionMap } from \"../QueryExpressionMap\"\nimport { RelationCountMetadata } from \"../../metadata/RelationCountMetadata\"\nimport { RelationCountAttribute } from \"./RelationCountAttribute\"\n\nexport class RelationCountMetadataToAttributeTransformer {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected expressionMap: QueryExpressionMap) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform() {\n        // by example:\n        // post has relation count:\n        // @RelationCount(post => post.categories) categoryCount\n        // category has relation count\n        // @RelationCount(category => category.images) imageCount\n        // we load post and join category\n        // we expect post.categoryCount and post.category.imageCount to have relation counts\n\n        // first create relation count attributes for all relation count metadatas of the main selected object (post from example)\n        if (this.expressionMap.mainAlias) {\n            this.expressionMap.mainAlias.metadata.relationCounts.forEach(\n                (relationCount) => {\n                    const attribute = this.metadataToAttribute(\n                        this.expressionMap.mainAlias!.name,\n                        relationCount,\n                    )\n                    this.expressionMap.relationCountAttributes.push(attribute)\n                },\n            )\n        }\n\n        // second create relation count attributes for all relation count metadatas of all joined objects (category from example)\n        this.expressionMap.joinAttributes.forEach((join) => {\n            // ensure this join has a metadata, because relation count can only work for real orm entities\n            if (!join.metadata || join.metadata.isJunction) return\n\n            join.metadata.relationCounts.forEach((relationCount) => {\n                const attribute = this.metadataToAttribute(\n                    join.alias.name,\n                    relationCount,\n                )\n                this.expressionMap.relationCountAttributes.push(attribute)\n            })\n        })\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private metadataToAttribute(\n        parentAliasName: string,\n        relationCount: RelationCountMetadata,\n    ): RelationCountAttribute {\n        return new RelationCountAttribute(this.expressionMap, {\n            relationName:\n                parentAliasName + \".\" + relationCount.relation.propertyName, // category.images\n            mapToProperty: parentAliasName + \".\" + relationCount.propertyName, // category.imageIds\n            alias: relationCount.alias,\n            queryBuilderFactory: relationCount.queryBuilderFactory,\n        })\n    }\n}\n"],"names":[],"mappings":";;;;;AAEA,MAAA,+DAAiE;AAEjE,MAAa,2CAA2C;IACpD,4EAA4E;IAC5E,cAAc;IACd,4EAA4E;IAE5E,YAAsB,aAAiC,CAAA;QAAjC,IAAA,CAAA,aAAa,GAAb,aAAa,CAAoB;IAAG,CAAC;IAE3D,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E,SAAS,GAAA;QACL,cAAc;QACd,2BAA2B;QAC3B,wDAAwD;QACxD,8BAA8B;QAC9B,yDAAyD;QACzD,iCAAiC;QACjC,oFAAoF;QAEpF,0HAA0H;QAC1H,IAAI,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,CAAC;YAC/B,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAC,cAAc,CAAC,OAAO,CACxD,CAAC,aAAa,EAAE,EAAE;gBACd,MAAM,SAAS,GAAG,IAAI,CAAC,mBAAmB,CACtC,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,EAClC,aAAa,CAChB,CAAA;gBACD,IAAI,CAAC,aAAa,CAAC,uBAAuB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;YAC9D,CAAC,CACJ,CAAA;QACL,CAAC;QAED,yHAAyH;QACzH,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YAC/C,8FAA8F;YAC9F,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,OAAM;YAEtD,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,aAAa,EAAE,EAAE;gBACnD,MAAM,SAAS,GAAG,IAAI,CAAC,mBAAmB,CACtC,IAAI,CAAC,KAAK,CAAC,IAAI,EACf,aAAa,CAChB,CAAA;gBACD,IAAI,CAAC,aAAa,CAAC,uBAAuB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;YAC9D,CAAC,CAAC,CAAA;QACN,CAAC,CAAC,CAAA;IACN,CAAC;IAED,4EAA4E;IAC5E,kBAAkB;IAClB,4EAA4E;IAEpE,mBAAmB,CACvB,eAAuB,EACvB,aAAoC,EAAA;QAEpC,OAAO,IAAI,yBAAA,sBAAsB,CAAC,IAAI,CAAC,aAAa,EAAE;YAClD,YAAY,EACR,eAAe,GAAG,GAAG,GAAG,aAAa,CAAC,QAAQ,CAAC,YAAY,EAAE,kBAAkB;YACnF,aAAa,EAAE,eAAe,GAAG,GAAG,GAAG,aAAa,CAAC,YAAY,EAAE,oBAAoB;YACvF,KAAK,EAAE,aAAa,CAAC,KAAK;YAC1B,mBAAmB,EAAE,aAAa,CAAC,mBAAmB;SACzD,CAAC,CAAA;IACN,CAAC;CACJ;AAhED,QAAA,2CAAA,GAAA,4CAgEC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4121, "column": 0}, "map": {"version":3,"file":"SelectQueryBuilder.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/SelectQueryBuilder.ts"],"sourcesContent":["import { RawSqlResultsToEntityTransformer } from \"./transformer/RawSqlResultsToEntityTransformer\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { PessimisticLockTransactionRequiredError } from \"../error/PessimisticLockTransactionRequiredError\"\nimport { NoVersionOrUpdateDateColumnError } from \"../error/NoVersionOrUpdateDateColumnError\"\nimport { OptimisticLockVersionMismatchError } from \"../error/OptimisticLockVersionMismatchError\"\nimport { OptimisticLockCanNotBeUsedError } from \"../error/OptimisticLockCanNotBeUsedError\"\nimport { JoinAttribute } from \"./JoinAttribute\"\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\"\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\"\nimport { RelationIdLoader } from \"./relation-id/RelationIdLoader\"\nimport { RelationIdLoader as QueryStrategyRelationIdLoader } from \"./RelationIdLoader\"\nimport { RelationIdMetadataToAttributeTransformer } from \"./relation-id/RelationIdMetadataToAttributeTransformer\"\nimport { RelationCountLoader } from \"./relation-count/RelationCountLoader\"\nimport { RelationCountMetadataToAttributeTransformer } from \"./relation-count/RelationCountMetadataToAttributeTransformer\"\nimport { QueryBuilder } from \"./QueryBuilder\"\nimport { ReadStream } from \"../platform/PlatformTools\"\nimport { LockNotSupportedOnGivenDriverError } from \"../error/LockNotSupportedOnGivenDriverError\"\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\"\nimport { SelectQuery } from \"./SelectQuery\"\nimport { EntityMetadata } from \"../metadata/EntityMetadata\"\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { QueryExpressionMap } from \"./QueryExpressionMap\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { WhereExpressionBuilder } from \"./WhereExpressionBuilder\"\nimport { Brackets } from \"./Brackets\"\nimport { QueryResultCacheOptions } from \"../cache/QueryResultCacheOptions\"\nimport { OffsetWithoutLimitNotSupportedError } from \"../error/OffsetWithoutLimitNotSupportedError\"\nimport { SelectQueryBuilderOption } from \"./SelectQueryBuilderOption\"\nimport { ObjectUtils } from \"../util/ObjectUtils\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\"\nimport { TypeORMError } from \"../error\"\nimport { FindManyOptions } from \"../find-options/FindManyOptions\"\nimport { FindOptionsSelect } from \"../find-options/FindOptionsSelect\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { FindOptionsOrder } from \"../find-options/FindOptionsOrder\"\nimport { FindOptionsWhere } from \"../find-options/FindOptionsWhere\"\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"\nimport { FindOptionsRelations } from \"../find-options/FindOptionsRelations\"\nimport { OrmUtils } from \"../util/OrmUtils\"\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\nimport { AuroraMysqlDriver } from \"../driver/aurora-mysql/AuroraMysqlDriver\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\nimport { FindOperator } from \"../find-options/FindOperator\"\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\"\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\"\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SelectQueryBuilder<Entity extends ObjectLiteral>\n    extends QueryBuilder<Entity>\n    implements WhereExpressionBuilder\n{\n    readonly \"@instanceof\" = Symbol.for(\"SelectQueryBuilder\")\n\n    protected findOptions: FindManyOptions = {}\n    protected selects: string[] = []\n    protected joins: {\n        type: \"inner\" | \"left\"\n        alias: string\n        parentAlias: string\n        relationMetadata: RelationMetadata\n        select: boolean\n        selection: FindOptionsSelect<any> | undefined\n    }[] = []\n    protected conditions: string = \"\"\n    protected orderBys: {\n        alias: string\n        direction: \"ASC\" | \"DESC\"\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\"\n    }[] = []\n    protected relationMetadatas: RelationMetadata[] = []\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment()\n        sql += this.createCteExpression()\n        sql += this.createSelectExpression()\n        sql += this.createJoinExpression()\n        sql += this.createWhereExpression()\n        sql += this.createGroupByExpression()\n        sql += this.createHavingExpression()\n        sql += this.createOrderByExpression()\n        sql += this.createLimitOffsetExpression()\n        sql += this.createLockExpression()\n        sql = sql.trim()\n        if (this.expressionMap.subQuery) sql = \"(\" + sql + \")\"\n        return this.replacePropertyNamesForTheWholeQuery(sql)\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    setFindOptions(findOptions: FindManyOptions<Entity>) {\n        this.findOptions = findOptions\n        this.applyFindOptions()\n        return this\n    }\n\n    /**\n     * Creates a subquery - query that can be used inside other queries.\n     */\n    subQuery(): SelectQueryBuilder<any> {\n        const qb = this.createQueryBuilder()\n        qb.expressionMap.subQuery = true\n        qb.parentQueryBuilder = this\n        return qb\n    }\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(): this\n\n    /**\n     * Creates SELECT query.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        selectionAliasName?: string,\n    ): this\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string, selectionAliasName?: string): this\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection: string[]): this\n\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(\n        selection?:\n            | string\n            | string[]\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        selectionAliasName?: string,\n    ): SelectQueryBuilder<Entity> {\n        this.expressionMap.queryType = \"select\"\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map((selection) => ({\n                selection: selection,\n            }))\n        } else if (typeof selection === \"function\") {\n            const subQueryBuilder = selection(this.subQuery())\n            this.setParameters(subQueryBuilder.getParameters())\n            this.expressionMap.selects.push({\n                selection: subQueryBuilder.getQuery(),\n                aliasName: selectionAliasName,\n            })\n        } else if (selection) {\n            this.expressionMap.selects = [\n                { selection: selection, aliasName: selectionAliasName },\n            ]\n        }\n\n        return this\n    }\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(\n        selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        selectionAliasName?: string,\n    ): this\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string, selectionAliasName?: string): this\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection: string[]): this\n\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(\n        selection:\n            | string\n            | string[]\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        selectionAliasName?: string,\n    ): this {\n        if (!selection) return this\n\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = this.expressionMap.selects.concat(\n                selection.map((selection) => ({ selection: selection })),\n            )\n        } else if (typeof selection === \"function\") {\n            const subQueryBuilder = selection(this.subQuery())\n            this.setParameters(subQueryBuilder.getParameters())\n            this.expressionMap.selects.push({\n                selection: subQueryBuilder.getQuery(),\n                aliasName: selectionAliasName,\n            })\n        } else if (selection) {\n            this.expressionMap.selects.push({\n                selection: selection,\n                aliasName: selectionAliasName,\n            })\n        }\n\n        return this\n    }\n\n    /**\n     * Set max execution time.\n     * @param milliseconds\n     */\n    maxExecutionTime(milliseconds: number): this {\n        this.expressionMap.maxExecutionTime = milliseconds\n        return this\n    }\n\n    /**\n     * Sets whether the selection is DISTINCT.\n     */\n    distinct(distinct: boolean = true): this {\n        this.expressionMap.selectDistinct = distinct\n        return this\n    }\n\n    /**\n     * Sets the distinct on clause for Postgres.\n     */\n    distinctOn(distinctOn: string[]): this {\n        this.expressionMap.selectDistinctOn = distinctOn\n        return this\n    }\n\n    fromDummy(): SelectQueryBuilder<any> {\n        return this.from(\n            this.connection.driver.dummyTableName ??\n                \"(SELECT 1 AS dummy_column)\",\n            \"dummy_table\",\n        )\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        aliasName: string,\n    ): SelectQueryBuilder<T>\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        aliasName: string,\n    ): SelectQueryBuilder<T>\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget:\n            | EntityTarget<T>\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string,\n    ): SelectQueryBuilder<T> {\n        const mainAlias = this.createFromAlias(entityTarget, aliasName)\n        this.expressionMap.setMainAlias(mainAlias)\n        return this as any as SelectQueryBuilder<T>\n    }\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T extends ObjectLiteral>(\n        entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>,\n        aliasName: string,\n    ): SelectQueryBuilder<T>\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        aliasName: string,\n    ): SelectQueryBuilder<T>\n\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom<T extends ObjectLiteral>(\n        entityTarget:\n            | EntityTarget<T>\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string,\n    ): SelectQueryBuilder<T> {\n        const alias = this.createFromAlias(entityTarget, aliasName)\n        if (!this.expressionMap.mainAlias)\n            this.expressionMap.setMainAlias(alias)\n\n        return this as any as SelectQueryBuilder<T>\n    }\n\n    /**\n     * INNER JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs (without selection) given entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters)\n        return this\n    }\n\n    /**\n     * LEFT JOINs (without selection) given subquery.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs (without selection) entity's property.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs (without selection) entity's table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs (without selection) given table.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters)\n        return this\n    }\n\n    /**\n     * INNER JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.innerJoin(entityOrProperty, alias, condition, parameters)\n        return this\n    }\n\n    /**\n     * LEFT JOINs given subquery and adds all selection properties to SELECT..\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's property and adds all selection properties to SELECT.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs table and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.leftJoin(entityOrProperty, alias, condition, parameters)\n        return this\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.join(\n            \"INNER\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            true,\n        )\n        return this\n    }\n\n    /**\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapAsEntity?: Function | string,\n    ): this\n\n    /**\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapAsEntity?: Function | string,\n    ): this {\n        this.addSelect(alias)\n        this.join(\n            \"INNER\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            false,\n            mapAsEntity,\n        )\n        return this\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this {\n        this.addSelect(alias)\n        this.join(\n            \"LEFT\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            true,\n        )\n        return this\n    }\n\n    /**\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        subQueryFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapAsEntity?: Function | string,\n    ): this\n\n    /**\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * Given entity property should be a relation.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        property: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        entity: Function | string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        tableName: string,\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n    ): this\n\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(\n        mapToProperty: string,\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        alias: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapAsEntity?: Function | string,\n    ): this {\n        this.addSelect(alias)\n        this.join(\n            \"LEFT\",\n            entityOrProperty,\n            alias,\n            condition,\n            parameters,\n            mapToProperty,\n            false,\n            mapAsEntity,\n        )\n        return this\n    }\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, property: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entity: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, tableName: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\n\n    /**\n     */\n    // selectAndMap(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this {\n    //     const select = new SelectAttribute(this.expressionMap);\n    //     select.mapToProperty = mapToProperty;\n    //     select.entityOrProperty = entityOrProperty;\n    //     select.aliasName = aliasName;\n    //     select.qbFactory = qbFactory;\n    //     return this;\n    // }\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        options?: { disableMixedMap?: boolean },\n    ): this\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        alias: string,\n        queryBuilderFactory: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n    ): this\n\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(\n        mapToProperty: string,\n        relationName: string,\n        aliasNameOrOptions?: string | { disableMixedMap?: boolean },\n        queryBuilderFactory?: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n    ): this {\n        const relationIdAttribute = new RelationIdAttribute(this.expressionMap)\n        relationIdAttribute.mapToProperty = mapToProperty\n        relationIdAttribute.relationName = relationName\n        if (typeof aliasNameOrOptions === \"string\")\n            relationIdAttribute.alias = aliasNameOrOptions\n        if (\n            typeof aliasNameOrOptions === \"object\" &&\n            (aliasNameOrOptions as any).disableMixedMap\n        )\n            relationIdAttribute.disableMixedMap = true\n\n        relationIdAttribute.queryBuilderFactory = queryBuilderFactory\n        this.expressionMap.relationIdAttributes.push(relationIdAttribute)\n\n        if (relationIdAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationIdAttribute.junctionAlias,\n                metadata: relationIdAttribute.relation.junctionEntityMetadata,\n            })\n        }\n        return this\n    }\n\n    /**\n     * Counts number of entities of entity's relation and maps the value into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationCountAndMap(\n        mapToProperty: string,\n        relationName: string,\n        aliasName?: string,\n        queryBuilderFactory?: (\n            qb: SelectQueryBuilder<any>,\n        ) => SelectQueryBuilder<any>,\n    ): this {\n        const relationCountAttribute = new RelationCountAttribute(\n            this.expressionMap,\n        )\n        relationCountAttribute.mapToProperty = mapToProperty\n        relationCountAttribute.relationName = relationName\n        relationCountAttribute.alias = aliasName\n        relationCountAttribute.queryBuilderFactory = queryBuilderFactory\n        this.expressionMap.relationCountAttributes.push(relationCountAttribute)\n\n        this.expressionMap.createAlias({\n            type: \"other\",\n            name: relationCountAttribute.junctionAlias,\n        })\n        if (relationCountAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationCountAttribute.junctionAlias,\n                metadata:\n                    relationCountAttribute.relation.junctionEntityMetadata,\n            })\n        }\n        return this\n    }\n\n    /**\n     * Loads all relation ids for all relations of the selected entity.\n     * All relation ids will be mapped to relation property themself.\n     * If array of strings is given then loads only relation ids of the given properties.\n     */\n    loadAllRelationIds(options?: {\n        relations?: string[]\n        disableMixedMap?: boolean\n    }): this {\n        // todo: add skip relations\n        this.expressionMap.mainAlias!.metadata.relations.forEach((relation) => {\n            if (\n                options !== undefined &&\n                options.relations !== undefined &&\n                options.relations.indexOf(relation.propertyPath) === -1\n            )\n                return\n\n            this.loadRelationIdAndMap(\n                this.expressionMap.mainAlias!.name +\n                    \".\" +\n                    relation.propertyPath,\n                this.expressionMap.mainAlias!.name +\n                    \".\" +\n                    relation.propertyPath,\n                options,\n            )\n        })\n        return this\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(\n        where:\n            | Brackets\n            | string\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres = [] // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.getWhereCondition(where)\n        if (condition) {\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ]\n        }\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(\n        where:\n            | string\n            | Brackets\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(\n        where:\n            | Brackets\n            | string\n            | ((qb: this) => string)\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Sets a new where EXISTS clause\n     */\n    whereExists(subQuery: SelectQueryBuilder<any>): this {\n        return this.where(...this.getExistsCondition(subQuery))\n    }\n\n    /**\n     * Adds a new AND where EXISTS clause\n     */\n    andWhereExists(subQuery: SelectQueryBuilder<any>): this {\n        return this.andWhere(...this.getExistsCondition(subQuery))\n    }\n\n    /**\n     * Adds a new OR where EXISTS clause\n     */\n    orWhereExists(subQuery: SelectQueryBuilder<any>): this {\n        return this.orWhere(...this.getExistsCondition(subQuery))\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    whereInIds(ids: any | any[]): this {\n        return this.where(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    andWhereInIds(ids: any | any[]): this {\n        return this.andWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    orWhereInIds(ids: any | any[]): this {\n        return this.orWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Sets HAVING condition in the query builder.\n     * If you had previously HAVING expression defined,\n     * calling this function will override previously set HAVING conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    having(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"simple\", condition: having })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"and\", condition: having })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orHaving(having: string, parameters?: ObjectLiteral): this {\n        this.expressionMap.havings.push({ type: \"or\", condition: having })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(): this\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy: string): this\n\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy?: string): this {\n        if (groupBy) {\n            this.expressionMap.groupBys = [groupBy]\n        } else {\n            this.expressionMap.groupBys = []\n        }\n        return this\n    }\n\n    /**\n     * Adds GROUP BY condition in the query builder.\n     */\n    addGroupBy(groupBy: string): this {\n        this.expressionMap.groupBys.push(groupBy)\n        return this\n    }\n\n    /**\n     * Enables time travelling for the current query (only supported by cockroach currently)\n     */\n    timeTravelQuery(timeTravelFn?: string | boolean): this {\n        if (this.connection.driver.options.type === \"cockroachdb\") {\n            if (timeTravelFn === undefined) {\n                this.expressionMap.timeTravel = \"follower_read_timestamp()\"\n            } else {\n                this.expressionMap.timeTravel = timeTravelFn\n            }\n        }\n\n        return this\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort: string,\n        order?: \"ASC\" | \"DESC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort?: string | OrderByCondition,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new TypeORMError(\n                `SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`,\n            )\n        if (\n            nulls !== undefined &&\n            nulls !== \"NULLS FIRST\" &&\n            nulls !== \"NULLS LAST\"\n        )\n            throw new TypeORMError(\n                `SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`,\n            )\n\n        if (sort) {\n            if (typeof sort === \"object\") {\n                this.expressionMap.orderBys = sort as OrderByCondition\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort as string]: { order, nulls },\n                    }\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order }\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {}\n        }\n        return this\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(\n        sort: string,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new TypeORMError(\n                `SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`,\n            )\n        if (\n            nulls !== undefined &&\n            nulls !== \"NULLS FIRST\" &&\n            nulls !== \"NULLS LAST\"\n        )\n            throw new TypeORMError(\n                `SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`,\n            )\n\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls }\n        } else {\n            this.expressionMap.orderBys[sort] = order\n        }\n        return this\n    }\n\n    /**\n     * Sets LIMIT - maximum number of rows to be selected.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use the take method instead.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = this.normalizeNumber(limit)\n        if (\n            this.expressionMap.limit !== undefined &&\n            isNaN(this.expressionMap.limit)\n        )\n            throw new TypeORMError(\n                `Provided \"limit\" value is not a number. Please provide a numeric value.`,\n            )\n\n        return this\n    }\n\n    /**\n     * Sets OFFSET - selection offset.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use the skip method instead.\n     */\n    offset(offset?: number): this {\n        this.expressionMap.offset = this.normalizeNumber(offset)\n        if (\n            this.expressionMap.offset !== undefined &&\n            isNaN(this.expressionMap.offset)\n        )\n            throw new TypeORMError(\n                `Provided \"offset\" value is not a number. Please provide a numeric value.`,\n            )\n\n        return this\n    }\n\n    /**\n     * Sets maximal number of entities to take.\n     */\n    take(take?: number): this {\n        this.expressionMap.take = this.normalizeNumber(take)\n        if (\n            this.expressionMap.take !== undefined &&\n            isNaN(this.expressionMap.take)\n        )\n            throw new TypeORMError(\n                `Provided \"take\" value is not a number. Please provide a numeric value.`,\n            )\n\n        return this\n    }\n\n    /**\n     * Sets number of entities to skip.\n     */\n    skip(skip?: number): this {\n        this.expressionMap.skip = this.normalizeNumber(skip)\n        if (\n            this.expressionMap.skip !== undefined &&\n            isNaN(this.expressionMap.skip)\n        )\n            throw new TypeORMError(\n                `Provided \"skip\" value is not a number. Please provide a numeric value.`,\n            )\n\n        return this\n    }\n\n    /**\n     * Set certain index to be used by the query.\n     *\n     * @param index Name of index to be used.\n     */\n    useIndex(index: string): this {\n        this.expressionMap.useIndex = index\n\n        return this\n    }\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode: \"optimistic\", lockVersion: number | Date): this\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(\n        lockMode:\n            | \"pessimistic_read\"\n            | \"pessimistic_write\"\n            | \"dirty_read\"\n            /*\n                \"pessimistic_partial_write\" and \"pessimistic_write_or_fail\" are deprecated and\n                will be removed in a future version.\n\n                Use setOnLocked instead.\n             */\n            | \"pessimistic_partial_write\"\n            | \"pessimistic_write_or_fail\"\n            | \"for_no_key_update\"\n            | \"for_key_share\",\n        lockVersion?: undefined,\n        lockTables?: string[],\n    ): this\n\n    /**\n     * Sets locking mode.\n     */\n    setLock(\n        lockMode:\n            | \"optimistic\"\n            | \"pessimistic_read\"\n            | \"pessimistic_write\"\n            | \"dirty_read\"\n            /*\n                \"pessimistic_partial_write\" and \"pessimistic_write_or_fail\" are deprecated and\n                will be removed in a future version.\n\n                Use setOnLocked instead.\n             */\n            | \"pessimistic_partial_write\"\n            | \"pessimistic_write_or_fail\"\n            | \"for_no_key_update\"\n            | \"for_key_share\",\n        lockVersion?: number | Date,\n        lockTables?: string[],\n    ): this {\n        this.expressionMap.lockMode = lockMode\n        this.expressionMap.lockVersion = lockVersion\n        this.expressionMap.lockTables = lockTables\n        return this\n    }\n\n    /**\n     * Sets lock handling by adding NO WAIT or SKIP LOCKED.\n     */\n    setOnLocked(onLocked: \"nowait\" | \"skip_locked\"): this {\n        this.expressionMap.onLocked = onLocked\n        return this\n    }\n\n    /**\n     * Disables the global condition of \"non-deleted\" for the entity with delete date columns.\n     */\n    withDeleted(): this {\n        this.expressionMap.withDeleted = true\n        return this\n    }\n\n    /**\n     * Gets first raw result returned by execution of generated query builder sql.\n     */\n    async getRawOne<T = any>(): Promise<T | undefined> {\n        return (await this.getRawMany())[0]\n    }\n\n    /**\n     * Gets all raw results returned by execution of generated query builder sql.\n     */\n    async getRawMany<T = any>(): Promise<T[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        this.expressionMap.queryEntity = false\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            const results = await this.loadRawResults(queryRunner)\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    async getRawAndEntities<T = any>(): Promise<{\n        entities: Entity[]\n        raw: T[]\n    }> {\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            this.expressionMap.queryEntity = true\n            const results = await this.executeEntitiesAndRawResults(queryRunner)\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release()\n        }\n    }\n\n    /**\n     * Gets single entity returned by execution of generated query builder sql.\n     */\n    async getOne(): Promise<Entity | null> {\n        const results = await this.getRawAndEntities()\n        const result = results.entities[0] as any\n\n        if (\n            result &&\n            this.expressionMap.lockMode === \"optimistic\" &&\n            this.expressionMap.lockVersion\n        ) {\n            const metadata = this.expressionMap.mainAlias!.metadata\n\n            if (this.expressionMap.lockVersion instanceof Date) {\n                const actualVersion =\n                    metadata.updateDateColumn!.getEntityValue(result) // what if columns arent set?\n                if (\n                    actualVersion.getTime() !==\n                    this.expressionMap.lockVersion.getTime()\n                )\n                    throw new OptimisticLockVersionMismatchError(\n                        metadata.name,\n                        this.expressionMap.lockVersion,\n                        actualVersion,\n                    )\n            } else {\n                const actualVersion =\n                    metadata.versionColumn!.getEntityValue(result) // what if columns arent set?\n                if (actualVersion !== this.expressionMap.lockVersion)\n                    throw new OptimisticLockVersionMismatchError(\n                        metadata.name,\n                        this.expressionMap.lockVersion,\n                        actualVersion,\n                    )\n            }\n        }\n\n        if (result === undefined) {\n            return null\n        }\n        return result\n    }\n\n    /**\n     * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.\n     */\n    async getOneOrFail(): Promise<Entity> {\n        const entity = await this.getOne()\n\n        if (!entity) {\n            throw new EntityNotFoundError(\n                this.expressionMap.mainAlias!.target,\n                this.expressionMap.parameters,\n            )\n        }\n\n        return entity\n    }\n\n    /**\n     * Gets entities returned by execution of generated query builder sql.\n     */\n    async getMany(): Promise<Entity[]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        const results = await this.getRawAndEntities()\n        return results.entities\n    }\n\n    /**\n     * Gets count - number of entities selected by sql generated by this query builder.\n     * Count excludes all limitations set by offset, limit, skip, and take.\n     */\n    async getCount(): Promise<number> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            this.expressionMap.queryEntity = false\n            const results = await this.executeCountQuery(queryRunner)\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release()\n        }\n    }\n\n    /**\n     * Gets exists\n     * Returns whether any rows exists matching current query.\n     */\n    async getExists(): Promise<boolean> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            this.expressionMap.queryEntity = false\n            const results = await this.executeExistsQuery(queryRunner)\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release()\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns entities and overall entities count (without limitation).\n     * This method is useful to build pagination.\n     */\n    async getManyAndCount(): Promise<[Entity[], number]> {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError()\n\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            this.expressionMap.queryEntity = true\n            const entitiesAndRaw = await this.executeEntitiesAndRawResults(\n                queryRunner,\n            )\n            this.expressionMap.queryEntity = false\n            const cacheId = this.expressionMap.cacheId\n            // Creates a new cacheId for the count query, or it will retreive the above query results\n            // and count will return 0.\n            this.expressionMap.cacheId = cacheId ? `${cacheId}-count` : cacheId\n            const count = await this.executeCountQuery(queryRunner)\n            const results: [Entity[], number] = [entitiesAndRaw.entities, count]\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release()\n        }\n    }\n\n    /**\n     * Executes built SQL query and returns raw data stream.\n     */\n    async stream(): Promise<ReadStream> {\n        this.expressionMap.queryEntity = false\n        const [sql, parameters] = this.getQueryAndParameters()\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            const releaseFn = () => {\n                if (queryRunner !== this.queryRunner)\n                    // means we created our own query runner\n                    return queryRunner.release()\n                return\n            }\n            const results = queryRunner.stream(\n                sql,\n                parameters,\n                releaseFn,\n                releaseFn,\n            )\n\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction()\n            }\n\n            return results\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        }\n    }\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(enabled: boolean): this\n\n    /**\n     * Enables query result caching and sets in milliseconds in which cache will expire.\n     * If not set then global caching time will be used.\n     */\n    cache(milliseconds: number): this\n\n    /**\n     * Enables query result caching and sets cache id and milliseconds in which cache will expire.\n     */\n    cache(id: any, milliseconds?: number): this\n\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(\n        enabledOrMillisecondsOrId: boolean | number | string,\n        maybeMilliseconds?: number,\n    ): this {\n        if (typeof enabledOrMillisecondsOrId === \"boolean\") {\n            this.expressionMap.cache = enabledOrMillisecondsOrId\n        } else if (typeof enabledOrMillisecondsOrId === \"number\") {\n            this.expressionMap.cache = true\n            this.expressionMap.cacheDuration = enabledOrMillisecondsOrId\n        } else if (\n            typeof enabledOrMillisecondsOrId === \"string\" ||\n            typeof enabledOrMillisecondsOrId === \"number\"\n        ) {\n            this.expressionMap.cache = true\n            this.expressionMap.cacheId = enabledOrMillisecondsOrId\n        }\n\n        if (maybeMilliseconds) {\n            this.expressionMap.cacheDuration = maybeMilliseconds\n        }\n\n        return this\n    }\n\n    /**\n     * Sets extra options that can be used to configure how query builder works.\n     */\n    setOption(option: SelectQueryBuilderOption): this {\n        this.expressionMap.options.push(option)\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    protected join(\n        direction: \"INNER\" | \"LEFT\",\n        entityOrProperty:\n            | Function\n            | string\n            | ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\n        aliasName: string,\n        condition?: string,\n        parameters?: ObjectLiteral,\n        mapToProperty?: string,\n        isMappingMany?: boolean,\n        mapAsEntity?: Function | string,\n    ): void {\n        if (parameters) {\n            this.setParameters(parameters)\n        }\n\n        const joinAttribute = new JoinAttribute(\n            this.connection,\n            this.expressionMap,\n        )\n        joinAttribute.direction = direction\n        joinAttribute.mapAsEntity = mapAsEntity\n        joinAttribute.mapToProperty = mapToProperty\n        joinAttribute.isMappingMany = isMappingMany\n        joinAttribute.entityOrProperty = entityOrProperty // relationName\n        joinAttribute.condition = condition // joinInverseSideCondition\n        // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n        this.expressionMap.joinAttributes.push(joinAttribute)\n\n        const joinAttributeMetadata = joinAttribute.metadata\n        if (joinAttributeMetadata) {\n            if (\n                joinAttributeMetadata.deleteDateColumn &&\n                !this.expressionMap.withDeleted\n            ) {\n                const conditionDeleteColumn = `${aliasName}.${joinAttributeMetadata.deleteDateColumn.propertyName} IS NULL`\n                joinAttribute.condition = joinAttribute.condition\n                    ? ` ${joinAttribute.condition} AND ${conditionDeleteColumn}`\n                    : `${conditionDeleteColumn}`\n            }\n            // todo: find and set metadata right there?\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                metadata: joinAttributeMetadata,\n            })\n            if (\n                joinAttribute.relation &&\n                joinAttribute.relation.junctionEntityMetadata\n            ) {\n                this.expressionMap.createAlias({\n                    type: \"join\",\n                    name: joinAttribute.junctionAlias,\n                    metadata: joinAttribute.relation.junctionEntityMetadata,\n                })\n            }\n        } else {\n            let subQuery: string = \"\"\n            if (typeof entityOrProperty === \"function\") {\n                const subQueryBuilder: SelectQueryBuilder<any> = (\n                    entityOrProperty as any\n                )((this as any as SelectQueryBuilder<any>).subQuery())\n                this.setParameters(subQueryBuilder.getParameters())\n                subQuery = subQueryBuilder.getQuery()\n            } else {\n                subQuery = entityOrProperty\n            }\n            const isSubQuery =\n                typeof entityOrProperty === \"function\" ||\n                (entityOrProperty.substr(0, 1) === \"(\" &&\n                    entityOrProperty.substr(-1) === \")\")\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                tablePath:\n                    isSubQuery === false\n                        ? (entityOrProperty as string)\n                        : undefined,\n                subQuery: isSubQuery === true ? subQuery : undefined,\n            })\n        }\n    }\n\n    /**\n     * Creates \"SELECT FROM\" part of SQL query.\n     */\n    protected createSelectExpression() {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(\n                \"Cannot build query because main alias is not set (call qb#from method)\",\n            )\n\n        // todo throw exception if selects or from is missing\n\n        const allSelects: SelectQuery[] = []\n        const excludedSelects: SelectQuery[] = []\n\n        if (this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias.metadata\n            allSelects.push(\n                ...this.buildEscapedEntityColumnSelects(\n                    this.expressionMap.mainAlias.name,\n                    metadata,\n                ),\n            )\n            excludedSelects.push(\n                ...this.findEntityColumnSelects(\n                    this.expressionMap.mainAlias.name,\n                    metadata,\n                ),\n            )\n        }\n\n        // add selects from joins\n        this.expressionMap.joinAttributes.forEach((join) => {\n            if (join.metadata) {\n                allSelects.push(\n                    ...this.buildEscapedEntityColumnSelects(\n                        join.alias.name!,\n                        join.metadata,\n                    ),\n                )\n                excludedSelects.push(\n                    ...this.findEntityColumnSelects(\n                        join.alias.name!,\n                        join.metadata,\n                    ),\n                )\n            } else {\n                const hasMainAlias = this.expressionMap.selects.some(\n                    (select) => select.selection === join.alias.name,\n                )\n                if (hasMainAlias) {\n                    allSelects.push({\n                        selection: this.escape(join.alias.name!) + \".*\",\n                    })\n                    const excludedSelect = this.expressionMap.selects.find(\n                        (select) => select.selection === join.alias.name,\n                    )\n                    excludedSelects.push(excludedSelect!)\n                }\n            }\n        })\n\n        // add all other selects\n        this.expressionMap.selects\n            .filter((select) => excludedSelects.indexOf(select) === -1)\n            .forEach((select) =>\n                allSelects.push({\n                    selection: this.replacePropertyNames(select.selection),\n                    aliasName: select.aliasName,\n                }),\n            )\n\n        // if still selection is empty, then simply set it to all (*)\n        if (allSelects.length === 0) allSelects.push({ selection: \"*\" })\n\n        // Use certain index\n        let useIndex: string = \"\"\n        if (this.expressionMap.useIndex) {\n            if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n                useIndex = ` USE INDEX (${this.expressionMap.useIndex})`\n            }\n        }\n\n        // create a selection query\n        const froms = this.expressionMap.aliases\n            .filter(\n                (alias) =>\n                    alias.type === \"from\" &&\n                    (alias.tablePath || alias.subQuery),\n            )\n            .map((alias) => {\n                if (alias.subQuery)\n                    return alias.subQuery + \" \" + this.escape(alias.name)\n\n                return (\n                    this.getTableName(alias.tablePath!) +\n                    \" \" +\n                    this.escape(alias.name)\n                )\n            })\n\n        const select = this.createSelectDistinctExpression()\n        const selection = allSelects\n            .map(\n                (select) =>\n                    select.selection +\n                    (select.aliasName\n                        ? \" AS \" + this.escape(select.aliasName)\n                        : \"\"),\n            )\n            .join(\", \")\n\n        return (\n            select +\n            selection +\n            \" FROM \" +\n            froms.join(\", \") +\n            this.createTableLockExpression() +\n            useIndex\n        )\n    }\n\n    /**\n     * Creates select | select distinct part of SQL query.\n     */\n    protected createSelectDistinctExpression(): string {\n        const { selectDistinct, selectDistinctOn, maxExecutionTime } =\n            this.expressionMap\n        const { driver } = this.connection\n\n        let select = \"SELECT \"\n\n        if (maxExecutionTime > 0) {\n            if (DriverUtils.isMySQLFamily(driver)) {\n                select += `/*+ MAX_EXECUTION_TIME(${this.expressionMap.maxExecutionTime}) */ `\n            }\n        }\n\n        if (\n            DriverUtils.isPostgresFamily(driver) &&\n            selectDistinctOn.length > 0\n        ) {\n            const selectDistinctOnMap = selectDistinctOn\n                .map((on) => this.replacePropertyNames(on))\n                .join(\", \")\n\n            select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `\n        } else if (selectDistinct) {\n            select = \"SELECT DISTINCT \"\n        }\n\n        return select\n    }\n\n    /**\n     * Creates \"JOIN\" part of SQL query.\n     */\n    protected createJoinExpression(): string {\n        // examples:\n        // select from owning side\n        // qb.select(\"post\")\n        //     .leftJoinAndSelect(\"post.category\", \"category\");\n        // select from non-owning side\n        // qb.select(\"category\")\n        //     .leftJoinAndSelect(\"category.post\", \"post\");\n\n        const joins = this.expressionMap.joinAttributes.map((joinAttr) => {\n            const relation = joinAttr.relation\n            const destinationTableName = joinAttr.tablePath\n            const destinationTableAlias = joinAttr.alias.name\n            let appendedCondition = joinAttr.condition\n                ? \" AND (\" + joinAttr.condition + \")\"\n                : \"\"\n            const parentAlias = joinAttr.parentAlias\n\n            // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n            // table to join, without junction table involved. This means we simply join direct table.\n            if (!parentAlias || !relation) {\n                const destinationJoin = joinAttr.alias.subQuery\n                    ? joinAttr.alias.subQuery\n                    : this.getTableName(destinationTableName)\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    destinationJoin +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    (joinAttr.condition\n                        ? \" ON \" + this.replacePropertyNames(joinAttr.condition)\n                        : \"\")\n                )\n            }\n\n            // if real entity relation is involved\n            if (relation.isManyToOne || relation.isOneToOneOwner) {\n                // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n                const condition = relation.joinColumns\n                    .map((joinColumn) => {\n                        return (\n                            destinationTableAlias +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath +\n                            \"=\" +\n                            parentAlias +\n                            \".\" +\n                            relation.propertyPath +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath\n                        )\n                    })\n                    .join(\" AND \")\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(condition + appendedCondition)\n                )\n            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n                // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n                const condition = relation\n                    .inverseRelation!.joinColumns.map((joinColumn) => {\n                        if (\n                            relation.inverseEntityMetadata.tableType ===\n                                \"entity-child\" &&\n                            relation.inverseEntityMetadata.discriminatorColumn\n                        ) {\n                            appendedCondition +=\n                                \" AND \" +\n                                destinationTableAlias +\n                                \".\" +\n                                relation.inverseEntityMetadata\n                                    .discriminatorColumn.databaseName +\n                                \"='\" +\n                                relation.inverseEntityMetadata\n                                    .discriminatorValue +\n                                \"'\"\n                        }\n\n                        return (\n                            destinationTableAlias +\n                            \".\" +\n                            relation.inverseRelation!.propertyPath +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath +\n                            \"=\" +\n                            parentAlias +\n                            \".\" +\n                            joinColumn.referencedColumn!.propertyPath\n                        )\n                    })\n                    .join(\" AND \")\n\n                if (!condition)\n                    throw new TypeORMError(\n                        `Relation ${relation.entityMetadata.name}.${relation.propertyName} does not have join columns.`,\n                    )\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(condition + appendedCondition)\n                )\n            } else {\n                // means many-to-many\n                const junctionTableName =\n                    relation.junctionEntityMetadata!.tablePath\n\n                const junctionAlias = joinAttr.junctionAlias\n                let junctionCondition = \"\",\n                    destinationCondition = \"\"\n\n                if (relation.isOwning) {\n                    junctionCondition = relation.joinColumns\n                        .map((joinColumn) => {\n                            // `post_category`.`postId` = `post`.`id`\n                            return (\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath +\n                                \"=\" +\n                                parentAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath\n                            )\n                        })\n                        .join(\" AND \")\n\n                    destinationCondition = relation.inverseJoinColumns\n                        .map((joinColumn) => {\n                            // `category`.`id` = `post_category`.`categoryId`\n                            return (\n                                destinationTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath +\n                                \"=\" +\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath\n                            )\n                        })\n                        .join(\" AND \")\n                } else {\n                    junctionCondition = relation\n                        .inverseRelation!.inverseJoinColumns.map(\n                            (joinColumn) => {\n                                // `post_category`.`categoryId` = `category`.`id`\n                                return (\n                                    junctionAlias +\n                                    \".\" +\n                                    joinColumn.propertyPath +\n                                    \"=\" +\n                                    parentAlias +\n                                    \".\" +\n                                    joinColumn.referencedColumn!.propertyPath\n                                )\n                            },\n                        )\n                        .join(\" AND \")\n\n                    destinationCondition = relation\n                        .inverseRelation!.joinColumns.map((joinColumn) => {\n                            // `post`.`id` = `post_category`.`postId`\n                            return (\n                                destinationTableAlias +\n                                \".\" +\n                                joinColumn.referencedColumn!.propertyPath +\n                                \"=\" +\n                                junctionAlias +\n                                \".\" +\n                                joinColumn.propertyPath\n                            )\n                        })\n                        .join(\" AND \")\n                }\n\n                return (\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(junctionTableName) +\n                    \" \" +\n                    this.escape(junctionAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(junctionCondition) +\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(\n                        destinationCondition + appendedCondition,\n                    )\n                )\n            }\n        })\n\n        return joins.join(\" \")\n    }\n\n    /**\n     * Creates \"GROUP BY\" part of SQL query.\n     */\n    protected createGroupByExpression() {\n        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length)\n            return \"\"\n        return (\n            \" GROUP BY \" +\n            this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"))\n        )\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.allOrderBys\n        if (Object.keys(orderBys).length === 0) return \"\"\n\n        return (\n            \" ORDER BY \" +\n            Object.keys(orderBys)\n                .map((columnName) => {\n                    const orderValue =\n                        typeof orderBys[columnName] === \"string\"\n                            ? orderBys[columnName]\n                            : (orderBys[columnName] as any).order +\n                              \" \" +\n                              (orderBys[columnName] as any).nulls\n                    const selection = this.expressionMap.selects.find(\n                        (s) => s.selection === columnName,\n                    )\n                    if (\n                        selection &&\n                        !selection.aliasName &&\n                        columnName.indexOf(\".\") !== -1\n                    ) {\n                        const criteriaParts = columnName.split(\".\")\n                        const aliasName = criteriaParts[0]\n                        const propertyPath = criteriaParts.slice(1).join(\".\")\n                        const alias = this.expressionMap.aliases.find(\n                            (alias) => alias.name === aliasName,\n                        )\n                        if (alias) {\n                            const column =\n                                alias.metadata.findColumnWithPropertyPath(\n                                    propertyPath,\n                                )\n                            if (column) {\n                                const orderAlias = DriverUtils.buildAlias(\n                                    this.connection.driver,\n                                    undefined,\n                                    aliasName,\n                                    column.databaseName,\n                                )\n                                return (\n                                    this.escape(orderAlias) + \" \" + orderValue\n                                )\n                            }\n                        }\n                    }\n\n                    return (\n                        this.replacePropertyNames(columnName) + \" \" + orderValue\n                    )\n                })\n                .join(\", \")\n        )\n    }\n\n    /**\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n     */\n    protected createLimitOffsetExpression(): string {\n        // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\n        // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\n        let offset: number | undefined = this.expressionMap.offset,\n            limit: number | undefined = this.expressionMap.limit\n        if (\n            !offset &&\n            !limit &&\n            this.expressionMap.joinAttributes.length === 0\n        ) {\n            offset = this.expressionMap.skip\n            limit = this.expressionMap.take\n        }\n\n        if (this.connection.driver.options.type === \"mssql\") {\n            // Due to a limitation in SQL Server's parser implementation it does not support using\n            // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\n            // user does not request one we insert a dummy ORDER BY that does nothing and should\n            // have no effect on the query planner or on the order of the results returned.\n            // https://dba.stackexchange.com/a/193799\n            let prefix = \"\"\n            if (\n                (limit || offset) &&\n                Object.keys(this.expressionMap.allOrderBys).length <= 0\n            ) {\n                prefix = \" ORDER BY (SELECT NULL)\"\n            }\n\n            if (limit && offset)\n                return (\n                    prefix +\n                    \" OFFSET \" +\n                    offset +\n                    \" ROWS FETCH NEXT \" +\n                    limit +\n                    \" ROWS ONLY\"\n                )\n            if (limit)\n                return (\n                    prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\"\n                )\n            if (offset) return prefix + \" OFFSET \" + offset + \" ROWS\"\n        } else if (\n            DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\" ||\n            this.connection.driver.options.type === \"sap\" ||\n            this.connection.driver.options.type === \"spanner\"\n        ) {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset\n            if (limit) return \" LIMIT \" + limit\n            if (offset) throw new OffsetWithoutLimitNotSupportedError()\n        } else if (DriverUtils.isSQLiteFamily(this.connection.driver)) {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset\n            if (limit) return \" LIMIT \" + limit\n            if (offset) return \" LIMIT -1 OFFSET \" + offset\n        } else if (this.connection.driver.options.type === \"oracle\") {\n            if (limit && offset)\n                return (\n                    \" OFFSET \" +\n                    offset +\n                    \" ROWS FETCH NEXT \" +\n                    limit +\n                    \" ROWS ONLY\"\n                )\n            if (limit) return \" FETCH NEXT \" + limit + \" ROWS ONLY\"\n            if (offset) return \" OFFSET \" + offset + \" ROWS\"\n        } else {\n            if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset\n            if (limit) return \" LIMIT \" + limit\n            if (offset) return \" OFFSET \" + offset\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LOCK\" part of SELECT Query after table Clause\n     * ex.\n     *  SELECT 1\n     *  FROM USER U WITH (NOLOCK)\n     *  JOIN ORDER O WITH (NOLOCK)\n     *      ON U.ID=O.OrderID\n     */\n    private createTableLockExpression(): string {\n        if (this.connection.driver.options.type === \"mssql\") {\n            switch (this.expressionMap.lockMode) {\n                case \"pessimistic_read\":\n                    return \" WITH (HOLDLOCK, ROWLOCK)\"\n                case \"pessimistic_write\":\n                    return \" WITH (UPDLOCK, ROWLOCK)\"\n                case \"dirty_read\":\n                    return \" WITH (NOLOCK)\"\n            }\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LOCK\" part of SQL query.\n     */\n    protected createLockExpression(): string {\n        const driver = this.connection.driver\n\n        let lockTablesClause = \"\"\n\n        if (this.expressionMap.lockTables) {\n            if (\n                !(\n                    DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\"\n                )\n            ) {\n                throw new TypeORMError(\n                    \"Lock tables not supported in selected driver\",\n                )\n            }\n            if (this.expressionMap.lockTables.length < 1) {\n                throw new TypeORMError(\"lockTables cannot be an empty array\")\n            }\n            lockTablesClause = \" OF \" + this.expressionMap.lockTables.join(\", \")\n        }\n\n        let onLockExpression = \"\"\n        if (this.expressionMap.onLocked === \"nowait\") {\n            onLockExpression = \" NOWAIT\"\n        } else if (this.expressionMap.onLocked === \"skip_locked\") {\n            onLockExpression = \" SKIP LOCKED\"\n        }\n        switch (this.expressionMap.lockMode) {\n            case \"pessimistic_read\":\n                if (\n                    driver.options.type === \"mysql\" ||\n                    driver.options.type === \"aurora-mysql\"\n                ) {\n                    if (\n                        DriverUtils.isReleaseVersionOrGreater(driver, \"8.0.0\")\n                    ) {\n                        return (\n                            \" FOR SHARE\" + lockTablesClause + onLockExpression\n                        )\n                    } else {\n                        return \" LOCK IN SHARE MODE\"\n                    }\n                } else if (driver.options.type === \"mariadb\") {\n                    return \" LOCK IN SHARE MODE\"\n                } else if (DriverUtils.isPostgresFamily(driver)) {\n                    return \" FOR SHARE\" + lockTablesClause + onLockExpression\n                } else if (driver.options.type === \"oracle\") {\n                    return \" FOR UPDATE\"\n                } else if (driver.options.type === \"mssql\") {\n                    return \"\"\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"pessimistic_write\":\n                if (\n                    DriverUtils.isMySQLFamily(driver) ||\n                    driver.options.type === \"aurora-mysql\" ||\n                    driver.options.type === \"oracle\"\n                ) {\n                    return \" FOR UPDATE\" + onLockExpression\n                } else if (\n                    DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\"\n                ) {\n                    return \" FOR UPDATE\" + lockTablesClause + onLockExpression\n                } else if (driver.options.type === \"mssql\") {\n                    return \"\"\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"pessimistic_partial_write\":\n                if (DriverUtils.isPostgresFamily(driver)) {\n                    return \" FOR UPDATE\" + lockTablesClause + \" SKIP LOCKED\"\n                } else if (DriverUtils.isMySQLFamily(driver)) {\n                    return \" FOR UPDATE SKIP LOCKED\"\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"pessimistic_write_or_fail\":\n                if (\n                    DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\"\n                ) {\n                    return \" FOR UPDATE\" + lockTablesClause + \" NOWAIT\"\n                } else if (DriverUtils.isMySQLFamily(driver)) {\n                    return \" FOR UPDATE NOWAIT\"\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"for_no_key_update\":\n                if (\n                    DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\"\n                ) {\n                    return (\n                        \" FOR NO KEY UPDATE\" +\n                        lockTablesClause +\n                        onLockExpression\n                    )\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            case \"for_key_share\":\n                if (DriverUtils.isPostgresFamily(driver)) {\n                    return (\n                        \" FOR KEY SHARE\" + lockTablesClause + onLockExpression\n                    )\n                } else {\n                    throw new LockNotSupportedOnGivenDriverError()\n                }\n            default:\n                return \"\"\n        }\n    }\n\n    /**\n     * Creates \"HAVING\" part of SQL query.\n     */\n    protected createHavingExpression() {\n        if (!this.expressionMap.havings || !this.expressionMap.havings.length)\n            return \"\"\n        const conditions = this.expressionMap.havings\n            .map((having, index) => {\n                switch (having.type) {\n                    case \"and\":\n                        return (\n                            (index > 0 ? \"AND \" : \"\") +\n                            this.replacePropertyNames(having.condition)\n                        )\n                    case \"or\":\n                        return (\n                            (index > 0 ? \"OR \" : \"\") +\n                            this.replacePropertyNames(having.condition)\n                        )\n                    default:\n                        return this.replacePropertyNames(having.condition)\n                }\n            })\n            .join(\" \")\n\n        if (!conditions.length) return \"\"\n        return \" HAVING \" + conditions\n    }\n\n    protected buildEscapedEntityColumnSelects(\n        aliasName: string,\n        metadata: EntityMetadata,\n    ): SelectQuery[] {\n        const hasMainAlias = this.expressionMap.selects.some(\n            (select) => select.selection === aliasName,\n        )\n\n        const columns: ColumnMetadata[] = []\n        if (hasMainAlias) {\n            columns.push(\n                ...metadata.columns.filter(\n                    (column) => column.isSelect === true,\n                ),\n            )\n        }\n        columns.push(\n            ...metadata.columns.filter((column) => {\n                return this.expressionMap.selects.some(\n                    (select) =>\n                        select.selection ===\n                        aliasName + \".\" + column.propertyPath,\n                )\n            }),\n        )\n\n        // if user used partial selection and did not select some primary columns which are required to be selected\n        // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\n        // to make entity contain exactly what user selected\n        if (columns.length === 0)\n            // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\n            return []\n\n        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity\n            ? metadata.primaryColumns.filter(\n                  (primaryColumn) => columns.indexOf(primaryColumn) === -1,\n              )\n            : []\n        const allColumns = [...columns, ...nonSelectedPrimaryColumns]\n        const finalSelects: SelectQuery[] = []\n\n        const escapedAliasName = this.escape(aliasName)\n        allColumns.forEach((column) => {\n            let selectionPath =\n                escapedAliasName + \".\" + this.escape(column.databaseName)\n\n            if (column.isVirtualProperty && column.query) {\n                selectionPath = `(${column.query(escapedAliasName)})`\n            }\n\n            if (\n                this.connection.driver.spatialTypes.indexOf(column.type) !== -1\n            ) {\n                if (\n                    DriverUtils.isMySQLFamily(this.connection.driver) ||\n                    this.connection.driver.options.type === \"aurora-mysql\"\n                ) {\n                    const useLegacy = (\n                        this.connection.driver as\n                            | MysqlDriver\n                            | AuroraMysqlDriver\n                    ).options.legacySpatialSupport\n                    const asText = useLegacy ? \"AsText\" : \"ST_AsText\"\n                    selectionPath = `${asText}(${selectionPath})`\n                }\n\n                if (DriverUtils.isPostgresFamily(this.connection.driver))\n                    if (column.precision) {\n                        // cast to JSON to trigger parsing in the driver\n                        selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`\n                    } else {\n                        selectionPath = `ST_AsGeoJSON(${selectionPath})::json`\n                    }\n                if (this.connection.driver.options.type === \"mssql\")\n                    selectionPath = `${selectionPath}.ToString()`\n            }\n\n            const selections = this.expressionMap.selects.filter(\n                (select) =>\n                    select.selection === aliasName + \".\" + column.propertyPath,\n            )\n            if (selections.length) {\n                selections.forEach((selection) => {\n                    finalSelects.push({\n                        selection: selectionPath,\n                        aliasName: selection.aliasName\n                            ? selection.aliasName\n                            : DriverUtils.buildAlias(\n                                  this.connection.driver,\n                                  undefined,\n                                  aliasName,\n                                  column.databaseName,\n                              ),\n                        // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n                        virtual: selection.virtual,\n                    })\n                })\n            } else {\n                finalSelects.push({\n                    selection: selectionPath,\n                    aliasName: DriverUtils.buildAlias(\n                        this.connection.driver,\n                        undefined,\n                        aliasName,\n                        column.databaseName,\n                    ),\n                    // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n                    virtual: hasMainAlias,\n                })\n            }\n        })\n        return finalSelects\n    }\n\n    protected findEntityColumnSelects(\n        aliasName: string,\n        metadata: EntityMetadata,\n    ): SelectQuery[] {\n        const mainSelect = this.expressionMap.selects.find(\n            (select) => select.selection === aliasName,\n        )\n        if (mainSelect) return [mainSelect]\n\n        return this.expressionMap.selects.filter((select) => {\n            return metadata.columns.some(\n                (column) =>\n                    select.selection === aliasName + \".\" + column.propertyPath,\n            )\n        })\n    }\n\n    private computeCountExpression() {\n        const mainAlias = this.expressionMap.mainAlias!.name // todo: will this work with \"fromTableName\"?\n        const metadata = this.expressionMap.mainAlias!.metadata\n\n        const primaryColumns = metadata.primaryColumns\n        const distinctAlias = this.escape(mainAlias)\n\n        // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead\n        // so we prevent poor query patterns in the most likely cases\n        if (\n            this.expressionMap.joinAttributes.length === 0 &&\n            this.expressionMap.relationIdAttributes.length === 0 &&\n            this.expressionMap.relationCountAttributes.length === 0\n        ) {\n            return \"COUNT(1)\"\n        }\n\n        // For everything else, we'll need to do some hackery to get the correct count values.\n\n        if (\n            this.connection.driver.options.type === \"cockroachdb\" ||\n            DriverUtils.isPostgresFamily(this.connection.driver)\n        ) {\n            // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function\n            // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT\n            return (\n                \"COUNT(DISTINCT(\" +\n                primaryColumns\n                    .map(\n                        (c) =>\n                            `${distinctAlias}.${this.escape(c.databaseName)}`,\n                    )\n                    .join(\", \") +\n                \"))\"\n            )\n        }\n\n        if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n            // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct\n            // https://mariadb.com/kb/en/count-distinct/\n            return (\n                \"COUNT(DISTINCT \" +\n                primaryColumns\n                    .map(\n                        (c) =>\n                            `${distinctAlias}.${this.escape(c.databaseName)}`,\n                    )\n                    .join(\", \") +\n                \")\"\n            )\n        }\n\n        if (this.connection.driver.options.type === \"mssql\") {\n            // SQL Server has gotta be different from everyone else.  They don't support\n            // distinct counting multiple columns & they don't have the same operator\n            // characteristic for concatenating, so we gotta use the `CONCAT` function.\n            // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.\n\n            const columnsExpression = primaryColumns\n                .map(\n                    (primaryColumn) =>\n                        `${distinctAlias}.${this.escape(\n                            primaryColumn.databaseName,\n                        )}`,\n                )\n                .join(\", '|;|', \")\n\n            if (primaryColumns.length === 1) {\n                return `COUNT(DISTINCT(${columnsExpression}))`\n            }\n\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`\n        }\n\n        if (this.connection.driver.options.type === \"spanner\") {\n            // spanner also has gotta be different from everyone else.\n            // they do not support concatenation of different column types without casting them to string\n\n            if (primaryColumns.length === 1) {\n                return `COUNT(DISTINCT(${distinctAlias}.${this.escape(\n                    primaryColumns[0].databaseName,\n                )}))`\n            }\n\n            const columnsExpression = primaryColumns\n                .map(\n                    (primaryColumn) =>\n                        `CAST(${distinctAlias}.${this.escape(\n                            primaryColumn.databaseName,\n                        )} AS STRING)`,\n                )\n                .join(\", '|;|', \")\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`\n        }\n\n        // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.\n        // Per the SQL spec, this is the canonical string concatenation mechanism which is most\n        // likely to work across servers implementing the SQL standard.\n\n        // Please note, if there is only one primary column that the concatenation does not occur in this\n        // query and the query is a standard `COUNT DISTINCT` in that case.\n\n        return (\n            `COUNT(DISTINCT(` +\n            primaryColumns\n                .map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`)\n                .join(\" || '|;|' || \") +\n            \"))\"\n        )\n    }\n\n    protected async executeCountQuery(\n        queryRunner: QueryRunner,\n    ): Promise<number> {\n        const countSql = this.computeCountExpression()\n\n        const results = await this.clone()\n            .orderBy()\n            .groupBy()\n            .offset(undefined)\n            .limit(undefined)\n            .skip(undefined)\n            .take(undefined)\n            .select(countSql, \"cnt\")\n            .setOption(\"disable-global-order\")\n            .loadRawResults(queryRunner)\n\n        if (!results || !results[0] || !results[0][\"cnt\"]) return 0\n\n        return parseInt(results[0][\"cnt\"])\n    }\n\n    protected async executeExistsQuery(\n        queryRunner: QueryRunner,\n    ): Promise<boolean> {\n        const results = await this.connection\n            .createQueryBuilder()\n            .fromDummy()\n            .select(\"1\", \"row_exists\")\n            .whereExists(this)\n            .limit(1)\n            .loadRawResults(queryRunner)\n\n        return results.length > 0\n    }\n\n    protected applyFindOptions() {\n        // todo: convert relations: string[] to object map to simplify code\n        // todo: same with selects\n\n        if (this.expressionMap.mainAlias!.metadata) {\n            if (this.findOptions.relationLoadStrategy) {\n                this.expressionMap.relationLoadStrategy =\n                    this.findOptions.relationLoadStrategy\n            }\n\n            if (this.findOptions.comment) {\n                this.comment(this.findOptions.comment)\n            }\n\n            if (this.findOptions.withDeleted) {\n                this.withDeleted()\n            }\n\n            if (this.findOptions.select) {\n                const select = Array.isArray(this.findOptions.select)\n                    ? OrmUtils.propertyPathsToTruthyObject(\n                          this.findOptions.select as string[],\n                      )\n                    : this.findOptions.select\n\n                this.buildSelect(\n                    select,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name,\n                )\n            }\n\n            if (this.selects.length) {\n                this.select(this.selects)\n            }\n\n            this.selects = []\n            if (this.findOptions.relations) {\n                const relations = Array.isArray(this.findOptions.relations)\n                    ? OrmUtils.propertyPathsToTruthyObject(\n                          this.findOptions.relations,\n                      )\n                    : this.findOptions.relations\n\n                this.buildRelations(\n                    relations,\n                    typeof this.findOptions.select === \"object\"\n                        ? (this.findOptions.select as FindOptionsSelect<any>)\n                        : undefined,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name,\n                )\n                if (\n                    this.findOptions.loadEagerRelations !== false &&\n                    this.expressionMap.relationLoadStrategy === \"join\"\n                ) {\n                    this.buildEagerRelations(\n                        relations,\n                        typeof this.findOptions.select === \"object\"\n                            ? (this.findOptions\n                                  .select as FindOptionsSelect<any>)\n                            : undefined,\n                        this.expressionMap.mainAlias!.metadata,\n                        this.expressionMap.mainAlias!.name,\n                    )\n                }\n            }\n            if (this.selects.length) {\n                this.addSelect(this.selects)\n            }\n\n            if (this.findOptions.where) {\n                this.conditions = this.buildWhere(\n                    this.findOptions.where,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name,\n                )\n\n                if (this.conditions.length)\n                    this.andWhere(\n                        this.conditions.substr(0, 1) !== \"(\"\n                            ? \"(\" + this.conditions + \")\"\n                            : this.conditions,\n                    ) // temporary and where and braces\n            }\n\n            if (this.findOptions.order) {\n                this.buildOrder(\n                    this.findOptions.order,\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.mainAlias!.name,\n                )\n            }\n\n            // apply joins\n            if (this.joins.length) {\n                this.joins.forEach((join) => {\n                    if (join.select && !join.selection) {\n                        // if (join.selection) {\n                        //\n                        // } else {\n                        if (join.type === \"inner\") {\n                            this.innerJoinAndSelect(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias,\n                            )\n                        } else {\n                            this.leftJoinAndSelect(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias,\n                            )\n                        }\n                        // }\n                    } else {\n                        if (join.type === \"inner\") {\n                            this.innerJoin(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias,\n                            )\n                        } else {\n                            this.leftJoin(\n                                `${join.parentAlias}.${join.relationMetadata.propertyPath}`,\n                                join.alias,\n                            )\n                        }\n                    }\n\n                    // if (join.select) {\n                    //     if (this.findOptions.loadEagerRelations !== false) {\n                    //         FindOptionsUtils.joinEagerRelations(\n                    //             this,\n                    //             join.alias,\n                    //             join.relationMetadata.inverseEntityMetadata\n                    //         );\n                    //     }\n                    // }\n                })\n            }\n\n            // if (this.conditions.length) {\n            //     this.where(this.conditions.join(\" AND \"));\n            // }\n\n            // apply offset\n            if (this.findOptions.skip !== undefined) {\n                // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n                //     this.offset(this.findOptions.skip);\n                // } else {\n                this.skip(this.findOptions.skip)\n                // }\n            }\n\n            // apply limit\n            if (this.findOptions.take !== undefined) {\n                // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n                //     this.limit(this.findOptions.take);\n                // } else {\n                this.take(this.findOptions.take)\n                // }\n            }\n\n            // apply caching options\n            if (typeof this.findOptions.cache === \"number\") {\n                this.cache(this.findOptions.cache)\n            } else if (typeof this.findOptions.cache === \"boolean\") {\n                this.cache(this.findOptions.cache)\n            } else if (typeof this.findOptions.cache === \"object\") {\n                this.cache(\n                    this.findOptions.cache.id,\n                    this.findOptions.cache.milliseconds,\n                )\n            }\n\n            if (this.findOptions.join) {\n                if (this.findOptions.join.leftJoin)\n                    Object.keys(this.findOptions.join.leftJoin).forEach(\n                        (key) => {\n                            this.leftJoin(\n                                this.findOptions.join!.leftJoin![key],\n                                key,\n                            )\n                        },\n                    )\n\n                if (this.findOptions.join.innerJoin)\n                    Object.keys(this.findOptions.join.innerJoin).forEach(\n                        (key) => {\n                            this.innerJoin(\n                                this.findOptions.join!.innerJoin![key],\n                                key,\n                            )\n                        },\n                    )\n\n                if (this.findOptions.join.leftJoinAndSelect)\n                    Object.keys(\n                        this.findOptions.join.leftJoinAndSelect,\n                    ).forEach((key) => {\n                        this.leftJoinAndSelect(\n                            this.findOptions.join!.leftJoinAndSelect![key],\n                            key,\n                        )\n                    })\n\n                if (this.findOptions.join.innerJoinAndSelect)\n                    Object.keys(\n                        this.findOptions.join.innerJoinAndSelect,\n                    ).forEach((key) => {\n                        this.innerJoinAndSelect(\n                            this.findOptions.join!.innerJoinAndSelect![key],\n                            key,\n                        )\n                    })\n            }\n\n            if (this.findOptions.lock) {\n                if (this.findOptions.lock.mode === \"optimistic\") {\n                    this.setLock(\n                        this.findOptions.lock.mode,\n                        this.findOptions.lock.version,\n                    )\n                } else if (\n                    this.findOptions.lock.mode === \"pessimistic_read\" ||\n                    this.findOptions.lock.mode === \"pessimistic_write\" ||\n                    this.findOptions.lock.mode === \"dirty_read\" ||\n                    this.findOptions.lock.mode ===\n                        \"pessimistic_partial_write\" ||\n                    this.findOptions.lock.mode ===\n                        \"pessimistic_write_or_fail\" ||\n                    this.findOptions.lock.mode === \"for_no_key_update\" ||\n                    this.findOptions.lock.mode === \"for_key_share\"\n                ) {\n                    const tableNames = this.findOptions.lock.tables\n                        ? this.findOptions.lock.tables.map((table) => {\n                              const tableAlias =\n                                  this.expressionMap.aliases.find((alias) => {\n                                      return (\n                                          alias.metadata\n                                              .tableNameWithoutPrefix === table\n                                      )\n                                  })\n                              if (!tableAlias) {\n                                  throw new TypeORMError(\n                                      `\"${table}\" is not part of this query`,\n                                  )\n                              }\n                              return this.escape(tableAlias.name)\n                          })\n                        : undefined\n                    this.setLock(\n                        this.findOptions.lock.mode,\n                        undefined,\n                        tableNames,\n                    )\n\n                    if (this.findOptions.lock.onLocked) {\n                        this.setOnLocked(this.findOptions.lock.onLocked)\n                    }\n                }\n            }\n\n            if (this.findOptions.loadRelationIds === true) {\n                this.loadAllRelationIds()\n            } else if (typeof this.findOptions.loadRelationIds === \"object\") {\n                this.loadAllRelationIds(this.findOptions.loadRelationIds as any)\n            }\n\n            if (this.findOptions.loadEagerRelations !== false) {\n                FindOptionsUtils.joinEagerRelations(\n                    this,\n                    this.expressionMap.mainAlias!.name,\n                    this.expressionMap.mainAlias!.metadata,\n                )\n            }\n\n            if (this.findOptions.transaction === true) {\n                this.expressionMap.useTransaction = true\n            }\n\n            // if (this.orderBys.length) {\n            //     this.orderBys.forEach(orderBy => {\n            //         this.addOrderBy(orderBy.alias, orderBy.direction, orderBy.nulls);\n            //     });\n            // }\n\n            // todo\n            // if (this.options.options && this.options.options.eagerRelations) {\n            //     this.queryBuilder\n            // }\n\n            // todo\n            // if (this.findOptions.options && this.findOptions.listeners === false) {\n            //     this.callListeners(false);\n            // }\n        }\n    }\n\n    public concatRelationMetadata(relationMetadata: RelationMetadata) {\n        this.relationMetadatas.push(relationMetadata)\n    }\n\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    protected async executeEntitiesAndRawResults(\n        queryRunner: QueryRunner,\n    ): Promise<{ entities: Entity[]; raw: any[] }> {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(\n                `Alias is not set. Use \"from\" method to set an alias.`,\n            )\n\n        if (\n            (this.expressionMap.lockMode === \"pessimistic_read\" ||\n                this.expressionMap.lockMode === \"pessimistic_write\" ||\n                this.expressionMap.lockMode === \"pessimistic_partial_write\" ||\n                this.expressionMap.lockMode === \"pessimistic_write_or_fail\" ||\n                this.expressionMap.lockMode === \"for_no_key_update\" ||\n                this.expressionMap.lockMode === \"for_key_share\") &&\n            !queryRunner.isTransactionActive\n        )\n            throw new PessimisticLockTransactionRequiredError()\n\n        if (this.expressionMap.lockMode === \"optimistic\") {\n            const metadata = this.expressionMap.mainAlias.metadata\n            if (!metadata.versionColumn && !metadata.updateDateColumn)\n                throw new NoVersionOrUpdateDateColumnError(metadata.name)\n        }\n\n        const relationIdLoader = new RelationIdLoader(\n            this.connection,\n            queryRunner,\n            this.expressionMap.relationIdAttributes,\n        )\n        const relationCountLoader = new RelationCountLoader(\n            this.connection,\n            queryRunner,\n            this.expressionMap.relationCountAttributes,\n        )\n        const relationIdMetadataTransformer =\n            new RelationIdMetadataToAttributeTransformer(this.expressionMap)\n        relationIdMetadataTransformer.transform()\n        const relationCountMetadataTransformer =\n            new RelationCountMetadataToAttributeTransformer(this.expressionMap)\n        relationCountMetadataTransformer.transform()\n\n        let rawResults: any[] = [],\n            entities: any[] = []\n\n        // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\n        // where we make two queries to find the data we need\n        // first query find ids in skip and take range\n        // and second query loads the actual data in given ids range\n        if (\n            (this.expressionMap.skip || this.expressionMap.take) &&\n            this.expressionMap.joinAttributes.length > 0\n        ) {\n            // we are skipping order by here because its not working in subqueries anyway\n            // to make order by working we need to apply it on a distinct query\n            const [selects, orderBys] =\n                this.createOrderByCombinedWithSelectExpression(\"distinctAlias\")\n            const metadata = this.expressionMap.mainAlias.metadata\n            const mainAliasName = this.expressionMap.mainAlias.name\n\n            const querySelects = metadata.primaryColumns.map(\n                (primaryColumn) => {\n                    const distinctAlias = this.escape(\"distinctAlias\")\n                    const columnAlias = this.escape(\n                        DriverUtils.buildAlias(\n                            this.connection.driver,\n                            undefined,\n                            mainAliasName,\n                            primaryColumn.databaseName,\n                        ),\n                    )\n                    if (!orderBys[columnAlias])\n                        // make sure we aren't overriding user-defined order in inverse direction\n                        orderBys[columnAlias] = \"ASC\"\n\n                    const alias = DriverUtils.buildAlias(\n                        this.connection.driver,\n                        undefined,\n                        \"ids_\" + mainAliasName,\n                        primaryColumn.databaseName,\n                    )\n\n                    return `${distinctAlias}.${columnAlias} AS ${this.escape(\n                        alias,\n                    )}`\n                },\n            )\n\n            const originalQuery = this.clone()\n\n            // preserve original timeTravel value since we set it to \"false\" in subquery\n            const originalQueryTimeTravel =\n                originalQuery.expressionMap.timeTravel\n\n            rawResults = await new SelectQueryBuilder(\n                this.connection,\n                queryRunner,\n            )\n                .select(`DISTINCT ${querySelects.join(\", \")}`)\n                .addSelect(selects)\n                .from(\n                    `(${originalQuery\n                        .orderBy()\n                        .timeTravelQuery(false) // set it to \"false\" since time travel clause must appear at the very end and applies to the entire SELECT clause.\n                        .getQuery()})`,\n                    \"distinctAlias\",\n                )\n                .timeTravelQuery(originalQueryTimeTravel)\n                .offset(this.expressionMap.skip)\n                .limit(this.expressionMap.take)\n                .orderBy(orderBys)\n                .cache(\n                    this.expressionMap.cache && this.expressionMap.cacheId\n                        ? `${this.expressionMap.cacheId}-pagination`\n                        : this.expressionMap.cache,\n                    this.expressionMap.cacheDuration,\n                )\n                .setParameters(this.getParameters())\n                .setNativeParameters(this.expressionMap.nativeParameters)\n                .getRawMany()\n\n            if (rawResults.length > 0) {\n                let condition = \"\"\n                const parameters: ObjectLiteral = {}\n                if (metadata.hasMultiplePrimaryKeys) {\n                    condition = rawResults\n                        .map((result, index) => {\n                            return metadata.primaryColumns\n                                .map((primaryColumn) => {\n                                    const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`\n                                    const paramKeyResult =\n                                        DriverUtils.buildAlias(\n                                            this.connection.driver,\n                                            undefined,\n                                            \"ids_\" + mainAliasName,\n                                            primaryColumn.databaseName,\n                                        )\n                                    parameters[paramKey] =\n                                        result[paramKeyResult]\n                                    return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`\n                                })\n                                .join(\" AND \")\n                        })\n                        .join(\" OR \")\n                } else {\n                    const alias = DriverUtils.buildAlias(\n                        this.connection.driver,\n                        undefined,\n                        \"ids_\" + mainAliasName,\n                        metadata.primaryColumns[0].databaseName,\n                    )\n\n                    const ids = rawResults.map((result) => result[alias])\n                    const areAllNumbers = ids.every(\n                        (id: any) => typeof id === \"number\",\n                    )\n                    if (areAllNumbers) {\n                        // fixes #190. if all numbers then its safe to perform query without parameter\n                        condition = `${mainAliasName}.${\n                            metadata.primaryColumns[0].propertyPath\n                        } IN (${ids.join(\", \")})`\n                    } else {\n                        parameters[\"orm_distinct_ids\"] = ids\n                        condition =\n                            mainAliasName +\n                            \".\" +\n                            metadata.primaryColumns[0].propertyPath +\n                            \" IN (:...orm_distinct_ids)\"\n                    }\n                }\n                rawResults = await this.clone()\n                    .mergeExpressionMap({\n                        extraAppendedAndWhereCondition: condition,\n                    })\n                    .setParameters(parameters)\n                    .loadRawResults(queryRunner)\n            }\n        } else {\n            rawResults = await this.loadRawResults(queryRunner)\n        }\n\n        if (rawResults.length > 0) {\n            // transform raw results into entities\n            const rawRelationIdResults = await relationIdLoader.load(rawResults)\n            const rawRelationCountResults = await relationCountLoader.load(\n                rawResults,\n            )\n            const transformer = new RawSqlResultsToEntityTransformer(\n                this.expressionMap,\n                this.connection.driver,\n                rawRelationIdResults,\n                rawRelationCountResults,\n                this.queryRunner,\n            )\n            entities = transformer.transform(\n                rawResults,\n                this.expressionMap.mainAlias!,\n            )\n\n            // broadcast all \"after load\" events\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias.hasMetadata\n            ) {\n                await queryRunner.broadcaster.broadcast(\n                    \"Load\",\n                    this.expressionMap.mainAlias.metadata,\n                    entities,\n                )\n            }\n        }\n\n        if (this.expressionMap.relationLoadStrategy === \"query\") {\n            const queryStrategyRelationIdLoader =\n                new QueryStrategyRelationIdLoader(this.connection, queryRunner)\n\n            await Promise.all(\n                this.relationMetadatas.map(async (relation) => {\n                    const relationTarget = relation.inverseEntityMetadata.target\n                    const relationAlias =\n                        relation.inverseEntityMetadata.targetName\n\n                    const select = Array.isArray(this.findOptions.select)\n                        ? OrmUtils.propertyPathsToTruthyObject(\n                              this.findOptions.select as string[],\n                          )\n                        : this.findOptions.select\n                    const relations = Array.isArray(this.findOptions.relations)\n                        ? OrmUtils.propertyPathsToTruthyObject(\n                              this.findOptions.relations,\n                          )\n                        : this.findOptions.relations\n\n                    const queryBuilder = this.createQueryBuilder(queryRunner)\n                        .select(relationAlias)\n                        .from(relationTarget, relationAlias)\n                        .setFindOptions({\n                            select: select\n                                ? OrmUtils.deepValue(\n                                      select,\n                                      relation.propertyPath,\n                                  )\n                                : undefined,\n                            order: this.findOptions.order\n                                ? OrmUtils.deepValue(\n                                      this.findOptions.order,\n                                      relation.propertyPath,\n                                  )\n                                : undefined,\n                            relations: relations\n                                ? OrmUtils.deepValue(\n                                      relations,\n                                      relation.propertyPath,\n                                  )\n                                : undefined,\n                            withDeleted: this.findOptions.withDeleted,\n                            relationLoadStrategy:\n                                this.findOptions.relationLoadStrategy,\n                        })\n                    if (entities.length > 0) {\n                        const relatedEntityGroups: any[] =\n                            await queryStrategyRelationIdLoader.loadManyToManyRelationIdsAndGroup(\n                                relation,\n                                entities,\n                                undefined,\n                                queryBuilder,\n                            )\n                        entities.forEach((entity) => {\n                            const relatedEntityGroup = relatedEntityGroups.find(\n                                (group) => group.entity === entity,\n                            )\n                            if (relatedEntityGroup) {\n                                const value =\n                                    relatedEntityGroup.related === undefined\n                                        ? null\n                                        : relatedEntityGroup.related\n                                relation.setEntityValue(entity, value)\n                            }\n                        })\n                    }\n                }),\n            )\n        }\n\n        return {\n            raw: rawResults,\n            entities: entities,\n        }\n    }\n\n    protected createOrderByCombinedWithSelectExpression(\n        parentAlias: string,\n    ): [string, OrderByCondition] {\n        // if table has a default order then apply it\n        const orderBys = this.expressionMap.allOrderBys\n        const selectString = Object.keys(orderBys)\n            .map((orderCriteria) => {\n                if (orderCriteria.indexOf(\".\") !== -1) {\n                    const criteriaParts = orderCriteria.split(\".\")\n                    const aliasName = criteriaParts[0]\n                    const propertyPath = criteriaParts.slice(1).join(\".\")\n                    const alias = this.expressionMap.findAliasByName(aliasName)\n                    const column =\n                        alias.metadata.findColumnWithPropertyPath(propertyPath)\n                    return (\n                        this.escape(parentAlias) +\n                        \".\" +\n                        this.escape(\n                            DriverUtils.buildAlias(\n                                this.connection.driver,\n                                undefined,\n                                aliasName,\n                                column!.databaseName,\n                            ),\n                        )\n                    )\n                } else {\n                    if (\n                        this.expressionMap.selects.find(\n                            (select) =>\n                                select.selection === orderCriteria ||\n                                select.aliasName === orderCriteria,\n                        )\n                    )\n                        return (\n                            this.escape(parentAlias) +\n                            \".\" +\n                            this.escape(orderCriteria)\n                        )\n\n                    return \"\"\n                }\n            })\n            .join(\", \")\n\n        const orderByObject: OrderByCondition = {}\n        Object.keys(orderBys).forEach((orderCriteria) => {\n            if (orderCriteria.indexOf(\".\") !== -1) {\n                const criteriaParts = orderCriteria.split(\".\")\n                const aliasName = criteriaParts[0]\n                const propertyPath = criteriaParts.slice(1).join(\".\")\n                const alias = this.expressionMap.findAliasByName(aliasName)\n                const column =\n                    alias.metadata.findColumnWithPropertyPath(propertyPath)\n                orderByObject[\n                    this.escape(parentAlias) +\n                        \".\" +\n                        this.escape(\n                            DriverUtils.buildAlias(\n                                this.connection.driver,\n                                undefined,\n                                aliasName,\n                                column!.databaseName,\n                            ),\n                        )\n                ] = orderBys[orderCriteria]\n            } else {\n                if (\n                    this.expressionMap.selects.find(\n                        (select) =>\n                            select.selection === orderCriteria ||\n                            select.aliasName === orderCriteria,\n                    )\n                ) {\n                    orderByObject[\n                        this.escape(parentAlias) +\n                            \".\" +\n                            this.escape(orderCriteria)\n                    ] = orderBys[orderCriteria]\n                } else {\n                    orderByObject[orderCriteria] = orderBys[orderCriteria]\n                }\n            }\n        })\n\n        return [selectString, orderByObject]\n    }\n\n    /**\n     * Loads raw results from the database.\n     */\n    protected async loadRawResults(queryRunner: QueryRunner) {\n        const [sql, parameters] = this.getQueryAndParameters()\n        const queryId =\n            sql +\n            \" -- PARAMETERS: \" +\n            JSON.stringify(parameters, (_, value) =>\n                typeof value === \"bigint\" ? value.toString() : value,\n            )\n        const cacheOptions =\n            typeof this.connection.options.cache === \"object\"\n                ? this.connection.options.cache\n                : {}\n        let savedQueryResultCacheOptions: QueryResultCacheOptions | undefined =\n            undefined\n        const isCachingEnabled =\n            // Caching is enabled globally and isn't disabled locally.\n            (cacheOptions.alwaysEnabled &&\n                this.expressionMap.cache !== false) ||\n            // ...or it's enabled locally explicitly.\n            this.expressionMap.cache === true\n        let cacheError = false\n        if (this.connection.queryResultCache && isCachingEnabled) {\n            try {\n                savedQueryResultCacheOptions =\n                    await this.connection.queryResultCache.getFromCache(\n                        {\n                            identifier: this.expressionMap.cacheId,\n                            query: queryId,\n                            duration:\n                                this.expressionMap.cacheDuration ||\n                                cacheOptions.duration ||\n                                1000,\n                        },\n                        queryRunner,\n                    )\n                if (\n                    savedQueryResultCacheOptions &&\n                    !this.connection.queryResultCache.isExpired(\n                        savedQueryResultCacheOptions,\n                    )\n                ) {\n                    return JSON.parse(savedQueryResultCacheOptions.result)\n                }\n            } catch (error) {\n                if (!cacheOptions.ignoreErrors) {\n                    throw error\n                }\n                cacheError = true\n            }\n        }\n\n        const results = await queryRunner.query(sql, parameters, true)\n\n        if (\n            !cacheError &&\n            this.connection.queryResultCache &&\n            isCachingEnabled\n        ) {\n            try {\n                await this.connection.queryResultCache.storeInCache(\n                    {\n                        identifier: this.expressionMap.cacheId,\n                        query: queryId,\n                        time: Date.now(),\n                        duration:\n                            this.expressionMap.cacheDuration ||\n                            cacheOptions.duration ||\n                            1000,\n                        result: JSON.stringify(results.records),\n                    },\n                    savedQueryResultCacheOptions,\n                    queryRunner,\n                )\n            } catch (error) {\n                if (!cacheOptions.ignoreErrors) {\n                    throw error\n                }\n            }\n        }\n\n        return results.records\n    }\n\n    /**\n     * Merges into expression map given expression map properties.\n     */\n    protected mergeExpressionMap(\n        expressionMap: Partial<QueryExpressionMap>,\n    ): this {\n        ObjectUtils.assign(this.expressionMap, expressionMap)\n        return this\n    }\n\n    /**\n     * Normalizes a give number - converts to int if possible.\n     */\n    protected normalizeNumber(num: any) {\n        if (typeof num === \"number\" || num === undefined || num === null)\n            return num\n\n        return Number(num)\n    }\n\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    protected obtainQueryRunner() {\n        return (\n            this.queryRunner ||\n            this.connection.createQueryRunner(\n                this.connection.defaultReplicationModeForReads(),\n            )\n        )\n    }\n\n    protected buildSelect(\n        select: FindOptionsSelect<any>,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        for (const key in select) {\n            if (select[key] === undefined || select[key] === false) continue\n\n            const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key\n            const column =\n                metadata.findColumnWithPropertyPathStrict(propertyPath)\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\n\n            if (!embed && !column && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\n\n            if (column) {\n                this.selects.push(alias + \".\" + propertyPath)\n                // this.addSelect(alias + \".\" + propertyPath);\n            } else if (embed) {\n                this.buildSelect(\n                    select[key] as FindOptionsSelect<any>,\n                    metadata,\n                    alias,\n                    propertyPath,\n                )\n\n                // } else if (relation) {\n                //     const joinAlias = alias + \"_\" + relation.propertyName;\n                //     const existJoin = this.joins.find(join => join.alias === joinAlias);\n                //     if (!existJoin) {\n                //         this.joins.push({\n                //             type: \"left\",\n                //             select: false,\n                //             alias: joinAlias,\n                //             parentAlias: alias,\n                //             relationMetadata: relation\n                //         });\n                //     }\n                //     this.buildOrder(select[key] as FindOptionsOrder<any>, relation.inverseEntityMetadata, joinAlias);\n            }\n        }\n    }\n\n    protected buildRelations(\n        relations: FindOptionsRelations<any>,\n        selection: FindOptionsSelect<any> | undefined,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        if (!relations) return\n\n        Object.keys(relations).forEach((relationName) => {\n            const relationValue = (relations as any)[relationName]\n            const propertyPath = embedPrefix\n                ? embedPrefix + \".\" + relationName\n                : relationName\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\n            if (!embed && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\n\n            if (embed) {\n                this.buildRelations(\n                    relationValue,\n                    typeof selection === \"object\"\n                        ? OrmUtils.deepValue(selection, embed.propertyPath)\n                        : undefined,\n                    metadata,\n                    alias,\n                    propertyPath,\n                )\n            } else if (relation) {\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\")\n                joinAlias = DriverUtils.buildAlias(\n                    this.connection.driver,\n                    { joiner: \"__\" },\n                    alias,\n                    joinAlias,\n                )\n                if (\n                    relationValue === true ||\n                    typeof relationValue === \"object\"\n                ) {\n                    if (this.expressionMap.relationLoadStrategy === \"query\") {\n                        this.concatRelationMetadata(relation)\n                    } else {\n                        // join\n                        this.joins.push({\n                            type: \"left\",\n                            select: true,\n                            selection:\n                                selection &&\n                                typeof selection[relationName] === \"object\"\n                                    ? (selection[\n                                          relationName\n                                      ] as FindOptionsSelect<any>)\n                                    : undefined,\n                            alias: joinAlias,\n                            parentAlias: alias,\n                            relationMetadata: relation,\n                        })\n\n                        if (\n                            selection &&\n                            typeof selection[relationName] === \"object\"\n                        ) {\n                            this.buildSelect(\n                                selection[\n                                    relationName\n                                ] as FindOptionsSelect<any>,\n                                relation.inverseEntityMetadata,\n                                joinAlias,\n                            )\n                        }\n                    }\n                }\n\n                if (\n                    typeof relationValue === \"object\" &&\n                    this.expressionMap.relationLoadStrategy === \"join\"\n                ) {\n                    this.buildRelations(\n                        relationValue,\n                        typeof selection === \"object\"\n                            ? OrmUtils.deepValue(\n                                  selection,\n                                  relation.propertyPath,\n                              )\n                            : undefined,\n                        relation.inverseEntityMetadata,\n                        joinAlias,\n                        undefined,\n                    )\n                }\n            }\n        })\n    }\n\n    protected buildEagerRelations(\n        relations: FindOptionsRelations<any>,\n        selection: FindOptionsSelect<any> | undefined,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        if (!relations) return\n\n        Object.keys(relations).forEach((relationName) => {\n            const relationValue = (relations as any)[relationName]\n            const propertyPath = embedPrefix\n                ? embedPrefix + \".\" + relationName\n                : relationName\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\n            if (!embed && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\n\n            if (embed) {\n                this.buildEagerRelations(\n                    relationValue,\n                    typeof selection === \"object\"\n                        ? OrmUtils.deepValue(selection, embed.propertyPath)\n                        : undefined,\n                    metadata,\n                    alias,\n                    propertyPath,\n                )\n            } else if (relation) {\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\")\n                joinAlias = DriverUtils.buildAlias(\n                    this.connection.driver,\n                    { joiner: \"__\" },\n                    alias,\n                    joinAlias,\n                )\n\n                if (\n                    relationValue === true ||\n                    typeof relationValue === \"object\"\n                ) {\n                    relation.inverseEntityMetadata.eagerRelations.forEach(\n                        (eagerRelation) => {\n                            let eagerRelationJoinAlias =\n                                joinAlias +\n                                \"_\" +\n                                eagerRelation.propertyPath.replace(\".\", \"_\")\n                            eagerRelationJoinAlias = DriverUtils.buildAlias(\n                                this.connection.driver,\n                                { joiner: \"__\" },\n                                joinAlias,\n                                eagerRelationJoinAlias,\n                            )\n\n                            const existJoin = this.joins.find(\n                                (join) => join.alias === eagerRelationJoinAlias,\n                            )\n                            if (!existJoin) {\n                                this.joins.push({\n                                    type: \"left\",\n                                    select: true,\n                                    alias: eagerRelationJoinAlias,\n                                    parentAlias: joinAlias,\n                                    selection: undefined,\n                                    relationMetadata: eagerRelation,\n                                })\n                            }\n\n                            if (\n                                selection &&\n                                typeof selection[relationName] === \"object\"\n                            ) {\n                                this.buildSelect(\n                                    selection[\n                                        relationName\n                                    ] as FindOptionsSelect<any>,\n                                    relation.inverseEntityMetadata,\n                                    joinAlias,\n                                )\n                            }\n                        },\n                    )\n                }\n\n                if (typeof relationValue === \"object\") {\n                    this.buildEagerRelations(\n                        relationValue,\n                        typeof selection === \"object\"\n                            ? OrmUtils.deepValue(\n                                  selection,\n                                  relation.propertyPath,\n                              )\n                            : undefined,\n                        relation.inverseEntityMetadata,\n                        joinAlias,\n                        undefined,\n                    )\n                }\n            }\n        })\n    }\n\n    protected buildOrder(\n        order: FindOptionsOrder<any>,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        for (const key in order) {\n            if (order[key] === undefined) continue\n\n            const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key\n            const column =\n                metadata.findColumnWithPropertyPathStrict(propertyPath)\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath)\n            const relation = metadata.findRelationWithPropertyPath(propertyPath)\n\n            if (!embed && !column && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata)\n\n            if (column) {\n                let direction =\n                    typeof order[key] === \"object\"\n                        ? (order[key] as any).direction\n                        : order[key]\n                direction =\n                    direction === \"DESC\" ||\n                    direction === \"desc\" ||\n                    direction === -1\n                        ? \"DESC\"\n                        : \"ASC\"\n                let nulls =\n                    typeof order[key] === \"object\"\n                        ? (order[key] as any).nulls\n                        : undefined\n                nulls =\n                    nulls?.toLowerCase() === \"first\"\n                        ? \"NULLS FIRST\"\n                        : nulls?.toLowerCase() === \"last\"\n                        ? \"NULLS LAST\"\n                        : undefined\n\n                const aliasPath = `${alias}.${propertyPath}`\n                // const selection = this.expressionMap.selects.find(\n                //     (s) => s.selection === aliasPath,\n                // )\n                // if (selection) {\n                //     // this is not building correctly now???\n                //     aliasPath = this.escape(\n                //         DriverUtils.buildAlias(\n                //             this.connection.driver,\n                //             undefined,\n                //             alias,\n                //             column.databaseName,\n                //         ),\n                //     )\n                //     // selection.aliasName = aliasPath\n                // } else {\n                //     if (column.isVirtualProperty && column.query) {\n                //         aliasPath = `(${column.query(alias)})`\n                //     }\n                // }\n\n                // console.log(\"add sort\", selection, aliasPath, direction, nulls)\n                this.addOrderBy(aliasPath, direction, nulls)\n                // this.orderBys.push({ alias: alias + \".\" + propertyPath, direction, nulls });\n            } else if (embed) {\n                this.buildOrder(\n                    order[key] as FindOptionsOrder<any>,\n                    metadata,\n                    alias,\n                    propertyPath,\n                )\n            } else if (relation) {\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\")\n                joinAlias = DriverUtils.buildAlias(\n                    this.connection.driver,\n                    { joiner: \"__\" },\n                    alias,\n                    joinAlias,\n                )\n                // console.log(\"joinAlias\", joinAlias, joinAlias.length, this.connection.driver.maxAliasLength)\n                // todo: use expressionMap.joinAttributes, and create a new one using\n                //  const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n\n                const existJoin = this.joins.find(\n                    (join) => join.alias === joinAlias,\n                )\n                if (!existJoin) {\n                    this.joins.push({\n                        type: \"left\",\n                        select: false,\n                        alias: joinAlias,\n                        parentAlias: alias,\n                        selection: undefined,\n                        relationMetadata: relation,\n                    })\n                }\n                this.buildOrder(\n                    order[key] as FindOptionsOrder<any>,\n                    relation.inverseEntityMetadata,\n                    joinAlias,\n                )\n            }\n        }\n    }\n\n    protected buildWhere(\n        where: FindOptionsWhere<any>[] | FindOptionsWhere<any>,\n        metadata: EntityMetadata,\n        alias: string,\n        embedPrefix?: string,\n    ) {\n        let condition: string = \"\"\n        // let parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n        if (Array.isArray(where)) {\n            if (where.length) {\n                condition = where\n                    .map((whereItem) => {\n                        return this.buildWhere(\n                            whereItem,\n                            metadata,\n                            alias,\n                            embedPrefix,\n                        )\n                    })\n                    .filter((condition) => !!condition)\n                    .map((condition) => \"(\" + condition + \")\")\n                    .join(\" OR \")\n            }\n        } else {\n            const andConditions: string[] = []\n            for (const key in where) {\n                if (where[key] === undefined || where[key] === null) continue\n\n                const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key\n                const column =\n                    metadata.findColumnWithPropertyPathStrict(propertyPath)\n                const embed =\n                    metadata.findEmbeddedWithPropertyPath(propertyPath)\n                const relation =\n                    metadata.findRelationWithPropertyPath(propertyPath)\n\n                if (!embed && !column && !relation)\n                    throw new EntityPropertyNotFoundError(\n                        propertyPath,\n                        metadata,\n                    )\n\n                if (column) {\n                    let aliasPath = `${alias}.${propertyPath}`\n                    if (column.isVirtualProperty && column.query) {\n                        aliasPath = `(${column.query(this.escape(alias))})`\n                    }\n                    // const parameterName = alias + \"_\" + propertyPath.split(\".\").join(\"_\") + \"_\" + parameterIndex;\n\n                    // todo: we need to handle other operators as well?\n                    let parameterValue = where[key]\n                    if (InstanceChecker.isEqualOperator(where[key])) {\n                        parameterValue = where[key].value\n                    }\n\n                    if (column.transformer) {\n                        if (parameterValue instanceof FindOperator) {\n                            parameterValue.transformValue(column.transformer)\n                        } else {\n                            parameterValue = ApplyValueTransformers.transformTo(\n                                column.transformer,\n                                parameterValue,\n                            )\n                        }\n                    }\n\n                    // MSSQL requires parameters to carry extra type information\n                    if (this.connection.driver.options.type === \"mssql\") {\n                        parameterValue = (\n                            this.connection.driver as SqlServerDriver\n                        ).parametrizeValues(column, parameterValue)\n                    }\n\n                    // if (parameterValue === null) {\n                    //     andConditions.push(`${aliasPath} IS NULL`);\n                    //\n                    // } else if (parameterValue instanceof FindOperator) {\n                    //     // let parameters: any[] = [];\n                    //     // if (parameterValue.useParameter) {\n                    //     //     const realParameterValues: any[] = parameterValue.multipleParameters ? parameterValue.value : [parameterValue.value];\n                    //     //     realParameterValues.forEach((realParameterValue, realParameterValueIndex) => {\n                    //     //\n                    //     //         // don't create parameters for number to prevent max number of variables issues as much as possible\n                    //     //         if (typeof realParameterValue === \"number\") {\n                    //     //             parameters.push(realParameterValue);\n                    //     //\n                    //     //         } else {\n                    //     //             this.expressionMap.nativeParameters[parameterName + realParameterValueIndex] = realParameterValue;\n                    //     //             parameterIndex++;\n                    //     //             parameters.push(this.connection.driver.createParameter(parameterName + realParameterValueIndex, parameterIndex - 1));\n                    //     //         }\n                    //     //     });\n                    //     // }\n                    //     andConditions.push(\n                    //         this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue))\n                    //         // parameterValue.toSql(this.connection, aliasPath, parameters));\n                    //     )\n                    //\n                    // } else {\n                    //     this.expressionMap.nativeParameters[parameterName] = parameterValue;\n                    //     parameterIndex++;\n                    //     const parameter = this.connection.driver.createParameter(parameterName, parameterIndex - 1);\n                    //     andConditions.push(`${aliasPath} = ${parameter}`);\n                    // }\n\n                    andConditions.push(\n                        this.createWhereConditionExpression(\n                            this.getWherePredicateCondition(\n                                aliasPath,\n                                parameterValue,\n                            ),\n                        ),\n                        // parameterValue.toSql(this.connection, aliasPath, parameters));\n                    )\n\n                    // this.conditions.push(`${alias}.${propertyPath} = :${paramName}`);\n                    // this.expressionMap.parameters[paramName] = where[key]; // todo: handle functions and other edge cases\n                } else if (embed) {\n                    const condition = this.buildWhere(\n                        where[key],\n                        metadata,\n                        alias,\n                        propertyPath,\n                    )\n                    if (condition) andConditions.push(condition)\n                } else if (relation) {\n                    // if all properties of where are undefined we don't need to join anything\n                    // this can happen when user defines map with conditional queries inside\n                    if (typeof where[key] === \"object\") {\n                        const allAllUndefined = Object.keys(where[key]).every(\n                            (k) => where[key][k] === undefined,\n                        )\n                        if (allAllUndefined) {\n                            continue\n                        }\n                    }\n\n                    if (InstanceChecker.isFindOperator(where[key])) {\n                        if (\n                            where[key].type === \"moreThan\" ||\n                            where[key].type === \"lessThan\" ||\n                            where[key].type === \"moreThanOrEqual\" ||\n                            where[key].type === \"lessThanOrEqual\"\n                        ) {\n                            let sqlOperator = \"\"\n                            if (where[key].type === \"moreThan\") {\n                                sqlOperator = \">\"\n                            } else if (where[key].type === \"lessThan\") {\n                                sqlOperator = \"<\"\n                            } else if (where[key].type === \"moreThanOrEqual\") {\n                                sqlOperator = \">=\"\n                            } else if (where[key].type === \"lessThanOrEqual\") {\n                                sqlOperator = \"<=\"\n                            }\n                            // basically relation count functionality\n                            const qb: QueryBuilder<any> = this.subQuery()\n                            if (relation.isManyToManyOwner) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(\n                                        relation.joinTableName,\n                                        relation.joinTableName,\n                                    )\n                                    .where(\n                                        relation.joinColumns\n                                            .map((column) => {\n                                                return `${\n                                                    relation.joinTableName\n                                                }.${\n                                                    column.propertyName\n                                                } = ${alias}.${\n                                                    column.referencedColumn!\n                                                        .propertyName\n                                                }`\n                                            })\n                                            .join(\" AND \"),\n                                    )\n                            } else if (relation.isManyToManyNotOwner) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(\n                                        relation.inverseRelation!.joinTableName,\n                                        relation.inverseRelation!.joinTableName,\n                                    )\n                                    .where(\n                                        relation\n                                            .inverseRelation!.inverseJoinColumns.map(\n                                                (column) => {\n                                                    return `${\n                                                        relation.inverseRelation!\n                                                            .joinTableName\n                                                    }.${\n                                                        column.propertyName\n                                                    } = ${alias}.${\n                                                        column.referencedColumn!\n                                                            .propertyName\n                                                    }`\n                                                },\n                                            )\n                                            .join(\" AND \"),\n                                    )\n                            } else if (relation.isOneToMany) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(\n                                        relation.inverseEntityMetadata.target,\n                                        relation.inverseEntityMetadata\n                                            .tableName,\n                                    )\n                                    .where(\n                                        relation\n                                            .inverseRelation!.joinColumns.map(\n                                                (column) => {\n                                                    return `${\n                                                        relation\n                                                            .inverseEntityMetadata\n                                                            .tableName\n                                                    }.${\n                                                        column.propertyName\n                                                    } = ${alias}.${\n                                                        column.referencedColumn!\n                                                            .propertyName\n                                                    }`\n                                                },\n                                            )\n                                            .join(\" AND \"),\n                                    )\n                            } else {\n                                throw new Error(\n                                    `This relation isn't supported by given find operator`,\n                                )\n                            }\n                            // this\n                            //     .addSelect(qb.getSql(), relation.propertyAliasName + \"_cnt\")\n                            //     .andWhere(this.escape(relation.propertyAliasName + \"_cnt\") + \" \" + sqlOperator + \" \" + parseInt(where[key].value));\n                            this.andWhere(\n                                qb.getSql() +\n                                    \" \" +\n                                    sqlOperator +\n                                    \" \" +\n                                    parseInt(where[key].value),\n                            )\n                        } else {\n                            if (\n                                relation.isManyToOne ||\n                                (relation.isOneToOne &&\n                                    relation.isOneToOneOwner)\n                            ) {\n                                const aliasPath = `${alias}.${propertyPath}`\n\n                                andConditions.push(\n                                    this.createWhereConditionExpression(\n                                        this.getWherePredicateCondition(\n                                            aliasPath,\n                                            where[key],\n                                        ),\n                                    ),\n                                )\n                            } else {\n                                throw new Error(\n                                    `This relation isn't supported by given find operator`,\n                                )\n                            }\n                        }\n                    } else {\n                        // const joinAlias = alias + \"_\" + relation.propertyName;\n                        let joinAlias =\n                            alias +\n                            \"_\" +\n                            relation.propertyPath.replace(\".\", \"_\")\n                        joinAlias = DriverUtils.buildAlias(\n                            this.connection.driver,\n                            { joiner: \"__\" },\n                            alias,\n                            joinAlias,\n                        )\n\n                        const existJoin = this.joins.find(\n                            (join) => join.alias === joinAlias,\n                        )\n                        if (!existJoin) {\n                            this.joins.push({\n                                type: \"left\",\n                                select: false,\n                                selection: undefined,\n                                alias: joinAlias,\n                                parentAlias: alias,\n                                relationMetadata: relation,\n                            })\n                        }\n\n                        const condition = this.buildWhere(\n                            where[key],\n                            relation.inverseEntityMetadata,\n                            joinAlias,\n                        )\n                        if (condition) {\n                            andConditions.push(condition)\n                            // parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n                        }\n                    }\n                }\n            }\n            condition = andConditions.length\n                ? \"(\" + andConditions.join(\") AND (\") + \")\"\n                : andConditions.join(\" AND \")\n        }\n        return condition.length ? \"(\" + condition + \")\" : condition\n    }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,+FAAiG;AAEjG,MAAA,wGAA0G;AAC1G,MAAA,0FAA4F;AAC5F,MAAA,8FAAgG;AAChG,MAAA,wFAA0F;AAC1F,MAAA,6CAA+C;AAC/C,MAAA,qEAAuE;AACvE,MAAA,8EAAgF;AAChF,MAAA,+DAAiE;AACjE,MAAA,mDAAsF;AACtF,MAAA,+GAAiH;AACjH,MAAA,wEAA0E;AAC1E,MAAA,wHAA0H;AAC1H,MAAA,2CAA6C;AAE7C,MAAA,8FAAgG;AAYhG,MAAA,gGAAkG;AAElG,MAAA,+CAAiD;AACjD,MAAA,iDAAmD;AACnD,MAAA,gEAAkE;AAClE,MAAA,8BAAuC;AAMvC,MAAA,iEAAmE;AAEnE,MAAA,yCAA2C;AAC3C,MAAA,gFAAkF;AAElF,MAAA,uDAAyD;AACzD,MAAA,yDAA2D;AAC3D,MAAA,qEAAuE;AAGvE;;GAEG,CACH,MAAa,kBACT,SAAQ,eAAA,YAAoB;IADhC,aAAA;;QAIa,IAAA,CAAA,cAAa,GAAG,MAAM,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAA;QAE/C,IAAA,CAAA,WAAW,GAAoB,CAAA,CAAE,CAAA;QACjC,IAAA,CAAA,OAAO,GAAa,EAAE,CAAA;QACtB,IAAA,CAAA,KAAK,GAOT,EAAE,CAAA;QACE,IAAA,CAAA,UAAU,GAAW,EAAE,CAAA;QACvB,IAAA,CAAA,QAAQ,GAIZ,EAAE,CAAA;QACE,IAAA,CAAA,iBAAiB,GAAuB,EAAE,CAAA;IA81IxD,CAAC;IA51IG,4EAA4E;IAC5E,6BAA6B;IAC7B,4EAA4E;IAE5E;;OAEG,CACH,QAAQ,GAAA;QACJ,IAAI,GAAG,GAAG,IAAI,CAAC,aAAa,EAAE,CAAA;QAC9B,GAAG,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAA;QACjC,GAAG,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAA;QACpC,GAAG,IAAI,IAAI,CAAC,oBAAoB,EAAE,CAAA;QAClC,GAAG,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAA;QACnC,GAAG,IAAI,IAAI,CAAC,uBAAuB,EAAE,CAAA;QACrC,GAAG,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAA;QACpC,GAAG,IAAI,IAAI,CAAC,uBAAuB,EAAE,CAAA;QACrC,GAAG,IAAI,IAAI,CAAC,2BAA2B,EAAE,CAAA;QACzC,GAAG,IAAI,IAAI,CAAC,oBAAoB,EAAE,CAAA;QAClC,GAAG,GAAG,GAAG,CAAC,IAAI,EAAE,CAAA;QAChB,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAA;QACtD,OAAO,IAAI,CAAC,oCAAoC,CAAC,GAAG,CAAC,CAAA;IACzD,CAAC;IAED,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E,cAAc,CAAC,WAAoC,EAAA;QAC/C,IAAI,CAAC,WAAW,GAAG,WAAW,CAAA;QAC9B,IAAI,CAAC,gBAAgB,EAAE,CAAA;QACvB,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,QAAQ,GAAA;QACJ,MAAM,EAAE,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAA;QACpC,EAAE,CAAC,aAAa,CAAC,QAAQ,GAAG,IAAI,CAAA;QAChC,EAAE,CAAC,kBAAkB,GAAG,IAAI,CAAA;QAC5B,OAAO,EAAE,CAAA;IACb,CAAC;IA6BD;;;OAGG,CACH,MAAM,CACF,SAGgE,EAChE,kBAA2B,EAAA;QAE3B,IAAI,CAAC,aAAa,CAAC,SAAS,GAAG,QAAQ,CAAA;QACvC,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC;YAC3B,IAAI,CAAC,aAAa,CAAC,OAAO,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC,SAAS,EAAE,CAAG,CAAD,AAAE;oBACvD,SAAS,EAAE,SAAS;iBACvB,CAAC,CAAC,CAAA;QACP,CAAC,MAAM,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE,CAAC;YACzC,MAAM,eAAe,GAAG,SAAS,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAA;YAClD,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,aAAa,EAAE,CAAC,CAAA;YACnD,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC;gBAC5B,SAAS,EAAE,eAAe,CAAC,QAAQ,EAAE;gBACrC,SAAS,EAAE,kBAAkB;aAChC,CAAC,CAAA;QACN,CAAC,MAAM,IAAI,SAAS,EAAE,CAAC;YACnB,IAAI,CAAC,aAAa,CAAC,OAAO,GAAG;gBACzB;oBAAE,SAAS,EAAE,SAAS;oBAAE,SAAS,EAAE,kBAAkB;gBAAA,CAAE;aAC1D,CAAA;QACL,CAAC;QAED,OAAO,IAAI,CAAA;IACf,CAAC;IAoBD;;OAEG,CACH,SAAS,CACL,SAGgE,EAChE,kBAA2B,EAAA;QAE3B,IAAI,CAAC,SAAS,EAAE,OAAO,IAAI,CAAA;QAE3B,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC;YAC3B,IAAI,CAAC,aAAa,CAAC,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,CAC1D,SAAS,CAAC,GAAG,CAAC,CAAC,SAAS,EAAE,CAAG,CAAC,AAAF;oBAAI,SAAS,EAAE,SAAS;gBAAA,CAAE,CAAC,CAAC,CAC3D,CAAA;QACL,CAAC,MAAM,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE,CAAC;YACzC,MAAM,eAAe,GAAG,SAAS,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAA;YAClD,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,aAAa,EAAE,CAAC,CAAA;YACnD,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC;gBAC5B,SAAS,EAAE,eAAe,CAAC,QAAQ,EAAE;gBACrC,SAAS,EAAE,kBAAkB;aAChC,CAAC,CAAA;QACN,CAAC,MAAM,IAAI,SAAS,EAAE,CAAC;YACnB,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC;gBAC5B,SAAS,EAAE,SAAS;gBACpB,SAAS,EAAE,kBAAkB;aAChC,CAAC,CAAA;QACN,CAAC;QAED,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;OAGG,CACH,gBAAgB,CAAC,YAAoB,EAAA;QACjC,IAAI,CAAC,aAAa,CAAC,gBAAgB,GAAG,YAAY,CAAA;QAClD,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,QAAQ,CAAC,WAAoB,IAAI,EAAA;QAC7B,IAAI,CAAC,aAAa,CAAC,cAAc,GAAG,QAAQ,CAAA;QAC5C,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,UAAU,CAAC,UAAoB,EAAA;QAC3B,IAAI,CAAC,aAAa,CAAC,gBAAgB,GAAG,UAAU,CAAA;QAChD,OAAO,IAAI,CAAA;IACf,CAAC;IAED,SAAS,GAAA;QACL,OAAO,IAAI,CAAC,IAAI,CACZ,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,cAAc,IACjC,4BAA4B,EAChC,aAAa,CAChB,CAAA;IACL,CAAC;IAsBD;;;;OAIG,CACH,IAAI,CACA,YAEgE,EAChE,SAAiB,EAAA;QAEjB,MAAM,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE,SAAS,CAAC,CAAA;QAC/D,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,SAAS,CAAC,CAAA;QAC1C,OAAO,IAAoC,CAAA;IAC/C,CAAC;IAoBD;;;OAGG,CACH,OAAO,CACH,YAEgE,EAChE,SAAiB,EAAA;QAEjB,MAAM,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE,SAAS,CAAC,CAAA;QAC3D,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,EAC7B,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,KAAK,CAAC,CAAA;QAE1C,OAAO,IAAoC,CAAA;IAC/C,CAAC;IAqDD;;;;OAIG,CACH,SAAS,CACL,gBAGgE,EAChE,KAAa,EACb,SAAkB,EAClB,UAA0B,EAAA;QAE1B,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,CAAC,CAAA;QAClE,OAAO,IAAI,CAAA;IACf,CAAC;IAqDD;;;;OAIG,CACH,QAAQ,CACJ,gBAGgE,EAChE,KAAa,EACb,SAAkB,EAClB,UAA0B,EAAA;QAE1B,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,CAAC,CAAA;QACjE,OAAO,IAAI,CAAA;IACf,CAAC;IAqDD;;;;OAIG,CACH,kBAAkB,CACd,gBAGgE,EAChE,KAAa,EACb,SAAkB,EAClB,UAA0B,EAAA;QAE1B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAA;QACrB,IAAI,CAAC,SAAS,CAAC,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,CAAC,CAAA;QAC9D,OAAO,IAAI,CAAA;IACf,CAAC;IAqDD;;;;OAIG,CACH,iBAAiB,CACb,gBAGgE,EAChE,KAAa,EACb,SAAkB,EAClB,UAA0B,EAAA;QAE1B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAA;QACrB,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,CAAC,CAAA;QAC7D,OAAO,IAAI,CAAA;IACf,CAAC;IAkED;;;;;;OAMG,CACH,mBAAmB,CACf,aAAqB,EACrB,gBAGgE,EAChE,KAAa,EACb,SAAkB,EAClB,UAA0B,EAAA;QAE1B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAA;QACrB,IAAI,CAAC,IAAI,CACL,OAAO,EACP,gBAAgB,EAChB,KAAK,EACL,SAAS,EACT,UAAU,EACV,aAAa,EACb,IAAI,CACP,CAAA;QACD,OAAO,IAAI,CAAA;IACf,CAAC;IAmED;;;;;;OAMG,CACH,kBAAkB,CACd,aAAqB,EACrB,gBAGgE,EAChE,KAAa,EACb,SAAkB,EAClB,UAA0B,EAC1B,WAA+B,EAAA;QAE/B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAA;QACrB,IAAI,CAAC,IAAI,CACL,OAAO,EACP,gBAAgB,EAChB,KAAK,EACL,SAAS,EACT,UAAU,EACV,aAAa,EACb,KAAK,EACL,WAAW,CACd,CAAA;QACD,OAAO,IAAI,CAAA;IACf,CAAC;IAkED;;;;;;OAMG,CACH,kBAAkB,CACd,aAAqB,EACrB,gBAGgE,EAChE,KAAa,EACb,SAAkB,EAClB,UAA0B,EAAA;QAE1B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAA;QACrB,IAAI,CAAC,IAAI,CACL,MAAM,EACN,gBAAgB,EAChB,KAAK,EACL,SAAS,EACT,UAAU,EACV,aAAa,EACb,IAAI,CACP,CAAA;QACD,OAAO,IAAI,CAAA;IACf,CAAC;IAmED;;;;;;OAMG,CACH,iBAAiB,CACb,aAAqB,EACrB,gBAGgE,EAChE,KAAa,EACb,SAAkB,EAClB,UAA0B,EAC1B,WAA+B,EAAA;QAE/B,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAA;QACrB,IAAI,CAAC,IAAI,CACL,MAAM,EACN,gBAAgB,EAChB,KAAK,EACL,SAAS,EACT,UAAU,EACV,aAAa,EACb,KAAK,EACL,WAAW,CACd,CAAA;QACD,OAAO,IAAI,CAAA;IACf,CAAC;IAgDD;;;OAGG,CACH,oBAAoB,CAChB,aAAqB,EACrB,YAAoB,EACpB,kBAA2D,EAC3D,mBAE4B,EAAA;QAE5B,MAAM,mBAAmB,GAAG,IAAI,sBAAA,mBAAmB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAA;QACvE,mBAAmB,CAAC,aAAa,GAAG,aAAa,CAAA;QACjD,mBAAmB,CAAC,YAAY,GAAG,YAAY,CAAA;QAC/C,IAAI,OAAO,kBAAkB,KAAK,QAAQ,EACtC,mBAAmB,CAAC,KAAK,GAAG,kBAAkB,CAAA;QAClD,IACI,OAAO,kBAAkB,KAAK,QAAQ,IACrC,kBAA0B,CAAC,eAAe,EAE3C,mBAAmB,CAAC,eAAe,GAAG,IAAI,CAAA;QAE9C,mBAAmB,CAAC,mBAAmB,GAAG,mBAAmB,CAAA;QAC7D,IAAI,CAAC,aAAa,CAAC,oBAAoB,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAA;QAEjE,IAAI,mBAAmB,CAAC,QAAQ,CAAC,sBAAsB,EAAE,CAAC;YACtD,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;gBAC3B,IAAI,EAAE,OAAO;gBACb,IAAI,EAAE,mBAAmB,CAAC,aAAa;gBACvC,QAAQ,EAAE,mBAAmB,CAAC,QAAQ,CAAC,sBAAsB;aAChE,CAAC,CAAA;QACN,CAAC;QACD,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;OAGG,CACH,uBAAuB,CACnB,aAAqB,EACrB,YAAoB,EACpB,SAAkB,EAClB,mBAE4B,EAAA;QAE5B,MAAM,sBAAsB,GAAG,IAAI,yBAAA,sBAAsB,CACrD,IAAI,CAAC,aAAa,CACrB,CAAA;QACD,sBAAsB,CAAC,aAAa,GAAG,aAAa,CAAA;QACpD,sBAAsB,CAAC,YAAY,GAAG,YAAY,CAAA;QAClD,sBAAsB,CAAC,KAAK,GAAG,SAAS,CAAA;QACxC,sBAAsB,CAAC,mBAAmB,GAAG,mBAAmB,CAAA;QAChE,IAAI,CAAC,aAAa,CAAC,uBAAuB,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAA;QAEvE,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;YAC3B,IAAI,EAAE,OAAO;YACb,IAAI,EAAE,sBAAsB,CAAC,aAAa;SAC7C,CAAC,CAAA;QACF,IAAI,sBAAsB,CAAC,QAAQ,CAAC,sBAAsB,EAAE,CAAC;YACzD,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;gBAC3B,IAAI,EAAE,OAAO;gBACb,IAAI,EAAE,sBAAsB,CAAC,aAAa;gBAC1C,QAAQ,EACJ,sBAAsB,CAAC,QAAQ,CAAC,sBAAsB;aAC7D,CAAC,CAAA;QACN,CAAC;QACD,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;;OAIG,CACH,kBAAkB,CAAC,OAGlB,EAAA;QACG,2BAA2B;QAC3B,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;YAClE,IACI,OAAO,KAAK,SAAS,IACrB,OAAO,CAAC,SAAS,KAAK,SAAS,IAC/B,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAEvD,OAAM;YAEV,IAAI,CAAC,oBAAoB,CACrB,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,GAC9B,GAAG,GACH,QAAQ,CAAC,YAAY,EACzB,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,GAC9B,GAAG,GACH,QAAQ,CAAC,YAAY,EACzB,OAAO,CACV,CAAA;QACL,CAAC,CAAC,CAAA;QACF,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;;;OAKG,CACH,KAAK,CACD,KAKqB,EACrB,UAA0B,EAAA;QAE1B,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,EAAE,CAAA,CAAC,oFAAoF;QACnH,MAAM,SAAS,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAA;QAC/C,IAAI,SAAS,EAAE,CAAC;YACZ,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG;gBACxB;oBAAE,IAAI,EAAE,QAAQ;oBAAE,SAAS,EAAE,SAAS;gBAAA,CAAE;aAC3C,CAAA;QACL,CAAC;QACD,IAAI,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAA;QAC9C,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;OAGG,CACH,QAAQ,CACJ,KAKqB,EACrB,UAA0B,EAAA;QAE1B,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC;YAC3B,IAAI,EAAE,KAAK;YACX,SAAS,EAAE,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;SAC3C,CAAC,CAAA;QACF,IAAI,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAA;QAC9C,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;OAGG,CACH,OAAO,CACH,KAKqB,EACrB,UAA0B,EAAA;QAE1B,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,IAAI,CAAC;YAC3B,IAAI,EAAE,IAAI;YACV,SAAS,EAAE,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;SAC3C,CAAC,CAAA;QACF,IAAI,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAA;QAC9C,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,WAAW,CAAC,QAAiC,EAAA;QACzC,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC,CAAA;IAC3D,CAAC;IAED;;OAEG,CACH,cAAc,CAAC,QAAiC,EAAA;QAC5C,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC,CAAA;IAC9D,CAAC;IAED;;OAEG,CACH,aAAa,CAAC,QAAiC,EAAA;QAC3C,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC,CAAA;IAC7D,CAAC;IAED;;;;;;;OAOG,CACH,UAAU,CAAC,GAAgB,EAAA;QACvB,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,CAAC,CAAA;IACvD,CAAC;IAED;;;;;;;OAOG,CACH,aAAa,CAAC,GAAgB,EAAA;QAC1B,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,CAAC,CAAA;IAC1D,CAAC;IAED;;;;;;;OAOG,CACH,YAAY,CAAC,GAAgB,EAAA;QACzB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,CAAC,CAAA;IACzD,CAAC;IAED;;;;;OAKG,CACH,MAAM,CAAC,MAAc,EAAE,UAA0B,EAAA;QAC7C,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC;YAAE,IAAI,EAAE,QAAQ;YAAE,SAAS,EAAE,MAAM;QAAA,CAAE,CAAC,CAAA;QACtE,IAAI,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAA;QAC9C,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;OAGG,CACH,SAAS,CAAC,MAAc,EAAE,UAA0B,EAAA;QAChD,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC;YAAE,IAAI,EAAE,KAAK;YAAE,SAAS,EAAE,MAAM;QAAA,CAAE,CAAC,CAAA;QACnE,IAAI,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAA;QAC9C,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;OAGG,CACH,QAAQ,CAAC,MAAc,EAAE,UAA0B,EAAA;QAC/C,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC;YAAE,IAAI,EAAE,IAAI;YAAE,SAAS,EAAE,MAAM;QAAA,CAAE,CAAC,CAAA;QAClE,IAAI,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAA;QAC9C,OAAO,IAAI,CAAA;IACf,CAAC;IAgBD;;;;OAIG,CACH,OAAO,CAAC,OAAgB,EAAA;QACpB,IAAI,OAAO,EAAE,CAAC;YACV,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG;gBAAC,OAAO;aAAC,CAAA;QAC3C,CAAC,MAAM,CAAC;YACJ,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,EAAE,CAAA;QACpC,CAAC;QACD,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,UAAU,CAAC,OAAe,EAAA;QACtB,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;QACzC,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,eAAe,CAAC,YAA+B,EAAA;QAC3C,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,aAAa,EAAE,CAAC;YACxD,IAAI,YAAY,KAAK,SAAS,EAAE,CAAC;gBAC7B,IAAI,CAAC,aAAa,CAAC,UAAU,GAAG,2BAA2B,CAAA;YAC/D,CAAC,MAAM,CAAC;gBACJ,IAAI,CAAC,aAAa,CAAC,UAAU,GAAG,YAAY,CAAA;YAChD,CAAC;QACL,CAAC;QAED,OAAO,IAAI,CAAA;IACf,CAAC;IA6BD;;;;OAIG,CACH,OAAO,CACH,IAAgC,EAChC,QAAwB,KAAK,EAC7B,KAAoC,EAAA;QAEpC,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,KAAK,MAAM,EAC1D,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,8EAAA,CAAgF,CACnF,CAAA;QACL,IACI,KAAK,KAAK,SAAS,IACnB,KAAK,KAAK,aAAa,IACvB,KAAK,KAAK,YAAY,EAEtB,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,4FAAA,CAA8F,CACjG,CAAA;QAEL,IAAI,IAAI,EAAE,CAAC;YACP,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,CAAC;gBAC3B,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,IAAwB,CAAA;YAC1D,CAAC,MAAM,CAAC;gBACJ,IAAI,KAAK,EAAE,CAAC;oBACR,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG;wBAC1B,CAAC,IAAc,CAAC,EAAE;4BAAE,KAAK;4BAAE,KAAK;wBAAA,CAAE;qBACrC,CAAA;gBACL,CAAC,MAAM,CAAC;oBACJ,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG;wBAAE,CAAC,IAAc,CAAC,EAAE,KAAK;oBAAA,CAAE,CAAA;gBAC7D,CAAC;YACL,CAAC;QACL,CAAC,MAAM,CAAC;YACJ,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,CAAA,CAAE,CAAA;QACpC,CAAC;QACD,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,UAAU,CACN,IAAY,EACZ,QAAwB,KAAK,EAC7B,KAAoC,EAAA;QAEpC,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,KAAK,MAAM,EAC1D,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,8EAAA,CAAgF,CACnF,CAAA;QACL,IACI,KAAK,KAAK,SAAS,IACnB,KAAK,KAAK,aAAa,IACvB,KAAK,KAAK,YAAY,EAEtB,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,4FAAA,CAA8F,CACjG,CAAA;QAEL,IAAI,KAAK,EAAE,CAAC;YACR,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG;gBAAE,KAAK;gBAAE,KAAK;YAAA,CAAE,CAAA;QACxD,CAAC,MAAM,CAAC;YACJ,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,KAAK,CAAA;QAC7C,CAAC;QACD,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;;;OAKG,CACH,KAAK,CAAC,KAAc,EAAA;QAChB,IAAI,CAAC,aAAa,CAAC,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAA;QACtD,IACI,IAAI,CAAC,aAAa,CAAC,KAAK,KAAK,SAAS,IACtC,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,EAE/B,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,uEAAA,CAAyE,CAC5E,CAAA;QAEL,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;;;OAKG,CACH,MAAM,CAAC,MAAe,EAAA;QAClB,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAA;QACxD,IACI,IAAI,CAAC,aAAa,CAAC,MAAM,KAAK,SAAS,IACvC,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,EAEhC,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,wEAAA,CAA0E,CAC7E,CAAA;QAEL,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,IAAI,CAAC,IAAa,EAAA;QACd,IAAI,CAAC,aAAa,CAAC,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAA;QACpD,IACI,IAAI,CAAC,aAAa,CAAC,IAAI,KAAK,SAAS,IACrC,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAE9B,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,sEAAA,CAAwE,CAC3E,CAAA;QAEL,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,IAAI,CAAC,IAAa,EAAA;QACd,IAAI,CAAC,aAAa,CAAC,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAA;QACpD,IACI,IAAI,CAAC,aAAa,CAAC,IAAI,KAAK,SAAS,IACrC,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAE9B,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,sEAAA,CAAwE,CAC3E,CAAA;QAEL,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;;;OAIG,CACH,QAAQ,CAAC,KAAa,EAAA;QAClB,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,KAAK,CAAA;QAEnC,OAAO,IAAI,CAAA;IACf,CAAC;IA6BD;;OAEG,CACH,OAAO,CACH,QAcqB,EACrB,WAA2B,EAC3B,UAAqB,EAAA;QAErB,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,QAAQ,CAAA;QACtC,IAAI,CAAC,aAAa,CAAC,WAAW,GAAG,WAAW,CAAA;QAC5C,IAAI,CAAC,aAAa,CAAC,UAAU,GAAG,UAAU,CAAA;QAC1C,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,WAAW,CAAC,QAAkC,EAAA;QAC1C,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,QAAQ,CAAA;QACtC,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,WAAW,GAAA;QACP,IAAI,CAAC,aAAa,CAAC,WAAW,GAAG,IAAI,CAAA;QACrC,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,KAAK,CAAC,SAAS,GAAA;QACX,OAAO,CAAC,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAA;IACvC,CAAC;IAED;;OAEG,CACH,KAAK,CAAC,UAAU,GAAA;QACZ,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,YAAY,EAC5C,MAAM,IAAI,kCAAA,+BAA+B,EAAE,CAAA;QAE/C,IAAI,CAAC,aAAa,CAAC,WAAW,GAAG,KAAK,CAAA;QACtC,MAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAA;QAC5C,IAAI,sBAAsB,GAAY,KAAK,CAAA;QAC3C,IAAI,CAAC;YACD,sCAAsC;YACtC,IACI,IAAI,CAAC,aAAa,CAAC,cAAc,KAAK,IAAI,IAC1C,WAAW,CAAC,mBAAmB,KAAK,KAAK,EAC3C,CAAC;gBACC,MAAM,WAAW,CAAC,gBAAgB,EAAE,CAAA;gBACpC,sBAAsB,GAAG,IAAI,CAAA;YACjC,CAAC;YAED,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;YAEtD,qCAAqC;YACrC,IAAI,sBAAsB,EAAE,CAAC;gBACzB,MAAM,WAAW,CAAC,iBAAiB,EAAE,CAAA;YACzC,CAAC;YAED,OAAO,OAAO,CAAA;QAClB,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;YACb,wCAAwC;YACxC,IAAI,sBAAsB,EAAE,CAAC;gBACzB,IAAI,CAAC;oBACD,MAAM,WAAW,CAAC,mBAAmB,EAAE,CAAA;gBAC3C,CAAC,CAAC,OAAO,aAAa,EAAE,CAAC,CAAC;YAC9B,CAAC;YACD,MAAM,KAAK,CAAA;QACf,CAAC,QAAS,CAAC;YACP,IAAI,WAAW,KAAK,IAAI,CAAC,WAAW,EAAE,CAAC;gBACnC,wCAAwC;gBACxC,MAAM,WAAW,CAAC,OAAO,EAAE,CAAA;YAC/B,CAAC;QACL,CAAC;IACL,CAAC;IAED;;OAEG,CACH,KAAK,CAAC,iBAAiB,GAAA;QAInB,MAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAA;QAC5C,IAAI,sBAAsB,GAAY,KAAK,CAAA;QAC3C,IAAI,CAAC;YACD,sCAAsC;YACtC,IACI,IAAI,CAAC,aAAa,CAAC,cAAc,KAAK,IAAI,IAC1C,WAAW,CAAC,mBAAmB,KAAK,KAAK,EAC3C,CAAC;gBACC,MAAM,WAAW,CAAC,gBAAgB,EAAE,CAAA;gBACpC,sBAAsB,GAAG,IAAI,CAAA;YACjC,CAAC;YAED,IAAI,CAAC,aAAa,CAAC,WAAW,GAAG,IAAI,CAAA;YACrC,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,4BAA4B,CAAC,WAAW,CAAC,CAAA;YAEpE,qCAAqC;YACrC,IAAI,sBAAsB,EAAE,CAAC;gBACzB,MAAM,WAAW,CAAC,iBAAiB,EAAE,CAAA;YACzC,CAAC;YAED,OAAO,OAAO,CAAA;QAClB,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;YACb,wCAAwC;YACxC,IAAI,sBAAsB,EAAE,CAAC;gBACzB,IAAI,CAAC;oBACD,MAAM,WAAW,CAAC,mBAAmB,EAAE,CAAA;gBAC3C,CAAC,CAAC,OAAO,aAAa,EAAE,CAAC,CAAC;YAC9B,CAAC;YACD,MAAM,KAAK,CAAA;QACf,CAAC,QAAS,CAAC;YACP,IAAI,WAAW,KAAK,IAAI,CAAC,WAAW,EAChC,wCAAwC;YACxC,MAAM,WAAW,CAAC,OAAO,EAAE,CAAA;QACnC,CAAC;IACL,CAAC;IAED;;OAEG,CACH,KAAK,CAAC,MAAM,GAAA;QACR,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAA;QAC9C,MAAM,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAQ,CAAA;QAEzC,IACI,MAAM,IACN,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,YAAY,IAC5C,IAAI,CAAC,aAAa,CAAC,WAAW,EAChC,CAAC;YACC,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,CAAA;YAEvD,IAAI,IAAI,CAAC,aAAa,CAAC,WAAW,YAAY,IAAI,EAAE,CAAC;gBACjD,MAAM,aAAa,GACf,QAAQ,CAAC,gBAAiB,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA,CAAC,6BAA6B;gBACnF,IACI,aAAa,CAAC,OAAO,EAAE,KACvB,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,OAAO,EAAE,EAExC,MAAM,IAAI,qCAAA,kCAAkC,CACxC,QAAQ,CAAC,IAAI,EACb,IAAI,CAAC,aAAa,CAAC,WAAW,EAC9B,aAAa,CAChB,CAAA;YACT,CAAC,MAAM,CAAC;gBACJ,MAAM,aAAa,GACf,QAAQ,CAAC,aAAc,CAAC,cAAc,CAAC,MAAM,CAAC,CAAA,CAAC,6BAA6B;gBAChF,IAAI,aAAa,KAAK,IAAI,CAAC,aAAa,CAAC,WAAW,EAChD,MAAM,IAAI,qCAAA,kCAAkC,CACxC,QAAQ,CAAC,IAAI,EACb,IAAI,CAAC,aAAa,CAAC,WAAW,EAC9B,aAAa,CAChB,CAAA;YACT,CAAC;QACL,CAAC;QAED,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;YACvB,OAAO,IAAI,CAAA;QACf,CAAC;QACD,OAAO,MAAM,CAAA;IACjB,CAAC;IAED;;OAEG,CACH,KAAK,CAAC,YAAY,GAAA;QACd,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,EAAE,CAAA;QAElC,IAAI,CAAC,MAAM,EAAE,CAAC;YACV,MAAM,IAAI,sBAAA,mBAAmB,CACzB,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,MAAM,EACpC,IAAI,CAAC,aAAa,CAAC,UAAU,CAChC,CAAA;QACL,CAAC;QAED,OAAO,MAAM,CAAA;IACjB,CAAC;IAED;;OAEG,CACH,KAAK,CAAC,OAAO,GAAA;QACT,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,YAAY,EAC5C,MAAM,IAAI,kCAAA,+BAA+B,EAAE,CAAA;QAE/C,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAA;QAC9C,OAAO,OAAO,CAAC,QAAQ,CAAA;IAC3B,CAAC;IAED;;;OAGG,CACH,KAAK,CAAC,QAAQ,GAAA;QACV,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,YAAY,EAC5C,MAAM,IAAI,kCAAA,+BAA+B,EAAE,CAAA;QAE/C,MAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAA;QAC5C,IAAI,sBAAsB,GAAY,KAAK,CAAA;QAC3C,IAAI,CAAC;YACD,sCAAsC;YACtC,IACI,IAAI,CAAC,aAAa,CAAC,cAAc,KAAK,IAAI,IAC1C,WAAW,CAAC,mBAAmB,KAAK,KAAK,EAC3C,CAAC;gBACC,MAAM,WAAW,CAAC,gBAAgB,EAAE,CAAA;gBACpC,sBAAsB,GAAG,IAAI,CAAA;YACjC,CAAC;YAED,IAAI,CAAC,aAAa,CAAC,WAAW,GAAG,KAAK,CAAA;YACtC,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAA;YAEzD,qCAAqC;YACrC,IAAI,sBAAsB,EAAE,CAAC;gBACzB,MAAM,WAAW,CAAC,iBAAiB,EAAE,CAAA;YACzC,CAAC;YAED,OAAO,OAAO,CAAA;QAClB,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;YACb,wCAAwC;YACxC,IAAI,sBAAsB,EAAE,CAAC;gBACzB,IAAI,CAAC;oBACD,MAAM,WAAW,CAAC,mBAAmB,EAAE,CAAA;gBAC3C,CAAC,CAAC,OAAO,aAAa,EAAE,CAAC,CAAC;YAC9B,CAAC;YACD,MAAM,KAAK,CAAA;QACf,CAAC,QAAS,CAAC;YACP,IAAI,WAAW,KAAK,IAAI,CAAC,WAAW,EAChC,wCAAwC;YACxC,MAAM,WAAW,CAAC,OAAO,EAAE,CAAA;QACnC,CAAC;IACL,CAAC;IAED;;;OAGG,CACH,KAAK,CAAC,SAAS,GAAA;QACX,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,YAAY,EAC5C,MAAM,IAAI,kCAAA,+BAA+B,EAAE,CAAA;QAE/C,MAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAA;QAC5C,IAAI,sBAAsB,GAAY,KAAK,CAAA;QAC3C,IAAI,CAAC;YACD,sCAAsC;YACtC,IACI,IAAI,CAAC,aAAa,CAAC,cAAc,KAAK,IAAI,IAC1C,WAAW,CAAC,mBAAmB,KAAK,KAAK,EAC3C,CAAC;gBACC,MAAM,WAAW,CAAC,gBAAgB,EAAE,CAAA;gBACpC,sBAAsB,GAAG,IAAI,CAAA;YACjC,CAAC;YAED,IAAI,CAAC,aAAa,CAAC,WAAW,GAAG,KAAK,CAAA;YACtC,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAA;YAE1D,qCAAqC;YACrC,IAAI,sBAAsB,EAAE,CAAC;gBACzB,MAAM,WAAW,CAAC,iBAAiB,EAAE,CAAA;YACzC,CAAC;YAED,OAAO,OAAO,CAAA;QAClB,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;YACb,wCAAwC;YACxC,IAAI,sBAAsB,EAAE,CAAC;gBACzB,IAAI,CAAC;oBACD,MAAM,WAAW,CAAC,mBAAmB,EAAE,CAAA;gBAC3C,CAAC,CAAC,OAAO,aAAa,EAAE,CAAC,CAAC;YAC9B,CAAC;YACD,MAAM,KAAK,CAAA;QACf,CAAC,QAAS,CAAC;YACP,IAAI,WAAW,KAAK,IAAI,CAAC,WAAW,EAChC,wCAAwC;YACxC,MAAM,WAAW,CAAC,OAAO,EAAE,CAAA;QACnC,CAAC;IACL,CAAC;IAED;;;OAGG,CACH,KAAK,CAAC,eAAe,GAAA;QACjB,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,YAAY,EAC5C,MAAM,IAAI,kCAAA,+BAA+B,EAAE,CAAA;QAE/C,MAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAA;QAC5C,IAAI,sBAAsB,GAAY,KAAK,CAAA;QAC3C,IAAI,CAAC;YACD,sCAAsC;YACtC,IACI,IAAI,CAAC,aAAa,CAAC,cAAc,KAAK,IAAI,IAC1C,WAAW,CAAC,mBAAmB,KAAK,KAAK,EAC3C,CAAC;gBACC,MAAM,WAAW,CAAC,gBAAgB,EAAE,CAAA;gBACpC,sBAAsB,GAAG,IAAI,CAAA;YACjC,CAAC;YAED,IAAI,CAAC,aAAa,CAAC,WAAW,GAAG,IAAI,CAAA;YACrC,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,4BAA4B,CAC1D,WAAW,CACd,CAAA;YACD,IAAI,CAAC,aAAa,CAAC,WAAW,GAAG,KAAK,CAAA;YACtC,MAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAA;YAC1C,yFAAyF;YACzF,2BAA2B;YAC3B,IAAI,CAAC,aAAa,CAAC,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,GAAG,OAAO,CAAA,MAAA,CAAQ,CAAC,CAAC,CAAC,OAAO,CAAA;YACnE,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAA;YACvD,MAAM,OAAO,GAAuB;gBAAC,cAAc,CAAC,QAAQ;gBAAE,KAAK;aAAC,CAAA;YAEpE,qCAAqC;YACrC,IAAI,sBAAsB,EAAE,CAAC;gBACzB,MAAM,WAAW,CAAC,iBAAiB,EAAE,CAAA;YACzC,CAAC;YAED,OAAO,OAAO,CAAA;QAClB,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;YACb,wCAAwC;YACxC,IAAI,sBAAsB,EAAE,CAAC;gBACzB,IAAI,CAAC;oBACD,MAAM,WAAW,CAAC,mBAAmB,EAAE,CAAA;gBAC3C,CAAC,CAAC,OAAO,aAAa,EAAE,CAAC,CAAC;YAC9B,CAAC;YACD,MAAM,KAAK,CAAA;QACf,CAAC,QAAS,CAAC;YACP,IAAI,WAAW,KAAK,IAAI,CAAC,WAAW,EAChC,wCAAwC;YACxC,MAAM,WAAW,CAAC,OAAO,EAAE,CAAA;QACnC,CAAC;IACL,CAAC;IAED;;OAEG,CACH,KAAK,CAAC,MAAM,GAAA;QACR,IAAI,CAAC,aAAa,CAAC,WAAW,GAAG,KAAK,CAAA;QACtC,MAAM,CAAC,GAAG,EAAE,UAAU,CAAC,GAAG,IAAI,CAAC,qBAAqB,EAAE,CAAA;QACtD,MAAM,WAAW,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAA;QAC5C,IAAI,sBAAsB,GAAY,KAAK,CAAA;QAC3C,IAAI,CAAC;YACD,sCAAsC;YACtC,IACI,IAAI,CAAC,aAAa,CAAC,cAAc,KAAK,IAAI,IAC1C,WAAW,CAAC,mBAAmB,KAAK,KAAK,EAC3C,CAAC;gBACC,MAAM,WAAW,CAAC,gBAAgB,EAAE,CAAA;gBACpC,sBAAsB,GAAG,IAAI,CAAA;YACjC,CAAC;YAED,MAAM,SAAS,GAAG,GAAG,EAAE;gBACnB,IAAI,WAAW,KAAK,IAAI,CAAC,WAAW,EAChC,wCAAwC;gBACxC,OAAO,WAAW,CAAC,OAAO,EAAE,CAAA;gBAChC,OAAM;YACV,CAAC,CAAA;YACD,MAAM,OAAO,GAAG,WAAW,CAAC,MAAM,CAC9B,GAAG,EACH,UAAU,EACV,SAAS,EACT,SAAS,CACZ,CAAA;YAED,qCAAqC;YACrC,IAAI,sBAAsB,EAAE,CAAC;gBACzB,MAAM,WAAW,CAAC,iBAAiB,EAAE,CAAA;YACzC,CAAC;YAED,OAAO,OAAO,CAAA;QAClB,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;YACb,wCAAwC;YACxC,IAAI,sBAAsB,EAAE,CAAC;gBACzB,IAAI,CAAC;oBACD,MAAM,WAAW,CAAC,mBAAmB,EAAE,CAAA;gBAC3C,CAAC,CAAC,OAAO,aAAa,EAAE,CAAC,CAAC;YAC9B,CAAC;YACD,MAAM,KAAK,CAAA;QACf,CAAC;IACL,CAAC;IAkBD;;OAEG,CACH,KAAK,CACD,yBAAoD,EACpD,iBAA0B,EAAA;QAE1B,IAAI,OAAO,yBAAyB,KAAK,SAAS,EAAE,CAAC;YACjD,IAAI,CAAC,aAAa,CAAC,KAAK,GAAG,yBAAyB,CAAA;QACxD,CAAC,MAAM,IAAI,OAAO,yBAAyB,KAAK,QAAQ,EAAE,CAAC;YACvD,IAAI,CAAC,aAAa,CAAC,KAAK,GAAG,IAAI,CAAA;YAC/B,IAAI,CAAC,aAAa,CAAC,aAAa,GAAG,yBAAyB,CAAA;QAChE,CAAC,MAAM,IACH,OAAO,yBAAyB,KAAK,QAAQ,IAC7C,OAAO,yBAAyB,KAAK,QAAQ,EAC/C,CAAC;YACC,IAAI,CAAC,aAAa,CAAC,KAAK,GAAG,IAAI,CAAA;YAC/B,IAAI,CAAC,aAAa,CAAC,OAAO,GAAG,yBAAyB,CAAA;QAC1D,CAAC;QAED,IAAI,iBAAiB,EAAE,CAAC;YACpB,IAAI,CAAC,aAAa,CAAC,aAAa,GAAG,iBAAiB,CAAA;QACxD,CAAC;QAED,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACH,SAAS,CAAC,MAAgC,EAAA;QACtC,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QACvC,OAAO,IAAI,CAAA;IACf,CAAC;IAED,4EAA4E;IAC5E,oBAAoB;IACpB,4EAA4E;IAElE,IAAI,CACV,SAA2B,EAC3B,gBAGgE,EAChE,SAAiB,EACjB,SAAkB,EAClB,UAA0B,EAC1B,aAAsB,EACtB,aAAuB,EACvB,WAA+B,EAAA;QAE/B,IAAI,UAAU,EAAE,CAAC;YACb,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAA;QAClC,CAAC;QAED,MAAM,aAAa,GAAG,IAAI,gBAAA,aAAa,CACnC,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,aAAa,CACrB,CAAA;QACD,aAAa,CAAC,SAAS,GAAG,SAAS,CAAA;QACnC,aAAa,CAAC,WAAW,GAAG,WAAW,CAAA;QACvC,aAAa,CAAC,aAAa,GAAG,aAAa,CAAA;QAC3C,aAAa,CAAC,aAAa,GAAG,aAAa,CAAA;QAC3C,aAAa,CAAC,gBAAgB,GAAG,gBAAgB,CAAA,CAAC,eAAe;QACjE,aAAa,CAAC,SAAS,GAAG,SAAS,CAAA,CAAC,2BAA2B;QAC/D,yJAAyJ;QACzJ,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,IAAI,CAAC,aAAa,CAAC,CAAA;QAErD,MAAM,qBAAqB,GAAG,aAAa,CAAC,QAAQ,CAAA;QACpD,IAAI,qBAAqB,EAAE,CAAC;YACxB,IACI,qBAAqB,CAAC,gBAAgB,IACtC,CAAC,IAAI,CAAC,aAAa,CAAC,WAAW,EACjC,CAAC;gBACC,MAAM,qBAAqB,GAAG,GAAG,SAAS,CAAA,CAAA,EAAI,qBAAqB,CAAC,gBAAgB,CAAC,YAAY,CAAA,QAAA,CAAU,CAAA;gBAC3G,aAAa,CAAC,SAAS,GAAG,aAAa,CAAC,SAAS,GAC3C,CAAA,CAAA,EAAI,aAAa,CAAC,SAAS,CAAA,KAAA,EAAQ,qBAAqB,EAAE,GAC1D,GAAG,qBAAqB,EAAE,CAAA;YACpC,CAAC;YACD,2CAA2C;YAC3C,aAAa,CAAC,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;gBACjD,IAAI,EAAE,MAAM;gBACZ,IAAI,EAAE,SAAS;gBACf,QAAQ,EAAE,qBAAqB;aAClC,CAAC,CAAA;YACF,IACI,aAAa,CAAC,QAAQ,IACtB,aAAa,CAAC,QAAQ,CAAC,sBAAsB,EAC/C,CAAC;gBACC,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;oBAC3B,IAAI,EAAE,MAAM;oBACZ,IAAI,EAAE,aAAa,CAAC,aAAa;oBACjC,QAAQ,EAAE,aAAa,CAAC,QAAQ,CAAC,sBAAsB;iBAC1D,CAAC,CAAA;YACN,CAAC;QACL,CAAC,MAAM,CAAC;YACJ,IAAI,QAAQ,GAAW,EAAE,CAAA;YACzB,IAAI,OAAO,gBAAgB,KAAK,UAAU,EAAE,CAAC;gBACzC,MAAM,eAAe,GACjB,gBACH,CAAE,IAAuC,CAAC,QAAQ,EAAE,CAAC,CAAA;gBACtD,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,aAAa,EAAE,CAAC,CAAA;gBACnD,QAAQ,GAAG,eAAe,CAAC,QAAQ,EAAE,CAAA;YACzC,CAAC,MAAM,CAAC;gBACJ,QAAQ,GAAG,gBAAgB,CAAA;YAC/B,CAAC;YACD,MAAM,UAAU,GACZ,OAAO,gBAAgB,KAAK,UAAU,IACrC,gBAAgB,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,IAClC,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAA;YAC5C,aAAa,CAAC,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;gBACjD,IAAI,EAAE,MAAM;gBACZ,IAAI,EAAE,SAAS;gBACf,SAAS,EACL,UAAU,KAAK,KAAK,GACb,gBAA2B,GAC5B,SAAS;gBACnB,QAAQ,EAAE,UAAU,KAAK,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS;aACvD,CAAC,CAAA;QACN,CAAC;IACL,CAAC;IAED;;OAEG,CACO,sBAAsB,GAAA;QAC5B,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,EAC7B,MAAM,IAAI,QAAA,YAAY,CAClB,wEAAwE,CAC3E,CAAA;QAEL,qDAAqD;QAErD,MAAM,UAAU,GAAkB,EAAE,CAAA;QACpC,MAAM,eAAe,GAAkB,EAAE,CAAA;QAEzC,IAAI,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;YAC3C,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAA;YACtD,UAAU,CAAC,IAAI,CACX,GAAG,IAAI,CAAC,+BAA+B,CACnC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI,EACjC,QAAQ,CACX,CACJ,CAAA;YACD,eAAe,CAAC,IAAI,CAChB,GAAG,IAAI,CAAC,uBAAuB,CAC3B,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI,EACjC,QAAQ,CACX,CACJ,CAAA;QACL,CAAC;QAED,yBAAyB;QACzB,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YAC/C,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAChB,UAAU,CAAC,IAAI,CACX,GAAG,IAAI,CAAC,+BAA+B,CACnC,IAAI,CAAC,KAAK,CAAC,IAAK,EAChB,IAAI,CAAC,QAAQ,CAChB,CACJ,CAAA;gBACD,eAAe,CAAC,IAAI,CAChB,GAAG,IAAI,CAAC,uBAAuB,CAC3B,IAAI,CAAC,KAAK,CAAC,IAAK,EAChB,IAAI,CAAC,QAAQ,CAChB,CACJ,CAAA;YACL,CAAC,MAAM,CAAC;gBACJ,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAChD,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,SAAS,KAAK,IAAI,CAAC,KAAK,CAAC,IAAI,CACnD,CAAA;gBACD,IAAI,YAAY,EAAE,CAAC;oBACf,UAAU,CAAC,IAAI,CAAC;wBACZ,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAK,CAAC,GAAG,IAAI;qBAClD,CAAC,CAAA;oBACF,MAAM,cAAc,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAClD,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,SAAS,KAAK,IAAI,CAAC,KAAK,CAAC,IAAI,CACnD,CAAA;oBACD,eAAe,CAAC,IAAI,CAAC,cAAe,CAAC,CAAA;gBACzC,CAAC;YACL,CAAC;QACL,CAAC,CAAC,CAAA;QAEF,wBAAwB;QACxB,IAAI,CAAC,aAAa,CAAC,OAAO,CACrB,MAAM,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,cAAgB,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAC1D,OAAO,CAAC,CAAC,MAAM,EAAE,CACd,CADgB,SACN,CAAC,IAAI,CAAC;gBACZ,SAAS,EAAE,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,SAAS,CAAC;gBACtD,SAAS,EAAE,MAAM,CAAC,SAAS;aAC9B,CAAC,CACL,CAAA;QAEL,6DAA6D;QAC7D,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC;YAAE,SAAS,EAAE,GAAG;QAAA,CAAE,CAAC,CAAA;QAEhE,oBAAoB;QACpB,IAAI,QAAQ,GAAW,EAAE,CAAA;QACzB,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC;YAC9B,IAAI,cAAA,WAAW,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE,CAAC;gBACpD,QAAQ,GAAG,CAAA,YAAA,EAAe,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAA,CAAA,CAAG,CAAA;YAC5D,CAAC;QACL,CAAC;QAED,2BAA2B;QAC3B,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CACnC,MAAM,CACH,CAAC,KAAK,EAAE,CACJ,CADM,IACD,CAAC,IAAI,KAAK,MAAM,IACrB,CAAC,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,QAAQ,CAAC,CAC1C,CACA,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;YACX,IAAI,KAAK,CAAC,QAAQ,EACd,OAAO,KAAK,CAAC,QAAQ,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;YAEzD,OAAO,AACH,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,SAAU,CAAC,GACnC,GAAG,GACH,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAC1B,CAAA;QACL,CAAC,CAAC,CAAA;QAEN,MAAM,MAAM,GAAG,IAAI,CAAC,8BAA8B,EAAE,CAAA;QACpD,MAAM,SAAS,GAAG,UAAU,CACvB,GAAG,CACA,CAAC,MAAM,EAAE,CACL,CADO,KACD,CAAC,SAAS,GAChB,CAAC,MAAM,CAAC,SAAS,GACX,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,GACtC,EAAE,CAAC,CAChB,CACA,IAAI,CAAC,IAAI,CAAC,CAAA;QAEf,OAAO,AACH,MAAM,GACN,SAAS,GACT,QAAQ,GACR,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAChB,IAAI,CAAC,yBAAyB,EAAE,GAChC,QAAQ,CACX,CAAA;IACL,CAAC;IAED;;OAEG,CACO,8BAA8B,GAAA;QACpC,MAAM,EAAE,cAAc,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,GACxD,IAAI,CAAC,aAAa,CAAA;QACtB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,UAAU,CAAA;QAElC,IAAI,MAAM,GAAG,SAAS,CAAA;QAEtB,IAAI,gBAAgB,GAAG,CAAC,EAAE,CAAC;YACvB,IAAI,cAAA,WAAW,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC;gBACpC,MAAM,IAAI,CAAA,uBAAA,EAA0B,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAA,KAAA,CAAO,CAAA;YAClF,CAAC;QACL,CAAC;QAED,IACI,cAAA,WAAW,CAAC,gBAAgB,CAAC,MAAM,CAAC,IACpC,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAC7B,CAAC;YACC,MAAM,mBAAmB,GAAG,gBAAgB,CACvC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAG,CAAD,GAAK,CAAC,oBAAoB,CAAC,EAAE,CAAC,CAAC,CAC1C,IAAI,CAAC,IAAI,CAAC,CAAA;YAEf,MAAM,GAAG,CAAA,oBAAA,EAAuB,mBAAmB,CAAA,EAAA,CAAI,CAAA;QAC3D,CAAC,MAAM,IAAI,cAAc,EAAE,CAAC;YACxB,MAAM,GAAG,kBAAkB,CAAA;QAC/B,CAAC;QAED,OAAO,MAAM,CAAA;IACjB,CAAC;IAED;;OAEG,CACO,oBAAoB,GAAA;QAC1B,YAAY;QACZ,0BAA0B;QAC1B,oBAAoB;QACpB,uDAAuD;QACvD,8BAA8B;QAC9B,wBAAwB;QACxB,mDAAmD;QAEnD,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE;YAC7D,MAAM,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAA;YAClC,MAAM,oBAAoB,GAAG,QAAQ,CAAC,SAAS,CAAA;YAC/C,MAAM,qBAAqB,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAA;YACjD,IAAI,iBAAiB,GAAG,QAAQ,CAAC,SAAS,GACpC,QAAQ,GAAG,QAAQ,CAAC,SAAS,GAAG,GAAG,GACnC,EAAE,CAAA;YACR,MAAM,WAAW,GAAG,QAAQ,CAAC,WAAW,CAAA;YAExC,sGAAsG;YACtG,0FAA0F;YAC1F,IAAI,CAAC,WAAW,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAC5B,MAAM,eAAe,GAAG,QAAQ,CAAC,KAAK,CAAC,QAAQ,GACzC,QAAQ,CAAC,KAAK,CAAC,QAAQ,GACvB,IAAI,CAAC,YAAY,CAAC,oBAAoB,CAAC,CAAA;gBAC7C,OAAO,AACH,GAAG,GACH,QAAQ,CAAC,SAAS,GAClB,QAAQ,GACR,eAAe,GACf,GAAG,GACH,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,GAClC,IAAI,CAAC,yBAAyB,EAAE,GAChC,CAAC,QAAQ,CAAC,SAAS,GACb,MAAM,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,SAAS,CAAC,GACtD,EAAE,CAAC,CACZ,CAAA;YACL,CAAC;YAED,sCAAsC;YACtC,IAAI,QAAQ,CAAC,WAAW,IAAI,QAAQ,CAAC,eAAe,EAAE,CAAC;gBACnD,sEAAsE;gBACtE,MAAM,SAAS,GAAG,QAAQ,CAAC,WAAW,CACjC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE;oBAChB,OAAO,AACH,qBAAqB,GACrB,GAAG,GACH,UAAU,CAAC,gBAAiB,CAAC,YAAY,GACzC,GAAG,GACH,WAAW,GACX,GAAG,GACH,QAAQ,CAAC,YAAY,GACrB,GAAG,GACH,UAAU,CAAC,gBAAiB,CAAC,YAAY,CAC5C,CAAA;gBACL,CAAC,CAAC,CACD,IAAI,CAAC,OAAO,CAAC,CAAA;gBAElB,OACI,AADG,GACA,GACH,QAAQ,CAAC,SAAS,GAClB,QAAQ,GACR,IAAI,CAAC,YAAY,CAAC,oBAAoB,CAAC,GACvC,GAAG,GACH,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,GAClC,IAAI,CAAC,yBAAyB,EAAE,GAChC,MAAM,GACN,IAAI,CAAC,oBAAoB,CAAC,SAAS,GAAG,iBAAiB,CAAC,CAC3D,CAAA;YACL,CAAC,MAAM,IAAI,QAAQ,CAAC,WAAW,IAAI,QAAQ,CAAC,kBAAkB,EAAE,CAAC;gBAC7D,8DAA8D;gBAC9D,MAAM,SAAS,GAAG,QAAQ,CACrB,eAAgB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE;oBAC7C,IACI,QAAQ,CAAC,qBAAqB,CAAC,SAAS,KACpC,cAAc,IAClB,QAAQ,CAAC,qBAAqB,CAAC,mBAAmB,EACpD,CAAC;wBACC,iBAAiB,IACb,OAAO,GACP,qBAAqB,GACrB,GAAG,GACH,QAAQ,CAAC,qBAAqB,CACzB,mBAAmB,CAAC,YAAY,GACrC,IAAI,GACJ,QAAQ,CAAC,qBAAqB,CACzB,kBAAkB,GACvB,GAAG,CAAA;oBACX,CAAC;oBAED,OAAO,AACH,qBAAqB,GACrB,GAAG,GACH,QAAQ,CAAC,eAAgB,CAAC,YAAY,GACtC,GAAG,GACH,UAAU,CAAC,gBAAiB,CAAC,YAAY,GACzC,GAAG,GACH,WAAW,GACX,GAAG,GACH,UAAU,CAAC,gBAAiB,CAAC,YAAY,CAC5C,CAAA;gBACL,CAAC,CAAC,CACD,IAAI,CAAC,OAAO,CAAC,CAAA;gBAElB,IAAI,CAAC,SAAS,EACV,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,SAAA,EAAY,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAA,CAAA,EAAI,QAAQ,CAAC,YAAY,CAAA,4BAAA,CAA8B,CAClG,CAAA;gBAEL,OAAO,AACH,GAAG,GACH,QAAQ,CAAC,SAAS,GAClB,QAAQ,GACR,IAAI,CAAC,YAAY,CAAC,oBAAoB,CAAC,GACvC,GAAG,GACH,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,GAClC,IAAI,CAAC,yBAAyB,EAAE,GAChC,MAAM,GACN,IAAI,CAAC,oBAAoB,CAAC,SAAS,GAAG,iBAAiB,CAAC,CAC3D,CAAA;YACL,CAAC,MAAM,CAAC;gBACJ,qBAAqB;gBACrB,MAAM,iBAAiB,GACnB,QAAQ,CAAC,sBAAuB,CAAC,SAAS,CAAA;gBAE9C,MAAM,aAAa,GAAG,QAAQ,CAAC,aAAa,CAAA;gBAC5C,IAAI,iBAAiB,GAAG,EAAE,EACtB,oBAAoB,GAAG,EAAE,CAAA;gBAE7B,IAAI,QAAQ,CAAC,QAAQ,EAAE,CAAC;oBACpB,iBAAiB,GAAG,QAAQ,CAAC,WAAW,CACnC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE;wBAChB,yCAAyC;wBACzC,OAAO,AACH,aAAa,GACb,GAAG,GACH,UAAU,CAAC,YAAY,GACvB,GAAG,GACH,WAAW,GACX,GAAG,GACH,UAAU,CAAC,gBAAiB,CAAC,YAAY,CAC5C,CAAA;oBACL,CAAC,CAAC,CACD,IAAI,CAAC,OAAO,CAAC,CAAA;oBAElB,oBAAoB,GAAG,QAAQ,CAAC,kBAAkB,CAC7C,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE;wBAChB,iDAAiD;wBACjD,OAAO,AACH,qBAAqB,GACrB,GAAG,GACH,UAAU,CAAC,gBAAiB,CAAC,YAAY,GACzC,GAAG,GACH,aAAa,GACb,GAAG,GACH,UAAU,CAAC,YAAY,CAC1B,CAAA;oBACL,CAAC,CAAC,CACD,IAAI,CAAC,OAAO,CAAC,CAAA;gBACtB,CAAC,MAAM,CAAC;oBACJ,iBAAiB,GAAG,QAAQ,CACvB,eAAgB,CAAC,kBAAkB,CAAC,GAAG,CACpC,CAAC,UAAU,EAAE,EAAE;wBACX,iDAAiD;wBACjD,OAAO,AACH,aAAa,GACb,GAAG,GACH,UAAU,CAAC,YAAY,GACvB,GAAG,GACH,WAAW,GACX,GAAG,GACH,UAAU,CAAC,gBAAiB,CAAC,YAAY,CAC5C,CAAA;oBACL,CAAC,CACJ,CACA,IAAI,CAAC,OAAO,CAAC,CAAA;oBAElB,oBAAoB,GAAG,QAAQ,CAC1B,eAAgB,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE;wBAC7C,yCAAyC;wBACzC,OAAO,AACH,qBAAqB,GACrB,GAAG,GACH,UAAU,CAAC,gBAAiB,CAAC,YAAY,GACzC,GAAG,GACH,aAAa,GACb,GAAG,GACH,UAAU,CAAC,YAAY,CAC1B,CAAA;oBACL,CAAC,CAAC,CACD,IAAI,CAAC,OAAO,CAAC,CAAA;gBACtB,CAAC;gBAED,OACI,AADG,GACA,GACH,QAAQ,CAAC,SAAS,GAClB,QAAQ,GACR,IAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,GACpC,GAAG,GACH,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,GAC1B,IAAI,CAAC,yBAAyB,EAAE,GAChC,MAAM,GACN,IAAI,CAAC,oBAAoB,CAAC,iBAAiB,CAAC,GAC5C,GAAG,GACH,QAAQ,CAAC,SAAS,GAClB,QAAQ,GACR,IAAI,CAAC,YAAY,CAAC,oBAAoB,CAAC,GACvC,GAAG,GACH,IAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC,GAClC,IAAI,CAAC,yBAAyB,EAAE,GAChC,MAAM,GACN,IAAI,CAAC,oBAAoB,CACrB,oBAAoB,GAAG,iBAAiB,CAC3C,CACJ,CAAA;YACL,CAAC;QACL,CAAC,CAAC,CAAA;QAEF,OAAO,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;IAC1B,CAAC;IAED;;OAEG,CACO,uBAAuB,GAAA;QAC7B,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,MAAM,EACnE,OAAO,EAAE,CAAA;QACb,OAAO,AACH,YAAY,GACZ,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CACpE,CAAA;IACL,CAAC;IAED;;OAEG,CACO,uBAAuB,GAAA;QAC7B,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,CAAA;QAC/C,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE,CAAA;QAEjD,OAAO,AACH,YAAY,GACZ,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAChB,GAAG,CAAC,CAAC,UAAU,EAAE,EAAE;YAChB,MAAM,UAAU,GACZ,OAAO,QAAQ,CAAC,UAAU,CAAC,KAAK,QAAQ,GAClC,QAAQ,CAAC,UAAU,CAAC,GACnB,QAAQ,CAAC,UAAU,CAAS,CAAC,KAAK,GACnC,GAAG,GACF,QAAQ,CAAC,UAAU,CAAS,CAAC,KAAK,CAAA;YAC7C,MAAM,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAC7C,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,SAAS,KAAK,UAAU,CACpC,CAAA;YACD,IACI,SAAS,IACT,CAAC,SAAS,CAAC,SAAS,IACpB,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAChC,CAAC;gBACC,MAAM,aAAa,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;gBAC3C,MAAM,SAAS,GAAG,aAAa,CAAC,CAAC,CAAC,CAAA;gBAClC,MAAM,YAAY,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;gBACrD,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CACzC,CAAC,KAAK,EAAE,CAAG,CAAD,IAAM,CAAC,IAAI,KAAK,SAAS,CACtC,CAAA;gBACD,IAAI,KAAK,EAAE,CAAC;oBACR,MAAM,MAAM,GACR,KAAK,CAAC,QAAQ,CAAC,0BAA0B,CACrC,YAAY,CACf,CAAA;oBACL,IAAI,MAAM,EAAE,CAAC;wBACT,MAAM,UAAU,GAAG,cAAA,WAAW,CAAC,UAAU,CACrC,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,SAAS,EACT,SAAS,EACT,MAAM,CAAC,YAAY,CACtB,CAAA;wBACD,OAAO,AACH,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,GAAG,GAAG,UAAU,CAC7C,CAAA;oBACL,CAAC;gBACL,CAAC;YACL,CAAC;YAED,OAAO,AACH,IAAI,CAAC,oBAAoB,CAAC,UAAU,CAAC,GAAG,GAAG,GAAG,UAAU,CAC3D,CAAA;QACL,CAAC,CAAC,CACD,IAAI,CAAC,IAAI,CAAC,CAClB,CAAA;IACL,CAAC;IAED;;OAEG,CACO,2BAA2B,GAAA;QACjC,oHAAoH;QACpH,wHAAwH;QACxH,IAAI,MAAM,GAAuB,IAAI,CAAC,aAAa,CAAC,MAAM,EACtD,KAAK,GAAuB,IAAI,CAAC,aAAa,CAAC,KAAK,CAAA;QACxD,IACI,CAAC,MAAM,IACP,CAAC,KAAK,IACN,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,MAAM,KAAK,CAAC,EAChD,CAAC;YACC,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAA;YAChC,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAA;QACnC,CAAC;QAED,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;YAClD,sFAAsF;YACtF,qFAAqF;YACrF,oFAAoF;YACpF,+EAA+E;YAC/E,yCAAyC;YACzC,IAAI,MAAM,GAAG,EAAE,CAAA;YACf,IACI,CAAC,KAAK,IAAI,MAAM,CAAC,IACjB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC,MAAM,IAAI,CAAC,EACzD,CAAC;gBACC,MAAM,GAAG,yBAAyB,CAAA;YACtC,CAAC;YAED,IAAI,KAAK,IAAI,MAAM,EACf,OAAO,AACH,MAAM,GACN,UAAU,GACV,MAAM,GACN,mBAAmB,GACnB,KAAK,GACL,YAAY,CACf,CAAA;YACL,IAAI,KAAK,EACL,OAAO,AACH,MAAM,GAAG,4BAA4B,GAAG,KAAK,GAAG,YAAY,CAC/D,CAAA;YACL,IAAI,MAAM,EAAE,OAAO,MAAM,GAAG,UAAU,GAAG,MAAM,GAAG,OAAO,CAAA;QAC7D,CAAC,MAAM,IACH,cAAA,WAAW,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IACjD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,cAAc,IACtD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,KAAK,IAC7C,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,SAAS,EACnD,CAAC;YACC,IAAI,KAAK,IAAI,MAAM,EAAE,OAAO,SAAS,GAAG,KAAK,GAAG,UAAU,GAAG,MAAM,CAAA;YACnE,IAAI,KAAK,EAAE,OAAO,SAAS,GAAG,KAAK,CAAA;YACnC,IAAI,MAAM,EAAE,MAAM,IAAI,sCAAA,mCAAmC,EAAE,CAAA;QAC/D,CAAC,MAAM,IAAI,cAAA,WAAW,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE,CAAC;YAC5D,IAAI,KAAK,IAAI,MAAM,EAAE,OAAO,SAAS,GAAG,KAAK,GAAG,UAAU,GAAG,MAAM,CAAA;YACnE,IAAI,KAAK,EAAE,OAAO,SAAS,GAAG,KAAK,CAAA;YACnC,IAAI,MAAM,EAAE,OAAO,mBAAmB,GAAG,MAAM,CAAA;QACnD,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;YAC1D,IAAI,KAAK,IAAI,MAAM,EACf,OAAO,AACH,UAAU,GACV,MAAM,GACN,mBAAmB,GACnB,KAAK,GACL,YAAY,CACf,CAAA;YACL,IAAI,KAAK,EAAE,OAAO,cAAc,GAAG,KAAK,GAAG,YAAY,CAAA;YACvD,IAAI,MAAM,EAAE,OAAO,UAAU,GAAG,MAAM,GAAG,OAAO,CAAA;QACpD,CAAC,MAAM,CAAC;YACJ,IAAI,KAAK,IAAI,MAAM,EAAE,OAAO,SAAS,GAAG,KAAK,GAAG,UAAU,GAAG,MAAM,CAAA;YACnE,IAAI,KAAK,EAAE,OAAO,SAAS,GAAG,KAAK,CAAA;YACnC,IAAI,MAAM,EAAE,OAAO,UAAU,GAAG,MAAM,CAAA;QAC1C,CAAC;QAED,OAAO,EAAE,CAAA;IACb,CAAC;IAED;;;;;;;OAOG,CACK,yBAAyB,GAAA;QAC7B,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;YAClD,OAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC;gBAClC,KAAK,kBAAkB;oBACnB,OAAO,2BAA2B,CAAA;gBACtC,KAAK,mBAAmB;oBACpB,OAAO,0BAA0B,CAAA;gBACrC,KAAK,YAAY;oBACb,OAAO,gBAAgB,CAAA;YAC/B,CAAC;QACL,CAAC;QAED,OAAO,EAAE,CAAA;IACb,CAAC;IAED;;OAEG,CACO,oBAAoB,GAAA;QAC1B,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAA;QAErC,IAAI,gBAAgB,GAAG,EAAE,CAAA;QAEzB,IAAI,IAAI,CAAC,aAAa,CAAC,UAAU,EAAE,CAAC;YAChC,IACI,CAAC,CACG,cAAA,WAAW,CAAC,gBAAgB,CAAC,MAAM,CAAC,IACpC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,aAAa,CACxC,EACH,CAAC;gBACC,MAAM,IAAI,QAAA,YAAY,CAClB,8CAA8C,CACjD,CAAA;YACL,CAAC;YACD,IAAI,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC3C,MAAM,IAAI,QAAA,YAAY,CAAC,qCAAqC,CAAC,CAAA;YACjE,CAAC;YACD,gBAAgB,GAAG,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;QACxE,CAAC;QAED,IAAI,gBAAgB,GAAG,EAAE,CAAA;QACzB,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,QAAQ,EAAE,CAAC;YAC3C,gBAAgB,GAAG,SAAS,CAAA;QAChC,CAAC,MAAM,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,aAAa,EAAE,CAAC;YACvD,gBAAgB,GAAG,cAAc,CAAA;QACrC,CAAC;QACD,OAAQ,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC;YAClC,KAAK,kBAAkB;gBACnB,IACI,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,OAAO,IAC/B,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,cAAc,EACxC,CAAC;oBACC,IACI,cAAA,WAAW,CAAC,yBAAyB,CAAC,MAAM,EAAE,OAAO,CAAC,EACxD,CAAC;wBACC,OACI,AADG,YACS,GAAG,gBAAgB,GAAG,gBAAgB,CACrD,CAAA;oBACL,CAAC,MAAM,CAAC;wBACJ,OAAO,qBAAqB,CAAA;oBAChC,CAAC;gBACL,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;oBAC3C,OAAO,qBAAqB,CAAA;gBAChC,CAAC,MAAM,IAAI,cAAA,WAAW,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAAE,CAAC;oBAC9C,OAAO,YAAY,GAAG,gBAAgB,GAAG,gBAAgB,CAAA;gBAC7D,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,QAAQ,EAAE,CAAC;oBAC1C,OAAO,aAAa,CAAA;gBACxB,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;oBACzC,OAAO,EAAE,CAAA;gBACb,CAAC,MAAM,CAAC;oBACJ,MAAM,IAAI,qCAAA,kCAAkC,EAAE,CAAA;gBAClD,CAAC;YACL,KAAK,mBAAmB;gBACpB,IACI,cAAA,WAAW,CAAC,aAAa,CAAC,MAAM,CAAC,IACjC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,cAAc,IACtC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,QAAQ,EAClC,CAAC;oBACC,OAAO,aAAa,GAAG,gBAAgB,CAAA;gBAC3C,CAAC,MAAM,IACH,cAAA,WAAW,CAAC,gBAAgB,CAAC,MAAM,CAAC,IACpC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,aAAa,EACvC,CAAC;oBACC,OAAO,aAAa,GAAG,gBAAgB,GAAG,gBAAgB,CAAA;gBAC9D,CAAC,MAAM,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;oBACzC,OAAO,EAAE,CAAA;gBACb,CAAC,MAAM,CAAC;oBACJ,MAAM,IAAI,qCAAA,kCAAkC,EAAE,CAAA;gBAClD,CAAC;YACL,KAAK,2BAA2B;gBAC5B,IAAI,cAAA,WAAW,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAAE,CAAC;oBACvC,OAAO,aAAa,GAAG,gBAAgB,GAAG,cAAc,CAAA;gBAC5D,CAAC,MAAM,IAAI,cAAA,WAAW,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC;oBAC3C,OAAO,yBAAyB,CAAA;gBACpC,CAAC,MAAM,CAAC;oBACJ,MAAM,IAAI,qCAAA,kCAAkC,EAAE,CAAA;gBAClD,CAAC;YACL,KAAK,2BAA2B;gBAC5B,IACI,cAAA,WAAW,CAAC,gBAAgB,CAAC,MAAM,CAAC,IACpC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,aAAa,EACvC,CAAC;oBACC,OAAO,aAAa,GAAG,gBAAgB,GAAG,SAAS,CAAA;gBACvD,CAAC,MAAM,IAAI,cAAA,WAAW,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC;oBAC3C,OAAO,oBAAoB,CAAA;gBAC/B,CAAC,MAAM,CAAC;oBACJ,MAAM,IAAI,qCAAA,kCAAkC,EAAE,CAAA;gBAClD,CAAC;YACL,KAAK,mBAAmB;gBACpB,IACI,cAAA,WAAW,CAAC,gBAAgB,CAAC,MAAM,CAAC,IACpC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,aAAa,EACvC,CAAC;oBACC,OAAO,AACH,oBAAoB,GACpB,gBAAgB,GAChB,gBAAgB,CACnB,CAAA;gBACL,CAAC,MAAM,CAAC;oBACJ,MAAM,IAAI,qCAAA,kCAAkC,EAAE,CAAA;gBAClD,CAAC;YACL,KAAK,eAAe;gBAChB,IAAI,cAAA,WAAW,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAAE,CAAC;oBACvC,OAAO,AACH,gBAAgB,GAAG,gBAAgB,GAAG,gBAAgB,CACzD,CAAA;gBACL,CAAC,MAAM,CAAC;oBACJ,MAAM,IAAI,qCAAA,kCAAkC,EAAE,CAAA;gBAClD,CAAC;YACL;gBACI,OAAO,EAAE,CAAA;QACjB,CAAC;IACL,CAAC;IAED;;OAEG,CACO,sBAAsB,GAAA;QAC5B,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,EACjE,OAAO,EAAE,CAAA;QACb,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CACxC,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;YACnB,OAAQ,MAAM,CAAC,IAAI,EAAE,CAAC;gBAClB,KAAK,KAAK;oBACN,OACI,AADG,CACF,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,GACzB,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,SAAS,CAAC,CAC9C,CAAA;gBACL,KAAK,IAAI;oBACL,OAAO,AACH,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,GACxB,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,SAAS,CAAC,CAC9C,CAAA;gBACL;oBACI,OAAO,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;YAC1D,CAAC;QACL,CAAC,CAAC,CACD,IAAI,CAAC,GAAG,CAAC,CAAA;QAEd,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,OAAO,EAAE,CAAA;QACjC,OAAO,UAAU,GAAG,UAAU,CAAA;IAClC,CAAC;IAES,+BAA+B,CACrC,SAAiB,EACjB,QAAwB,EAAA;QAExB,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAChD,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,SAAS,KAAK,SAAS,CAC7C,CAAA;QAED,MAAM,OAAO,GAAqB,EAAE,CAAA;QACpC,IAAI,YAAY,EAAE,CAAC;YACf,OAAO,CAAC,IAAI,CACR,GAAG,QAAQ,CAAC,OAAO,CAAC,MAAM,CACtB,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,QAAQ,KAAK,IAAI,CACvC,CACJ,CAAA;QACL,CAAC;QACD,OAAO,CAAC,IAAI,CACR,GAAG,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE;YAClC,OAAO,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAClC,CAAC,MAAM,EAAE,CACL,CADO,KACD,CAAC,SAAS,KAChB,SAAS,GAAG,GAAG,GAAG,MAAM,CAAC,YAAY,CAC5C,CAAA;QACL,CAAC,CAAC,CACL,CAAA;QAED,2GAA2G;QAC3G,4HAA4H;QAC5H,oDAAoD;QACpD,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EACpB,0HAA0H;QAC1H,OAAO,EAAE,CAAA;QAEb,MAAM,yBAAyB,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,GAC1D,QAAQ,CAAC,cAAc,CAAC,MAAM,CAC1B,CAAC,aAAa,EAAE,CAAG,CAAD,MAAQ,CAAC,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAC3D,GACD,EAAE,CAAA;QACR,MAAM,UAAU,GAAG,CAAC;eAAG,OAAO,EAAE;eAAG,yBAAyB;SAAC,CAAA;QAC7D,MAAM,YAAY,GAAkB,EAAE,CAAA;QAEtC,MAAM,gBAAgB,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;QAC/C,UAAU,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YAC1B,IAAI,aAAa,GACb,gBAAgB,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAA;YAE7D,IAAI,MAAM,CAAC,iBAAiB,IAAI,MAAM,CAAC,KAAK,EAAE,CAAC;gBAC3C,aAAa,GAAG,CAAA,CAAA,EAAI,MAAM,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAA,CAAA,CAAG,CAAA;YACzD,CAAC;YAED,IACI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EACjE,CAAC;gBACC,IACI,cAAA,WAAW,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IACjD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,cAAc,EACxD,CAAC;oBACC,MAAM,SAAS,GACX,IAAI,CAAC,UAAU,CAAC,MAGnB,CAAC,OAAO,CAAC,oBAAoB,CAAA;oBAC9B,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,WAAW,CAAA;oBACjD,aAAa,GAAG,GAAG,MAAM,CAAA,CAAA,EAAI,aAAa,CAAA,CAAA,CAAG,CAAA;gBACjD,CAAC;gBAED,IAAI,cAAA,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EACpD,IAAI,MAAM,CAAC,SAAS,EAAE,CAAC;oBACnB,gDAAgD;oBAChD,aAAa,GAAG,CAAA,aAAA,EAAgB,aAAa,CAAA,EAAA,EAAK,MAAM,CAAC,SAAS,CAAA,OAAA,CAAS,CAAA;gBAC/E,CAAC,MAAM,CAAC;oBACJ,aAAa,GAAG,CAAA,aAAA,EAAgB,aAAa,CAAA,OAAA,CAAS,CAAA;gBAC1D,CAAC;gBACL,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,OAAO,EAC/C,aAAa,GAAG,GAAG,aAAa,CAAA,WAAA,CAAa,CAAA;YACrD,CAAC;YAED,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,CAChD,CAAC,MAAM,EAAE,CACL,CADO,KACD,CAAC,SAAS,KAAK,SAAS,GAAG,GAAG,GAAG,MAAM,CAAC,YAAY,CACjE,CAAA;YACD,IAAI,UAAU,CAAC,MAAM,EAAE,CAAC;gBACpB,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,EAAE;oBAC7B,YAAY,CAAC,IAAI,CAAC;wBACd,SAAS,EAAE,aAAa;wBACxB,SAAS,EAAE,SAAS,CAAC,SAAS,GACxB,SAAS,CAAC,SAAS,GACnB,cAAA,WAAW,CAAC,UAAU,CAClB,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,SAAS,EACT,SAAS,EACT,MAAM,CAAC,YAAY,CACtB;wBACP,4FAA4F;wBAC5F,OAAO,EAAE,SAAS,CAAC,OAAO;qBAC7B,CAAC,CAAA;gBACN,CAAC,CAAC,CAAA;YACN,CAAC,MAAM,CAAC;gBACJ,YAAY,CAAC,IAAI,CAAC;oBACd,SAAS,EAAE,aAAa;oBACxB,SAAS,EAAE,cAAA,WAAW,CAAC,UAAU,CAC7B,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,SAAS,EACT,SAAS,EACT,MAAM,CAAC,YAAY,CACtB;oBACD,4FAA4F;oBAC5F,OAAO,EAAE,YAAY;iBACxB,CAAC,CAAA;YACN,CAAC;QACL,CAAC,CAAC,CAAA;QACF,OAAO,YAAY,CAAA;IACvB,CAAC;IAES,uBAAuB,CAC7B,SAAiB,EACjB,QAAwB,EAAA;QAExB,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAC9C,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,SAAS,KAAK,SAAS,CAC7C,CAAA;QACD,IAAI,UAAU,EAAE,OAAO;YAAC,UAAU;SAAC,CAAA;QAEnC,OAAO,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE;YAChD,OAAO,QAAQ,CAAC,OAAO,CAAC,IAAI,CACxB,CAAC,MAAM,EAAE,CACL,CADO,KACD,CAAC,SAAS,KAAK,SAAS,GAAG,GAAG,GAAG,MAAM,CAAC,YAAY,CACjE,CAAA;QACL,CAAC,CAAC,CAAA;IACN,CAAC;IAEO,sBAAsB,GAAA;QAC1B,MAAM,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,CAAA,CAAC,6CAA6C;QAClG,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,CAAA;QAEvD,MAAM,cAAc,GAAG,QAAQ,CAAC,cAAc,CAAA;QAC9C,MAAM,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;QAE5C,4FAA4F;QAC5F,6DAA6D;QAC7D,IACI,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,MAAM,KAAK,CAAC,IAC9C,IAAI,CAAC,aAAa,CAAC,oBAAoB,CAAC,MAAM,KAAK,CAAC,IACpD,IAAI,CAAC,aAAa,CAAC,uBAAuB,CAAC,MAAM,KAAK,CAAC,EACzD,CAAC;YACC,OAAO,UAAU,CAAA;QACrB,CAAC;QAED,sFAAsF;QAEtF,IACI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,aAAa,IACrD,cAAA,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EACtD,CAAC;YACC,mFAAmF;YACnF,mEAAmE;YACnE,OAAO,AACH,iBAAiB,GACjB,cAAc,CACT,GAAG,CACA,CAAC,CAAC,EAAE,CACA,CADE,EACC,aAAa,CAAA,CAAA,EAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,YAAY,CAAC,EAAE,CACxD,CACA,IAAI,CAAC,IAAI,CAAC,GACf,IAAI,CACP,CAAA;QACL,CAAC;QAED,IAAI,cAAA,WAAW,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE,CAAC;YACpD,oFAAoF;YACpF,4CAA4C;YAC5C,OAAO,AACH,iBAAiB,GACjB,cAAc,CACT,GAAG,CACA,CAAC,CAAC,EAAE,CACA,CADE,EACC,aAAa,CAAA,CAAA,EAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,YAAY,CAAC,EAAE,CACxD,CACA,IAAI,CAAC,IAAI,CAAC,GACf,GAAG,CACN,CAAA;QACL,CAAC;QAED,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;YAClD,4EAA4E;YAC5E,yEAAyE;YACzE,2EAA2E;YAC3E,qFAAqF;YAErF,MAAM,iBAAiB,GAAG,cAAc,CACnC,GAAG,CACA,CAAC,aAAa,EAAE,CACZ,CADc,EACX,aAAa,CAAA,CAAA,EAAI,IAAI,CAAC,MAAM,CAC3B,aAAa,CAAC,YAAY,CAC7B,EAAE,CACV,CACA,IAAI,CAAC,WAAW,CAAC,CAAA;YAEtB,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBAC9B,OAAO,CAAA,eAAA,EAAkB,iBAAiB,CAAA,EAAA,CAAI,CAAA;YAClD,CAAC;YAED,OAAO,CAAA,sBAAA,EAAyB,iBAAiB,CAAA,GAAA,CAAK,CAAA;QAC1D,CAAC;QAED,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;YACpD,0DAA0D;YAC1D,6FAA6F;YAE7F,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBAC9B,OAAO,CAAA,eAAA,EAAkB,aAAa,CAAA,CAAA,EAAI,IAAI,CAAC,MAAM,CACjD,cAAc,CAAC,CAAC,CAAC,CAAC,YAAY,CACjC,CAAA,EAAA,CAAI,CAAA;YACT,CAAC;YAED,MAAM,iBAAiB,GAAG,cAAc,CACnC,GAAG,CACA,CAAC,aAAa,EAAE,CACZ,CAAA,AADc,KACd,EAAQ,aAAa,CAAA,CAAA,EAAI,IAAI,CAAC,MAAM,CAChC,aAAa,CAAC,YAAY,CAC7B,CAAA,WAAA,CAAa,CACrB,CACA,IAAI,CAAC,WAAW,CAAC,CAAA;YACtB,OAAO,CAAA,sBAAA,EAAyB,iBAAiB,CAAA,GAAA,CAAK,CAAA;QAC1D,CAAC;QAED,wGAAwG;QACxG,uFAAuF;QACvF,+DAA+D;QAE/D,iGAAiG;QACjG,mEAAmE;QAEnE,OAAO,AACH,CAAA,eAAA,CAAiB,GACjB,cAAc,CACT,GAAG,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,EAAI,aAAa,CAAA,CAAA,EAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,YAAY,CAAC,EAAE,CAAC,CAC7D,IAAI,CAAC,eAAe,CAAC,GAC1B,IAAI,CACP,CAAA;IACL,CAAC;IAES,KAAK,CAAC,iBAAiB,CAC7B,WAAwB,EAAA;QAExB,MAAM,QAAQ,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAA;QAE9C,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,KAAK,EAAE,CAC7B,OAAO,EAAE,CACT,OAAO,EAAE,CACT,MAAM,CAAC,SAAS,CAAC,CACjB,KAAK,CAAC,SAAS,CAAC,CAChB,IAAI,CAAC,SAAS,CAAC,CACf,IAAI,CAAC,SAAS,CAAC,CACf,MAAM,CAAC,QAAQ,EAAE,KAAK,CAAC,CACvB,SAAS,CAAC,sBAAsB,CAAC,CACjC,cAAc,CAAC,WAAW,CAAC,CAAA;QAEhC,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAA;QAE3D,OAAO,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAA;IACtC,CAAC;IAES,KAAK,CAAC,kBAAkB,CAC9B,WAAwB,EAAA;QAExB,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,UAAU,CAChC,kBAAkB,EAAE,CACpB,SAAS,EAAE,CACX,MAAM,CAAC,GAAG,EAAE,YAAY,CAAC,CACzB,WAAW,CAAC,IAAI,CAAC,CACjB,KAAK,CAAC,CAAC,CAAC,CACR,cAAc,CAAC,WAAW,CAAC,CAAA;QAEhC,OAAO,OAAO,CAAC,MAAM,GAAG,CAAC,CAAA;IAC7B,CAAC;IAES,gBAAgB,GAAA;QACtB,mEAAmE;QACnE,0BAA0B;QAE1B,IAAI,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,EAAE,CAAC;YACzC,IAAI,IAAI,CAAC,WAAW,CAAC,oBAAoB,EAAE,CAAC;gBACxC,IAAI,CAAC,aAAa,CAAC,oBAAoB,GACnC,IAAI,CAAC,WAAW,CAAC,oBAAoB,CAAA;YAC7C,CAAC;YAED,IAAI,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC;gBAC3B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAA;YAC1C,CAAC;YAED,IAAI,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE,CAAC;gBAC/B,IAAI,CAAC,WAAW,EAAE,CAAA;YACtB,CAAC;YAED,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC;gBAC1B,MAAM,MAAM,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,GAC/C,WAAA,QAAQ,CAAC,2BAA2B,CAChC,IAAI,CAAC,WAAW,CAAC,MAAkB,CACtC,GACD,IAAI,CAAC,WAAW,CAAC,MAAM,CAAA;gBAE7B,IAAI,CAAC,WAAW,CACZ,MAAM,EACN,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,EACtC,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,CACrC,CAAA;YACL,CAAC;YAED,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;gBACtB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;YAC7B,CAAC;YAED,IAAI,CAAC,OAAO,GAAG,EAAE,CAAA;YACjB,IAAI,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,CAAC;gBAC7B,MAAM,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,GACrD,WAAA,QAAQ,CAAC,2BAA2B,CAChC,IAAI,CAAC,WAAW,CAAC,SAAS,CAC7B,GACD,IAAI,CAAC,WAAW,CAAC,SAAS,CAAA;gBAEhC,IAAI,CAAC,cAAc,CACf,SAAS,EACT,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,KAAK,QAAQ,GACpC,IAAI,CAAC,WAAW,CAAC,MAAiC,GACnD,SAAS,EACf,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,EACtC,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,CACrC,CAAA;gBACD,IACI,IAAI,CAAC,WAAW,CAAC,kBAAkB,KAAK,KAAK,IAC7C,IAAI,CAAC,aAAa,CAAC,oBAAoB,KAAK,MAAM,EACpD,CAAC;oBACC,IAAI,CAAC,mBAAmB,CACpB,SAAS,EACT,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,KAAK,QAAQ,GACpC,IAAI,CAAC,WAAW,CACZ,MAAiC,GACtC,SAAS,EACf,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,EACtC,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,CACrC,CAAA;gBACL,CAAC;YACL,CAAC;YACD,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;gBACtB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;YAChC,CAAC;YAED,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;gBACzB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAC7B,IAAI,CAAC,WAAW,CAAC,KAAK,EACtB,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,EACtC,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,CACrC,CAAA;gBAED,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,IAAI,CAAC,QAAQ,CACT,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,GAC9B,GAAG,GAAG,IAAI,CAAC,UAAU,GAAG,GAAG,GAC3B,IAAI,CAAC,UAAU,CACxB,CAAA,CAAC,iCAAiC;YAC3C,CAAC;YAED,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;gBACzB,IAAI,CAAC,UAAU,CACX,IAAI,CAAC,WAAW,CAAC,KAAK,EACtB,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,EACtC,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,CACrC,CAAA;YACL,CAAC;YAED,cAAc;YACd,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;gBACpB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;oBACxB,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC;wBACjC,wBAAwB;wBACxB,EAAE;wBACF,WAAW;wBACX,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;4BACxB,IAAI,CAAC,kBAAkB,CACnB,GAAG,IAAI,CAAC,WAAW,CAAA,CAAA,EAAI,IAAI,CAAC,gBAAgB,CAAC,YAAY,EAAE,EAC3D,IAAI,CAAC,KAAK,CACb,CAAA;wBACL,CAAC,MAAM,CAAC;4BACJ,IAAI,CAAC,iBAAiB,CAClB,GAAG,IAAI,CAAC,WAAW,CAAA,CAAA,EAAI,IAAI,CAAC,gBAAgB,CAAC,YAAY,EAAE,EAC3D,IAAI,CAAC,KAAK,CACb,CAAA;wBACL,CAAC;oBACD,IAAI;oBACR,CAAC,MAAM,CAAC;wBACJ,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;4BACxB,IAAI,CAAC,SAAS,CACV,GAAG,IAAI,CAAC,WAAW,CAAA,CAAA,EAAI,IAAI,CAAC,gBAAgB,CAAC,YAAY,EAAE,EAC3D,IAAI,CAAC,KAAK,CACb,CAAA;wBACL,CAAC,MAAM,CAAC;4BACJ,IAAI,CAAC,QAAQ,CACT,GAAG,IAAI,CAAC,WAAW,CAAA,CAAA,EAAI,IAAI,CAAC,gBAAgB,CAAC,YAAY,EAAE,EAC3D,IAAI,CAAC,KAAK,CACb,CAAA;wBACL,CAAC;oBACL,CAAC;gBAED,qBAAqB;gBACrB,2DAA2D;gBAC3D,+CAA+C;gBAC/C,oBAAoB;gBACpB,0BAA0B;gBAC1B,0DAA0D;gBAC1D,aAAa;gBACb,QAAQ;gBACR,IAAI;gBACR,CAAC,CAAC,CAAA;YACN,CAAC;YAED,gCAAgC;YAChC,iDAAiD;YACjD,IAAI;YAEJ,eAAe;YACf,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;gBACtC,mFAAmF;gBACnF,0CAA0C;gBAC1C,WAAW;gBACX,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAA;YAChC,IAAI;YACR,CAAC;YAED,cAAc;YACd,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;gBACtC,mFAAmF;gBACnF,yCAAyC;gBACzC,WAAW;gBACX,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAA;YAChC,IAAI;YACR,CAAC;YAED,wBAAwB;YACxB,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,KAAK,QAAQ,EAAE,CAAC;gBAC7C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;YACtC,CAAC,MAAM,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;gBACrD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAA;YACtC,CAAC,MAAM,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,KAAK,QAAQ,EAAE,CAAC;gBACpD,IAAI,CAAC,KAAK,CACN,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,EACzB,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,YAAY,CACtC,CAAA;YACL,CAAC;YAED,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;gBACxB,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,EAC9B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAO,CAC/C,CAAC,GAAG,EAAE,EAAE;oBACJ,IAAI,CAAC,QAAQ,CACT,IAAI,CAAC,WAAW,CAAC,IAAK,CAAC,QAAS,CAAC,GAAG,CAAC,EACrC,GAAG,CACN,CAAA;gBACL,CAAC,CACJ,CAAA;gBAEL,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,EAC/B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CAChD,CAAC,GAAG,EAAE,EAAE;oBACJ,IAAI,CAAC,SAAS,CACV,IAAI,CAAC,WAAW,CAAC,IAAK,CAAC,SAAU,CAAC,GAAG,CAAC,EACtC,GAAG,CACN,CAAA;gBACL,CAAC,CACJ,CAAA;gBAEL,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,iBAAiB,EACvC,MAAM,CAAC,IAAI,CACP,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,iBAAiB,CAC1C,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;oBACd,IAAI,CAAC,iBAAiB,CAClB,IAAI,CAAC,WAAW,CAAC,IAAK,CAAC,iBAAkB,CAAC,GAAG,CAAC,EAC9C,GAAG,CACN,CAAA;gBACL,CAAC,CAAC,CAAA;gBAEN,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,kBAAkB,EACxC,MAAM,CAAC,IAAI,CACP,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,kBAAkB,CAC3C,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;oBACd,IAAI,CAAC,kBAAkB,CACnB,IAAI,CAAC,WAAW,CAAC,IAAK,CAAC,kBAAmB,CAAC,GAAG,CAAC,EAC/C,GAAG,CACN,CAAA;gBACL,CAAC,CAAC,CAAA;YACV,CAAC;YAED,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;gBACxB,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,KAAK,YAAY,EAAE,CAAC;oBAC9C,IAAI,CAAC,OAAO,CACR,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,EAC1B,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAChC,CAAA;gBACL,CAAC,MAAM,IACH,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,KAAK,kBAAkB,IACjD,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,KAAK,mBAAmB,IAClD,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,KAAK,YAAY,IAC3C,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,KACtB,2BAA2B,IAC/B,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,KACtB,2BAA2B,IAC/B,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,KAAK,mBAAmB,IAClD,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,KAAK,eAAe,EAChD,CAAC;oBACC,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,GACzC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;wBACvC,MAAM,UAAU,GACZ,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;4BACtC,OAAO,AACH,KAAK,CAAC,QAAQ,CACT,sBAAsB,KAAK,KAAK,CACxC,CAAA;wBACL,CAAC,CAAC,CAAA;wBACN,IAAI,CAAC,UAAU,EAAE,CAAC;4BACd,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,CAAA,EAAI,KAAK,CAAA,2BAAA,CAA6B,CACzC,CAAA;wBACL,CAAC;wBACD,OAAO,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;oBACvC,CAAC,CAAC,GACF,SAAS,CAAA;oBACf,IAAI,CAAC,OAAO,CACR,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,EAC1B,SAAS,EACT,UAAU,CACb,CAAA;oBAED,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;wBACjC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA;oBACpD,CAAC;gBACL,CAAC;YACL,CAAC;YAED,IAAI,IAAI,CAAC,WAAW,CAAC,eAAe,KAAK,IAAI,EAAE,CAAC;gBAC5C,IAAI,CAAC,kBAAkB,EAAE,CAAA;YAC7B,CAAC,MAAM,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,eAAe,KAAK,QAAQ,EAAE,CAAC;gBAC9D,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,WAAW,CAAC,eAAsB,CAAC,CAAA;YACpE,CAAC;YAED,IAAI,IAAI,CAAC,WAAW,CAAC,kBAAkB,KAAK,KAAK,EAAE,CAAC;gBAChD,mBAAA,gBAAgB,CAAC,kBAAkB,CAC/B,IAAI,EACJ,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,IAAI,EAClC,IAAI,CAAC,aAAa,CAAC,SAAU,CAAC,QAAQ,CACzC,CAAA;YACL,CAAC;YAED,IAAI,IAAI,CAAC,WAAW,CAAC,WAAW,KAAK,IAAI,EAAE,CAAC;gBACxC,IAAI,CAAC,aAAa,CAAC,cAAc,GAAG,IAAI,CAAA;YAC5C,CAAC;QAED,8BAA8B;QAC9B,yCAAyC;QACzC,4EAA4E;QAC5E,UAAU;QACV,IAAI;QAEJ,OAAO;QACP,qEAAqE;QACrE,wBAAwB;QACxB,IAAI;QAEJ,OAAO;QACP,0EAA0E;QAC1E,iCAAiC;QACjC,IAAI;QACR,CAAC;IACL,CAAC;IAEM,sBAAsB,CAAC,gBAAkC,EAAA;QAC5D,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAA;IACjD,CAAC;IAED;;OAEG,CACO,KAAK,CAAC,4BAA4B,CACxC,WAAwB,EAAA;QAExB,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,EAC7B,MAAM,IAAI,QAAA,YAAY,CAClB,CAAA,oDAAA,CAAsD,CACzD,CAAA;QAEL,IACI,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,kBAAkB,IAC/C,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,mBAAmB,IACnD,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,2BAA2B,IAC3D,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,2BAA2B,IAC3D,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,mBAAmB,IACnD,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,eAAe,CAAC,IACpD,CAAC,WAAW,CAAC,mBAAmB,EAEhC,MAAM,IAAI,0CAAA,uCAAuC,EAAE,CAAA;QAEvD,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,KAAK,YAAY,EAAE,CAAC;YAC/C,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAA;YACtD,IAAI,CAAC,QAAQ,CAAC,aAAa,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EACrD,MAAM,IAAI,mCAAA,gCAAgC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA;QACjE,CAAC;QAED,MAAM,gBAAgB,GAAG,IAAI,mBAAA,gBAAgB,CACzC,IAAI,CAAC,UAAU,EACf,WAAW,EACX,IAAI,CAAC,aAAa,CAAC,oBAAoB,CAC1C,CAAA;QACD,MAAM,mBAAmB,GAAG,IAAI,sBAAA,mBAAmB,CAC/C,IAAI,CAAC,UAAU,EACf,WAAW,EACX,IAAI,CAAC,aAAa,CAAC,uBAAuB,CAC7C,CAAA;QACD,MAAM,6BAA6B,GAC/B,IAAI,2CAAA,wCAAwC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAA;QACpE,6BAA6B,CAAC,SAAS,EAAE,CAAA;QACzC,MAAM,gCAAgC,GAClC,IAAI,8CAAA,2CAA2C,CAAC,IAAI,CAAC,aAAa,CAAC,CAAA;QACvE,gCAAgC,CAAC,SAAS,EAAE,CAAA;QAE5C,IAAI,UAAU,GAAU,EAAE,EACtB,QAAQ,GAAU,EAAE,CAAA;QAExB,gGAAgG;QAChG,qDAAqD;QACrD,8CAA8C;QAC9C,4DAA4D;QAC5D,IACI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IACpD,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,EAC9C,CAAC;YACC,6EAA6E;YAC7E,mEAAmE;YACnE,MAAM,CAAC,OAAO,EAAE,QAAQ,CAAC,GACrB,IAAI,CAAC,yCAAyC,CAAC,eAAe,CAAC,CAAA;YACnE,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAA;YACtD,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI,CAAA;YAEvD,MAAM,YAAY,GAAG,QAAQ,CAAC,cAAc,CAAC,GAAG,CAC5C,CAAC,aAAa,EAAE,EAAE;gBACd,MAAM,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,CAAA;gBAClD,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAC3B,cAAA,WAAW,CAAC,UAAU,CAClB,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,SAAS,EACT,aAAa,EACb,aAAa,CAAC,YAAY,CAC7B,CACJ,CAAA;gBACD,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,EACtB,yEAAyE;gBACzE,QAAQ,CAAC,WAAW,CAAC,GAAG,KAAK,CAAA;gBAEjC,MAAM,KAAK,GAAG,cAAA,WAAW,CAAC,UAAU,CAChC,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,SAAS,EACT,MAAM,GAAG,aAAa,EACtB,aAAa,CAAC,YAAY,CAC7B,CAAA;gBAED,OAAO,GAAG,aAAa,CAAA,CAAA,EAAI,WAAW,CAAA,IAAA,EAAO,IAAI,CAAC,MAAM,CACpD,KAAK,CACR,EAAE,CAAA;YACP,CAAC,CACJ,CAAA;YAED,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,EAAE,CAAA;YAElC,4EAA4E;YAC5E,MAAM,uBAAuB,GACzB,aAAa,CAAC,aAAa,CAAC,UAAU,CAAA;YAE1C,UAAU,GAAG,MAAM,IAAI,kBAAkB,CACrC,IAAI,CAAC,UAAU,EACf,WAAW,CACd,CACI,MAAM,CAAC,CAAA,SAAA,EAAY,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAC7C,SAAS,CAAC,OAAO,CAAC,CAClB,IAAI,CACD,CAAA,CAAA,EAAI,aAAa,CACZ,OAAO,EAAE,CACT,eAAe,CAAC,KAAK,CAAC,CAAC,kHAAkH;aACzI,QAAQ,EAAE,CAAA,CAAA,CAAG,EAClB,eAAe,CAClB,CACA,eAAe,CAAC,uBAAuB,CAAC,CACxC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAC/B,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAC9B,OAAO,CAAC,QAAQ,CAAC,CACjB,KAAK,CACF,IAAI,CAAC,aAAa,CAAC,KAAK,IAAI,IAAI,CAAC,aAAa,CAAC,OAAO,GAChD,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAA,WAAA,CAAa,GAC1C,IAAI,CAAC,aAAa,CAAC,KAAK,EAC9B,IAAI,CAAC,aAAa,CAAC,aAAa,CACnC,CACA,aAAa,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,CACnC,mBAAmB,CAAC,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC,CACxD,UAAU,EAAE,CAAA;YAEjB,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACxB,IAAI,SAAS,GAAG,EAAE,CAAA;gBAClB,MAAM,UAAU,GAAkB,CAAA,CAAE,CAAA;gBACpC,IAAI,QAAQ,CAAC,sBAAsB,EAAE,CAAC;oBAClC,SAAS,GAAG,UAAU,CACjB,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;wBACnB,OAAO,QAAQ,CAAC,cAAc,CACzB,GAAG,CAAC,CAAC,aAAa,EAAE,EAAE;4BACnB,MAAM,QAAQ,GAAG,CAAA,iBAAA,EAAoB,KAAK,CAAA,CAAA,EAAI,aAAa,CAAC,YAAY,EAAE,CAAA;4BAC1E,MAAM,cAAc,GAChB,cAAA,WAAW,CAAC,UAAU,CAClB,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,SAAS,EACT,MAAM,GAAG,aAAa,EACtB,aAAa,CAAC,YAAY,CAC7B,CAAA;4BACL,UAAU,CAAC,QAAQ,CAAC,GAChB,MAAM,CAAC,cAAc,CAAC,CAAA;4BAC1B,OAAO,GAAG,aAAa,CAAA,CAAA,EAAI,aAAa,CAAC,YAAY,CAAA,EAAA,EAAK,QAAQ,EAAE,CAAA;wBACxE,CAAC,CAAC,CACD,IAAI,CAAC,OAAO,CAAC,CAAA;oBACtB,CAAC,CAAC,CACD,IAAI,CAAC,MAAM,CAAC,CAAA;gBACrB,CAAC,MAAM,CAAC;oBACJ,MAAM,KAAK,GAAG,cAAA,WAAW,CAAC,UAAU,CAChC,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,SAAS,EACT,MAAM,GAAG,aAAa,EACtB,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,YAAY,CAC1C,CAAA;oBAED,MAAM,GAAG,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAG,CAAD,KAAO,CAAC,KAAK,CAAC,CAAC,CAAA;oBACrD,MAAM,aAAa,GAAG,GAAG,CAAC,KAAK,CAC3B,CAAC,EAAO,EAAE,CAAG,CAAD,MAAQ,EAAE,KAAK,QAAQ,CACtC,CAAA;oBACD,IAAI,aAAa,EAAE,CAAC;wBAChB,8EAA8E;wBAC9E,SAAS,GAAG,GAAG,aAAa,CAAA,CAAA,EACxB,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,YAC/B,CAAA,KAAA,EAAQ,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,CAAA,CAAG,CAAA;oBAC7B,CAAC,MAAM,CAAC;wBACJ,UAAU,CAAC,kBAAkB,CAAC,GAAG,GAAG,CAAA;wBACpC,SAAS,GACL,aAAa,GACb,GAAG,GACH,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,YAAY,GACvC,4BAA4B,CAAA;oBACpC,CAAC;gBACL,CAAC;gBACD,UAAU,GAAG,MAAM,IAAI,CAAC,KAAK,EAAE,CAC1B,kBAAkB,CAAC;oBAChB,8BAA8B,EAAE,SAAS;iBAC5C,CAAC,CACD,aAAa,CAAC,UAAU,CAAC,CACzB,cAAc,CAAC,WAAW,CAAC,CAAA;YACpC,CAAC;QACL,CAAC,MAAM,CAAC;YACJ,UAAU,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAA;QACvD,CAAC;QAED,IAAI,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACxB,sCAAsC;YACtC,MAAM,oBAAoB,GAAG,MAAM,gBAAgB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAA;YACpE,MAAM,uBAAuB,GAAG,MAAM,mBAAmB,CAAC,IAAI,CAC1D,UAAU,CACb,CAAA;YACD,MAAM,WAAW,GAAG,IAAI,mCAAA,gCAAgC,CACpD,IAAI,CAAC,aAAa,EAClB,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,oBAAoB,EACpB,uBAAuB,EACvB,IAAI,CAAC,WAAW,CACnB,CAAA;YACD,QAAQ,GAAG,WAAW,CAAC,SAAS,CAC5B,UAAU,EACV,IAAI,CAAC,aAAa,CAAC,SAAU,CAChC,CAAA;YAED,oCAAoC;YACpC,IACI,IAAI,CAAC,aAAa,CAAC,aAAa,KAAK,IAAI,IACzC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,WAAW,EAC1C,CAAC;gBACC,MAAM,WAAW,CAAC,WAAW,CAAC,SAAS,CACnC,MAAM,EACN,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,QAAQ,EACrC,QAAQ,CACX,CAAA;YACL,CAAC;QACL,CAAC;QAED,IAAI,IAAI,CAAC,aAAa,CAAC,oBAAoB,KAAK,OAAO,EAAE,CAAC;YACtD,MAAM,6BAA6B,GAC/B,IAAI,mBAAA,gBAA6B,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,CAAC,CAAA;YAEnE,MAAM,OAAO,CAAC,GAAG,CACb,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,EAAE,EAAE;gBAC1C,MAAM,cAAc,GAAG,QAAQ,CAAC,qBAAqB,CAAC,MAAM,CAAA;gBAC5D,MAAM,aAAa,GACf,QAAQ,CAAC,qBAAqB,CAAC,UAAU,CAAA;gBAE7C,MAAM,MAAM,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,GAC/C,WAAA,QAAQ,CAAC,2BAA2B,CAChC,IAAI,CAAC,WAAW,CAAC,MAAkB,CACtC,GACD,IAAI,CAAC,WAAW,CAAC,MAAM,CAAA;gBAC7B,MAAM,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,GACrD,WAAA,QAAQ,CAAC,2BAA2B,CAChC,IAAI,CAAC,WAAW,CAAC,SAAS,CAC7B,GACD,IAAI,CAAC,WAAW,CAAC,SAAS,CAAA;gBAEhC,MAAM,YAAY,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CACpD,MAAM,CAAC,aAAa,CAAC,CACrB,IAAI,CAAC,cAAc,EAAE,aAAa,CAAC,CACnC,cAAc,CAAC;oBACZ,MAAM,EAAE,MAAM,GACR,WAAA,QAAQ,CAAC,SAAS,CACd,MAAM,EACN,QAAQ,CAAC,YAAY,CACxB,GACD,SAAS;oBACf,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,KAAK,GACvB,WAAA,QAAQ,CAAC,SAAS,CACd,IAAI,CAAC,WAAW,CAAC,KAAK,EACtB,QAAQ,CAAC,YAAY,CACxB,GACD,SAAS;oBACf,SAAS,EAAE,SAAS,GACd,WAAA,QAAQ,CAAC,SAAS,CACd,SAAS,EACT,QAAQ,CAAC,YAAY,CACxB,GACD,SAAS;oBACf,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,WAAW;oBACzC,oBAAoB,EAChB,IAAI,CAAC,WAAW,CAAC,oBAAoB;iBAC5C,CAAC,CAAA;gBACN,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBACtB,MAAM,mBAAmB,GACrB,MAAM,6BAA6B,CAAC,iCAAiC,CACjE,QAAQ,EACR,QAAQ,EACR,SAAS,EACT,YAAY,CACf,CAAA;oBACL,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;wBACxB,MAAM,kBAAkB,GAAG,mBAAmB,CAAC,IAAI,CAC/C,CAAC,KAAK,EAAE,CAAG,CAAD,IAAM,CAAC,MAAM,KAAK,MAAM,CACrC,CAAA;wBACD,IAAI,kBAAkB,EAAE,CAAC;4BACrB,MAAM,KAAK,GACP,kBAAkB,CAAC,OAAO,KAAK,SAAS,GAClC,IAAI,GACJ,kBAAkB,CAAC,OAAO,CAAA;4BACpC,QAAQ,CAAC,cAAc,CAAC,MAAM,EAAE,KAAK,CAAC,CAAA;wBAC1C,CAAC;oBACL,CAAC,CAAC,CAAA;gBACN,CAAC;YACL,CAAC,CAAC,CACL,CAAA;QACL,CAAC;QAED,OAAO;YACH,GAAG,EAAE,UAAU;YACf,QAAQ,EAAE,QAAQ;SACrB,CAAA;IACL,CAAC;IAES,yCAAyC,CAC/C,WAAmB,EAAA;QAEnB,6CAA6C;QAC7C,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,CAAA;QAC/C,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CACrC,GAAG,CAAC,CAAC,aAAa,EAAE,EAAE;YACnB,IAAI,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;gBACpC,MAAM,aAAa,GAAG,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;gBAC9C,MAAM,SAAS,GAAG,aAAa,CAAC,CAAC,CAAC,CAAA;gBAClC,MAAM,YAAY,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;gBACrD,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,SAAS,CAAC,CAAA;gBAC3D,MAAM,MAAM,GACR,KAAK,CAAC,QAAQ,CAAC,0BAA0B,CAAC,YAAY,CAAC,CAAA;gBAC3D,OAAO,AACH,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,GACxB,GAAG,GACH,IAAI,CAAC,MAAM,CACP,cAAA,WAAW,CAAC,UAAU,CAClB,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,SAAS,EACT,SAAS,EACT,MAAO,CAAC,YAAY,CACvB,CACJ,CACJ,CAAA;YACL,CAAC,MAAM,CAAC;gBACJ,IACI,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAC3B,CAAC,MAAM,EAAE,CACL,CADO,KACD,CAAC,SAAS,KAAK,aAAa,IAClC,MAAM,CAAC,SAAS,KAAK,aAAa,CACzC,EAED,OAAO,AACH,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,GACxB,GAAG,GACH,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CAC7B,CAAA;gBAEL,OAAO,EAAE,CAAA;YACb,CAAC;QACL,CAAC,CAAC,CACD,IAAI,CAAC,IAAI,CAAC,CAAA;QAEf,MAAM,aAAa,GAAqB,CAAA,CAAE,CAAA;QAC1C,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC,aAAa,EAAE,EAAE;YAC5C,IAAI,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;gBACpC,MAAM,aAAa,GAAG,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;gBAC9C,MAAM,SAAS,GAAG,aAAa,CAAC,CAAC,CAAC,CAAA;gBAClC,MAAM,YAAY,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;gBACrD,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,SAAS,CAAC,CAAA;gBAC3D,MAAM,MAAM,GACR,KAAK,CAAC,QAAQ,CAAC,0BAA0B,CAAC,YAAY,CAAC,CAAA;gBAC3D,aAAa,CACT,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,GACpB,GAAG,GACH,IAAI,CAAC,MAAM,CACP,cAAA,WAAW,CAAC,UAAU,CAClB,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB,SAAS,EACT,SAAS,EACT,MAAO,CAAC,YAAY,CACvB,CACJ,CACR,GAAG,QAAQ,CAAC,aAAa,CAAC,CAAA;YAC/B,CAAC,MAAM,CAAC;gBACJ,IACI,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAC3B,CAAC,MAAM,EAAE,CACL,CADO,KACD,CAAC,SAAS,KAAK,aAAa,IAClC,MAAM,CAAC,SAAS,KAAK,aAAa,CACzC,EACH,CAAC;oBACC,aAAa,CACT,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,GACpB,GAAG,GACH,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CACjC,GAAG,QAAQ,CAAC,aAAa,CAAC,CAAA;gBAC/B,CAAC,MAAM,CAAC;oBACJ,aAAa,CAAC,aAAa,CAAC,GAAG,QAAQ,CAAC,aAAa,CAAC,CAAA;gBAC1D,CAAC;YACL,CAAC;QACL,CAAC,CAAC,CAAA;QAEF,OAAO;YAAC,YAAY;YAAE,aAAa;SAAC,CAAA;IACxC,CAAC;IAED;;OAEG,CACO,KAAK,CAAC,cAAc,CAAC,WAAwB,EAAA;QACnD,MAAM,CAAC,GAAG,EAAE,UAAU,CAAC,GAAG,IAAI,CAAC,qBAAqB,EAAE,CAAA;QACtD,MAAM,OAAO,GACT,GAAG,GACH,kBAAkB,GAClB,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,CAClC,CADoC,MAC7B,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,KAAK,CACvD,CAAA;QACL,MAAM,YAAY,GACd,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,KAAK,QAAQ,GAC3C,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,GAC7B,CAAA,CAAE,CAAA;QACZ,IAAI,4BAA4B,GAC5B,SAAS,CAAA;QACb,MAAM,gBAAgB,GAClB,0DAA0D;QACzD,YAAY,CAAC,aAAa,IACvB,IAAI,CAAC,aAAa,CAAC,KAAK,KAAK,KAAK,CAAC,GACvC,yCAAyC;QACzC,IAAI,CAAC,aAAa,CAAC,KAAK,KAAK,IAAI,CAAA;QACrC,IAAI,UAAU,GAAG,KAAK,CAAA;QACtB,IAAI,IAAI,CAAC,UAAU,CAAC,gBAAgB,IAAI,gBAAgB,EAAE,CAAC;YACvD,IAAI,CAAC;gBACD,4BAA4B,GACxB,MAAM,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,YAAY,CAC/C;oBACI,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,OAAO;oBACtC,KAAK,EAAE,OAAO;oBACd,QAAQ,EACJ,IAAI,CAAC,aAAa,CAAC,aAAa,IAChC,YAAY,CAAC,QAAQ,IACrB,IAAI;iBACX,EACD,WAAW,CACd,CAAA;gBACL,IACI,4BAA4B,IAC5B,CAAC,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,SAAS,CACvC,4BAA4B,CAC/B,EACH,CAAC;oBACC,OAAO,IAAI,CAAC,KAAK,CAAC,4BAA4B,CAAC,MAAM,CAAC,CAAA;gBAC1D,CAAC;YACL,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;gBACb,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE,CAAC;oBAC7B,MAAM,KAAK,CAAA;gBACf,CAAC;gBACD,UAAU,GAAG,IAAI,CAAA;YACrB,CAAC;QACL,CAAC;QAED,MAAM,OAAO,GAAG,MAAM,WAAW,CAAC,KAAK,CAAC,GAAG,EAAE,UAAU,EAAE,IAAI,CAAC,CAAA;QAE9D,IACI,CAAC,UAAU,IACX,IAAI,CAAC,UAAU,CAAC,gBAAgB,IAChC,gBAAgB,EAClB,CAAC;YACC,IAAI,CAAC;gBACD,MAAM,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,YAAY,CAC/C;oBACI,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,OAAO;oBACtC,KAAK,EAAE,OAAO;oBACd,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;oBAChB,QAAQ,EACJ,IAAI,CAAC,aAAa,CAAC,aAAa,IAChC,YAAY,CAAC,QAAQ,IACrB,IAAI;oBACR,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC;iBAC1C,EACD,4BAA4B,EAC5B,WAAW,CACd,CAAA;YACL,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;gBACb,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE,CAAC;oBAC7B,MAAM,KAAK,CAAA;gBACf,CAAC;YACL,CAAC;QACL,CAAC;QAED,OAAO,OAAO,CAAC,OAAO,CAAA;IAC1B,CAAC;IAED;;OAEG,CACO,kBAAkB,CACxB,aAA0C,EAAA;QAE1C,cAAA,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,EAAE,aAAa,CAAC,CAAA;QACrD,OAAO,IAAI,CAAA;IACf,CAAC;IAED;;OAEG,CACO,eAAe,CAAC,GAAQ,EAAA;QAC9B,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,SAAS,IAAI,GAAG,KAAK,IAAI,EAC5D,OAAO,GAAG,CAAA;QAEd,OAAO,MAAM,CAAC,GAAG,CAAC,CAAA;IACtB,CAAC;IAED;;OAEG,CACO,iBAAiB,GAAA;QACvB,OAAO,AACH,IAAI,CAAC,WAAW,IAChB,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAC7B,IAAI,CAAC,UAAU,CAAC,8BAA8B,EAAE,CACnD,CACJ,CAAA;IACL,CAAC;IAES,WAAW,CACjB,MAA8B,EAC9B,QAAwB,EACxB,KAAa,EACb,WAAoB,EAAA;QAEpB,IAAK,MAAM,GAAG,IAAI,MAAM,CAAE,CAAC;YACvB,IAAI,MAAM,CAAC,GAAG,CAAC,KAAK,SAAS,IAAI,MAAM,CAAC,GAAG,CAAC,KAAK,KAAK,EAAE,SAAQ;YAEhE,MAAM,YAAY,GAAG,WAAW,CAAC,CAAC,CAAC,WAAW,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAA;YAChE,MAAM,MAAM,GACR,QAAQ,CAAC,gCAAgC,CAAC,YAAY,CAAC,CAAA;YAC3D,MAAM,KAAK,GAAG,QAAQ,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;YACjE,MAAM,QAAQ,GAAG,QAAQ,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;YAEpE,IAAI,CAAC,KAAK,IAAI,CAAC,MAAM,IAAI,CAAC,QAAQ,EAC9B,MAAM,IAAI,8BAAA,2BAA2B,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAA;YAEjE,IAAI,MAAM,EAAE,CAAC;gBACT,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,GAAG,GAAG,YAAY,CAAC,CAAA;YAC7C,8CAA8C;YAClD,CAAC,MAAM,IAAI,KAAK,EAAE,CAAC;gBACf,IAAI,CAAC,WAAW,CACZ,MAAM,CAAC,GAAG,CAA2B,EACrC,QAAQ,EACR,KAAK,EACL,YAAY,CACf,CAAA;YAED,yBAAyB;YACzB,6DAA6D;YAC7D,2EAA2E;YAC3E,wBAAwB;YACxB,4BAA4B;YAC5B,4BAA4B;YAC5B,6BAA6B;YAC7B,gCAAgC;YAChC,kCAAkC;YAClC,yCAAyC;YACzC,cAAc;YACd,QAAQ;YACR,wGAAwG;YAC5G,CAAC;QACL,CAAC;IACL,CAAC;IAES,cAAc,CACpB,SAAoC,EACpC,SAA6C,EAC7C,QAAwB,EACxB,KAAa,EACb,WAAoB,EAAA;QAEpB,IAAI,CAAC,SAAS,EAAE,OAAM;QAEtB,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,EAAE;YAC5C,MAAM,aAAa,GAAI,SAAiB,CAAC,YAAY,CAAC,CAAA;YACtD,MAAM,YAAY,GAAG,WAAW,GAC1B,WAAW,GAAG,GAAG,GAAG,YAAY,GAChC,YAAY,CAAA;YAClB,MAAM,KAAK,GAAG,QAAQ,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;YACjE,MAAM,QAAQ,GAAG,QAAQ,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;YACpE,IAAI,CAAC,KAAK,IAAI,CAAC,QAAQ,EACnB,MAAM,IAAI,8BAAA,2BAA2B,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAA;YAEjE,IAAI,KAAK,EAAE,CAAC;gBACR,IAAI,CAAC,cAAc,CACf,aAAa,EACb,OAAO,SAAS,KAAK,QAAQ,GACvB,WAAA,QAAQ,CAAC,SAAS,CAAC,SAAS,EAAE,KAAK,CAAC,YAAY,CAAC,GACjD,SAAS,EACf,QAAQ,EACR,KAAK,EACL,YAAY,CACf,CAAA;YACL,CAAC,MAAM,IAAI,QAAQ,EAAE,CAAC;gBAClB,IAAI,SAAS,GAAG,KAAK,GAAG,GAAG,GAAG,YAAY,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAA;gBAC5D,SAAS,GAAG,cAAA,WAAW,CAAC,UAAU,CAC9B,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB;oBAAE,MAAM,EAAE,IAAI;gBAAA,CAAE,EAChB,KAAK,EACL,SAAS,CACZ,CAAA;gBACD,IACI,aAAa,KAAK,IAAI,IACtB,OAAO,aAAa,KAAK,QAAQ,EACnC,CAAC;oBACC,IAAI,IAAI,CAAC,aAAa,CAAC,oBAAoB,KAAK,OAAO,EAAE,CAAC;wBACtD,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAA;oBACzC,CAAC,MAAM,CAAC;wBACJ,OAAO;wBACP,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;4BACZ,IAAI,EAAE,MAAM;4BACZ,MAAM,EAAE,IAAI;4BACZ,SAAS,EACL,SAAS,IACT,OAAO,SAAS,CAAC,YAAY,CAAC,KAAK,QAAQ,GACpC,SAAS,CACN,YAAY,CACY,GAC5B,SAAS;4BACnB,KAAK,EAAE,SAAS;4BAChB,WAAW,EAAE,KAAK;4BAClB,gBAAgB,EAAE,QAAQ;yBAC7B,CAAC,CAAA;wBAEF,IACI,SAAS,IACT,OAAO,SAAS,CAAC,YAAY,CAAC,KAAK,QAAQ,EAC7C,CAAC;4BACC,IAAI,CAAC,WAAW,CACZ,SAAS,CACL,YAAY,CACW,EAC3B,QAAQ,CAAC,qBAAqB,EAC9B,SAAS,CACZ,CAAA;wBACL,CAAC;oBACL,CAAC;gBACL,CAAC;gBAED,IACI,OAAO,aAAa,KAAK,QAAQ,IACjC,IAAI,CAAC,aAAa,CAAC,oBAAoB,KAAK,MAAM,EACpD,CAAC;oBACC,IAAI,CAAC,cAAc,CACf,aAAa,EACb,OAAO,SAAS,KAAK,QAAQ,GACvB,WAAA,QAAQ,CAAC,SAAS,CACd,SAAS,EACT,QAAQ,CAAC,YAAY,CACxB,GACD,SAAS,EACf,QAAQ,CAAC,qBAAqB,EAC9B,SAAS,EACT,SAAS,CACZ,CAAA;gBACL,CAAC;YACL,CAAC;QACL,CAAC,CAAC,CAAA;IACN,CAAC;IAES,mBAAmB,CACzB,SAAoC,EACpC,SAA6C,EAC7C,QAAwB,EACxB,KAAa,EACb,WAAoB,EAAA;QAEpB,IAAI,CAAC,SAAS,EAAE,OAAM;QAEtB,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,EAAE;YAC5C,MAAM,aAAa,GAAI,SAAiB,CAAC,YAAY,CAAC,CAAA;YACtD,MAAM,YAAY,GAAG,WAAW,GAC1B,WAAW,GAAG,GAAG,GAAG,YAAY,GAChC,YAAY,CAAA;YAClB,MAAM,KAAK,GAAG,QAAQ,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;YACjE,MAAM,QAAQ,GAAG,QAAQ,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;YACpE,IAAI,CAAC,KAAK,IAAI,CAAC,QAAQ,EACnB,MAAM,IAAI,8BAAA,2BAA2B,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAA;YAEjE,IAAI,KAAK,EAAE,CAAC;gBACR,IAAI,CAAC,mBAAmB,CACpB,aAAa,EACb,OAAO,SAAS,KAAK,QAAQ,GACvB,WAAA,QAAQ,CAAC,SAAS,CAAC,SAAS,EAAE,KAAK,CAAC,YAAY,CAAC,GACjD,SAAS,EACf,QAAQ,EACR,KAAK,EACL,YAAY,CACf,CAAA;YACL,CAAC,MAAM,IAAI,QAAQ,EAAE,CAAC;gBAClB,IAAI,SAAS,GAAG,KAAK,GAAG,GAAG,GAAG,YAAY,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAA;gBAC5D,SAAS,GAAG,cAAA,WAAW,CAAC,UAAU,CAC9B,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB;oBAAE,MAAM,EAAE,IAAI;gBAAA,CAAE,EAChB,KAAK,EACL,SAAS,CACZ,CAAA;gBAED,IACI,aAAa,KAAK,IAAI,IACtB,OAAO,aAAa,KAAK,QAAQ,EACnC,CAAC;oBACC,QAAQ,CAAC,qBAAqB,CAAC,cAAc,CAAC,OAAO,CACjD,CAAC,aAAa,EAAE,EAAE;wBACd,IAAI,sBAAsB,GACtB,SAAS,GACT,GAAG,GACH,aAAa,CAAC,YAAY,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAA;wBAChD,sBAAsB,GAAG,cAAA,WAAW,CAAC,UAAU,CAC3C,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB;4BAAE,MAAM,EAAE,IAAI;wBAAA,CAAE,EAChB,SAAS,EACT,sBAAsB,CACzB,CAAA;wBAED,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAC7B,CAAC,IAAI,EAAE,CAAG,CAAD,GAAK,CAAC,KAAK,KAAK,sBAAsB,CAClD,CAAA;wBACD,IAAI,CAAC,SAAS,EAAE,CAAC;4BACb,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gCACZ,IAAI,EAAE,MAAM;gCACZ,MAAM,EAAE,IAAI;gCACZ,KAAK,EAAE,sBAAsB;gCAC7B,WAAW,EAAE,SAAS;gCACtB,SAAS,EAAE,SAAS;gCACpB,gBAAgB,EAAE,aAAa;6BAClC,CAAC,CAAA;wBACN,CAAC;wBAED,IACI,SAAS,IACT,OAAO,SAAS,CAAC,YAAY,CAAC,KAAK,QAAQ,EAC7C,CAAC;4BACC,IAAI,CAAC,WAAW,CACZ,SAAS,CACL,YAAY,CACW,EAC3B,QAAQ,CAAC,qBAAqB,EAC9B,SAAS,CACZ,CAAA;wBACL,CAAC;oBACL,CAAC,CACJ,CAAA;gBACL,CAAC;gBAED,IAAI,OAAO,aAAa,KAAK,QAAQ,EAAE,CAAC;oBACpC,IAAI,CAAC,mBAAmB,CACpB,aAAa,EACb,OAAO,SAAS,KAAK,QAAQ,GACvB,WAAA,QAAQ,CAAC,SAAS,CACd,SAAS,EACT,QAAQ,CAAC,YAAY,CACxB,GACD,SAAS,EACf,QAAQ,CAAC,qBAAqB,EAC9B,SAAS,EACT,SAAS,CACZ,CAAA;gBACL,CAAC;YACL,CAAC;QACL,CAAC,CAAC,CAAA;IACN,CAAC;IAES,UAAU,CAChB,KAA4B,EAC5B,QAAwB,EACxB,KAAa,EACb,WAAoB,EAAA;QAEpB,IAAK,MAAM,GAAG,IAAI,KAAK,CAAE,CAAC;YACtB,IAAI,KAAK,CAAC,GAAG,CAAC,KAAK,SAAS,EAAE,SAAQ;YAEtC,MAAM,YAAY,GAAG,WAAW,CAAC,CAAC,CAAC,WAAW,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAA;YAChE,MAAM,MAAM,GACR,QAAQ,CAAC,gCAAgC,CAAC,YAAY,CAAC,CAAA;YAC3D,MAAM,KAAK,GAAG,QAAQ,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;YACjE,MAAM,QAAQ,GAAG,QAAQ,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;YAEpE,IAAI,CAAC,KAAK,IAAI,CAAC,MAAM,IAAI,CAAC,QAAQ,EAC9B,MAAM,IAAI,8BAAA,2BAA2B,CAAC,YAAY,EAAE,QAAQ,CAAC,CAAA;YAEjE,IAAI,MAAM,EAAE,CAAC;gBACT,IAAI,SAAS,GACT,OAAO,KAAK,CAAC,GAAG,CAAC,KAAK,QAAQ,GACvB,KAAK,CAAC,GAAG,CAAS,CAAC,SAAS,GAC7B,KAAK,CAAC,GAAG,CAAC,CAAA;gBACpB,SAAS,GACL,SAAS,KAAK,MAAM,IACpB,SAAS,KAAK,MAAM,IACpB,SAAS,KAAK,CAAC,CAAC,GACV,MAAM,GACN,KAAK,CAAA;gBACf,IAAI,KAAK,GACL,OAAO,KAAK,CAAC,GAAG,CAAC,KAAK,QAAQ,GACvB,KAAK,CAAC,GAAG,CAAS,CAAC,KAAK,GACzB,SAAS,CAAA;gBACnB,KAAK,GACD,KAAK,EAAE,WAAW,EAAE,KAAK,OAAO,GAC1B,aAAa,GACb,KAAK,EAAE,WAAW,EAAE,KAAK,MAAM,GAC/B,YAAY,GACZ,SAAS,CAAA;gBAEnB,MAAM,SAAS,GAAG,GAAG,KAAK,CAAA,CAAA,EAAI,YAAY,EAAE,CAAA;gBAC5C,qDAAqD;gBACrD,wCAAwC;gBACxC,IAAI;gBACJ,mBAAmB;gBACnB,+CAA+C;gBAC/C,+BAA+B;gBAC/B,kCAAkC;gBAClC,sCAAsC;gBACtC,yBAAyB;gBACzB,qBAAqB;gBACrB,mCAAmC;gBACnC,aAAa;gBACb,QAAQ;gBACR,yCAAyC;gBACzC,WAAW;gBACX,sDAAsD;gBACtD,iDAAiD;gBACjD,QAAQ;gBACR,IAAI;gBAEJ,kEAAkE;gBAClE,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE,SAAS,EAAE,KAAK,CAAC,CAAA;YAC5C,+EAA+E;YACnF,CAAC,MAAM,IAAI,KAAK,EAAE,CAAC;gBACf,IAAI,CAAC,UAAU,CACX,KAAK,CAAC,GAAG,CAA0B,EACnC,QAAQ,EACR,KAAK,EACL,YAAY,CACf,CAAA;YACL,CAAC,MAAM,IAAI,QAAQ,EAAE,CAAC;gBAClB,IAAI,SAAS,GAAG,KAAK,GAAG,GAAG,GAAG,YAAY,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAA;gBAC5D,SAAS,GAAG,cAAA,WAAW,CAAC,UAAU,CAC9B,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB;oBAAE,MAAM,EAAE,IAAI;gBAAA,CAAE,EAChB,KAAK,EACL,SAAS,CACZ,CAAA;gBACD,+FAA+F;gBAC/F,qEAAqE;gBACrE,iFAAiF;gBAEjF,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAC7B,CAAC,IAAI,EAAE,CAAG,CAAD,GAAK,CAAC,KAAK,KAAK,SAAS,CACrC,CAAA;gBACD,IAAI,CAAC,SAAS,EAAE,CAAC;oBACb,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;wBACZ,IAAI,EAAE,MAAM;wBACZ,MAAM,EAAE,KAAK;wBACb,KAAK,EAAE,SAAS;wBAChB,WAAW,EAAE,KAAK;wBAClB,SAAS,EAAE,SAAS;wBACpB,gBAAgB,EAAE,QAAQ;qBAC7B,CAAC,CAAA;gBACN,CAAC;gBACD,IAAI,CAAC,UAAU,CACX,KAAK,CAAC,GAAG,CAA0B,EACnC,QAAQ,CAAC,qBAAqB,EAC9B,SAAS,CACZ,CAAA;YACL,CAAC;QACL,CAAC;IACL,CAAC;IAES,UAAU,CAChB,KAAsD,EACtD,QAAwB,EACxB,KAAa,EACb,WAAoB,EAAA;QAEpB,IAAI,SAAS,GAAW,EAAE,CAAA;QAC1B,gFAAgF;QAChF,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;YACvB,IAAI,KAAK,CAAC,MAAM,EAAE,CAAC;gBACf,SAAS,GAAG,KAAK,CACZ,GAAG,CAAC,CAAC,SAAS,EAAE,EAAE;oBACf,OAAO,IAAI,CAAC,UAAU,CAClB,SAAS,EACT,QAAQ,EACR,KAAK,EACL,WAAW,CACd,CAAA;gBACL,CAAC,CAAC,CACD,MAAM,CAAC,CAAC,SAAS,EAAE,CAAG,CAAD,AAAE,CAAC,SAAS,CAAC,CAClC,GAAG,CAAC,CAAC,SAAS,EAAE,CAAG,CAAD,EAAI,GAAG,SAAS,GAAG,GAAG,CAAC,CACzC,IAAI,CAAC,MAAM,CAAC,CAAA;YACrB,CAAC;QACL,CAAC,MAAM,CAAC;YACJ,MAAM,aAAa,GAAa,EAAE,CAAA;YAClC,IAAK,MAAM,GAAG,IAAI,KAAK,CAAE,CAAC;gBACtB,IAAI,KAAK,CAAC,GAAG,CAAC,KAAK,SAAS,IAAI,KAAK,CAAC,GAAG,CAAC,KAAK,IAAI,EAAE,SAAQ;gBAE7D,MAAM,YAAY,GAAG,WAAW,CAAC,CAAC,CAAC,WAAW,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAA;gBAChE,MAAM,MAAM,GACR,QAAQ,CAAC,gCAAgC,CAAC,YAAY,CAAC,CAAA;gBAC3D,MAAM,KAAK,GACP,QAAQ,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;gBACvD,MAAM,QAAQ,GACV,QAAQ,CAAC,4BAA4B,CAAC,YAAY,CAAC,CAAA;gBAEvD,IAAI,CAAC,KAAK,IAAI,CAAC,MAAM,IAAI,CAAC,QAAQ,EAC9B,MAAM,IAAI,8BAAA,2BAA2B,CACjC,YAAY,EACZ,QAAQ,CACX,CAAA;gBAEL,IAAI,MAAM,EAAE,CAAC;oBACT,IAAI,SAAS,GAAG,GAAG,KAAK,CAAA,CAAA,EAAI,YAAY,EAAE,CAAA;oBAC1C,IAAI,MAAM,CAAC,iBAAiB,IAAI,MAAM,CAAC,KAAK,EAAE,CAAC;wBAC3C,SAAS,GAAG,CAAA,CAAA,EAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAA,CAAA,CAAG,CAAA;oBACvD,CAAC;oBACD,gGAAgG;oBAEhG,mDAAmD;oBACnD,IAAI,cAAc,GAAG,KAAK,CAAC,GAAG,CAAC,CAAA;oBAC/B,IAAI,kBAAA,eAAe,CAAC,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC;wBAC9C,cAAc,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,CAAA;oBACrC,CAAC;oBAED,IAAI,MAAM,CAAC,WAAW,EAAE,CAAC;wBACrB,IAAI,cAAc,YAAY,eAAA,YAAY,EAAE,CAAC;4BACzC,cAAc,CAAC,cAAc,CAAC,MAAM,CAAC,WAAW,CAAC,CAAA;wBACrD,CAAC,MAAM,CAAC;4BACJ,cAAc,GAAG,yBAAA,sBAAsB,CAAC,WAAW,CAC/C,MAAM,CAAC,WAAW,EAClB,cAAc,CACjB,CAAA;wBACL,CAAC;oBACL,CAAC;oBAED,4DAA4D;oBAC5D,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;wBAClD,cAAc,GACV,IAAI,CAAC,UAAU,CAAC,MACnB,CAAC,iBAAiB,CAAC,MAAM,EAAE,cAAc,CAAC,CAAA;oBAC/C,CAAC;oBAED,iCAAiC;oBACjC,kDAAkD;oBAClD,EAAE;oBACF,uDAAuD;oBACvD,qCAAqC;oBACrC,4CAA4C;oBAC5C,mIAAmI;oBACnI,4FAA4F;oBAC5F,SAAS;oBACT,qHAAqH;oBACrH,+DAA+D;oBAC/D,0DAA0D;oBAC1D,SAAS;oBACT,0BAA0B;oBAC1B,wHAAwH;oBACxH,uCAAuC;oBACvC,2IAA2I;oBAC3I,mBAAmB;oBACnB,iBAAiB;oBACjB,WAAW;oBACX,0BAA0B;oBAC1B,0GAA0G;oBAC1G,4EAA4E;oBAC5E,QAAQ;oBACR,EAAE;oBACF,WAAW;oBACX,2EAA2E;oBAC3E,wBAAwB;oBACxB,mGAAmG;oBACnG,yDAAyD;oBACzD,IAAI;oBAEJ,aAAa,CAAC,IAAI,CACd,IAAI,CAAC,8BAA8B,CAC/B,IAAI,CAAC,0BAA0B,CAC3B,SAAS,EACT,cAAc,CACjB,CACJ,CAEJ,CAAA;gBAED,oEAAoE;gBACpE,wGAAwG;gBAC5G,CAAC,MAAM,IAAI,KAAK,EAAE,CAAC;oBACf,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAC7B,KAAK,CAAC,GAAG,CAAC,EACV,QAAQ,EACR,KAAK,EACL,YAAY,CACf,CAAA;oBACD,IAAI,SAAS,EAAE,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;gBAChD,CAAC,MAAM,IAAI,QAAQ,EAAE,CAAC;oBAClB,0EAA0E;oBAC1E,wEAAwE;oBACxE,IAAI,OAAO,KAAK,CAAC,GAAG,CAAC,KAAK,QAAQ,EAAE,CAAC;wBACjC,MAAM,eAAe,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CACjD,CAAC,CAAC,EAAE,CAAG,CAAD,IAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,SAAS,CACrC,CAAA;wBACD,IAAI,eAAe,EAAE,CAAC;4BAClB,SAAQ;wBACZ,CAAC;oBACL,CAAC;oBAED,IAAI,kBAAA,eAAe,CAAC,cAAc,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC;wBAC7C,IACI,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,UAAU,IAC9B,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,UAAU,IAC9B,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,iBAAiB,IACrC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,iBAAiB,EACvC,CAAC;4BACC,IAAI,WAAW,GAAG,EAAE,CAAA;4BACpB,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,UAAU,EAAE,CAAC;gCACjC,WAAW,GAAG,GAAG,CAAA;4BACrB,CAAC,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,UAAU,EAAE,CAAC;gCACxC,WAAW,GAAG,GAAG,CAAA;4BACrB,CAAC,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,iBAAiB,EAAE,CAAC;gCAC/C,WAAW,GAAG,IAAI,CAAA;4BACtB,CAAC,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,iBAAiB,EAAE,CAAC;gCAC/C,WAAW,GAAG,IAAI,CAAA;4BACtB,CAAC;4BACD,yCAAyC;4BACzC,MAAM,EAAE,GAAsB,IAAI,CAAC,QAAQ,EAAE,CAAA;4BAC7C,IAAI,QAAQ,CAAC,iBAAiB,EAAE,CAAC;gCAC7B,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,CAChB,IAAI,CACD,QAAQ,CAAC,aAAa,EACtB,QAAQ,CAAC,aAAa,CACzB,CACA,KAAK,CACF,QAAQ,CAAC,WAAW,CACf,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE;oCACZ,OAAO,GACH,QAAQ,CAAC,aACb,CAAA,CAAA,EACI,MAAM,CAAC,YACX,CAAA,GAAA,EAAM,KAAK,CAAA,CAAA,EACP,MAAM,CAAC,gBAAiB,CACnB,YACT,EAAE,CAAA;gCACN,CAAC,CAAC,CACD,IAAI,CAAC,OAAO,CAAC,CACrB,CAAA;4BACT,CAAC,MAAM,IAAI,QAAQ,CAAC,oBAAoB,EAAE,CAAC;gCACvC,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,CAChB,IAAI,CACD,QAAQ,CAAC,eAAgB,CAAC,aAAa,EACvC,QAAQ,CAAC,eAAgB,CAAC,aAAa,CAC1C,CACA,KAAK,CACF,QAAQ,CACH,eAAgB,CAAC,kBAAkB,CAAC,GAAG,CACpC,CAAC,MAAM,EAAE,EAAE;oCACP,OAAO,GACH,QAAQ,CAAC,eAAgB,CACpB,aACT,CAAA,CAAA,EACI,MAAM,CAAC,YACX,CAAA,GAAA,EAAM,KAAK,CAAA,CAAA,EACP,MAAM,CAAC,gBAAiB,CACnB,YACT,EAAE,CAAA;gCACN,CAAC,CACJ,CACA,IAAI,CAAC,OAAO,CAAC,CACrB,CAAA;4BACT,CAAC,MAAM,IAAI,QAAQ,CAAC,WAAW,EAAE,CAAC;gCAC9B,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,CAChB,IAAI,CACD,QAAQ,CAAC,qBAAqB,CAAC,MAAM,EACrC,QAAQ,CAAC,qBAAqB,CACzB,SAAS,CACjB,CACA,KAAK,CACF,QAAQ,CACH,eAAgB,CAAC,WAAW,CAAC,GAAG,CAC7B,CAAC,MAAM,EAAE,EAAE;oCACP,OAAO,GACH,QAAQ,CACH,qBAAqB,CACrB,SACT,CAAA,CAAA,EACI,MAAM,CAAC,YACX,CAAA,GAAA,EAAM,KAAK,CAAA,CAAA,EACP,MAAM,CAAC,gBAAiB,CACnB,YACT,EAAE,CAAA;gCACN,CAAC,CACJ,CACA,IAAI,CAAC,OAAO,CAAC,CACrB,CAAA;4BACT,CAAC,MAAM,CAAC;gCACJ,MAAM,IAAI,KAAK,CACX,CAAA,oDAAA,CAAsD,CACzD,CAAA;4BACL,CAAC;4BACD,OAAO;4BACP,mEAAmE;4BACnE,0HAA0H;4BAC1H,IAAI,CAAC,QAAQ,CACT,EAAE,CAAC,MAAM,EAAE,GACP,GAAG,GACH,WAAW,GACX,GAAG,GACH,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CACjC,CAAA;wBACL,CAAC,MAAM,CAAC;4BACJ,IACI,QAAQ,CAAC,WAAW,IACnB,QAAQ,CAAC,UAAU,IAChB,QAAQ,CAAC,eAAe,CAAC,CAC/B,CAAC;gCACC,MAAM,SAAS,GAAG,GAAG,KAAK,CAAA,CAAA,EAAI,YAAY,EAAE,CAAA;gCAE5C,aAAa,CAAC,IAAI,CACd,IAAI,CAAC,8BAA8B,CAC/B,IAAI,CAAC,0BAA0B,CAC3B,SAAS,EACT,KAAK,CAAC,GAAG,CAAC,CACb,CACJ,CACJ,CAAA;4BACL,CAAC,MAAM,CAAC;gCACJ,MAAM,IAAI,KAAK,CACX,CAAA,oDAAA,CAAsD,CACzD,CAAA;4BACL,CAAC;wBACL,CAAC;oBACL,CAAC,MAAM,CAAC;wBACJ,yDAAyD;wBACzD,IAAI,SAAS,GACT,KAAK,GACL,GAAG,GACH,QAAQ,CAAC,YAAY,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAA;wBAC3C,SAAS,GAAG,cAAA,WAAW,CAAC,UAAU,CAC9B,IAAI,CAAC,UAAU,CAAC,MAAM,EACtB;4BAAE,MAAM,EAAE,IAAI;wBAAA,CAAE,EAChB,KAAK,EACL,SAAS,CACZ,CAAA;wBAED,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAC7B,CAAC,IAAI,EAAE,CAAG,CAAD,GAAK,CAAC,KAAK,KAAK,SAAS,CACrC,CAAA;wBACD,IAAI,CAAC,SAAS,EAAE,CAAC;4BACb,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gCACZ,IAAI,EAAE,MAAM;gCACZ,MAAM,EAAE,KAAK;gCACb,SAAS,EAAE,SAAS;gCACpB,KAAK,EAAE,SAAS;gCAChB,WAAW,EAAE,KAAK;gCAClB,gBAAgB,EAAE,QAAQ;6BAC7B,CAAC,CAAA;wBACN,CAAC;wBAED,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAC7B,KAAK,CAAC,GAAG,CAAC,EACV,QAAQ,CAAC,qBAAqB,EAC9B,SAAS,CACZ,CAAA;wBACD,IAAI,SAAS,EAAE,CAAC;4BACZ,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA;wBAC7B,4EAA4E;wBAChF,CAAC;oBACL,CAAC;gBACL,CAAC;YACL,CAAC;YACD,SAAS,GAAG,aAAa,CAAC,MAAM,GAC1B,GAAG,GAAG,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,GAAG,GACzC,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;QACrC,CAAC;QACD,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,SAAS,GAAG,GAAG,CAAC,CAAC,CAAC,SAAS,CAAA;IAC/D,CAAC;CACJ;AAp3ID,QAAA,kBAAA,GAAA,mBAo3IC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6170, "column": 0}, "map": {"version":3,"file":"UpdateResult.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/result/UpdateResult.ts"],"sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { QueryResult } from \"../../query-runner/QueryResult\"\n\n/**\n * Result object returned by UpdateQueryBuilder execution.\n */\nexport class UpdateResult {\n    static from(queryResult: QueryResult) {\n        const result = new this()\n        result.raw = queryResult.records\n        result.affected = queryResult.affected\n        return result\n    }\n\n    /**\n     * Raw SQL result returned by executed query.\n     */\n    raw: any\n\n    /**\n     * Number of affected rows/documents\n     * Not all drivers support this\n     */\n    affected?: number\n\n    /**\n     * Contains inserted entity id.\n     * Has entity-like structure (not just column database name and values).\n     */\n    // identifier: ObjectLiteral[] = [];\n\n    /**\n     * Generated values returned by a database.\n     * Has entity-like structure (not just column database name and values).\n     */\n    generatedMaps: ObjectLiteral[] = []\n}\n"],"names":[],"mappings":";;;;;AAGA;;GAEG,CACH,MAAa,YAAY;IAAzB,aAAA;QAmBI;;;WAGG,CACH,oCAAoC;QAEpC;;;WAGG,CACH,IAAA,CAAA,aAAa,GAAoB,EAAE,CAAA;IACvC,CAAC;IA7BG,MAAM,CAAC,IAAI,CAAC,WAAwB,EAAA;QAChC,MAAM,MAAM,GAAG,IAAI,IAAI,EAAE,CAAA;QACzB,MAAM,CAAC,GAAG,GAAG,WAAW,CAAC,OAAO,CAAA;QAChC,MAAM,CAAC,QAAQ,GAAG,WAAW,CAAC,QAAQ,CAAA;QACtC,OAAO,MAAM,CAAA;IACjB,CAAC;CAwBJ;AA9BD,QAAA,YAAA,GAAA,aA8BC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6201, "column": 0}, "map": {"version":3,"file":"SoftDeleteQueryBuilder.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/SoftDeleteQueryBuilder.ts"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { EntityTarget } from \"../common/EntityTarget\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { WhereExpressionBuilder } from \"./WhereExpressionBuilder\"\nimport { Brackets } from \"./Brackets\"\nimport { UpdateResult } from \"./result/UpdateResult\"\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\"\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { LimitOnUpdateNotSupportedError } from \"../error/LimitOnUpdateNotSupportedError\"\nimport { MissingDeleteDateColumnError } from \"../error/MissingDeleteDateColumnError\"\nimport { UpdateValuesMissingError } from \"../error/UpdateValuesMissingError\"\nimport { TypeORMError } from \"../error\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\nimport { InstanceChecker } from \"../util/InstanceChecker\"\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SoftDeleteQueryBuilder<Entity extends ObjectLiteral>\n    extends QueryBuilder<Entity>\n    implements WhereExpressionBuilder\n{\n    readonly \"@instanceof\" = Symbol.for(\"SoftDeleteQueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        connectionOrQueryBuilder: DataSource | QueryBuilder<any>,\n        queryRunner?: QueryRunner,\n    ) {\n        super(connectionOrQueryBuilder as any, queryRunner)\n        this.expressionMap.aliasNamePrefixingEnabled = false\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createUpdateExpression()\n        sql += this.createCteExpression()\n        sql += this.createOrderByExpression()\n        sql += this.createLimitExpression()\n        return this.replacePropertyNamesForTheWholeQuery(sql.trim())\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<UpdateResult> {\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            // call before soft remove and recover methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                if (this.expressionMap.queryType === \"soft-delete\")\n                    await queryRunner.broadcaster.broadcast(\n                        \"BeforeSoftRemove\",\n                        this.expressionMap.mainAlias!.metadata,\n                    )\n                else if (this.expressionMap.queryType === \"restore\")\n                    await queryRunner.broadcaster.broadcast(\n                        \"BeforeRecover\",\n                        this.expressionMap.mainAlias!.metadata,\n                    )\n            }\n\n            // if update entity mode is enabled we may need extra columns for the returning statement\n            const returningResultsEntityUpdator =\n                new ReturningResultsEntityUpdator(\n                    queryRunner,\n                    this.expressionMap,\n                )\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0\n            ) {\n                this.expressionMap.extraReturningColumns =\n                    returningResultsEntityUpdator.getSoftDeletionReturningColumns()\n            }\n\n            // execute update query\n            const [sql, parameters] = this.getQueryAndParameters()\n\n            const queryResult = await queryRunner.query(sql, parameters, true)\n            const updateResult = UpdateResult.from(queryResult)\n\n            // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0\n            ) {\n                await returningResultsEntityUpdator.update(\n                    updateResult,\n                    this.expressionMap.whereEntities,\n                )\n            }\n\n            // call after soft remove and recover methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                if (this.expressionMap.queryType === \"soft-delete\")\n                    await queryRunner.broadcaster.broadcast(\n                        \"AfterSoftRemove\",\n                        this.expressionMap.mainAlias!.metadata,\n                    )\n                else if (this.expressionMap.queryType === \"restore\")\n                    await queryRunner.broadcaster.broadcast(\n                        \"AfterRecover\",\n                        this.expressionMap.mainAlias!.metadata,\n                    )\n            }\n\n            // close transaction if we started it\n            if (transactionStartedByUs) await queryRunner.commitTransaction()\n\n            return updateResult\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Specifies FROM which entity's table select/update/delete/soft-delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    from<T extends ObjectLiteral>(\n        entityTarget: EntityTarget<T>,\n        aliasName?: string,\n    ): SoftDeleteQueryBuilder<T> {\n        entityTarget = InstanceChecker.isEntitySchema(entityTarget)\n            ? entityTarget.options.name\n            : entityTarget\n        const mainAlias = this.createFromAlias(entityTarget, aliasName)\n        this.expressionMap.setMainAlias(mainAlias)\n        return this as any as SoftDeleteQueryBuilder<T>\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres = [] // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.getWhereCondition(where)\n        if (condition)\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ]\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    whereInIds(ids: any | any[]): this {\n        return this.where(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    andWhereInIds(ids: any | any[]): this {\n        return this.andWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     */\n    orWhereInIds(ids: any | any[]): this {\n        return this.orWhere(this.getWhereInIdsCondition(ids))\n    }\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    output(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    output(output: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this {\n        return this.returning(output)\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    returning(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    returning(returning: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this {\n        // not all databases support returning/output cause\n        if (!this.connection.driver.isReturningSqlSupported(\"update\")) {\n            throw new ReturningStatementNotSupportedError()\n        }\n\n        this.expressionMap.returning = returning\n        return this\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort: string,\n        order?: \"ASC\" | \"DESC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort?: string | OrderByCondition,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (sort) {\n            if (typeof sort === \"object\") {\n                this.expressionMap.orderBys = sort as OrderByCondition\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort as string]: { order, nulls },\n                    }\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order }\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {}\n        }\n        return this\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(\n        sort: string,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls }\n        } else {\n            this.expressionMap.orderBys[sort] = order\n        }\n        return this\n    }\n\n    /**\n     * Sets LIMIT - maximum number of rows to be selected.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = limit\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    whereEntity(entity: Entity | Entity[]): this {\n        if (!this.expressionMap.mainAlias!.hasMetadata)\n            throw new TypeORMError(\n                `.whereEntity method can only be used on queries which update real entity table.`,\n            )\n\n        this.expressionMap.wheres = []\n        const entities: Entity[] = Array.isArray(entity) ? entity : [entity]\n        entities.forEach((entity) => {\n            const entityIdMap =\n                this.expressionMap.mainAlias!.metadata.getEntityIdMap(entity)\n            if (!entityIdMap)\n                throw new TypeORMError(\n                    `Provided entity does not have ids set, cannot perform operation.`,\n                )\n\n            this.orWhereInIds(entityIdMap)\n        })\n\n        this.expressionMap.whereEntities = entities\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    updateEntity(enabled: boolean): this {\n        this.expressionMap.updateEntity = enabled\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates UPDATE express used to perform insert query.\n     */\n    protected createUpdateExpression() {\n        const metadata = this.expressionMap.mainAlias!.hasMetadata\n            ? this.expressionMap.mainAlias!.metadata\n            : undefined\n        if (!metadata)\n            throw new TypeORMError(\n                `Cannot get entity metadata for the given alias \"${this.expressionMap.mainAlias}\"`,\n            )\n        if (!metadata.deleteDateColumn) {\n            throw new MissingDeleteDateColumnError(metadata)\n        }\n\n        // prepare columns and values to be updated\n        const updateColumnAndValues: string[] = []\n\n        switch (this.expressionMap.queryType) {\n            case \"soft-delete\":\n                updateColumnAndValues.push(\n                    this.escape(metadata.deleteDateColumn.databaseName) +\n                        \" = CURRENT_TIMESTAMP\",\n                )\n                break\n            case \"restore\":\n                updateColumnAndValues.push(\n                    this.escape(metadata.deleteDateColumn.databaseName) +\n                        \" = NULL\",\n                )\n                break\n            default:\n                throw new TypeORMError(\n                    `The queryType must be \"soft-delete\" or \"restore\"`,\n                )\n        }\n        if (metadata.versionColumn)\n            updateColumnAndValues.push(\n                this.escape(metadata.versionColumn.databaseName) +\n                    \" = \" +\n                    this.escape(metadata.versionColumn.databaseName) +\n                    \" + 1\",\n            )\n        if (metadata.updateDateColumn)\n            updateColumnAndValues.push(\n                this.escape(metadata.updateDateColumn.databaseName) +\n                    \" = CURRENT_TIMESTAMP\",\n            ) // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can \"DEFAULT\" be used?!\n\n        if (updateColumnAndValues.length <= 0) {\n            throw new UpdateValuesMissingError()\n        }\n\n        // get a table name and all column database names\n        const whereExpression = this.createWhereExpression()\n        const returningExpression = this.createReturningExpression(\"update\")\n\n        if (returningExpression === \"\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\", \")}${whereExpression}` // todo: how do we replace aliases in where to nothing?\n        }\n        if (this.connection.driver.options.type === \"mssql\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\n                \", \",\n            )} OUTPUT ${returningExpression}${whereExpression}`\n        }\n        return `UPDATE ${this.getTableName(\n            this.getMainTableName(),\n        )} SET ${updateColumnAndValues.join(\n            \", \",\n        )}${whereExpression} RETURNING ${returningExpression}`\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.orderBys\n        if (Object.keys(orderBys).length > 0)\n            return (\n                \" ORDER BY \" +\n                Object.keys(orderBys)\n                    .map((columnName) => {\n                        if (typeof orderBys[columnName] === \"string\") {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                orderBys[columnName]\n                            )\n                        } else {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                (orderBys[columnName] as any).order +\n                                \" \" +\n                                (orderBys[columnName] as any).nulls\n                            )\n                        }\n                    })\n                    .join(\", \")\n            )\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LIMIT\" parts of SQL query.\n     */\n    protected createLimitExpression(): string {\n        const limit: number | undefined = this.expressionMap.limit\n\n        if (limit) {\n            if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n                return \" LIMIT \" + limit\n            } else {\n                throw new LimitOnUpdateNotSupportedError()\n            }\n        }\n\n        return \"\"\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6516, "column": 0}, "map": {"version":3,"file":"UpdateQueryBuilder.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/UpdateQueryBuilder.ts"],"sourcesContent":["import { ColumnMetadata } from \"../metadata/ColumnMetadata\"\nimport { QueryBuilder } from \"./QueryBuilder\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { DataSource } from \"../data-source/DataSource\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { WhereExpressionBuilder } from \"./WhereExpressionBuilder\"\nimport { Brackets } from \"./Brackets\"\nimport { UpdateResult } from \"./result/UpdateResult\"\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\"\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\"\nimport { MysqlDriver } from \"../driver/mysql/MysqlDriver\"\nimport { OrderByCondition } from \"../find-options/OrderByCondition\"\nimport { LimitOnUpdateNotSupportedError } from \"../error/LimitOnUpdateNotSupportedError\"\nimport { UpdateValuesMissingError } from \"../error/UpdateValuesMissingError\"\nimport { QueryDeepPartialEntity } from \"./QueryPartialEntity\"\nimport { AuroraMysqlDriver } from \"../driver/aurora-mysql/AuroraMysqlDriver\"\nimport { TypeORMError } from \"../error\"\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\"\nimport { SqlServerDriver } from \"../driver/sqlserver/SqlServerDriver\"\nimport { DriverUtils } from \"../driver/DriverUtils\"\n\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class UpdateQueryBuilder<Entity extends ObjectLiteral>\n    extends QueryBuilder<Entity>\n    implements WhereExpressionBuilder\n{\n    readonly \"@instanceof\" = Symbol.for(\"UpdateQueryBuilder\")\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        connectionOrQueryBuilder: DataSource | QueryBuilder<any>,\n        queryRunner?: QueryRunner,\n    ) {\n        super(connectionOrQueryBuilder as any, queryRunner)\n        this.expressionMap.aliasNamePrefixingEnabled = false\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery(): string {\n        let sql = this.createComment()\n        sql += this.createCteExpression()\n        sql += this.createUpdateExpression()\n        sql += this.createOrderByExpression()\n        sql += this.createLimitExpression()\n        return this.replacePropertyNamesForTheWholeQuery(sql.trim())\n    }\n\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute(): Promise<UpdateResult> {\n        const queryRunner = this.obtainQueryRunner()\n        let transactionStartedByUs: boolean = false\n\n        try {\n            // start transaction if it was enabled\n            if (\n                this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false\n            ) {\n                await queryRunner.startTransaction()\n                transactionStartedByUs = true\n            }\n\n            // call before updation methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                await queryRunner.broadcaster.broadcast(\n                    \"BeforeUpdate\",\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.valuesSet,\n                )\n            }\n\n            let declareSql: string | null = null\n            let selectOutputSql: string | null = null\n\n            // if update entity mode is enabled we may need extra columns for the returning statement\n            const returningResultsEntityUpdator =\n                new ReturningResultsEntityUpdator(\n                    queryRunner,\n                    this.expressionMap,\n                )\n\n            const returningColumns: ColumnMetadata[] = []\n\n            if (\n                Array.isArray(this.expressionMap.returning) &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                for (const columnPath of this.expressionMap.returning) {\n                    returningColumns.push(\n                        ...this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(\n                            columnPath,\n                        ),\n                    )\n                }\n            }\n\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0\n            ) {\n                this.expressionMap.extraReturningColumns =\n                    returningResultsEntityUpdator.getUpdationReturningColumns()\n\n                returningColumns.push(\n                    ...this.expressionMap.extraReturningColumns.filter(\n                        (c) => !returningColumns.includes(c),\n                    ),\n                )\n            }\n\n            if (\n                returningColumns.length > 0 &&\n                this.connection.driver.options.type === \"mssql\"\n            ) {\n                declareSql = (\n                    this.connection.driver as SqlServerDriver\n                ).buildTableVariableDeclaration(\n                    \"@OutputTable\",\n                    returningColumns,\n                )\n                selectOutputSql = `SELECT * FROM @OutputTable`\n            }\n\n            // execute update query\n            const [updateSql, parameters] = this.getQueryAndParameters()\n\n            const statements = [declareSql, updateSql, selectOutputSql]\n            const queryResult = await queryRunner.query(\n                statements.filter((sql) => sql != null).join(\";\\n\\n\"),\n                parameters,\n                true,\n            )\n            const updateResult = UpdateResult.from(queryResult)\n\n            // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)\n            if (\n                this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias!.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0\n            ) {\n                await returningResultsEntityUpdator.update(\n                    updateResult,\n                    this.expressionMap.whereEntities,\n                )\n            }\n\n            // call after updation methods in listeners and subscribers\n            if (\n                this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias!.hasMetadata\n            ) {\n                await queryRunner.broadcaster.broadcast(\n                    \"AfterUpdate\",\n                    this.expressionMap.mainAlias!.metadata,\n                    this.expressionMap.valuesSet,\n                )\n            }\n\n            // close transaction if we started it\n            if (transactionStartedByUs) await queryRunner.commitTransaction()\n\n            return updateResult\n        } catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction()\n                } catch (rollbackError) {}\n            }\n            throw error\n        } finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release()\n            }\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Values needs to be updated.\n     */\n    set(values: QueryDeepPartialEntity<Entity>): this {\n        this.expressionMap.valuesSet = values\n        return this\n    }\n\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres = [] // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.getWhereCondition(where)\n        if (condition)\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ]\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(\n        where:\n            | string\n            | ((qb: this) => string)\n            | Brackets\n            | ObjectLiteral\n            | ObjectLiteral[],\n        parameters?: ObjectLiteral,\n    ): this {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.getWhereCondition(where),\n        })\n        if (parameters) this.setParameters(parameters)\n        return this\n    }\n\n    /**\n     * Sets WHERE condition in the query builder with a condition for the given ids.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     */\n    whereInIds(ids: any | any[]): this {\n        return this.where(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    andWhereInIds(ids: any | any[]): this {\n        return this.andWhere(this.getWhereInIdsCondition(ids))\n    }\n\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     */\n    orWhereInIds(ids: any | any[]): this {\n        return this.orWhere(this.getWhereInIdsCondition(ids))\n    }\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    output(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    output(output: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    output(output: string | string[]): this {\n        return this.returning(output)\n    }\n\n    /**\n     * Optional returning/output clause.\n     * This will return given column values.\n     */\n    returning(columns: string[]): this\n\n    /**\n     * Optional returning/output clause.\n     * Returning is a SQL string containing returning statement.\n     */\n    returning(returning: string): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this\n\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning: string | string[]): this {\n        // not all databases support returning/output cause\n        if (!this.connection.driver.isReturningSqlSupported(\"update\")) {\n            throw new ReturningStatementNotSupportedError()\n        }\n\n        this.expressionMap.returning = returning\n        return this\n    }\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     *\n     * Calling order by without order set will remove all previously set order bys.\n     */\n    orderBy(): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort: string,\n        order?: \"ASC\" | \"DESC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(order: OrderByCondition): this\n\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(\n        sort?: string | OrderByCondition,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (sort) {\n            if (typeof sort === \"object\") {\n                this.expressionMap.orderBys = sort as OrderByCondition\n            } else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort as string]: { order, nulls },\n                    }\n                } else {\n                    this.expressionMap.orderBys = { [sort as string]: order }\n                }\n            }\n        } else {\n            this.expressionMap.orderBys = {}\n        }\n        return this\n    }\n\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(\n        sort: string,\n        order: \"ASC\" | \"DESC\" = \"ASC\",\n        nulls?: \"NULLS FIRST\" | \"NULLS LAST\",\n    ): this {\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls }\n        } else {\n            this.expressionMap.orderBys[sort] = order\n        }\n        return this\n    }\n\n    /**\n     * Sets LIMIT - maximum number of rows to be selected.\n     */\n    limit(limit?: number): this {\n        this.expressionMap.limit = limit\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    whereEntity(entity: Entity | Entity[]): this {\n        if (!this.expressionMap.mainAlias!.hasMetadata)\n            throw new TypeORMError(\n                `.whereEntity method can only be used on queries which update real entity table.`,\n            )\n\n        this.expressionMap.wheres = []\n        const entities: Entity[] = Array.isArray(entity) ? entity : [entity]\n        entities.forEach((entity) => {\n            const entityIdMap =\n                this.expressionMap.mainAlias!.metadata.getEntityIdMap(entity)\n            if (!entityIdMap)\n                throw new TypeORMError(\n                    `Provided entity does not have ids set, cannot perform operation.`,\n                )\n\n            this.orWhereInIds(entityIdMap)\n        })\n\n        this.expressionMap.whereEntities = entities\n        return this\n    }\n\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    updateEntity(enabled: boolean): this {\n        this.expressionMap.updateEntity = enabled\n        return this\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates UPDATE express used to perform insert query.\n     */\n    protected createUpdateExpression() {\n        const valuesSet = this.getValueSet()\n        const metadata = this.expressionMap.mainAlias!.hasMetadata\n            ? this.expressionMap.mainAlias!.metadata\n            : undefined\n\n        // it doesn't make sense to update undefined properties, so just skip them\n        const valuesSetNormalized: ObjectLiteral = {}\n        for (const key in valuesSet) {\n            if (valuesSet[key] !== undefined) {\n                valuesSetNormalized[key] = valuesSet[key]\n            }\n        }\n\n        // prepare columns and values to be updated\n        const updateColumnAndValues: string[] = []\n        const updatedColumns: ColumnMetadata[] = []\n        if (metadata) {\n            this.createPropertyPath(metadata, valuesSetNormalized).forEach(\n                (propertyPath) => {\n                    // todo: make this and other query builder to work with properly with tables without metadata\n                    const columns =\n                        metadata.findColumnsWithPropertyPath(propertyPath)\n\n                    if (columns.length <= 0) {\n                        throw new EntityPropertyNotFoundError(\n                            propertyPath,\n                            metadata,\n                        )\n                    }\n\n                    columns.forEach((column) => {\n                        if (\n                            !column.isUpdate ||\n                            updatedColumns.includes(column)\n                        ) {\n                            return\n                        }\n\n                        updatedColumns.push(column)\n\n                        //\n                        let value = column.getEntityValue(valuesSetNormalized)\n                        if (\n                            column.referencedColumn &&\n                            typeof value === \"object\" &&\n                            !(value instanceof Date) &&\n                            value !== null &&\n                            !Buffer.isBuffer(value)\n                        ) {\n                            value =\n                                column.referencedColumn.getEntityValue(value)\n                        } else if (!(typeof value === \"function\")) {\n                            value =\n                                this.connection.driver.preparePersistentValue(\n                                    value,\n                                    column,\n                                )\n                        }\n\n                        // todo: duplication zone\n                        if (typeof value === \"function\") {\n                            // support for SQL expressions in update query\n                            updateColumnAndValues.push(\n                                this.escape(column.databaseName) +\n                                    \" = \" +\n                                    value(),\n                            )\n                        } else if (\n                            (this.connection.driver.options.type === \"sap\" ||\n                                this.connection.driver.options.type ===\n                                    \"spanner\") &&\n                            value === null\n                        ) {\n                            updateColumnAndValues.push(\n                                this.escape(column.databaseName) + \" = NULL\",\n                            )\n                        } else {\n                            if (\n                                this.connection.driver.options.type === \"mssql\"\n                            ) {\n                                value = (\n                                    this.connection.driver as SqlServerDriver\n                                ).parametrizeValue(column, value)\n                            }\n\n                            const paramName = this.createParameter(value)\n\n                            let expression = null\n                            if (\n                                (DriverUtils.isMySQLFamily(\n                                    this.connection.driver,\n                                ) ||\n                                    this.connection.driver.options.type ===\n                                        \"aurora-mysql\") &&\n                                this.connection.driver.spatialTypes.indexOf(\n                                    column.type,\n                                ) !== -1\n                            ) {\n                                const useLegacy = (\n                                    this.connection.driver as\n                                        | MysqlDriver\n                                        | AuroraMysqlDriver\n                                ).options.legacySpatialSupport\n                                const geomFromText = useLegacy\n                                    ? \"GeomFromText\"\n                                    : \"ST_GeomFromText\"\n                                if (column.srid != null) {\n                                    expression = `${geomFromText}(${paramName}, ${column.srid})`\n                                } else {\n                                    expression = `${geomFromText}(${paramName})`\n                                }\n                            } else if (\n                                DriverUtils.isPostgresFamily(\n                                    this.connection.driver,\n                                ) &&\n                                this.connection.driver.spatialTypes.indexOf(\n                                    column.type,\n                                ) !== -1\n                            ) {\n                                if (column.srid != null) {\n                                    expression = `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`\n                                } else {\n                                    expression = `ST_GeomFromGeoJSON(${paramName})::${column.type}`\n                                }\n                            } else if (\n                                this.connection.driver.options.type ===\n                                    \"mssql\" &&\n                                this.connection.driver.spatialTypes.indexOf(\n                                    column.type,\n                                ) !== -1\n                            ) {\n                                expression =\n                                    column.type +\n                                    \"::STGeomFromText(\" +\n                                    paramName +\n                                    \", \" +\n                                    (column.srid || \"0\") +\n                                    \")\"\n                            } else {\n                                expression = paramName\n                            }\n                            updateColumnAndValues.push(\n                                this.escape(column.databaseName) +\n                                    \" = \" +\n                                    expression,\n                            )\n                        }\n                    })\n                },\n            )\n\n            // Don't allow calling update only with columns that are `update: false`\n            if (\n                updateColumnAndValues.length > 0 ||\n                Object.keys(valuesSetNormalized).length === 0\n            ) {\n                if (\n                    metadata.versionColumn &&\n                    updatedColumns.indexOf(metadata.versionColumn) === -1\n                )\n                    updateColumnAndValues.push(\n                        this.escape(metadata.versionColumn.databaseName) +\n                            \" = \" +\n                            this.escape(metadata.versionColumn.databaseName) +\n                            \" + 1\",\n                    )\n                if (\n                    metadata.updateDateColumn &&\n                    updatedColumns.indexOf(metadata.updateDateColumn) === -1\n                )\n                    updateColumnAndValues.push(\n                        this.escape(metadata.updateDateColumn.databaseName) +\n                            \" = CURRENT_TIMESTAMP\",\n                    ) // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can \"DEFAULT\" be used?!\n            }\n        } else {\n            Object.keys(valuesSetNormalized).map((key) => {\n                const value = valuesSetNormalized[key]\n\n                // todo: duplication zone\n                if (typeof value === \"function\") {\n                    // support for SQL expressions in update query\n                    updateColumnAndValues.push(\n                        this.escape(key) + \" = \" + value(),\n                    )\n                } else if (\n                    (this.connection.driver.options.type === \"sap\" ||\n                        this.connection.driver.options.type === \"spanner\") &&\n                    value === null\n                ) {\n                    updateColumnAndValues.push(this.escape(key) + \" = NULL\")\n                } else {\n                    // we need to store array values in a special class to make sure parameter replacement will work correctly\n                    // if (value instanceof Array)\n                    //     value = new ArrayParameter(value);\n\n                    const paramName = this.createParameter(value)\n                    updateColumnAndValues.push(\n                        this.escape(key) + \" = \" + paramName,\n                    )\n                }\n            })\n        }\n\n        if (updateColumnAndValues.length <= 0) {\n            throw new UpdateValuesMissingError()\n        }\n\n        // get a table name and all column database names\n        const whereExpression = this.createWhereExpression()\n        const returningExpression = this.createReturningExpression(\"update\")\n\n        if (returningExpression === \"\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\", \")}${whereExpression}` // todo: how do we replace aliases in where to nothing?\n        }\n        if (this.connection.driver.options.type === \"mssql\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\n                \", \",\n            )} OUTPUT ${returningExpression}${whereExpression}`\n        }\n        if (this.connection.driver.options.type === \"spanner\") {\n            return `UPDATE ${this.getTableName(\n                this.getMainTableName(),\n            )} SET ${updateColumnAndValues.join(\n                \", \",\n            )}${whereExpression} THEN RETURN ${returningExpression}`\n        }\n\n        return `UPDATE ${this.getTableName(\n            this.getMainTableName(),\n        )} SET ${updateColumnAndValues.join(\n            \", \",\n        )}${whereExpression} RETURNING ${returningExpression}`\n    }\n\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    protected createOrderByExpression() {\n        const orderBys = this.expressionMap.orderBys\n        if (Object.keys(orderBys).length > 0)\n            return (\n                \" ORDER BY \" +\n                Object.keys(orderBys)\n                    .map((columnName) => {\n                        if (typeof orderBys[columnName] === \"string\") {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                orderBys[columnName]\n                            )\n                        } else {\n                            return (\n                                this.replacePropertyNames(columnName) +\n                                \" \" +\n                                (orderBys[columnName] as any).order +\n                                \" \" +\n                                (orderBys[columnName] as any).nulls\n                            )\n                        }\n                    })\n                    .join(\", \")\n            )\n\n        return \"\"\n    }\n\n    /**\n     * Creates \"LIMIT\" parts of SQL query.\n     */\n    protected createLimitExpression(): string {\n        const limit: number | undefined = this.expressionMap.limit\n\n        if (limit) {\n            if (\n                DriverUtils.isMySQLFamily(this.connection.driver) ||\n                this.connection.driver.options.type === \"aurora-mysql\"\n            ) {\n                return \" LIMIT \" + limit\n            } else {\n                throw new LimitOnUpdateNotSupportedError()\n            }\n        }\n\n        return \"\"\n    }\n\n    /**\n     * Gets array of values need to be inserted into the target table.\n     */\n    protected getValueSet(): ObjectLiteral {\n        if (typeof this.expressionMap.valuesSet === \"object\")\n            return this.expressionMap.valuesSet\n\n        throw new UpdateValuesMissingError()\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6925, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/index.ts"],"sourcesContent":["import { DeleteQueryBuilder } from \"./DeleteQueryBuilder\"\nimport { InsertQueryBuilder } from \"./InsertQueryBuilder\"\nimport { QueryBuilder } from \"./QueryBuilder\"\nimport { RelationQueryBuilder } from \"./RelationQueryBuilder\"\nimport { SelectQueryBuilder } from \"./SelectQueryBuilder\"\nimport { SoftDeleteQueryBuilder } from \"./SoftDeleteQueryBuilder\"\nimport { UpdateQueryBuilder } from \"./UpdateQueryBuilder\"\n\nexport function registerQueryBuilders() {\n    QueryBuilder.registerQueryBuilderClass(\n        \"DeleteQueryBuilder\",\n        (qb: QueryBuilder<any>) => new DeleteQueryBuilder(qb),\n    )\n    QueryBuilder.registerQueryBuilderClass(\n        \"InsertQueryBuilder\",\n        (qb: QueryBuilder<any>) => new InsertQueryBuilder(qb),\n    )\n    QueryBuilder.registerQueryBuilderClass(\n        \"RelationQueryBuilder\",\n        (qb: QueryBuilder<any>) => new RelationQueryBuilder(qb),\n    )\n    QueryBuilder.registerQueryBuilderClass(\n        \"SelectQueryBuilder\",\n        (qb: QueryBuilder<any>) => new SelectQueryBuilder(qb),\n    )\n    QueryBuilder.registerQueryBuilderClass(\n        \"SoftDeleteQueryBuilder\",\n        (qb: QueryBuilder<any>) => new SoftDeleteQueryBuilder(qb),\n    )\n    QueryBuilder.registerQueryBuilderClass(\n        \"UpdateQueryBuilder\",\n        (qb: QueryBuilder<any>) => new UpdateQueryBuilder(qb),\n    )\n}\n"],"names":[],"mappings":";;;;AAQA,QAAA,qBAAA,GAAA,sBAyBC;AAjCD,MAAA,uDAAyD;AACzD,MAAA,uDAAyD;AACzD,MAAA,2CAA6C;AAC7C,MAAA,2DAA6D;AAC7D,MAAA,uDAAyD;AACzD,MAAA,+DAAiE;AACjE,MAAA,uDAAyD;AAEzD,SAAgB,qBAAqB;IACjC,eAAA,YAAY,CAAC,yBAAyB,CAClC,oBAAoB,EACpB,CAAC,EAAqB,EAAE,CAAG,CAAD,GAAK,qBAAA,kBAAkB,CAAC,EAAE,CAAC,CACxD,CAAA;IACD,eAAA,YAAY,CAAC,yBAAyB,CAClC,oBAAoB,EACpB,CAAC,EAAqB,EAAE,CAAG,CAAD,GAAK,qBAAA,kBAAkB,CAAC,EAAE,CAAC,CACxD,CAAA;IACD,eAAA,YAAY,CAAC,yBAAyB,CAClC,sBAAsB,EACtB,CAAC,EAAqB,EAAE,CAAG,CAAD,GAAK,uBAAA,oBAAoB,CAAC,EAAE,CAAC,CAC1D,CAAA;IACD,eAAA,YAAY,CAAC,yBAAyB,CAClC,oBAAoB,EACpB,CAAC,EAAqB,EAAE,CAAG,CAAD,GAAK,qBAAA,kBAAkB,CAAC,EAAE,CAAC,CACxD,CAAA;IACD,eAAA,YAAY,CAAC,yBAAyB,CAClC,wBAAwB,EACxB,CAAC,EAAqB,EAAE,CAAG,CAAD,GAAK,yBAAA,sBAAsB,CAAC,EAAE,CAAC,CAC5D,CAAA;IACD,eAAA,YAAY,CAAC,yBAAyB,CAClC,oBAAoB,EACpB,CAAC,EAAqB,EAAE,CAAG,CAAD,GAAK,qBAAA,kBAAkB,CAAC,EAAE,CAAC,CACxD,CAAA;AACL,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6950, "column": 0}, "map": {"version":3,"file":"PlainObjectToNewEntityTransformer.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/transformer/PlainObjectToNewEntityTransformer.ts"],"sourcesContent":["import { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { ObjectUtils } from \"../../util/ObjectUtils\"\n\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\nexport class PlainObjectToNewEntityTransformer {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform<T extends ObjectLiteral>(\n        newEntity: T,\n        object: ObjectLiteral,\n        metadata: EntityMetadata,\n        getLazyRelationsPromiseValue: boolean = false,\n    ): T {\n        // console.log(\"groupAndTransform entity:\", newEntity);\n        // console.log(\"groupAndTransform object:\", object);\n        this.groupAndTransform(\n            newEntity,\n            object,\n            metadata,\n            getLazyRelationsPromiseValue,\n        )\n        // console.log(\"result:\", newEntity);\n        return newEntity\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    private groupAndTransform(\n        entity: ObjectLiteral,\n        object: ObjectLiteral,\n        metadata: EntityMetadata,\n        getLazyRelationsPromiseValue: boolean = false,\n    ): void {\n        // console.log(\"groupAndTransform entity:\", entity);\n        // console.log(\"groupAndTransform object:\", object);\n\n        // copy regular column properties from the given object\n        metadata.nonVirtualColumns.forEach((column) => {\n            const objectColumnValue = column.getEntityValue(object)\n            if (objectColumnValue !== undefined)\n                column.setEntityValue(entity, objectColumnValue)\n        })\n\n        // // copy relation properties from the given object\n        if (metadata.relations.length) {\n            metadata.relations.forEach((relation) => {\n                let entityRelatedValue = relation.getEntityValue(entity)\n                const objectRelatedValue = relation.getEntityValue(\n                    object,\n                    getLazyRelationsPromiseValue,\n                )\n                if (objectRelatedValue === undefined) return\n\n                if (relation.isOneToMany || relation.isManyToMany) {\n                    if (!Array.isArray(objectRelatedValue)) return\n\n                    if (!entityRelatedValue) {\n                        entityRelatedValue = []\n                        relation.setEntityValue(entity, entityRelatedValue)\n                    }\n\n                    objectRelatedValue.forEach((objectRelatedValueItem) => {\n                        // check if we have this item from the merging object in the original entity we merge into\n                        let objectRelatedValueEntity = (\n                            entityRelatedValue as any[]\n                        ).find((entityRelatedValueItem) => {\n                            return relation.inverseEntityMetadata.compareEntities(\n                                objectRelatedValueItem,\n                                entityRelatedValueItem,\n                            )\n                        })\n\n                        const inverseEntityMetadata =\n                            relation.inverseEntityMetadata.findInheritanceMetadata(\n                                objectRelatedValueItem,\n                            )\n\n                        // if such item already exist then merge new data into it, if its not we create a new entity and merge it into the array\n                        if (!objectRelatedValueEntity) {\n                            objectRelatedValueEntity =\n                                inverseEntityMetadata.create(undefined, {\n                                    fromDeserializer: true,\n                                })\n                            entityRelatedValue.push(objectRelatedValueEntity)\n                        }\n\n                        this.groupAndTransform(\n                            objectRelatedValueEntity,\n                            objectRelatedValueItem,\n                            inverseEntityMetadata,\n                            getLazyRelationsPromiseValue,\n                        )\n                    })\n                } else {\n                    // if related object isn't an object (direct relation id for example)\n                    // we just set it to the entity relation, we don't need anything more from it\n                    // however we do it only if original entity does not have this relation set to object\n                    // to prevent full overriding of objects\n                    if (!ObjectUtils.isObject(objectRelatedValue)) {\n                        if (!ObjectUtils.isObject(entityRelatedValue))\n                            relation.setEntityValue(entity, objectRelatedValue)\n                        return\n                    }\n\n                    const inverseEntityMetadata =\n                        relation.inverseEntityMetadata.findInheritanceMetadata(\n                            objectRelatedValue,\n                        )\n\n                    if (!entityRelatedValue) {\n                        entityRelatedValue = inverseEntityMetadata.create(\n                            undefined,\n                            {\n                                fromDeserializer: true,\n                            },\n                        )\n                        relation.setEntityValue(entity, entityRelatedValue)\n                    }\n\n                    this.groupAndTransform(\n                        entityRelatedValue,\n                        objectRelatedValue,\n                        inverseEntityMetadata,\n                        getLazyRelationsPromiseValue,\n                    )\n                }\n            })\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7039, "column": 0}, "map": {"version":3,"file":"PlainObjectToDatabaseEntityTransformer.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/transformer/PlainObjectToDatabaseEntityTransformer.ts"],"sourcesContent":["import { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { EntityManager } from \"../../entity-manager/EntityManager\"\nimport { RelationMetadata } from \"../../metadata/RelationMetadata\"\n\n/**\n */\nclass LoadMapItem {\n    entity?: ObjectLiteral\n    plainEntity: ObjectLiteral\n    metadata: EntityMetadata\n    parentLoadMapItem?: LoadMapItem\n    relation?: RelationMetadata\n\n    constructor(\n        plainEntity: ObjectLiteral,\n        metadata: EntityMetadata,\n        parentLoadMapItem?: LoadMapItem,\n        relation?: RelationMetadata,\n    ) {\n        this.plainEntity = plainEntity\n        this.metadata = metadata\n        this.parentLoadMapItem = parentLoadMapItem\n        this.relation = relation\n    }\n\n    get target(): Function | string {\n        return this.metadata.target\n    }\n\n    get id(): any {\n        return this.metadata.getEntityIdMixedMap(this.plainEntity)\n    }\n}\n\nclass LoadMap {\n    loadMapItems: LoadMapItem[] = []\n\n    get mainLoadMapItem(): LoadMapItem | undefined {\n        return this.loadMapItems.find(\n            (item) => !item.relation && !item.parentLoadMapItem,\n        )\n    }\n\n    addLoadMap(newLoadMap: LoadMapItem) {\n        const item = this.loadMapItems.find(\n            (item) =>\n                item.target === newLoadMap.target && item.id === newLoadMap.id,\n        )\n        if (!item) this.loadMapItems.push(newLoadMap)\n    }\n\n    fillEntities(target: Function | string, entities: any[]) {\n        entities.forEach((entity) => {\n            const item = this.loadMapItems.find((loadMapItem) => {\n                return (\n                    loadMapItem.target === target &&\n                    loadMapItem.metadata.compareEntities(\n                        entity,\n                        loadMapItem.plainEntity,\n                    )\n                )\n            })\n            if (item) item.entity = entity\n        })\n    }\n\n    groupByTargetIds(): { target: Function | string; ids: any[] }[] {\n        const groups: { target: Function | string; ids: any[] }[] = []\n        this.loadMapItems.forEach((loadMapItem) => {\n            let group = groups.find(\n                (group) => group.target === loadMapItem.target,\n            )\n            if (!group) {\n                group = { target: loadMapItem.target, ids: [] }\n                groups.push(group)\n            }\n\n            group.ids.push(loadMapItem.id)\n        })\n        return groups\n    }\n}\n\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\nexport class PlainObjectToDatabaseEntityTransformer {\n    constructor(private manager: EntityManager) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    async transform(\n        plainObject: ObjectLiteral,\n        metadata: EntityMetadata,\n    ): Promise<ObjectLiteral | undefined> {\n        // if plain object does not have id then nothing to load really\n        if (!metadata.hasAllPrimaryKeys(plainObject))\n            return Promise.reject(\n                \"Given object does not have a primary column, cannot transform it to database entity.\",\n            )\n\n        // create a special load map that will hold all metadata that will be used to operate with entities easily\n        const loadMap = new LoadMap()\n        const fillLoadMap = (\n            entity: ObjectLiteral,\n            entityMetadata: EntityMetadata,\n            parentLoadMapItem?: LoadMapItem,\n            relation?: RelationMetadata,\n        ) => {\n            const item = new LoadMapItem(\n                entity,\n                entityMetadata,\n                parentLoadMapItem,\n                relation,\n            )\n            loadMap.addLoadMap(item)\n\n            entityMetadata\n                .extractRelationValuesFromEntity(entity, metadata.relations)\n                .filter((value) => value !== null && value !== undefined)\n                .forEach(([relation, value, inverseEntityMetadata]) =>\n                    fillLoadMap(value, inverseEntityMetadata, item, relation),\n                )\n        }\n        fillLoadMap(plainObject, metadata)\n        // load all entities and store them in the load map\n        await Promise.all(\n            loadMap.groupByTargetIds().map((targetWithIds) => {\n                // todo: fix type hinting\n                return this.manager\n                    .findByIds<ObjectLiteral>(\n                        targetWithIds.target as any,\n                        targetWithIds.ids,\n                    )\n                    .then((entities) =>\n                        loadMap.fillEntities(targetWithIds.target, entities),\n                    )\n            }),\n        )\n\n        // go through each item in the load map and set their entity relationship using metadata stored in load map\n        loadMap.loadMapItems.forEach((loadMapItem) => {\n            if (\n                !loadMapItem.relation ||\n                !loadMapItem.entity ||\n                !loadMapItem.parentLoadMapItem ||\n                !loadMapItem.parentLoadMapItem.entity\n            )\n                return\n\n            if (\n                loadMapItem.relation.isManyToMany ||\n                loadMapItem.relation.isOneToMany\n            ) {\n                if (\n                    !loadMapItem.parentLoadMapItem.entity[\n                        loadMapItem.relation.propertyName\n                    ]\n                )\n                    loadMapItem.parentLoadMapItem.entity[\n                        loadMapItem.relation.propertyName\n                    ] = []\n                loadMapItem.parentLoadMapItem.entity[\n                    loadMapItem.relation.propertyName\n                ].push(loadMapItem.entity)\n            } else {\n                loadMapItem.parentLoadMapItem.entity[\n                    loadMapItem.relation.propertyName\n                ] = loadMapItem.entity\n            }\n        })\n\n        return loadMap.mainLoadMapItem\n            ? loadMap.mainLoadMapItem.entity\n            : undefined\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7139, "column": 0}, "map": {"version":3,"file":"DocumentToEntityTransformer.js","sourceRoot":"../..","sources":["file:///home/user/studio/node_modules/typeorm/src/query-builder/transformer/DocumentToEntityTransformer.ts"],"sourcesContent":["import { EntityMetadata } from \"../../metadata/EntityMetadata\"\nimport { ObjectLiteral } from \"../../common/ObjectLiteral\"\nimport { EmbeddedMetadata } from \"../../metadata/EmbeddedMetadata\"\n\n/**\n * Transforms raw document into entity object.\n * Entity is constructed based on its entity metadata.\n */\nexport class DocumentToEntityTransformer {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        // private selectionMap: AliasMap,\n        // private joinMappings: JoinMapping[],\n        // private relationCountMetas: RelationCountAttribute[],\n        private enableRelationIdValues: boolean = false,\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transformAll(documents: ObjectLiteral[], metadata: EntityMetadata) {\n        return documents.map((document) => this.transform(document, metadata))\n    }\n\n    transform(document: any, metadata: EntityMetadata) {\n        const entity: any = metadata.create(undefined, {\n            fromDeserializer: true,\n        })\n        let hasData = false\n\n        // handle _id property the special way\n        if (metadata.objectIdColumn) {\n            // todo: we can't use driver in this class\n            // do we really need prepare hydrated value here? If no then no problem. If yes then think maybe prepareHydratedValue process should be extracted out of driver class?\n            // entity[metadata.ObjectIdColumn.propertyName] = this.driver.prepareHydratedValue(document[metadata.ObjectIdColumn.name\"], metadata.ObjectIdColumn);\n            const { databaseNameWithoutPrefixes, propertyName } =\n                metadata.objectIdColumn\n\n            const documentIdWithoutPrefixes =\n                document[databaseNameWithoutPrefixes]\n            const documentIdWithPropertyName = document[propertyName]\n\n            if (documentIdWithoutPrefixes) {\n                entity[propertyName] = documentIdWithoutPrefixes\n                hasData = true\n            } else if (documentIdWithPropertyName) {\n                entity[propertyName] = documentIdWithPropertyName\n                hasData = true\n            }\n        }\n\n        // add special columns that contains relation ids\n        if (this.enableRelationIdValues) {\n            metadata.columns\n                .filter((column) => !!column.relationMetadata)\n                .forEach((column) => {\n                    const valueInObject =\n                        document[column.databaseNameWithoutPrefixes]\n                    if (\n                        valueInObject !== undefined &&\n                        valueInObject !== null &&\n                        column.propertyName\n                    ) {\n                        // todo: we can't use driver in this class\n                        // const value = this.driver.prepareHydratedValue(valueInObject, column);\n                        entity[column.propertyName] = valueInObject\n                        hasData = true\n                    }\n                })\n        }\n\n        /*this.joinMappings\n            .filter(joinMapping => joinMapping.parentName === alias.name && !joinMapping.alias.relationOwnerSelection && joinMapping.alias.target)\n            .map(joinMapping => {\n                const relatedEntities = this.transformRawResultsGroup(rawSqlResults, joinMapping.alias);\n                const isResultArray = joinMapping.isMany;\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\n\n                if (result && (!isResultArray || result.length > 0)) {\n                    entity[joinMapping.propertyName] = result;\n                    hasData = true;\n                }\n            });*/\n\n        // get value from columns selections and put them into object\n        metadata.ownColumns.forEach((column) => {\n            const valueInObject = document[column.databaseNameWithoutPrefixes]\n            if (\n                valueInObject !== undefined &&\n                column.propertyName &&\n                !column.isVirtual\n            ) {\n                // const value = this.driver.prepareHydratedValue(valueInObject, column);\n\n                entity[column.propertyName] = valueInObject\n                hasData = true\n            }\n        })\n\n        const addEmbeddedValuesRecursively = (\n            entity: any,\n            document: any,\n            embeddeds: EmbeddedMetadata[],\n        ) => {\n            embeddeds.forEach((embedded) => {\n                if (!document[embedded.prefix]) return\n\n                if (embedded.isArray) {\n                    entity[embedded.propertyName] = (\n                        document[embedded.prefix] as any[]\n                    ).map((subValue: any, index: number) => {\n                        const newItem = embedded.create({\n                            fromDeserializer: true,\n                        })\n                        embedded.columns.forEach((column) => {\n                            newItem[column.propertyName] =\n                                subValue[column.databaseNameWithoutPrefixes]\n                        })\n                        addEmbeddedValuesRecursively(\n                            newItem,\n                            document[embedded.prefix][index],\n                            embedded.embeddeds,\n                        )\n                        return newItem\n                    })\n                } else {\n                    if (\n                        embedded.embeddeds.length &&\n                        !entity[embedded.propertyName]\n                    )\n                        entity[embedded.propertyName] = embedded.create({\n                            fromDeserializer: true,\n                        })\n\n                    embedded.columns.forEach((column) => {\n                        const value =\n                            document[embedded.prefix][\n                                column.databaseNameWithoutPrefixes\n                            ]\n                        if (value === undefined) return\n\n                        if (!entity[embedded.propertyName])\n                            entity[embedded.propertyName] = embedded.create({\n                                fromDeserializer: true,\n                            })\n\n                        entity[embedded.propertyName][column.propertyName] =\n                            value\n                    })\n\n                    addEmbeddedValuesRecursively(\n                        entity[embedded.propertyName],\n                        document[embedded.prefix],\n                        embedded.embeddeds,\n                    )\n                }\n            })\n        }\n\n        addEmbeddedValuesRecursively(entity, document, metadata.embeddeds)\n\n        // if relation is loaded then go into it recursively and transform its values too\n        /*metadata.relations.forEach(relation => {\n            const relationAlias = this.selectionMap.findSelectionByParent(alias.name, relation.propertyName);\n            if (relationAlias) {\n                const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"join\" && joinMapping.alias === relationAlias);\n                const relatedEntities = this.transformRawResultsGroup(rawSqlResults, relationAlias);\n                const isResultArray = relation.isManyToMany || relation.isOneToMany;\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\n\n                if (result) {\n                    let propertyName = relation.propertyName;\n                    if (joinMapping) {\n                        propertyName = joinMapping.propertyName;\n                    }\n\n                    if (relation.isLazy) {\n                        entity[\"__\" + propertyName + \"__\"] = result;\n                    } else {\n                        entity[propertyName] = result;\n                    }\n\n                    if (!isResultArray || result.length > 0)\n                        hasData = true;\n                }\n            }\n\n            // if relation has id field then relation id/ids to that field.\n            if (relation.isManyToMany) {\n                if (relationAlias) {\n                    const ids: any[] = [];\n                    const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"relationId\" && joinMapping.alias === relationAlias);\n\n                    if (relation.idField || joinMapping) {\n                        const propertyName = joinMapping ? joinMapping.propertyName : relation.idField as string;\n                        const junctionMetadata = relation.junctionEntityMetadata;\n                        const columnName = relation.isOwning ? junctionMetadata.columns[1].name : junctionMetadata.columns[0].name;\n\n                        rawSqlResults.forEach(results => {\n                            if (relationAlias) {\n                                const resultsKey = relationAlias.name + \"_\" + columnName;\n                                const value = this.driver.prepareHydratedValue(results[resultsKey], relation.referencedColumn);\n                                if (value !== undefined && value !== null)\n                                    ids.push(value);\n                            }\n                        });\n\n                        if (ids && ids.length)\n                            entity[propertyName] = ids;\n                    }\n                }\n            } else if (relation.idField) {\n                const relationName = relation.name;\n                entity[relation.idField] = this.driver.prepareHydratedValue(rawSqlResults[0][alias.name + \"_\" + relationName], relation.referencedColumn);\n            }\n\n            // if relation counter\n            this.relationCountMetas.forEach(joinMeta => {\n                if (joinMeta.alias === relationAlias) {\n                    // console.log(\"relation count was found for relation: \", relation);\n                    // joinMeta.entity = entity;\n                    joinMeta.entities.push({ entity: entity, metadata: metadata });\n                    // console.log(joinMeta);\n                    // console.log(\"---------------------\");\n                }\n            });\n        });*/\n\n        return hasData ? entity : null\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7321, "column": 0}, "map": {"version":3,"file":"RelationLoader.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/RelationLoader.ts"],"sourcesContent":["import { DataSource } from \"../data-source/DataSource\"\nimport { ObjectLiteral } from \"../common/ObjectLiteral\"\nimport { QueryRunner } from \"../query-runner/QueryRunner\"\nimport { RelationMetadata } from \"../metadata/RelationMetadata\"\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\"\nimport { SelectQueryBuilder } from \"./SelectQueryBuilder\"\n\n/**\n * Wraps entities and creates getters/setters for their relations\n * to be able to lazily load relations when accessing these relations.\n */\nexport class RelationLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private connection: DataSource) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Loads relation data for the given entity and its relation.\n     */\n    load(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any[]> {\n        // todo: check all places where it uses non array\n        if (queryRunner && queryRunner.isReleased) queryRunner = undefined // get new one if already closed\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            return this.loadManyToOneOrOneToOneOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder,\n            )\n        } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            return this.loadOneToManyOrOneToOneNotOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder,\n            )\n        } else if (relation.isManyToManyOwner) {\n            return this.loadManyToManyOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder,\n            )\n        } else {\n            // many-to-many non owner\n            return this.loadManyToManyNotOwner(\n                relation,\n                entityOrEntities,\n                queryRunner,\n                queryBuilder,\n            )\n        }\n    }\n\n    /**\n     * Loads data for many-to-one and one-to-one owner relations.\n     *\n     * (ow) post.category<=>category.post\n     * loaded: category from post\n     * example: SELECT category.id AS category_id, category.name AS category_name FROM category category\n     *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1\n     */\n    loadManyToOneOrOneToOneOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n\n        const joinAliasName = relation.entityMetadata.name\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName) // category\n                  .from(relation.type, relation.propertyName)\n\n        const mainAlias = qb.expressionMap.mainAlias!.name\n        const columns = relation.entityMetadata.primaryColumns\n        const joinColumns = relation.isOwning\n            ? relation.joinColumns\n            : relation.inverseRelation!.joinColumns\n        const conditions = joinColumns\n            .map((joinColumn) => {\n                return `${relation.entityMetadata.name}.${\n                    joinColumn.propertyName\n                } = ${mainAlias}.${joinColumn.referencedColumn!.propertyName}`\n            })\n            .join(\" AND \")\n\n        qb.innerJoin(\n            relation.entityMetadata.target as Function,\n            joinAliasName,\n            conditions,\n        )\n\n        if (columns.length === 1) {\n            qb.where(\n                `${joinAliasName}.${columns[0].propertyPath} IN (:...${\n                    joinAliasName + \"_\" + columns[0].propertyName\n                })`,\n            )\n            qb.setParameter(\n                joinAliasName + \"_\" + columns[0].propertyName,\n                entities.map((entity) =>\n                    columns[0].getEntityValue(entity, true),\n                ),\n            )\n        } else {\n            const condition = entities\n                .map((entity, entityIndex) => {\n                    return columns\n                        .map((column, columnIndex) => {\n                            const paramName =\n                                joinAliasName +\n                                \"_entity_\" +\n                                entityIndex +\n                                \"_\" +\n                                columnIndex\n                            qb.setParameter(\n                                paramName,\n                                column.getEntityValue(entity, true),\n                            )\n                            return (\n                                joinAliasName +\n                                \".\" +\n                                column.propertyPath +\n                                \" = :\" +\n                                paramName\n                            )\n                        })\n                        .join(\" AND \")\n                })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \")\n            qb.where(condition)\n        }\n\n        FindOptionsUtils.joinEagerRelations(\n            qb,\n            qb.alias,\n            qb.expressionMap.mainAlias!.metadata,\n        )\n\n        return qb.getMany()\n        // return qb.getOne(); todo: fix all usages\n    }\n\n    /**\n     * Loads data for one-to-many and one-to-one not owner relations.\n     *\n     * SELECT post\n     * FROM post post\n     * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]\n     */\n    loadOneToManyOrOneToOneNotOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n        const columns = relation.inverseRelation!.joinColumns\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName)\n                  .from(\n                      relation.inverseRelation!.entityMetadata.target,\n                      relation.propertyName,\n                  )\n\n        const aliasName = qb.expressionMap.mainAlias!.name\n\n        if (columns.length === 1) {\n            qb.where(\n                `${aliasName}.${columns[0].propertyPath} IN (:...${\n                    aliasName + \"_\" + columns[0].propertyName\n                })`,\n            )\n            qb.setParameter(\n                aliasName + \"_\" + columns[0].propertyName,\n                entities.map((entity) =>\n                    columns[0].referencedColumn!.getEntityValue(entity, true),\n                ),\n            )\n        } else {\n            const condition = entities\n                .map((entity, entityIndex) => {\n                    return columns\n                        .map((column, columnIndex) => {\n                            const paramName =\n                                aliasName +\n                                \"_entity_\" +\n                                entityIndex +\n                                \"_\" +\n                                columnIndex\n                            qb.setParameter(\n                                paramName,\n                                column.referencedColumn!.getEntityValue(\n                                    entity,\n                                    true,\n                                ),\n                            )\n                            return (\n                                aliasName +\n                                \".\" +\n                                column.propertyPath +\n                                \" = :\" +\n                                paramName\n                            )\n                        })\n                        .join(\" AND \")\n                })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \")\n            qb.where(condition)\n        }\n\n        FindOptionsUtils.joinEagerRelations(\n            qb,\n            qb.alias,\n            qb.expressionMap.mainAlias!.metadata,\n        )\n\n        return qb.getMany()\n        // return relation.isOneToMany ? qb.getMany() : qb.getOne(); todo: fix all usages\n    }\n\n    /**\n     * Loads data for many-to-many owner relations.\n     *\n     * SELECT category\n     * FROM category category\n     * INNER JOIN post_categories post_categories\n     * ON post_categories.postId = :postId\n     * AND post_categories.categoryId = category.id\n     */\n    loadManyToManyOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n        const parameters = relation.joinColumns.reduce(\n            (parameters, joinColumn) => {\n                parameters[joinColumn.propertyName] = entities.map((entity) =>\n                    joinColumn.referencedColumn!.getEntityValue(entity, true),\n                )\n                return parameters\n            },\n            {} as ObjectLiteral,\n        )\n\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName)\n                  .from(relation.type, relation.propertyName)\n\n        const mainAlias = qb.expressionMap.mainAlias!.name\n        const joinAlias = relation.junctionEntityMetadata!.tableName\n        const joinColumnConditions = relation.joinColumns.map((joinColumn) => {\n            return `${joinAlias}.${joinColumn.propertyName} IN (:...${joinColumn.propertyName})`\n        })\n        const inverseJoinColumnConditions = relation.inverseJoinColumns.map(\n            (inverseJoinColumn) => {\n                return `${joinAlias}.${\n                    inverseJoinColumn.propertyName\n                }=${mainAlias}.${\n                    inverseJoinColumn.referencedColumn!.propertyName\n                }`\n            },\n        )\n\n        qb.innerJoin(\n            joinAlias,\n            joinAlias,\n            [...joinColumnConditions, ...inverseJoinColumnConditions].join(\n                \" AND \",\n            ),\n        ).setParameters(parameters)\n\n        FindOptionsUtils.joinEagerRelations(\n            qb,\n            qb.alias,\n            qb.expressionMap.mainAlias!.metadata,\n        )\n\n        return qb.getMany()\n    }\n\n    /**\n     * Loads data for many-to-many not owner relations.\n     *\n     * SELECT post\n     * FROM post post\n     * INNER JOIN post_categories post_categories\n     * ON post_categories.postId = post.id\n     * AND post_categories.categoryId = post_categories.categoryId\n     */\n    loadManyToManyNotOwner(\n        relation: RelationMetadata,\n        entityOrEntities: ObjectLiteral | ObjectLiteral[],\n        queryRunner?: QueryRunner,\n        queryBuilder?: SelectQueryBuilder<any>,\n    ): Promise<any> {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities]\n\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                  .createQueryBuilder(queryRunner)\n                  .select(relation.propertyName)\n                  .from(relation.type, relation.propertyName)\n\n        const mainAlias = qb.expressionMap.mainAlias!.name\n        const joinAlias = relation.junctionEntityMetadata!.tableName\n        const joinColumnConditions = relation.inverseRelation!.joinColumns.map(\n            (joinColumn) => {\n                return `${joinAlias}.${\n                    joinColumn.propertyName\n                } = ${mainAlias}.${joinColumn.referencedColumn!.propertyName}`\n            },\n        )\n        const inverseJoinColumnConditions =\n            relation.inverseRelation!.inverseJoinColumns.map(\n                (inverseJoinColumn) => {\n                    return `${joinAlias}.${inverseJoinColumn.propertyName} IN (:...${inverseJoinColumn.propertyName})`\n                },\n            )\n        const parameters = relation.inverseRelation!.inverseJoinColumns.reduce(\n            (parameters, joinColumn) => {\n                parameters[joinColumn.propertyName] = entities.map((entity) =>\n                    joinColumn.referencedColumn!.getEntityValue(entity, true),\n                )\n                return parameters\n            },\n            {} as ObjectLiteral,\n        )\n\n        qb.innerJoin(\n            joinAlias,\n            joinAlias,\n            [...joinColumnConditions, ...inverseJoinColumnConditions].join(\n                \" AND \",\n            ),\n        ).setParameters(parameters)\n\n        FindOptionsUtils.joinEagerRelations(\n            qb,\n            qb.alias,\n            qb.expressionMap.mainAlias!.metadata,\n        )\n\n        return qb.getMany()\n    }\n\n    /**\n     * Wraps given entity and creates getters/setters for its given relation\n     * to be able to lazily load data when accessing this relation.\n     */\n    enableLazyLoad(\n        relation: RelationMetadata,\n        entity: ObjectLiteral,\n        queryRunner?: QueryRunner,\n    ) {\n        const relationLoader = this\n        const dataIndex = \"__\" + relation.propertyName + \"__\" // in what property of the entity loaded data will be stored\n        const promiseIndex = \"__promise_\" + relation.propertyName + \"__\" // in what property of the entity loading promise will be stored\n        const resolveIndex = \"__has_\" + relation.propertyName + \"__\" // indicates if relation data already was loaded or not, we need this flag if loaded data is empty\n\n        const setData = (entity: ObjectLiteral, value: any) => {\n            entity[dataIndex] = value\n            entity[resolveIndex] = true\n            delete entity[promiseIndex]\n            return value\n        }\n        const setPromise = (entity: ObjectLiteral, value: Promise<any>) => {\n            delete entity[resolveIndex]\n            delete entity[dataIndex]\n            entity[promiseIndex] = value\n            value.then(\n                // ensure different value is not assigned yet\n                (result) =>\n                    entity[promiseIndex] === value\n                        ? setData(entity, result)\n                        : result,\n            )\n            return value\n        }\n\n        Object.defineProperty(entity, relation.propertyName, {\n            get: function () {\n                if (\n                    this[resolveIndex] === true ||\n                    this[dataIndex] !== undefined\n                )\n                    // if related data already was loaded then simply return it\n                    return Promise.resolve(this[dataIndex])\n\n                if (this[promiseIndex])\n                    // if related data is loading then return a promise relationLoader loads it\n                    return this[promiseIndex]\n\n                // nothing is loaded yet, load relation data and save it in the model once they are loaded\n                const loader = relationLoader\n                    .load(relation, this, queryRunner)\n                    .then((result) =>\n                        relation.isOneToOne || relation.isManyToOne\n                            ? result.length === 0\n                                ? null\n                                : result[0]\n                            : result,\n                    )\n                return setPromise(this, loader)\n            },\n            set: function (value: any | Promise<any>) {\n                if (value instanceof Promise) {\n                    // if set data is a promise then wait for its resolve and save in the object\n                    setPromise(this, value)\n                } else {\n                    // if its direct data set (non promise, probably not safe-typed)\n                    setData(this, value)\n                }\n            },\n            configurable: true,\n            enumerable: false,\n        })\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7540, "column": 0}, "map": {"version":3,"file":"NotBrackets.js","sourceRoot":"..","sources":["file:///home/user/studio/node_modules/src/query-builder/NotBrackets.ts"],"sourcesContent":["import { Brackets } from \"./Brackets\"\n\n/**\n * Syntax sugar.\n * Allows to use negate brackets in WHERE expressions for better syntax.\n */\nexport class NotBrackets extends Brackets {\n    readonly \"@instanceof\" = Symbol.for(\"NotBrackets\")\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,mCAAqC;AAErC;;;GAGG,CACH,MAAa,WAAY,SAAQ,WAAA,QAAQ;IAAzC,aAAA;;QACa,IAAA,CAAA,cAAa,GAAG,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,CAAA;IACtD,CAAC;CAAA;AAFD,QAAA,WAAA,GAAA,YAEC","ignoreList":[0],"debugId":null}}]
}