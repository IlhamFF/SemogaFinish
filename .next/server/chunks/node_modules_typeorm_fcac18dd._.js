module.exports = {

"[project]/node_modules/typeorm/metadata-builder/MetadataUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MetadataUtils = void 0;
/**
 * Metadata args utility functions.
 */ class MetadataUtils {
    /**
     * Gets given's entity all inherited classes.
     * Gives in order from parents to children.
     * For example Post extends ContentModel which extends Unit it will give
     * [Unit, ContentModel, Post]
     */ static getInheritanceTree(entity) {
        const tree = [
            entity
        ];
        const getPrototypeOf = (object)=>{
            const proto = Object.getPrototypeOf(object);
            if (proto && proto.name) {
                tree.push(proto);
                getPrototypeOf(proto);
            }
        };
        getPrototypeOf(entity);
        return tree;
    }
    /**
     * Checks if this table is inherited from another table.
     */ static isInherited(target1, target2) {
        return target1.prototype instanceof target2;
    }
    /**
     * Filters given array of targets by a given classes.
     * If classes are not given, then it returns array itself.
     */ static filterByTarget(array, classes) {
        if (!classes) return array;
        return array.filter((item)=>item.target && classes.indexOf(item.target) !== -1);
    }
}
exports.MetadataUtils = MetadataUtils; //# sourceMappingURL=MetadataUtils.js.map
}}),
"[project]/node_modules/typeorm/metadata-builder/EntityMetadataValidator.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntityMetadataValidator = void 0;
const MissingPrimaryColumnError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/MissingPrimaryColumnError.js [app-route] (ecmascript)");
const CircularRelationsError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/CircularRelationsError.js [app-route] (ecmascript)");
const DepGraph_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/DepGraph.js [app-route] (ecmascript)");
const DataTypeNotSupportedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/DataTypeNotSupportedError.js [app-route] (ecmascript)");
const NoConnectionOptionError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/NoConnectionOptionError.js [app-route] (ecmascript)");
const InitializedRelationError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/InitializedRelationError.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
/// todo: add check if there are multiple tables with the same name
/// todo: add checks when generated column / table names are too long for the specific driver
// todo: type in function validation, inverse side function validation
// todo: check on build for duplicate names, since naming checking was removed from MetadataStorage
// todo: duplicate name checking for: table, relation, column, index, naming strategy, join tables/columns?
// todo: check if multiple tree parent metadatas in validator
// todo: tree decorators can be used only on closure table (validation)
// todo: throw error if parent tree metadata was not specified in a closure table
// todo: MetadataArgsStorage: type in function validation, inverse side function validation
// todo: MetadataArgsStorage: check on build for duplicate names, since naming checking was removed from MetadataStorage
// todo: MetadataArgsStorage: duplicate name checking for: table, relation, column, index, naming strategy, join tables/columns?
// todo: MetadataArgsStorage: check for duplicate targets too since this check has been removed too
// todo: check if relation decorator contains primary: true and nullable: true
// todo: check column length, precision. scale
// todo: MySQL index can be unique or spatial or fulltext
/**
 * Validates built entity metadatas.
 */ class EntityMetadataValidator {
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Validates all given entity metadatas.
     */ validateMany(entityMetadatas, driver) {
        entityMetadatas.forEach((entityMetadata)=>this.validate(entityMetadata, entityMetadatas, driver));
        this.validateDependencies(entityMetadatas);
        this.validateEagerRelations(entityMetadatas);
    }
    /**
     * Validates given entity metadata.
     */ validate(entityMetadata, allEntityMetadatas, driver) {
        // check if table metadata has an id
        if (!entityMetadata.primaryColumns.length && !entityMetadata.isJunction) throw new MissingPrimaryColumnError_1.MissingPrimaryColumnError(entityMetadata);
        // if entity has multiple primary keys and uses custom constraint name,
        // then all primary keys should have the same constraint name
        if (entityMetadata.primaryColumns.length > 1) {
            const areConstraintNamesEqual = entityMetadata.primaryColumns.every((columnMetadata, i, columnMetadatas)=>columnMetadata.primaryKeyConstraintName === columnMetadatas[0].primaryKeyConstraintName);
            if (!areConstraintNamesEqual) {
                throw new error_1.TypeORMError(`Entity ${entityMetadata.name} has multiple primary columns with different constraint names. Constraint names should be the equal.`);
            }
        }
        // validate if table is using inheritance it has a discriminator
        // also validate if discriminator values are not empty and not repeated
        if (entityMetadata.inheritancePattern === "STI" || entityMetadata.tableType === "entity-child") {
            if (!entityMetadata.discriminatorColumn) throw new error_1.TypeORMError(`Entity ${entityMetadata.name} using single-table inheritance, it should also have a discriminator column. Did you forget to put discriminator column options?`);
            if (typeof entityMetadata.discriminatorValue === "undefined") throw new error_1.TypeORMError(`Entity ${entityMetadata.name} has an undefined discriminator value. Discriminator value should be defined.`);
            const sameDiscriminatorValueEntityMetadata = allEntityMetadatas.find((metadata)=>{
                return metadata !== entityMetadata && (metadata.inheritancePattern === "STI" || metadata.tableType === "entity-child") && metadata.tableName === entityMetadata.tableName && metadata.discriminatorValue === entityMetadata.discriminatorValue && metadata.inheritanceTree.some((parent)=>entityMetadata.inheritanceTree.indexOf(parent) !== -1);
            });
            if (sameDiscriminatorValueEntityMetadata) throw new error_1.TypeORMError(`Entities ${entityMetadata.name} and ${sameDiscriminatorValueEntityMetadata.name} have the same discriminator values. Make sure they are different while using the @ChildEntity decorator.`);
        }
        entityMetadata.relationCounts.forEach((relationCount)=>{
            if (relationCount.relation.isManyToOne || relationCount.relation.isOneToOne) throw new error_1.TypeORMError(`Relation count can not be implemented on ManyToOne or OneToOne relations.`);
        });
        if (!(driver.options.type === "mongodb")) {
            entityMetadata.columns.filter((column)=>!column.isVirtualProperty).forEach((column)=>{
                const normalizedColumn = driver.normalizeType(column);
                if (driver.supportedDataTypes.indexOf(normalizedColumn) === -1) throw new DataTypeNotSupportedError_1.DataTypeNotSupportedError(column, normalizedColumn, driver.options.type);
                if (column.length && driver.withLengthColumnTypes.indexOf(normalizedColumn) === -1) throw new error_1.TypeORMError(`Column ${column.propertyName} of Entity ${entityMetadata.name} does not support length property.`);
                if (column.type === "enum" && !column.enum && !column.enumName) throw new error_1.TypeORMError(`Column "${column.propertyName}" of Entity "${entityMetadata.name}" is defined as enum, but missing "enum" or "enumName" properties.`);
            });
        }
        if (DriverUtils_1.DriverUtils.isMySQLFamily(driver) || driver.options.type === "aurora-mysql") {
            const generatedColumns = entityMetadata.columns.filter((column)=>column.isGenerated && column.generationStrategy !== "uuid");
            if (generatedColumns.length > 1) throw new error_1.TypeORMError(`Error in ${entityMetadata.name} entity. There can be only one auto-increment column in MySql table.`);
        }
        // for mysql we are able to not define a default selected database, instead all entities can have their database
        // defined in their decorators. To make everything work either all entities must have database define and we
        // can live without database set in the connection options, either database in the connection options must be set
        if (DriverUtils_1.DriverUtils.isMySQLFamily(driver)) {
            const metadatasWithDatabase = allEntityMetadatas.filter((metadata)=>metadata.database);
            if (metadatasWithDatabase.length === 0 && !driver.database) throw new NoConnectionOptionError_1.NoConnectionOptionError("database");
        }
        if (driver.options.type === "mssql") {
            const charsetColumns = entityMetadata.columns.filter((column)=>column.charset);
            if (charsetColumns.length > 1) throw new error_1.TypeORMError(`Character set specifying is not supported in Sql Server`);
        }
        // Postgres supports only STORED generated columns.
        if (driver.options.type === "postgres") {
            const virtualColumn = entityMetadata.columns.find((column)=>column.asExpression && (!column.generatedType || column.generatedType === "VIRTUAL"));
            if (virtualColumn) throw new error_1.TypeORMError(`Column "${virtualColumn.propertyName}" of Entity "${entityMetadata.name}" is defined as VIRTUAL, but Postgres supports only STORED generated columns.`);
        }
        // check if relations are all without initialized properties
        const entityInstance = entityMetadata.create(undefined, {
            fromDeserializer: true
        });
        entityMetadata.relations.forEach((relation)=>{
            if (relation.isManyToMany || relation.isOneToMany) {
                // we skip relations for which persistence is disabled since initialization in them cannot harm somehow
                if (relation.persistenceEnabled === false) return;
                // get entity relation value and check if its an array
                const relationInitializedValue = relation.getEntityValue(entityInstance);
                if (Array.isArray(relationInitializedValue)) throw new InitializedRelationError_1.InitializedRelationError(relation);
            }
        });
        // validate relations
        entityMetadata.relations.forEach((relation)=>{
            // check OnDeleteTypes
            if (driver.supportedOnDeleteTypes && relation.onDelete && !driver.supportedOnDeleteTypes.includes(relation.onDelete)) {
                throw new error_1.TypeORMError(`OnDeleteType "${relation.onDelete}" is not supported for ${driver.options.type}!`);
            }
            // check OnUpdateTypes
            if (driver.supportedOnUpdateTypes && relation.onUpdate && !driver.supportedOnUpdateTypes.includes(relation.onUpdate)) {
                throw new error_1.TypeORMError(`OnUpdateType "${relation.onUpdate}" is not valid for ${driver.options.type}!`);
            }
        // check join tables:
        // using JoinTable is possible only on one side of the many-to-many relation
        // todo(dima): fix
        // if (relation.joinTable) {
        //     if (!relation.isManyToMany)
        //         throw new UsingJoinTableIsNotAllowedError(entityMetadata, relation);
        //     // if there is inverse side of the relation, then check if it does not have join table too
        //     if (relation.hasInverseSide && relation.inverseRelation.joinTable)
        //         throw new UsingJoinTableOnlyOnOneSideAllowedError(entityMetadata, relation);
        // }
        // check join columns:
        // using JoinColumn is possible only on one side of the relation and on one-to-one, many-to-one relation types
        // first check if relation is one-to-one or many-to-one
        // todo(dima): fix
        /*if (relation.joinColumn) {

                // join column can be applied only on one-to-one and many-to-one relations
                if (!relation.isOneToOne && !relation.isManyToOne)
                    throw new UsingJoinColumnIsNotAllowedError(entityMetadata, relation);

                // if there is inverse side of the relation, then check if it does not have join table too
                if (relation.hasInverseSide && relation.inverseRelation.joinColumn && relation.isOneToOne)
                    throw new UsingJoinColumnOnlyOnOneSideAllowedError(entityMetadata, relation);

                // check if join column really has referenced column
                if (relation.joinColumn && !relation.joinColumn.referencedColumn)
                    throw new TypeORMError(`Join column does not have referenced column set`);

            }

            // if its a one-to-one relation and JoinColumn is missing on both sides of the relation
            // or its one-side relation without JoinColumn we should give an error
            if (!relation.joinColumn && relation.isOneToOne && (!relation.hasInverseSide || !relation.inverseRelation.joinColumn))
                throw new MissingJoinColumnError(entityMetadata, relation);*/ // if its a many-to-many relation and JoinTable is missing on both sides of the relation
        // or its one-side relation without JoinTable we should give an error
        // todo(dima): fix it
        // if (!relation.joinTable && relation.isManyToMany && (!relation.hasInverseSide || !relation.inverseRelation.joinTable))
        //     throw new MissingJoinTableError(entityMetadata, relation);
        // todo: validate if its one-to-one and side which does not have join column MUST have inverse side
        // todo: validate if its many-to-many and side which does not have join table MUST have inverse side
        // todo: if there is a relation, and inverse side is specified only on one side, shall we give error
        // todo: with message like: "Inverse side is specified only on one side of the relationship. Specify on other side too to prevent confusion".
        // todo: add validation if there two entities with the same target, and show error message with description of the problem (maybe file was renamed/moved but left in output directory)
        // todo: check if there are multiple columns on the same column applied.
        // todo: check column type if is missing in relational databases (throw new TypeORMError(`Column type of ${type} cannot be determined.`);)
        // todo: include driver-specific checks. for example in mongodb empty prefixes are not allowed
        // todo: if multiple columns with same name - throw exception, including cases when columns are in embeds with same prefixes or without prefix at all
        // todo: if multiple primary key used, at least one of them must be unique or @Index decorator must be set on entity
        // todo: check if entity with duplicate names, some decorators exist
        });
        // make sure cascade remove is not set for both sides of relationships (can be set in OneToOne decorators)
        entityMetadata.relations.forEach((relation)=>{
            const isCircularCascadeRemove = relation.isCascadeRemove && relation.inverseRelation && relation.inverseRelation.isCascadeRemove;
            if (isCircularCascadeRemove) throw new error_1.TypeORMError(`Relation ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseRelation.entityMetadata.name}#${relation.inverseRelation.propertyName} both has cascade remove set. ` + `This may lead to unexpected circular removals. Please set cascade remove only from one side of relationship.`);
        }); // todo: maybe better just deny removal from one to one relation without join column?
        entityMetadata.eagerRelations.forEach((relation)=>{});
    }
    /**
     * Validates dependencies of the entity metadatas.
     */ validateDependencies(entityMetadatas) {
        const graph = new DepGraph_1.DepGraph();
        entityMetadatas.forEach((entityMetadata)=>{
            graph.addNode(entityMetadata.name);
        });
        entityMetadatas.forEach((entityMetadata)=>{
            entityMetadata.relationsWithJoinColumns.filter((relation)=>!relation.isNullable).forEach((relation)=>{
                graph.addDependency(entityMetadata.name, relation.inverseEntityMetadata.name);
            });
        });
        try {
            graph.overallOrder();
        } catch (err) {
            throw new CircularRelationsError_1.CircularRelationsError(err.toString().replace("Error: Dependency Cycle Found: ", ""));
        }
    }
    /**
     * Validates eager relations to prevent circular dependency in them.
     */ validateEagerRelations(entityMetadatas) {
        entityMetadatas.forEach((entityMetadata)=>{
            entityMetadata.eagerRelations.forEach((relation)=>{
                if (relation.inverseRelation && relation.inverseRelation.isEager) throw new error_1.TypeORMError(`Circular eager relations are disallowed. ` + `${entityMetadata.targetName}#${relation.propertyPath} contains "eager: true", and its inverse side ` + `${relation.inverseEntityMetadata.targetName}#${relation.inverseRelation.propertyPath} contains "eager: true" as well.` + ` Remove "eager: true" from one side of the relation.`);
            });
        });
    }
}
exports.EntityMetadataValidator = EntityMetadataValidator; //# sourceMappingURL=EntityMetadataValidator.js.map
}}),
"[project]/node_modules/typeorm/metadata-builder/JunctionEntityMetadataBuilder.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JunctionEntityMetadataBuilder = void 0;
const ColumnMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/ColumnMetadata.js [app-route] (ecmascript)");
const EntityMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/EntityMetadata.js [app-route] (ecmascript)");
const ForeignKeyMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/ForeignKeyMetadata.js [app-route] (ecmascript)");
const IndexMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/IndexMetadata.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
/**
 * Creates EntityMetadata for junction tables.
 * Junction tables are tables generated by many-to-many relations.
 */ class JunctionEntityMetadataBuilder {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        this.connection = connection;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Builds EntityMetadata for the junction of the given many-to-many relation.
     */ build(relation, joinTable) {
        const referencedColumns = this.collectReferencedColumns(relation, joinTable);
        const inverseReferencedColumns = this.collectInverseReferencedColumns(relation, joinTable);
        const joinTableName = joinTable.name || this.connection.namingStrategy.joinTableName(relation.entityMetadata.tableNameWithoutPrefix, relation.inverseEntityMetadata.tableNameWithoutPrefix, relation.propertyPath, relation.inverseRelation ? relation.inverseRelation.propertyName : "");
        const entityMetadata = new EntityMetadata_1.EntityMetadata({
            connection: this.connection,
            args: {
                target: "",
                name: joinTableName,
                type: "junction",
                database: joinTable.database || relation.entityMetadata.database,
                schema: joinTable.schema || relation.entityMetadata.schema,
                synchronize: joinTable.synchronize
            }
        });
        entityMetadata.build();
        // create original side junction columns
        const junctionColumns = referencedColumns.map((referencedColumn)=>{
            const joinColumn = joinTable.joinColumns ? joinTable.joinColumns.find((joinColumnArgs)=>{
                return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === referencedColumn.propertyName) && !!joinColumnArgs.name;
            }) : undefined;
            const columnName = joinColumn && joinColumn.name ? joinColumn.name : this.connection.namingStrategy.joinTableColumnName(relation.entityMetadata.tableNameWithoutPrefix, referencedColumn.propertyName, referencedColumn.databaseName);
            return new ColumnMetadata_1.ColumnMetadata({
                connection: this.connection,
                entityMetadata: entityMetadata,
                referencedColumn: referencedColumn,
                args: {
                    target: "",
                    mode: "virtual",
                    propertyName: columnName,
                    options: {
                        name: columnName,
                        length: !referencedColumn.length && (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && // some versions of mariadb support the column type and should not try to provide the length property
                        this.connection.driver.normalizeType(referencedColumn) !== "uuid" && (referencedColumn.generationStrategy === "uuid" || referencedColumn.type === "uuid") ? "36" : referencedColumn.length,
                        width: referencedColumn.width,
                        type: referencedColumn.type,
                        precision: referencedColumn.precision,
                        scale: referencedColumn.scale,
                        charset: referencedColumn.charset,
                        collation: referencedColumn.collation,
                        zerofill: referencedColumn.zerofill,
                        unsigned: referencedColumn.zerofill ? true : referencedColumn.unsigned,
                        enum: referencedColumn.enum,
                        enumName: referencedColumn.enumName,
                        foreignKeyConstraintName: joinColumn?.foreignKeyConstraintName,
                        nullable: false,
                        primary: true
                    }
                }
            });
        });
        // create inverse side junction columns
        const inverseJunctionColumns = inverseReferencedColumns.map((inverseReferencedColumn)=>{
            const joinColumn = joinTable.inverseJoinColumns ? joinTable.inverseJoinColumns.find((joinColumnArgs)=>{
                return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === inverseReferencedColumn.propertyName) && !!joinColumnArgs.name;
            }) : undefined;
            const columnName = joinColumn && joinColumn.name ? joinColumn.name : this.connection.namingStrategy.joinTableInverseColumnName(relation.inverseEntityMetadata.tableNameWithoutPrefix, inverseReferencedColumn.propertyName, inverseReferencedColumn.databaseName);
            return new ColumnMetadata_1.ColumnMetadata({
                connection: this.connection,
                entityMetadata: entityMetadata,
                referencedColumn: inverseReferencedColumn,
                args: {
                    target: "",
                    mode: "virtual",
                    propertyName: columnName,
                    options: {
                        length: !inverseReferencedColumn.length && (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && // some versions of mariadb support the column type and should not try to provide the length property
                        this.connection.driver.normalizeType(inverseReferencedColumn) !== "uuid" && (inverseReferencedColumn.generationStrategy === "uuid" || inverseReferencedColumn.type === "uuid") ? "36" : inverseReferencedColumn.length,
                        width: inverseReferencedColumn.width,
                        type: inverseReferencedColumn.type,
                        precision: inverseReferencedColumn.precision,
                        scale: inverseReferencedColumn.scale,
                        charset: inverseReferencedColumn.charset,
                        collation: inverseReferencedColumn.collation,
                        zerofill: inverseReferencedColumn.zerofill,
                        unsigned: inverseReferencedColumn.zerofill ? true : inverseReferencedColumn.unsigned,
                        enum: inverseReferencedColumn.enum,
                        enumName: inverseReferencedColumn.enumName,
                        foreignKeyConstraintName: joinColumn?.foreignKeyConstraintName,
                        name: columnName,
                        nullable: false,
                        primary: true
                    }
                }
            });
        });
        this.changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns);
        // set junction table columns
        entityMetadata.ownerColumns = junctionColumns;
        entityMetadata.inverseColumns = inverseJunctionColumns;
        entityMetadata.ownColumns = [
            ...junctionColumns,
            ...inverseJunctionColumns
        ];
        entityMetadata.ownColumns.forEach((column)=>column.relationMetadata = relation);
        // create junction table foreign keys
        // Note: UPDATE CASCADE clause is not supported in Oracle.
        // Note: UPDATE/DELETE CASCADE clauses are not supported in Spanner.
        entityMetadata.foreignKeys = relation.createForeignKeyConstraints ? [
            new ForeignKeyMetadata_1.ForeignKeyMetadata({
                entityMetadata: entityMetadata,
                referencedEntityMetadata: relation.entityMetadata,
                columns: junctionColumns,
                referencedColumns: referencedColumns,
                name: junctionColumns[0]?.foreignKeyConstraintName,
                onDelete: this.connection.driver.options.type === "spanner" ? "NO ACTION" : relation.onDelete || "CASCADE",
                onUpdate: this.connection.driver.options.type === "oracle" || this.connection.driver.options.type === "spanner" ? "NO ACTION" : relation.onUpdate || "CASCADE"
            }),
            new ForeignKeyMetadata_1.ForeignKeyMetadata({
                entityMetadata: entityMetadata,
                referencedEntityMetadata: relation.inverseEntityMetadata,
                columns: inverseJunctionColumns,
                referencedColumns: inverseReferencedColumns,
                name: inverseJunctionColumns[0]?.foreignKeyConstraintName,
                onDelete: this.connection.driver.options.type === "spanner" ? "NO ACTION" : relation.inverseRelation ? relation.inverseRelation.onDelete : "CASCADE",
                onUpdate: this.connection.driver.options.type === "oracle" || this.connection.driver.options.type === "spanner" ? "NO ACTION" : relation.inverseRelation ? relation.inverseRelation.onUpdate : "CASCADE"
            })
        ] : [];
        // create junction table indices
        entityMetadata.ownIndices = [
            new IndexMetadata_1.IndexMetadata({
                entityMetadata: entityMetadata,
                columns: junctionColumns,
                args: {
                    target: entityMetadata.target,
                    synchronize: true
                }
            }),
            new IndexMetadata_1.IndexMetadata({
                entityMetadata: entityMetadata,
                columns: inverseJunctionColumns,
                args: {
                    target: entityMetadata.target,
                    synchronize: true
                }
            })
        ];
        // finally return entity metadata
        return entityMetadata;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Collects referenced columns from the given join column args.
     */ collectReferencedColumns(relation, joinTable) {
        const hasAnyReferencedColumnName = joinTable.joinColumns ? joinTable.joinColumns.find((joinColumn)=>!!joinColumn.referencedColumnName) : false;
        if (!joinTable.joinColumns || joinTable.joinColumns && !hasAnyReferencedColumnName) {
            return relation.entityMetadata.columns.filter((column)=>column.isPrimary);
        } else {
            return joinTable.joinColumns.map((joinColumn)=>{
                const referencedColumn = relation.entityMetadata.columns.find((column)=>column.propertyName === joinColumn.referencedColumnName);
                if (!referencedColumn) throw new error_1.TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.entityMetadata.name}`);
                return referencedColumn;
            });
        }
    }
    /**
     * Collects inverse referenced columns from the given join column args.
     */ collectInverseReferencedColumns(relation, joinTable) {
        const hasInverseJoinColumns = !!joinTable.inverseJoinColumns;
        const hasAnyInverseReferencedColumnName = hasInverseJoinColumns ? joinTable.inverseJoinColumns.find((joinColumn)=>!!joinColumn.referencedColumnName) : false;
        if (!hasInverseJoinColumns || hasInverseJoinColumns && !hasAnyInverseReferencedColumnName) {
            return relation.inverseEntityMetadata.primaryColumns;
        } else {
            return joinTable.inverseJoinColumns.map((joinColumn)=>{
                const referencedColumn = relation.inverseEntityMetadata.ownColumns.find((column)=>column.propertyName === joinColumn.referencedColumnName);
                if (!referencedColumn) throw new error_1.TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);
                return referencedColumn;
            });
        }
    }
    changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns) {
        junctionColumns.forEach((junctionColumn)=>{
            inverseJunctionColumns.forEach((inverseJunctionColumn)=>{
                if (junctionColumn.givenDatabaseName === inverseJunctionColumn.givenDatabaseName) {
                    const junctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(junctionColumn.propertyName, 1);
                    junctionColumn.propertyName = junctionColumnName;
                    junctionColumn.givenDatabaseName = junctionColumnName;
                    const inverseJunctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(inverseJunctionColumn.propertyName, 2);
                    inverseJunctionColumn.propertyName = inverseJunctionColumnName;
                    inverseJunctionColumn.givenDatabaseName = inverseJunctionColumnName;
                }
            });
        });
    }
}
exports.JunctionEntityMetadataBuilder = JunctionEntityMetadataBuilder; //# sourceMappingURL=JunctionEntityMetadataBuilder.js.map
}}),
"[project]/node_modules/typeorm/metadata-builder/ClosureJunctionEntityMetadataBuilder.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ClosureJunctionEntityMetadataBuilder = void 0;
const EntityMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/EntityMetadata.js [app-route] (ecmascript)");
const ColumnMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/ColumnMetadata.js [app-route] (ecmascript)");
const ForeignKeyMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/ForeignKeyMetadata.js [app-route] (ecmascript)");
const IndexMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/IndexMetadata.js [app-route] (ecmascript)");
/**
 * Creates EntityMetadata for junction tables of the closure entities.
 * Closure junction tables are tables generated by closure entities.
 */ class ClosureJunctionEntityMetadataBuilder {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        this.connection = connection;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Builds EntityMetadata for the closure junction of the given closure entity.
     */ build(parentClosureEntityMetadata) {
        // create entity metadata itself
        const entityMetadata = new EntityMetadata_1.EntityMetadata({
            parentClosureEntityMetadata: parentClosureEntityMetadata,
            connection: this.connection,
            args: {
                target: "",
                name: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.closureTableName ? parentClosureEntityMetadata.treeOptions.closureTableName : parentClosureEntityMetadata.tableNameWithoutPrefix,
                type: "closure-junction"
            }
        });
        entityMetadata.build();
        // create ancestor and descendant columns for new closure junction table
        parentClosureEntityMetadata.primaryColumns.forEach((primaryColumn)=>{
            entityMetadata.ownColumns.push(new ColumnMetadata_1.ColumnMetadata({
                connection: this.connection,
                entityMetadata: entityMetadata,
                closureType: "ancestor",
                referencedColumn: primaryColumn,
                args: {
                    target: "",
                    mode: "virtual",
                    propertyName: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.ancestorColumnName ? parentClosureEntityMetadata.treeOptions.ancestorColumnName(primaryColumn) : primaryColumn.propertyName + "_ancestor",
                    options: {
                        primary: true,
                        length: primaryColumn.length,
                        type: primaryColumn.type
                    }
                }
            }));
            entityMetadata.ownColumns.push(new ColumnMetadata_1.ColumnMetadata({
                connection: this.connection,
                entityMetadata: entityMetadata,
                closureType: "descendant",
                referencedColumn: primaryColumn,
                args: {
                    target: "",
                    mode: "virtual",
                    propertyName: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.descendantColumnName ? parentClosureEntityMetadata.treeOptions.descendantColumnName(primaryColumn) : primaryColumn.propertyName + "_descendant",
                    options: {
                        primary: true,
                        length: primaryColumn.length,
                        type: primaryColumn.type
                    }
                }
            }));
        });
        entityMetadata.ownIndices = [
            new IndexMetadata_1.IndexMetadata({
                entityMetadata: entityMetadata,
                columns: [
                    entityMetadata.ownColumns[0]
                ],
                args: {
                    target: entityMetadata.target,
                    synchronize: true
                }
            }),
            new IndexMetadata_1.IndexMetadata({
                entityMetadata: entityMetadata,
                columns: [
                    entityMetadata.ownColumns[1]
                ],
                args: {
                    target: entityMetadata.target,
                    synchronize: true
                }
            })
        ];
        // if tree level column was defined by a closure entity then add it to the junction columns as well
        if (parentClosureEntityMetadata.treeLevelColumn) {
            entityMetadata.ownColumns.push(new ColumnMetadata_1.ColumnMetadata({
                connection: this.connection,
                entityMetadata: entityMetadata,
                args: {
                    target: "",
                    mode: "virtual",
                    propertyName: "level",
                    options: {
                        type: this.connection.driver.mappedDataTypes.treeLevel
                    }
                }
            }));
        }
        // create junction table foreign keys
        // Note: CASCADE is not applied to mssql because it does not support multi cascade paths
        entityMetadata.foreignKeys = [
            new ForeignKeyMetadata_1.ForeignKeyMetadata({
                entityMetadata: entityMetadata,
                referencedEntityMetadata: parentClosureEntityMetadata,
                columns: [
                    entityMetadata.ownColumns[0]
                ],
                referencedColumns: parentClosureEntityMetadata.primaryColumns,
                onDelete: this.connection.driver.options.type === "mssql" ? "NO ACTION" : "CASCADE"
            }),
            new ForeignKeyMetadata_1.ForeignKeyMetadata({
                entityMetadata: entityMetadata,
                referencedEntityMetadata: parentClosureEntityMetadata,
                columns: [
                    entityMetadata.ownColumns[1]
                ],
                referencedColumns: parentClosureEntityMetadata.primaryColumns,
                onDelete: this.connection.driver.options.type === "mssql" ? "NO ACTION" : "CASCADE"
            })
        ];
        return entityMetadata;
    }
}
exports.ClosureJunctionEntityMetadataBuilder = ClosureJunctionEntityMetadataBuilder; //# sourceMappingURL=ClosureJunctionEntityMetadataBuilder.js.map
}}),
"[project]/node_modules/typeorm/metadata-builder/RelationJoinColumnBuilder.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationJoinColumnBuilder = void 0;
const ColumnMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/ColumnMetadata.js [app-route] (ecmascript)");
const UniqueMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/UniqueMetadata.js [app-route] (ecmascript)");
const ForeignKeyMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/ForeignKeyMetadata.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
/**
 * Builds join column for the many-to-one and one-to-one owner relations.
 *
 * Cases it should cover:
 * 1. when join column is set with custom name and without referenced column name
 * we need automatically set referenced column name - primary ids by default
 * @JoinColumn({ name: "custom_name" })
 *
 * 2. when join column is set with only referenced column name
 * we need automatically set join column name - relation name + referenced column name
 * @JoinColumn({ referencedColumnName: "title" })
 *
 * 3. when join column is set without both referenced column name and join column name
 * we need to automatically set both of them
 * @JoinColumn()
 *
 * 4. when join column is not set at all (as in case of @ManyToOne relation)
 * we need to create join column for it with proper referenced column name and join column name
 *
 * 5. when multiple join columns set none of referencedColumnName and name can be optional
 * both options are required
 * @JoinColumn([
 *      { name: "category_title", referencedColumnName: "type" },
 *      { name: "category_title", referencedColumnName: "name" },
 * ])
 *
 * Since for many-to-one relations having JoinColumn decorator is not required,
 * we need to go through each many-to-one relation without join column decorator set
 * and create join column metadata args for them.
 */ class RelationJoinColumnBuilder {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        this.connection = connection;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Builds a foreign key of the many-to-one or one-to-one owner relations.
     */ build(joinColumns, relation) {
        const referencedColumns = this.collectReferencedColumns(joinColumns, relation);
        const columns = this.collectColumns(joinColumns, relation, referencedColumns);
        if (!referencedColumns.length || !relation.createForeignKeyConstraints) return {
            foreignKey: undefined,
            columns,
            uniqueConstraint: undefined
        }; // this case is possible for one-to-one non owning side and relations with createForeignKeyConstraints = false
        const foreignKey = new ForeignKeyMetadata_1.ForeignKeyMetadata({
            name: joinColumns[0]?.foreignKeyConstraintName,
            entityMetadata: relation.entityMetadata,
            referencedEntityMetadata: relation.inverseEntityMetadata,
            namingStrategy: this.connection.namingStrategy,
            columns,
            referencedColumns,
            onDelete: relation.onDelete,
            onUpdate: relation.onUpdate,
            deferrable: relation.deferrable
        });
        // SQL requires UNIQUE/PK constraints on columns referenced by a FK
        // Skip creating the unique constraint for the referenced columns if
        // they are already contained in the PK of the referenced entity
        if (columns.every((column)=>column.isPrimary) || !relation.isOneToOne) {
            return {
                foreignKey,
                columns,
                uniqueConstraint: undefined
            };
        }
        const uniqueConstraint = new UniqueMetadata_1.UniqueMetadata({
            entityMetadata: relation.entityMetadata,
            columns: foreignKey.columns,
            args: {
                name: this.connection.namingStrategy.relationConstraintName(relation.entityMetadata.tableName, foreignKey.columns.map((column)=>column.databaseName)),
                target: relation.entityMetadata.target
            }
        });
        uniqueConstraint.build(this.connection.namingStrategy);
        return {
            foreignKey,
            columns,
            uniqueConstraint
        };
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Collects referenced columns from the given join column args.
     */ collectReferencedColumns(joinColumns, relation) {
        const hasAnyReferencedColumnName = joinColumns.find((joinColumnArgs)=>!!joinColumnArgs.referencedColumnName);
        const manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;
        const hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;
        if (manyToOneWithoutJoinColumn || hasJoinColumnWithoutAnyReferencedColumnName) {
            // covers case3 and case1
            return relation.inverseEntityMetadata.primaryColumns;
        } else {
            // cases with referenced columns defined
            return joinColumns.map((joinColumn)=>{
                const referencedColumn = relation.inverseEntityMetadata.ownColumns.find((column)=>column.propertyName === joinColumn.referencedColumnName); // todo: can we also search in relations?
                if (!referencedColumn) throw new error_1.TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);
                return referencedColumn;
            });
        }
    }
    /**
     * Collects columns from the given join column args.
     */ collectColumns(joinColumns, relation, referencedColumns) {
        return referencedColumns.map((referencedColumn)=>{
            // in the case if relation has join column with only name set we need this check
            const joinColumnMetadataArg = joinColumns.find((joinColumn)=>{
                return (!joinColumn.referencedColumnName || joinColumn.referencedColumnName === referencedColumn.propertyName) && !!joinColumn.name;
            });
            const joinColumnName = joinColumnMetadataArg ? joinColumnMetadataArg.name : this.connection.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);
            const relationalColumns = relation.embeddedMetadata ? relation.embeddedMetadata.columns : relation.entityMetadata.ownColumns;
            let relationalColumn = relationalColumns.find((column)=>column.databaseNameWithoutPrefixes === joinColumnName);
            if (!relationalColumn) {
                relationalColumn = new ColumnMetadata_1.ColumnMetadata({
                    connection: this.connection,
                    entityMetadata: relation.entityMetadata,
                    embeddedMetadata: relation.embeddedMetadata,
                    args: {
                        target: "",
                        mode: "virtual",
                        propertyName: relation.propertyName,
                        options: {
                            name: joinColumnName,
                            type: referencedColumn.type,
                            length: !referencedColumn.length && (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") && // some versions of mariadb support the column type and should not try to provide the length property
                            this.connection.driver.normalizeType(referencedColumn) !== "uuid" && (referencedColumn.generationStrategy === "uuid" || referencedColumn.type === "uuid") ? "36" : referencedColumn.length,
                            width: referencedColumn.width,
                            charset: referencedColumn.charset,
                            collation: referencedColumn.collation,
                            precision: referencedColumn.precision,
                            scale: referencedColumn.scale,
                            zerofill: referencedColumn.zerofill,
                            unsigned: referencedColumn.unsigned,
                            comment: referencedColumn.comment,
                            enum: referencedColumn.enum,
                            enumName: referencedColumn.enumName,
                            primary: relation.isPrimary,
                            nullable: relation.isNullable
                        }
                    }
                });
                relation.entityMetadata.registerColumn(relationalColumn);
            }
            relationalColumn.referencedColumn = referencedColumn; // its important to set it here because we need to set referenced column for user defined join column
            relationalColumn.type = referencedColumn.type; // also since types of relational column and join column must be equal we override user defined column type
            relationalColumn.relationMetadata = relation;
            relationalColumn.build(this.connection);
            return relationalColumn;
        });
    }
}
exports.RelationJoinColumnBuilder = RelationJoinColumnBuilder; //# sourceMappingURL=RelationJoinColumnBuilder.js.map
}}),
"[project]/node_modules/typeorm/metadata-builder/EntityMetadataBuilder.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntityMetadataBuilder = void 0;
const EntityMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/EntityMetadata.js [app-route] (ecmascript)");
const ColumnMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/ColumnMetadata.js [app-route] (ecmascript)");
const IndexMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/IndexMetadata.js [app-route] (ecmascript)");
const RelationMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/RelationMetadata.js [app-route] (ecmascript)");
const EmbeddedMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/EmbeddedMetadata.js [app-route] (ecmascript)");
const RelationIdMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/RelationIdMetadata.js [app-route] (ecmascript)");
const RelationCountMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/RelationCountMetadata.js [app-route] (ecmascript)");
const EventListenerTypes_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)");
const MetadataUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata-builder/MetadataUtils.js [app-route] (ecmascript)");
const JunctionEntityMetadataBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata-builder/JunctionEntityMetadataBuilder.js [app-route] (ecmascript)");
const ClosureJunctionEntityMetadataBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata-builder/ClosureJunctionEntityMetadataBuilder.js [app-route] (ecmascript)");
const RelationJoinColumnBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata-builder/RelationJoinColumnBuilder.js [app-route] (ecmascript)");
const EntityListenerMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/EntityListenerMetadata.js [app-route] (ecmascript)");
const UniqueMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/UniqueMetadata.js [app-route] (ecmascript)");
const CheckMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/CheckMetadata.js [app-route] (ecmascript)");
const ExclusionMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/ExclusionMetadata.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const ForeignKeyMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/ForeignKeyMetadata.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Builds EntityMetadata objects and all its sub-metadatas.
 */ class EntityMetadataBuilder {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection, metadataArgsStorage){
        this.connection = connection;
        this.metadataArgsStorage = metadataArgsStorage;
        this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder_1.JunctionEntityMetadataBuilder(connection);
        this.closureJunctionEntityMetadataBuilder = new ClosureJunctionEntityMetadataBuilder_1.ClosureJunctionEntityMetadataBuilder(connection);
        this.relationJoinColumnBuilder = new RelationJoinColumnBuilder_1.RelationJoinColumnBuilder(connection);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Builds a complete entity metadatas for the given entity classes.
     */ build(entityClasses) {
        // if entity classes to filter entities by are given then do filtering, otherwise use all
        const allTables = entityClasses ? this.metadataArgsStorage.filterTables(entityClasses) : this.metadataArgsStorage.tables;
        // filter out table metadata args for those we really create entity metadatas and tables in the db
        const realTables = allTables.filter((table)=>table.type === "regular" || table.type === "closure" || table.type === "entity-child" || table.type === "view");
        // create entity metadatas for a user defined entities (marked with @Entity decorator or loaded from entity schemas)
        const entityMetadatas = realTables.map((tableArgs)=>this.createEntityMetadata(tableArgs));
        // compute parent entity metadatas for table inheritance
        entityMetadatas.forEach((entityMetadata)=>this.computeParentEntityMetadata(entityMetadatas, entityMetadata));
        // after all metadatas created we set child entity metadatas for table inheritance
        entityMetadatas.forEach((metadata)=>{
            metadata.childEntityMetadatas = entityMetadatas.filter((childMetadata)=>{
                return typeof metadata.target === "function" && typeof childMetadata.target === "function" && MetadataUtils_1.MetadataUtils.isInherited(childMetadata.target, metadata.target);
            });
        });
        // build entity metadata (step0), first for non-single-table-inherited entity metadatas (dependant)
        entityMetadatas.filter((entityMetadata)=>entityMetadata.tableType !== "entity-child").forEach((entityMetadata)=>entityMetadata.build());
        // build entity metadata (step0), now for single-table-inherited entity metadatas (dependant)
        entityMetadatas.filter((entityMetadata)=>entityMetadata.tableType === "entity-child").forEach((entityMetadata)=>entityMetadata.build());
        // compute entity metadata columns, relations, etc. first for the regular, non-single-table-inherited entity metadatas
        entityMetadatas.filter((entityMetadata)=>entityMetadata.tableType !== "entity-child").forEach((entityMetadata)=>this.computeEntityMetadataStep1(entityMetadatas, entityMetadata));
        // then do it for single table inheritance children (since they are depend on their parents to be built)
        entityMetadatas.filter((entityMetadata)=>entityMetadata.tableType === "entity-child").forEach((entityMetadata)=>this.computeEntityMetadataStep1(entityMetadatas, entityMetadata));
        // calculate entity metadata computed properties and all its sub-metadatas
        entityMetadatas.forEach((entityMetadata)=>this.computeEntityMetadataStep2(entityMetadata));
        // calculate entity metadata's inverse properties
        entityMetadatas.forEach((entityMetadata)=>this.computeInverseProperties(entityMetadata, entityMetadatas));
        // go through all entity metadatas and create foreign keys / junction entity metadatas for their relations
        entityMetadatas.filter((entityMetadata)=>entityMetadata.tableType !== "entity-child").forEach((entityMetadata)=>{
            // create entity's relations join columns (for many-to-one and one-to-one owner)
            entityMetadata.relations.filter((relation)=>relation.isOneToOne || relation.isManyToOne).forEach((relation)=>{
                const joinColumns = this.metadataArgsStorage.filterJoinColumns(relation.target, relation.propertyName);
                const { foreignKey, columns, uniqueConstraint } = this.relationJoinColumnBuilder.build(joinColumns, relation); // create a foreign key based on its metadata args
                if (foreignKey) {
                    relation.registerForeignKeys(foreignKey); // push it to the relation and thus register there a join column
                    entityMetadata.foreignKeys.push(foreignKey);
                }
                if (columns) {
                    relation.registerJoinColumns(columns);
                }
                if (uniqueConstraint) {
                    if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql" || this.connection.driver.options.type === "mssql" || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
                        const index = new IndexMetadata_1.IndexMetadata({
                            entityMetadata: uniqueConstraint.entityMetadata,
                            columns: uniqueConstraint.columns,
                            args: {
                                target: uniqueConstraint.target,
                                name: uniqueConstraint.name,
                                unique: true,
                                synchronize: true
                            }
                        });
                        if (this.connection.driver.options.type === "mssql") {
                            index.where = index.columns.map((column)=>{
                                return `${this.connection.driver.escape(column.databaseName)} IS NOT NULL`;
                            }).join(" AND ");
                        }
                        if (this.connection.driver.options.type === "spanner") {
                            index.isNullFiltered = true;
                        }
                        if (relation.embeddedMetadata) {
                            relation.embeddedMetadata.indices.push(index);
                        } else {
                            relation.entityMetadata.ownIndices.push(index);
                        }
                        this.computeEntityMetadataStep2(entityMetadata);
                    } else {
                        if (relation.embeddedMetadata) {
                            relation.embeddedMetadata.uniques.push(uniqueConstraint);
                        } else {
                            relation.entityMetadata.ownUniques.push(uniqueConstraint);
                        }
                        this.computeEntityMetadataStep2(entityMetadata);
                    }
                }
                if (foreignKey && this.connection.driver.options.type === "cockroachdb") {
                    const index = new IndexMetadata_1.IndexMetadata({
                        entityMetadata: relation.entityMetadata,
                        columns: foreignKey.columns,
                        args: {
                            target: relation.entityMetadata.target,
                            synchronize: true
                        }
                    });
                    if (relation.embeddedMetadata) {
                        relation.embeddedMetadata.indices.push(index);
                    } else {
                        relation.entityMetadata.ownIndices.push(index);
                    }
                    this.computeEntityMetadataStep2(entityMetadata);
                }
            });
            // create junction entity metadatas for entity many-to-many relations
            entityMetadata.relations.filter((relation)=>relation.isManyToMany).forEach((relation)=>{
                const joinTable = this.metadataArgsStorage.findJoinTable(relation.target, relation.propertyName);
                if (!joinTable) return; // no join table set - no need to do anything (it means this is many-to-many inverse side)
                // here we create a junction entity metadata for a new junction table of many-to-many relation
                const junctionEntityMetadata = this.junctionEntityMetadataBuilder.build(relation, joinTable);
                relation.registerForeignKeys(...junctionEntityMetadata.foreignKeys);
                relation.registerJoinColumns(junctionEntityMetadata.ownIndices[0].columns, junctionEntityMetadata.ownIndices[1].columns);
                relation.registerJunctionEntityMetadata(junctionEntityMetadata);
                // compute new entity metadata properties and push it to entity metadatas pool
                this.computeEntityMetadataStep2(junctionEntityMetadata);
                this.computeInverseProperties(junctionEntityMetadata, entityMetadatas);
                entityMetadatas.push(junctionEntityMetadata);
            });
        });
        // update entity metadata depend properties
        entityMetadatas.forEach((entityMetadata)=>{
            entityMetadata.relationsWithJoinColumns = entityMetadata.relations.filter((relation)=>relation.isWithJoinColumn);
            entityMetadata.hasNonNullableRelations = entityMetadata.relationsWithJoinColumns.some((relation)=>!relation.isNullable || relation.isPrimary);
        });
        // generate closure junction tables for all closure tables
        entityMetadatas.filter((metadata)=>metadata.treeType === "closure-table").forEach((entityMetadata)=>{
            const closureJunctionEntityMetadata = this.closureJunctionEntityMetadataBuilder.build(entityMetadata);
            entityMetadata.closureJunctionTable = closureJunctionEntityMetadata;
            this.computeEntityMetadataStep2(closureJunctionEntityMetadata);
            this.computeInverseProperties(closureJunctionEntityMetadata, entityMetadatas);
            entityMetadatas.push(closureJunctionEntityMetadata);
        });
        // generate keys for tables with single-table inheritance
        entityMetadatas.filter((metadata)=>metadata.inheritancePattern === "STI" && metadata.discriminatorColumn).forEach((entityMetadata)=>this.createKeysForTableInheritance(entityMetadata));
        // build all indices (need to do it after relations and their join columns are built)
        entityMetadatas.forEach((entityMetadata)=>{
            entityMetadata.indices.forEach((index)=>index.build(this.connection.namingStrategy));
        });
        // build all unique constraints (need to do it after relations and their join columns are built)
        entityMetadatas.forEach((entityMetadata)=>{
            entityMetadata.uniques.forEach((unique)=>unique.build(this.connection.namingStrategy));
        });
        // build all check constraints
        entityMetadatas.forEach((entityMetadata)=>{
            entityMetadata.checks.forEach((check)=>check.build(this.connection.namingStrategy));
        });
        // build all exclusion constraints
        entityMetadatas.forEach((entityMetadata)=>{
            entityMetadata.exclusions.forEach((exclusion)=>exclusion.build(this.connection.namingStrategy));
        });
        // generate foreign keys for tables
        entityMetadatas.forEach((entityMetadata)=>this.createForeignKeys(entityMetadata, entityMetadatas));
        // add lazy initializer for entity relations
        entityMetadatas.filter((metadata)=>typeof metadata.target === "function").forEach((entityMetadata)=>{
            entityMetadata.relations.filter((relation)=>relation.isLazy).forEach((relation)=>{
                this.connection.relationLoader.enableLazyLoad(relation, entityMetadata.target.prototype);
            });
        });
        entityMetadatas.forEach((entityMetadata)=>{
            entityMetadata.columns.forEach((column)=>{
                // const target = column.embeddedMetadata ? column.embeddedMetadata.type : column.target;
                const generated = this.metadataArgsStorage.findGenerated(column.target, column.propertyName);
                if (generated) {
                    column.isGenerated = true;
                    column.generationStrategy = generated.strategy;
                    if (generated.strategy === "uuid") {
                        column.type = "uuid";
                    } else if (generated.strategy === "rowid") {
                        column.type = "int";
                    } else {
                        column.type = column.type || Number;
                    }
                    column.build(this.connection);
                    this.computeEntityMetadataStep2(entityMetadata);
                }
            });
        });
        return entityMetadatas;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates entity metadata from the given table args.
     * Creates column, relation, etc. metadatas for everything this entity metadata owns.
     */ createEntityMetadata(tableArgs) {
        // we take all "inheritance tree" from a target entity to collect all stored metadata args
        // (by decorators or inside entity schemas). For example for target Post < ContentModel < Unit
        // it will be an array of [Post, ContentModel, Unit] and we can then get all metadata args of those classes
        const inheritanceTree = typeof tableArgs.target === "function" ? MetadataUtils_1.MetadataUtils.getInheritanceTree(tableArgs.target) : [
            tableArgs.target
        ]; // todo: implement later here inheritance for string-targets
        const tableInheritance = this.metadataArgsStorage.findInheritanceType(tableArgs.target);
        const tableTree = this.metadataArgsStorage.findTree(tableArgs.target);
        // if single table inheritance used, we need to copy all children columns in to parent table
        let singleTableChildrenTargets;
        if (tableInheritance && tableInheritance.pattern === "STI" || tableArgs.type === "entity-child") {
            singleTableChildrenTargets = this.metadataArgsStorage.filterSingleTableChildren(tableArgs.target).map((args)=>args.target).filter((target)=>typeof target === "function");
            inheritanceTree.push(...singleTableChildrenTargets);
        }
        return new EntityMetadata_1.EntityMetadata({
            connection: this.connection,
            args: tableArgs,
            inheritanceTree: inheritanceTree,
            tableTree: tableTree,
            inheritancePattern: tableInheritance ? tableInheritance.pattern : undefined
        });
    }
    computeParentEntityMetadata(allEntityMetadatas, entityMetadata) {
        // after all metadatas created we set parent entity metadata for table inheritance
        if (entityMetadata.tableType === "entity-child") {
            entityMetadata.parentEntityMetadata = allEntityMetadatas.find((allEntityMetadata)=>{
                return allEntityMetadata.inheritanceTree.indexOf(entityMetadata.target) !== -1 && allEntityMetadata.inheritancePattern === "STI";
            });
        }
    }
    computeEntityMetadataStep1(allEntityMetadatas, entityMetadata) {
        const entityInheritance = this.metadataArgsStorage.findInheritanceType(entityMetadata.target);
        const discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(entityMetadata.target);
        if (typeof discriminatorValue !== "undefined") {
            entityMetadata.discriminatorValue = discriminatorValue.value;
        } else {
            entityMetadata.discriminatorValue = entityMetadata.target.name;
        }
        // if single table inheritance is used, we need to mark all embedded columns as nullable
        entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(entityMetadata.inheritanceTree)).map((embedded)=>{
            if (entityMetadata.inheritancePattern === "STI") {
                embedded.columns = embedded.columns.map((column)=>{
                    column.isNullable = true;
                    return column;
                });
            }
            return embedded;
        });
        entityMetadata.ownColumns = this.metadataArgsStorage.filterColumns(entityMetadata.inheritanceTree).map((args)=>{
            // for single table children we reuse columns created for their parents
            if (entityMetadata.tableType === "entity-child") return entityMetadata.parentEntityMetadata.ownColumns.find((column)=>column.propertyName === args.propertyName);
            // for multiple table inheritance we can override default column values
            if (entityMetadata.tableType === "regular" && args.target !== entityMetadata.target) {
                const childArgs = this.metadataArgsStorage.columns.find((c)=>c.propertyName === args.propertyName && c.target === entityMetadata.target);
                if (childArgs && childArgs.options.default) {
                    args.options.default = childArgs.options.default;
                }
            }
            const column = new ColumnMetadata_1.ColumnMetadata({
                connection: this.connection,
                entityMetadata,
                args
            });
            // if single table inheritance used, we need to mark all inherit table columns as nullable
            const columnInSingleTableInheritedChild = allEntityMetadatas.find((otherEntityMetadata)=>otherEntityMetadata.tableType === "entity-child" && otherEntityMetadata.target === args.target);
            if (columnInSingleTableInheritedChild) column.isNullable = true;
            return column;
        });
        // for table inheritance we need to add a discriminator column
        //
        if (entityInheritance && entityInheritance.column) {
            const discriminatorColumnName = entityInheritance.column && entityInheritance.column.name ? entityInheritance.column.name : "type";
            let discriminatorColumn = entityMetadata.ownColumns.find((column)=>column.propertyName === discriminatorColumnName);
            if (!discriminatorColumn) {
                discriminatorColumn = new ColumnMetadata_1.ColumnMetadata({
                    connection: this.connection,
                    entityMetadata: entityMetadata,
                    args: {
                        target: entityMetadata.target,
                        mode: "virtual",
                        propertyName: discriminatorColumnName,
                        options: entityInheritance.column || {
                            name: discriminatorColumnName,
                            type: "varchar",
                            nullable: false
                        }
                    }
                });
                discriminatorColumn.isVirtual = true;
                discriminatorColumn.isDiscriminator = true;
                entityMetadata.ownColumns.push(discriminatorColumn);
            } else {
                discriminatorColumn.isDiscriminator = true;
            }
        }
        // add discriminator column to the child entity metadatas
        // discriminator column will not be there automatically since we are creating it in the code above
        if (entityMetadata.tableType === "entity-child") {
            const discriminatorColumn = entityMetadata.parentEntityMetadata.ownColumns.find((column)=>column.isDiscriminator);
            if (discriminatorColumn && !entityMetadata.ownColumns.find((column)=>column === discriminatorColumn)) {
                entityMetadata.ownColumns.push(discriminatorColumn);
            }
            // also copy the inheritance pattern & tree metadata
            // this comes in handy when inheritance and trees are used together
            entityMetadata.inheritancePattern = entityMetadata.parentEntityMetadata.inheritancePattern;
            if (!entityMetadata.treeType && !!entityMetadata.parentEntityMetadata.treeType) {
                entityMetadata.treeType = entityMetadata.parentEntityMetadata.treeType;
                entityMetadata.treeOptions = entityMetadata.parentEntityMetadata.treeOptions;
                entityMetadata.treeParentRelation = entityMetadata.parentEntityMetadata.treeParentRelation;
                entityMetadata.treeLevelColumn = entityMetadata.parentEntityMetadata.treeLevelColumn;
            }
        }
        const { namingStrategy } = this.connection;
        // check if tree is used then we need to add extra columns for specific tree types
        if (entityMetadata.treeType === "materialized-path") {
            entityMetadata.ownColumns.push(new ColumnMetadata_1.ColumnMetadata({
                connection: this.connection,
                entityMetadata: entityMetadata,
                materializedPath: true,
                args: {
                    target: entityMetadata.target,
                    mode: "virtual",
                    propertyName: "mpath",
                    options: /*tree.column || */ {
                        name: namingStrategy.materializedPathColumnName,
                        type: String,
                        nullable: true,
                        default: ""
                    }
                }
            }));
        } else if (entityMetadata.treeType === "nested-set") {
            const { left, right } = namingStrategy.nestedSetColumnNames;
            entityMetadata.ownColumns.push(new ColumnMetadata_1.ColumnMetadata({
                connection: this.connection,
                entityMetadata: entityMetadata,
                nestedSetLeft: true,
                args: {
                    target: entityMetadata.target,
                    mode: "virtual",
                    propertyName: left,
                    options: /*tree.column || */ {
                        name: left,
                        type: Number,
                        nullable: false,
                        default: 1
                    }
                }
            }));
            entityMetadata.ownColumns.push(new ColumnMetadata_1.ColumnMetadata({
                connection: this.connection,
                entityMetadata: entityMetadata,
                nestedSetRight: true,
                args: {
                    target: entityMetadata.target,
                    mode: "virtual",
                    propertyName: right,
                    options: /*tree.column || */ {
                        name: right,
                        type: Number,
                        nullable: false,
                        default: 2
                    }
                }
            }));
        }
        entityMetadata.ownRelations = this.metadataArgsStorage.filterRelations(entityMetadata.inheritanceTree).map((args)=>{
            // for single table children we reuse relations created for their parents
            if (entityMetadata.tableType === "entity-child") {
                const parentRelation = entityMetadata.parentEntityMetadata.ownRelations.find((relation)=>relation.propertyName === args.propertyName);
                const type = typeof args.type === "function" ? args.type() : args.type;
                if (parentRelation.type !== type) {
                    const clone = Object.create(parentRelation);
                    clone.type = type;
                    return clone;
                }
                return parentRelation;
            }
            return new RelationMetadata_1.RelationMetadata({
                entityMetadata,
                args
            });
        });
        entityMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(entityMetadata.inheritanceTree).map((args)=>{
            // for single table children we reuse relation ids created for their parents
            if (entityMetadata.tableType === "entity-child") return entityMetadata.parentEntityMetadata.relationIds.find((relationId)=>relationId.propertyName === args.propertyName);
            return new RelationIdMetadata_1.RelationIdMetadata({
                entityMetadata,
                args
            });
        });
        entityMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(entityMetadata.inheritanceTree).map((args)=>{
            // for single table children we reuse relation counts created for their parents
            if (entityMetadata.tableType === "entity-child") return entityMetadata.parentEntityMetadata.relationCounts.find((relationCount)=>relationCount.propertyName === args.propertyName);
            return new RelationCountMetadata_1.RelationCountMetadata({
                entityMetadata,
                args
            });
        });
        entityMetadata.ownListeners = this.metadataArgsStorage.filterListeners(entityMetadata.inheritanceTree).map((args)=>{
            return new EntityListenerMetadata_1.EntityListenerMetadata({
                entityMetadata: entityMetadata,
                args: args
            });
        });
        entityMetadata.checks = this.metadataArgsStorage.filterChecks(entityMetadata.inheritanceTree).map((args)=>{
            return new CheckMetadata_1.CheckMetadata({
                entityMetadata,
                args
            });
        });
        // Only PostgreSQL supports exclusion constraints.
        if (this.connection.driver.options.type === "postgres") {
            entityMetadata.exclusions = this.metadataArgsStorage.filterExclusions(entityMetadata.inheritanceTree).map((args)=>{
                return new ExclusionMetadata_1.ExclusionMetadata({
                    entityMetadata,
                    args
                });
            });
        }
        if (this.connection.driver.options.type === "cockroachdb") {
            entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).filter((args)=>!args.unique).map((args)=>{
                return new IndexMetadata_1.IndexMetadata({
                    entityMetadata,
                    args
                });
            });
            const uniques = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).filter((args)=>args.unique).map((args)=>{
                return new UniqueMetadata_1.UniqueMetadata({
                    entityMetadata: entityMetadata,
                    args: {
                        target: args.target,
                        name: args.name,
                        columns: args.columns
                    }
                });
            });
            entityMetadata.ownUniques.push(...uniques);
        } else {
            entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).map((args)=>{
                return new IndexMetadata_1.IndexMetadata({
                    entityMetadata,
                    args
                });
            });
        }
        // This drivers stores unique constraints as unique indices.
        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql" || this.connection.driver.options.type === "sap" || this.connection.driver.options.type === "spanner") {
            const indices = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map((args)=>{
                return new IndexMetadata_1.IndexMetadata({
                    entityMetadata: entityMetadata,
                    args: {
                        target: args.target,
                        name: args.name,
                        columns: args.columns,
                        unique: true,
                        synchronize: true
                    }
                });
            });
            entityMetadata.ownIndices.push(...indices);
        } else {
            const uniques = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map((args)=>{
                return new UniqueMetadata_1.UniqueMetadata({
                    entityMetadata,
                    args
                });
            });
            entityMetadata.ownUniques.push(...uniques);
        }
    }
    /**
     * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,
     * and does the same for all its sub-embeddeds (goes recursively).
     */ createEmbeddedsRecursively(entityMetadata, embeddedArgs) {
        return embeddedArgs.map((embeddedArgs)=>{
            const embeddedMetadata = new EmbeddedMetadata_1.EmbeddedMetadata({
                entityMetadata: entityMetadata,
                args: embeddedArgs
            });
            const targets = typeof embeddedMetadata.type === "function" ? MetadataUtils_1.MetadataUtils.getInheritanceTree(embeddedMetadata.type) : [
                embeddedMetadata.type
            ]; // todo: implement later here inheritance for string-targets
            embeddedMetadata.columns = this.metadataArgsStorage.filterColumns(targets).map((args)=>{
                return new ColumnMetadata_1.ColumnMetadata({
                    connection: this.connection,
                    entityMetadata,
                    embeddedMetadata,
                    args
                });
            });
            embeddedMetadata.relations = this.metadataArgsStorage.filterRelations(targets).map((args)=>{
                return new RelationMetadata_1.RelationMetadata({
                    entityMetadata,
                    embeddedMetadata,
                    args
                });
            });
            embeddedMetadata.listeners = this.metadataArgsStorage.filterListeners(targets).map((args)=>{
                return new EntityListenerMetadata_1.EntityListenerMetadata({
                    entityMetadata,
                    embeddedMetadata,
                    args
                });
            });
            embeddedMetadata.indices = this.metadataArgsStorage.filterIndices(targets).map((args)=>{
                return new IndexMetadata_1.IndexMetadata({
                    entityMetadata,
                    embeddedMetadata,
                    args
                });
            });
            embeddedMetadata.uniques = this.metadataArgsStorage.filterUniques(targets).map((args)=>{
                return new UniqueMetadata_1.UniqueMetadata({
                    entityMetadata,
                    embeddedMetadata,
                    args
                });
            });
            embeddedMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(targets).map((args)=>{
                return new RelationIdMetadata_1.RelationIdMetadata({
                    entityMetadata,
                    args
                });
            });
            embeddedMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(targets).map((args)=>{
                return new RelationCountMetadata_1.RelationCountMetadata({
                    entityMetadata,
                    args
                });
            });
            embeddedMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(targets));
            embeddedMetadata.embeddeds.forEach((subEmbedded)=>subEmbedded.parentEmbeddedMetadata = embeddedMetadata);
            entityMetadata.allEmbeddeds.push(embeddedMetadata);
            return embeddedMetadata;
        });
    }
    /**
     * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).
     */ computeEntityMetadataStep2(entityMetadata) {
        entityMetadata.embeddeds.forEach((embedded)=>embedded.build(this.connection));
        entityMetadata.embeddeds.forEach((embedded)=>{
            embedded.columnsFromTree.forEach((column)=>column.build(this.connection));
            embedded.relationsFromTree.forEach((relation)=>relation.build());
        });
        entityMetadata.ownColumns.forEach((column)=>column.build(this.connection));
        entityMetadata.ownRelations.forEach((relation)=>relation.build());
        entityMetadata.relations = entityMetadata.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.relationsFromTree), entityMetadata.ownRelations);
        entityMetadata.eagerRelations = entityMetadata.relations.filter((relation)=>relation.isEager);
        entityMetadata.lazyRelations = entityMetadata.relations.filter((relation)=>relation.isLazy);
        entityMetadata.oneToOneRelations = entityMetadata.relations.filter((relation)=>relation.isOneToOne);
        entityMetadata.oneToManyRelations = entityMetadata.relations.filter((relation)=>relation.isOneToMany);
        entityMetadata.manyToOneRelations = entityMetadata.relations.filter((relation)=>relation.isManyToOne);
        entityMetadata.manyToManyRelations = entityMetadata.relations.filter((relation)=>relation.isManyToMany);
        entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter((relation)=>relation.isOneToOneOwner);
        entityMetadata.ownerManyToManyRelations = entityMetadata.relations.filter((relation)=>relation.isManyToManyOwner);
        entityMetadata.treeParentRelation = entityMetadata.relations.find((relation)=>relation.isTreeParent);
        entityMetadata.treeChildrenRelation = entityMetadata.relations.find((relation)=>relation.isTreeChildren);
        entityMetadata.columns = entityMetadata.embeddeds.reduce((columns, embedded)=>columns.concat(embedded.columnsFromTree), entityMetadata.ownColumns);
        entityMetadata.listeners = entityMetadata.embeddeds.reduce((listeners, embedded)=>listeners.concat(embedded.listenersFromTree), entityMetadata.ownListeners);
        entityMetadata.afterLoadListeners = entityMetadata.listeners.filter((listener)=>listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_LOAD);
        entityMetadata.afterInsertListeners = entityMetadata.listeners.filter((listener)=>listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_INSERT);
        entityMetadata.afterUpdateListeners = entityMetadata.listeners.filter((listener)=>listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_UPDATE);
        entityMetadata.afterRemoveListeners = entityMetadata.listeners.filter((listener)=>listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_REMOVE);
        entityMetadata.afterSoftRemoveListeners = entityMetadata.listeners.filter((listener)=>listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_SOFT_REMOVE);
        entityMetadata.afterRecoverListeners = entityMetadata.listeners.filter((listener)=>listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_RECOVER);
        entityMetadata.beforeInsertListeners = entityMetadata.listeners.filter((listener)=>listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_INSERT);
        entityMetadata.beforeUpdateListeners = entityMetadata.listeners.filter((listener)=>listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_UPDATE);
        entityMetadata.beforeRemoveListeners = entityMetadata.listeners.filter((listener)=>listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_REMOVE);
        entityMetadata.beforeSoftRemoveListeners = entityMetadata.listeners.filter((listener)=>listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_SOFT_REMOVE);
        entityMetadata.beforeRecoverListeners = entityMetadata.listeners.filter((listener)=>listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_RECOVER);
        entityMetadata.indices = entityMetadata.embeddeds.reduce((indices, embedded)=>indices.concat(embedded.indicesFromTree), entityMetadata.ownIndices);
        entityMetadata.uniques = entityMetadata.embeddeds.reduce((uniques, embedded)=>uniques.concat(embedded.uniquesFromTree), entityMetadata.ownUniques);
        entityMetadata.primaryColumns = entityMetadata.columns.filter((column)=>column.isPrimary);
        entityMetadata.nonVirtualColumns = entityMetadata.columns.filter((column)=>!column.isVirtual);
        entityMetadata.ancestorColumns = entityMetadata.columns.filter((column)=>column.closureType === "ancestor");
        entityMetadata.descendantColumns = entityMetadata.columns.filter((column)=>column.closureType === "descendant");
        entityMetadata.hasMultiplePrimaryKeys = entityMetadata.primaryColumns.length > 1;
        entityMetadata.generatedColumns = entityMetadata.columns.filter((column)=>column.isGenerated || column.isObjectId);
        entityMetadata.hasUUIDGeneratedColumns = entityMetadata.columns.filter((column)=>column.isGenerated || column.generationStrategy === "uuid").length > 0;
        entityMetadata.createDateColumn = entityMetadata.columns.find((column)=>column.isCreateDate);
        entityMetadata.updateDateColumn = entityMetadata.columns.find((column)=>column.isUpdateDate);
        entityMetadata.deleteDateColumn = entityMetadata.columns.find((column)=>column.isDeleteDate);
        entityMetadata.versionColumn = entityMetadata.columns.find((column)=>column.isVersion);
        entityMetadata.discriminatorColumn = entityMetadata.columns.find((column)=>column.isDiscriminator);
        entityMetadata.treeLevelColumn = entityMetadata.columns.find((column)=>column.isTreeLevel);
        entityMetadata.nestedSetLeftColumn = entityMetadata.columns.find((column)=>column.isNestedSetLeft);
        entityMetadata.nestedSetRightColumn = entityMetadata.columns.find((column)=>column.isNestedSetRight);
        entityMetadata.materializedPathColumn = entityMetadata.columns.find((column)=>column.isMaterializedPath);
        entityMetadata.objectIdColumn = entityMetadata.columns.find((column)=>column.isObjectId);
        entityMetadata.foreignKeys.forEach((foreignKey)=>foreignKey.build(this.connection.namingStrategy));
        entityMetadata.propertiesMap = entityMetadata.createPropertiesMap();
        entityMetadata.relationIds.forEach((relationId)=>relationId.build());
        entityMetadata.relationCounts.forEach((relationCount)=>relationCount.build());
        entityMetadata.embeddeds.forEach((embedded)=>{
            embedded.relationIdsFromTree.forEach((relationId)=>relationId.build());
            embedded.relationCountsFromTree.forEach((relationCount)=>relationCount.build());
        });
    }
    /**
     * Computes entity metadata's relations inverse side properties.
     */ computeInverseProperties(entityMetadata, entityMetadatas) {
        entityMetadata.relations.forEach((relation)=>{
            // compute inverse side (related) entity metadatas for all relation metadatas
            const inverseEntityMetadata = entityMetadatas.find((m)=>m.target === relation.type || typeof relation.type === "string" && (m.targetName === relation.type || m.givenTableName === relation.type));
            if (!inverseEntityMetadata) throw new error_1.TypeORMError("Entity metadata for " + entityMetadata.name + "#" + relation.propertyPath + " was not found. Check if you specified a correct entity object and if it's connected in the connection options.");
            relation.inverseEntityMetadata = inverseEntityMetadata;
            relation.inverseSidePropertyPath = relation.buildInverseSidePropertyPath();
            // and compute inverse relation and mark if it has such
            relation.inverseRelation = inverseEntityMetadata.relations.find((foundRelation)=>foundRelation.propertyPath === relation.inverseSidePropertyPath);
        });
    }
    /**
     * Creates indices for the table of single table inheritance.
     */ createKeysForTableInheritance(entityMetadata) {
        const isDiscriminatorColumnAlreadyIndexed = entityMetadata.indices.some(({ givenColumnNames })=>!!givenColumnNames && Array.isArray(givenColumnNames) && givenColumnNames.length === 1 && givenColumnNames[0] === entityMetadata.discriminatorColumn?.databaseName);
        // If the discriminator column is already indexed, there is no need to
        // add another index on top of it.
        if (isDiscriminatorColumnAlreadyIndexed) {
            return;
        }
        entityMetadata.indices.push(new IndexMetadata_1.IndexMetadata({
            entityMetadata: entityMetadata,
            columns: [
                entityMetadata.discriminatorColumn
            ],
            args: {
                target: entityMetadata.target,
                unique: false
            }
        }));
    }
    /**
     * Creates from the given foreign key metadata args real foreign key metadatas.
     */ createForeignKeys(entityMetadata, entityMetadatas) {
        this.metadataArgsStorage.filterForeignKeys(entityMetadata.inheritanceTree).forEach((foreignKeyArgs)=>{
            const foreignKeyType = typeof foreignKeyArgs.type === "function" ? foreignKeyArgs.type() : foreignKeyArgs.type;
            const referencedEntityMetadata = entityMetadatas.find((m)=>typeof foreignKeyType === "string" ? m.targetName === foreignKeyType || m.givenTableName === foreignKeyType : InstanceChecker_1.InstanceChecker.isEntitySchema(foreignKeyType) ? m.target === foreignKeyType.options.name || m.target === foreignKeyType.options.target : m.target === foreignKeyType);
            if (!referencedEntityMetadata) {
                throw new error_1.TypeORMError("Entity metadata for " + entityMetadata.name + (foreignKeyArgs.propertyName ? "#" + foreignKeyArgs.propertyName : "") + " was not found. Check if you specified a correct entity object and if it's connected in the connection options.");
            }
            const columnNames = foreignKeyArgs.columnNames ?? [];
            const referencedColumnNames = foreignKeyArgs.referencedColumnNames ?? [];
            const columns = [];
            const referencedColumns = [];
            if (foreignKeyArgs.propertyName) {
                columnNames.push(foreignKeyArgs.propertyName);
                if (foreignKeyArgs.inverseSide) {
                    if (typeof foreignKeyArgs.inverseSide === "function") {
                        referencedColumnNames.push(foreignKeyArgs.inverseSide(referencedEntityMetadata.propertiesMap));
                    } else {
                        referencedColumnNames.push(foreignKeyArgs.inverseSide);
                    }
                }
            }
            if (!referencedColumnNames.length) {
                referencedColumns.push(...referencedEntityMetadata.primaryColumns);
            }
            const columnNameToColumn = (columnName, entityMetadata)=>{
                const column = entityMetadata.columns.find((column)=>column.propertyName === columnName || column.databaseName === columnName);
                if (column) return column;
                const foreignKeyName = foreignKeyArgs.name ? '"' + foreignKeyArgs.name + '" ' : "";
                const entityName = entityMetadata.targetName;
                throw new error_1.TypeORMError(`Foreign key constraint ${foreignKeyName}contains column that is missing in the entity (${entityName}): ${columnName}`);
            };
            columns.push(...columnNames.map((columnName)=>columnNameToColumn(columnName, entityMetadata)));
            referencedColumns.push(...referencedColumnNames.map((columnName)=>columnNameToColumn(columnName, referencedEntityMetadata)));
            entityMetadata.foreignKeys.push(new ForeignKeyMetadata_1.ForeignKeyMetadata({
                entityMetadata,
                referencedEntityMetadata,
                namingStrategy: this.connection.namingStrategy,
                columns,
                referencedColumns,
                ...foreignKeyArgs
            }));
        });
    }
}
exports.EntityMetadataBuilder = EntityMetadataBuilder; //# sourceMappingURL=EntityMetadataBuilder.js.map
}}),
"[project]/node_modules/typeorm/metadata-args/MetadataArgsStorage.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MetadataArgsStorage = void 0;
const MetadataUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata-builder/MetadataUtils.js [app-route] (ecmascript)");
/**
 * Storage all metadatas args of all available types: tables, columns, subscribers, relations, etc.
 * Each metadata args represents some specifications of what it represents.
 * MetadataArgs used to create a real Metadata objects.
 */ class MetadataArgsStorage {
    constructor(){
        // -------------------------------------------------------------------------
        // Properties
        // -------------------------------------------------------------------------
        this.tables = [];
        this.trees = [];
        this.entityRepositories = [];
        this.transactionEntityManagers = [];
        this.transactionRepositories = [];
        this.namingStrategies = [];
        this.entitySubscribers = [];
        this.indices = [];
        this.foreignKeys = [];
        this.uniques = [];
        this.checks = [];
        this.exclusions = [];
        this.columns = [];
        this.generations = [];
        this.relations = [];
        this.joinColumns = [];
        this.joinTables = [];
        this.entityListeners = [];
        this.relationCounts = [];
        this.relationIds = [];
        this.embeddeds = [];
        this.inheritances = [];
        this.discriminatorValues = [];
    }
    filterTables(target) {
        return this.filterByTarget(this.tables, target);
    }
    filterColumns(target) {
        return this.filterByTargetAndWithoutDuplicateProperties(this.columns, target);
    }
    findGenerated(target, propertyName) {
        return this.generations.find((generated)=>{
            return (Array.isArray(target) ? target.indexOf(generated.target) !== -1 : generated.target === target) && generated.propertyName === propertyName;
        });
    }
    findTree(target) {
        return this.trees.find((tree)=>{
            return Array.isArray(target) ? target.indexOf(tree.target) !== -1 : tree.target === target;
        });
    }
    filterRelations(target) {
        return this.filterByTargetAndWithoutDuplicateRelationProperties(this.relations, target);
    }
    filterRelationIds(target) {
        return this.filterByTargetAndWithoutDuplicateProperties(this.relationIds, target);
    }
    filterRelationCounts(target) {
        return this.filterByTargetAndWithoutDuplicateProperties(this.relationCounts, target);
    }
    filterIndices(target) {
        // todo: implement parent-entity overrides?
        return this.indices.filter((index)=>{
            return Array.isArray(target) ? target.indexOf(index.target) !== -1 : index.target === target;
        });
    }
    filterForeignKeys(target) {
        return this.foreignKeys.filter((foreignKey)=>{
            return Array.isArray(target) ? target.indexOf(foreignKey.target) !== -1 : foreignKey.target === target;
        });
    }
    filterUniques(target) {
        return this.uniques.filter((unique)=>{
            return Array.isArray(target) ? target.indexOf(unique.target) !== -1 : unique.target === target;
        });
    }
    filterChecks(target) {
        return this.checks.filter((check)=>{
            return Array.isArray(target) ? target.indexOf(check.target) !== -1 : check.target === target;
        });
    }
    filterExclusions(target) {
        return this.exclusions.filter((exclusion)=>{
            return Array.isArray(target) ? target.indexOf(exclusion.target) !== -1 : exclusion.target === target;
        });
    }
    filterListeners(target) {
        return this.filterByTarget(this.entityListeners, target);
    }
    filterEmbeddeds(target) {
        return this.filterByTargetAndWithoutDuplicateEmbeddedProperties(this.embeddeds, target);
    }
    findJoinTable(target, propertyName) {
        return this.joinTables.find((joinTable)=>{
            return joinTable.target === target && joinTable.propertyName === propertyName;
        });
    }
    filterJoinColumns(target, propertyName) {
        // todo: implement parent-entity overrides?
        return this.joinColumns.filter((joinColumn)=>{
            return joinColumn.target === target && joinColumn.propertyName === propertyName;
        });
    }
    filterSubscribers(target) {
        return this.filterByTarget(this.entitySubscribers, target);
    }
    filterNamingStrategies(target) {
        return this.filterByTarget(this.namingStrategies, target);
    }
    filterTransactionEntityManagers(target, propertyName) {
        return this.transactionEntityManagers.filter((transactionEm)=>{
            return (Array.isArray(target) ? target.indexOf(transactionEm.target) !== -1 : transactionEm.target === target) && transactionEm.methodName === propertyName;
        });
    }
    filterTransactionRepository(target, propertyName) {
        return this.transactionRepositories.filter((transactionEm)=>{
            return (Array.isArray(target) ? target.indexOf(transactionEm.target) !== -1 : transactionEm.target === target) && transactionEm.methodName === propertyName;
        });
    }
    filterSingleTableChildren(target) {
        return this.tables.filter((table)=>{
            return typeof table.target === "function" && typeof target === "function" && MetadataUtils_1.MetadataUtils.isInherited(table.target, target) && table.type === "entity-child";
        });
    }
    findInheritanceType(target) {
        return this.inheritances.find((inheritance)=>inheritance.target === target);
    }
    findDiscriminatorValue(target) {
        return this.discriminatorValues.find((discriminatorValue)=>discriminatorValue.target === target);
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Filters given array by a given target or targets.
     */ filterByTarget(array, target) {
        return array.filter((table)=>{
            return Array.isArray(target) ? target.indexOf(table.target) !== -1 : table.target === target;
        });
    }
    /**
     * Filters given array by a given target or targets and prevents duplicate property names.
     */ filterByTargetAndWithoutDuplicateProperties(array, target) {
        const newArray = [];
        array.forEach((item)=>{
            const sameTarget = Array.isArray(target) ? target.indexOf(item.target) !== -1 : item.target === target;
            if (sameTarget) {
                if (!newArray.find((newItem)=>newItem.propertyName === item.propertyName)) newArray.push(item);
            }
        });
        return newArray;
    }
    /**
     * Filters given array by a given target or targets and prevents duplicate relation property names.
     */ filterByTargetAndWithoutDuplicateRelationProperties(array, target) {
        const newArray = [];
        array.forEach((item)=>{
            const sameTarget = Array.isArray(target) ? target.indexOf(item.target) !== -1 : item.target === target;
            if (sameTarget) {
                const existingIndex = newArray.findIndex((newItem)=>newItem.propertyName === item.propertyName);
                if (Array.isArray(target) && existingIndex !== -1 && target.indexOf(item.target) < target.indexOf(newArray[existingIndex].target)) {
                    const clone = Object.create(newArray[existingIndex]);
                    clone.type = item.type;
                    newArray[existingIndex] = clone;
                } else if (existingIndex === -1) {
                    newArray.push(item);
                }
            }
        });
        return newArray;
    }
    /**
     * Filters given array by a given target or targets and prevents duplicate embedded property names.
     */ filterByTargetAndWithoutDuplicateEmbeddedProperties(array, target) {
        const newArray = [];
        array.forEach((item)=>{
            const sameTarget = Array.isArray(target) ? target.indexOf(item.target) !== -1 : item.target === target;
            if (sameTarget) {
                const isDuplicateEmbeddedProperty = newArray.find((newItem)=>newItem.prefix === item.prefix && newItem.propertyName === item.propertyName);
                if (!isDuplicateEmbeddedProperty) newArray.push(item);
            }
        });
        return newArray;
    }
}
exports.MetadataArgsStorage = MetadataArgsStorage; //# sourceMappingURL=MetadataArgsStorage.js.map
}}),
"[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PlatformTools = exports.Writable = exports.Readable = exports.ReadStream = exports.EventEmitter = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const ansis_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/ansis/index.js [app-route] (ecmascript)"));
const dotenv_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)"));
const fs_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"));
const path_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const sql_highlight_1 = __turbopack_context__.r("[project]/node_modules/sql-highlight/lib/index.js [app-route] (ecmascript)");
const formatter_1 = __turbopack_context__.r("[project]/node_modules/@sqltools/formatter/lib/sqlFormatter.js [app-route] (ecmascript)");
var events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
Object.defineProperty(exports, "EventEmitter", {
    enumerable: true,
    get: function() {
        return events_1.EventEmitter;
    }
});
var fs_2 = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
Object.defineProperty(exports, "ReadStream", {
    enumerable: true,
    get: function() {
        return fs_2.ReadStream;
    }
});
var stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
Object.defineProperty(exports, "Readable", {
    enumerable: true,
    get: function() {
        return stream_1.Readable;
    }
});
Object.defineProperty(exports, "Writable", {
    enumerable: true,
    get: function() {
        return stream_1.Writable;
    }
});
/**
 * Platform-specific tools.
 */ class PlatformTools {
    /**
     * Gets global variable where global stuff can be stored.
     */ static getGlobalVariable() {
        return global;
    }
    /**
     * Loads ("require"-s) given file or package.
     * This operation only supports on node platform
     */ static load(name) {
        // if name is not absolute or relative, then try to load package from the node_modules of the directory we are currently in
        // this is useful when we are using typeorm package globally installed and it accesses drivers
        // that are not installed globally
        try {
            // switch case to explicit require statements for webpack compatibility.
            switch(name){
                /**
                 * spanner
                 */ case "spanner":
                    return (()=>{
                        const e = new Error("Cannot find module '@google-cloud/spanner'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                /**
                 * mongodb
                 */ case "mongodb":
                    return (()=>{
                        const e = new Error("Cannot find module 'mongodb'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                /**
                 * hana
                 */ case "@sap/hana-client":
                    return (()=>{
                        const e = new Error("Cannot find module '@sap/hana-client'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                case "@sap/hana-client/extension/Stream":
                    return (()=>{
                        const e = new Error("Cannot find module '@sap/hana-client/extension/Stream'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                case "hdb-pool":
                    return (()=>{
                        const e = new Error("Cannot find module 'hdb-pool'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                /**
                 * mysql
                 */ case "mysql":
                    return (()=>{
                        const e = new Error("Cannot find module 'mysql'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                case "mysql2":
                    return (()=>{
                        const e = new Error("Cannot find module 'mysql2'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                /**
                 * oracle
                 */ case "oracledb":
                    return (()=>{
                        const e = new Error("Cannot find module 'oracledb'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                /**
                 * postgres
                 */ case "pg":
                    return __turbopack_context__.r("[externals]/pg [external] (pg, cjs)");
                case "pg-native":
                    return (()=>{
                        const e = new Error("Cannot find module 'pg-native'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                case "pg-query-stream":
                    return (()=>{
                        const e = new Error("Cannot find module 'pg-query-stream'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                case "typeorm-aurora-data-api-driver":
                    return (()=>{
                        const e = new Error("Cannot find module 'typeorm-aurora-data-api-driver'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                /**
                 * redis
                 */ case "redis":
                    return (()=>{
                        const e = new Error("Cannot find module 'redis'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                case "ioredis":
                    return (()=>{
                        const e = new Error("Cannot find module 'ioredis'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                /**
                 * better-sqlite3
                 */ case "better-sqlite3":
                    return (()=>{
                        const e = new Error("Cannot find module 'better-sqlite3'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                /**
                 * sqlite
                 */ case "sqlite3":
                    return (()=>{
                        const e = new Error("Cannot find module 'sqlite3'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                /**
                 * sql.js
                 */ case "sql.js":
                    return (()=>{
                        const e = new Error("Cannot find module 'sql.js'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                /**
                 * sqlserver
                 */ case "mssql":
                    return (()=>{
                        const e = new Error("Cannot find module 'mssql'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                /**
                 * react-native-sqlite
                 */ case "react-native-sqlite-storage":
                    return (()=>{
                        const e = new Error("Cannot find module 'react-native-sqlite-storage'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
            }
        } catch (err) {
            return (()=>{
                const e = new Error("Cannot find module as expression is too dynamic");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        }
        // If nothing above matched and we get here, the package was not listed within PlatformTools
        // and is an Invalid Package.  To make it explicit that this is NOT the intended use case for
        // PlatformTools.load - it's not just a way to replace `require` all willy-nilly - let's throw
        // an error.
        throw new TypeError(`Invalid Package for PlatformTools.load: ${name}`);
    }
    /**
     * Normalizes given path. Does "path.normalize" and replaces backslashes with forward slashes on Windows.
     */ static pathNormalize(pathStr) {
        let normalizedPath = path_1.default.normalize(pathStr);
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        return normalizedPath;
    }
    /**
     * Gets file extension. Does "path.extname".
     */ static pathExtname(pathStr) {
        return path_1.default.extname(pathStr);
    }
    /**
     * Resolved given path. Does "path.resolve".
     */ static pathResolve(pathStr) {
        return path_1.default.resolve(pathStr);
    }
    /**
     * Synchronously checks if file exist. Does "fs.existsSync".
     */ static fileExist(pathStr) {
        return fs_1.default.existsSync(pathStr);
    }
    static readFileSync(filename) {
        return fs_1.default.readFileSync(filename);
    }
    static appendFileSync(filename, data) {
        fs_1.default.appendFileSync(filename, data);
    }
    static async writeFile(path, data) {
        return fs_1.default.promises.writeFile(path, data);
    }
    /**
     * Loads a dotenv file into the environment variables.
     *
     * @param path The file to load as a dotenv configuration
     */ static dotenv(pathStr) {
        dotenv_1.default.config({
            path: pathStr
        });
    }
    /**
     * Gets environment variable.
     */ static getEnvVariable(name) {
        return process.env[name];
    }
    /**
     * Highlights sql string to be printed in the console.
     */ static highlightSql(sql) {
        return (0, sql_highlight_1.highlight)(sql, {
            colors: {
                keyword: ansis_1.default.blueBright.open,
                function: ansis_1.default.magentaBright.open,
                number: ansis_1.default.green.open,
                string: ansis_1.default.white.open,
                identifier: ansis_1.default.white.open,
                special: ansis_1.default.white.open,
                bracket: ansis_1.default.white.open,
                comment: ansis_1.default.gray.open,
                clear: ansis_1.default.reset.open
            }
        });
    }
    /**
     * Pretty-print sql string to be print in the console.
     */ static formatSql(sql, dataSourceType) {
        const databaseLanguageMap = {
            oracle: "pl/sql"
        };
        const databaseLanguage = dataSourceType ? databaseLanguageMap[dataSourceType] || "sql" : "sql";
        return (0, formatter_1.format)(sql, {
            language: databaseLanguage,
            indent: "    "
        });
    }
    /**
     * Logging functions needed by AdvancedConsoleLogger
     */ static logInfo(prefix, info) {
        console.log(ansis_1.default.gray.underline(prefix), info);
    }
    static logError(prefix, error) {
        console.log(ansis_1.default.underline.red(prefix), error);
    }
    static logWarn(prefix, warning) {
        console.log(ansis_1.default.underline.yellow(prefix), warning);
    }
    static log(message) {
        console.log(ansis_1.default.underline(message));
    }
    static info(info) {
        return ansis_1.default.gray(info);
    }
    static error(error) {
        return ansis_1.default.red(error);
    }
    static warn(message) {
        return ansis_1.default.yellow(message);
    }
    static logCmdErr(prefix, err) {
        console.log(ansis_1.default.black.bgRed(prefix));
        if (err) console.error(err);
    }
}
exports.PlatformTools = PlatformTools;
/**
 * Type of the currently running platform.
 */ PlatformTools.type = "node"; //# sourceMappingURL=PlatformTools.js.map
}}),
"[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TypeORMError = void 0;
class TypeORMError extends Error {
    get name() {
        return this.constructor.name;
    }
    constructor(message){
        super(message);
        // restore prototype chain because the base `Error` type
        // will break the prototype chain a little
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, new.target.prototype);
        } else {
            ;
            this.__proto__ = new.target.prototype;
        }
    }
}
exports.TypeORMError = TypeORMError; //# sourceMappingURL=TypeORMError.js.map
}}),
"[project]/node_modules/typeorm/error/CannotReflectMethodParameterTypeError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CannotReflectMethodParameterTypeError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when ORM cannot get method parameter's type.
 * Basically, when reflect-metadata is not available or tsconfig is not properly setup.
 */ class CannotReflectMethodParameterTypeError extends TypeORMError_1.TypeORMError {
    constructor(target, methodName){
        super(`Cannot get reflected type for a "${methodName}" method's parameter of "${target.name}" class. ` + `Make sure you have turned on an "emitDecoratorMetadata": true option in tsconfig.json. ` + `Also make sure you have imported "reflect-metadata" on top of the main entry file in your application.`);
    }
}
exports.CannotReflectMethodParameterTypeError = CannotReflectMethodParameterTypeError; //# sourceMappingURL=CannotReflectMethodParameterTypeError.js.map
}}),
"[project]/node_modules/typeorm/error/AlreadyHasActiveConnectionError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AlreadyHasActiveConnectionError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when consumer tries to recreate connection with the same name, but previous connection was not closed yet.
 */ class AlreadyHasActiveConnectionError extends TypeORMError_1.TypeORMError {
    constructor(connectionName){
        super(`Cannot create a new connection named "${connectionName}", because connection with such name ` + `already exist and it now has an active connection session.`);
    }
}
exports.AlreadyHasActiveConnectionError = AlreadyHasActiveConnectionError; //# sourceMappingURL=AlreadyHasActiveConnectionError.js.map
}}),
"[project]/node_modules/typeorm/error/SubjectWithoutIdentifierError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SubjectWithoutIdentifierError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when operation is going to be executed on a subject without identifier.
 * This error should never be thrown, however it still presents to prevent user from updation or removing the whole table.
 * If this error occurs still, it most probably is an ORM internal problem which must be reported and fixed.
 */ class SubjectWithoutIdentifierError extends TypeORMError_1.TypeORMError {
    constructor(subject){
        super(`Internal error. Subject ${subject.metadata.targetName} must have an identifier to perform operation.`);
    }
}
exports.SubjectWithoutIdentifierError = SubjectWithoutIdentifierError; //# sourceMappingURL=SubjectWithoutIdentifierError.js.map
}}),
"[project]/node_modules/typeorm/error/CannotConnectAlreadyConnectedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CannotConnectAlreadyConnectedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when consumer tries to connect when he already connected.
 */ class CannotConnectAlreadyConnectedError extends TypeORMError_1.TypeORMError {
    constructor(connectionName){
        super(`Cannot create a "${connectionName}" connection because connection to the database already established.`);
    }
}
exports.CannotConnectAlreadyConnectedError = CannotConnectAlreadyConnectedError; //# sourceMappingURL=CannotConnectAlreadyConnectedError.js.map
}}),
"[project]/node_modules/typeorm/error/LockNotSupportedOnGivenDriverError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LockNotSupportedOnGivenDriverError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when selected sql driver does not supports locking.
 */ class LockNotSupportedOnGivenDriverError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`Locking not supported on given driver.`);
    }
}
exports.LockNotSupportedOnGivenDriverError = LockNotSupportedOnGivenDriverError; //# sourceMappingURL=LockNotSupportedOnGivenDriverError.js.map
}}),
"[project]/node_modules/typeorm/error/ConnectionIsNotSetError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionIsNotSetError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when user tries to execute operation that requires connection to be established.
 */ class ConnectionIsNotSetError extends TypeORMError_1.TypeORMError {
    constructor(dbType){
        super(`Connection with ${dbType} database is not established. Check connection configuration.`);
    }
}
exports.ConnectionIsNotSetError = ConnectionIsNotSetError; //# sourceMappingURL=ConnectionIsNotSetError.js.map
}}),
"[project]/node_modules/typeorm/error/CannotCreateEntityIdMapError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CannotCreateEntityIdMapError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when user tries to create entity id map from the mixed id value,
 * but id value is a single value when entity requires multiple values.
 */ class CannotCreateEntityIdMapError extends TypeORMError_1.TypeORMError {
    constructor(metadata, id){
        super();
        const objectExample = metadata.primaryColumns.reduce((object, column, index)=>{
            column.setEntityValue(object, index + 1);
            return object;
        }, {});
        this.message = `Cannot use given entity id "${id}" because "${metadata.targetName}" contains multiple primary columns, you must provide object in following form: ${JSON.stringify(objectExample)} as an id.`;
    }
}
exports.CannotCreateEntityIdMapError = CannotCreateEntityIdMapError; //# sourceMappingURL=CannotCreateEntityIdMapError.js.map
}}),
"[project]/node_modules/typeorm/error/MetadataAlreadyExistsError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MetadataAlreadyExistsError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class MetadataAlreadyExistsError extends TypeORMError_1.TypeORMError {
    constructor(metadataType, constructor, propertyName){
        super(metadataType + " metadata already exists for the class constructor " + JSON.stringify(constructor) + (propertyName ? " on property " + propertyName : ". If you previously renamed or moved entity class, make sure" + " that compiled version of old entity class source wasn't left in the compiler output directory."));
    }
}
exports.MetadataAlreadyExistsError = MetadataAlreadyExistsError; //# sourceMappingURL=MetadataAlreadyExistsError.js.map
}}),
"[project]/node_modules/typeorm/error/CannotDetermineEntityError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CannotDetermineEntityError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when user tries to save/remove/etc. constructor-less object (object literal) instead of entity.
 */ class CannotDetermineEntityError extends TypeORMError_1.TypeORMError {
    constructor(operation){
        super(`Cannot ${operation}, given value must be instance of entity class, ` + `instead object literal is given. Or you must specify an entity target to method call.`);
    }
}
exports.CannotDetermineEntityError = CannotDetermineEntityError; //# sourceMappingURL=CannotDetermineEntityError.js.map
}}),
"[project]/node_modules/typeorm/error/UpdateValuesMissingError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdateValuesMissingError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class UpdateValuesMissingError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`Cannot perform update query because update values are not defined. Call "qb.set(...)" method to specify updated values.`);
    }
}
exports.UpdateValuesMissingError = UpdateValuesMissingError; //# sourceMappingURL=UpdateValuesMissingError.js.map
}}),
"[project]/node_modules/typeorm/error/TreeRepositoryNotSupportedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TreeRepositoryNotSupportedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class TreeRepositoryNotSupportedError extends TypeORMError_1.TypeORMError {
    constructor(driver){
        super(`Tree repositories are not supported in ${driver.options.type} driver.`);
    }
}
exports.TreeRepositoryNotSupportedError = TreeRepositoryNotSupportedError; //# sourceMappingURL=TreeRepositoryNotSupportedError.js.map
}}),
"[project]/node_modules/typeorm/error/CustomRepositoryNotFoundError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CustomRepositoryNotFoundError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown if custom repository was not found.
 */ class CustomRepositoryNotFoundError extends TypeORMError_1.TypeORMError {
    constructor(repository){
        super(`Custom repository ${typeof repository === "function" ? repository.name : repository.constructor.name} was not found. ` + `Did you forgot to put @EntityRepository decorator on it?`);
    }
}
exports.CustomRepositoryNotFoundError = CustomRepositoryNotFoundError; //# sourceMappingURL=CustomRepositoryNotFoundError.js.map
}}),
"[project]/node_modules/typeorm/error/TransactionNotStartedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TransactionNotStartedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when transaction is not started yet and user tries to run commit or rollback.
 */ class TransactionNotStartedError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`Transaction is not started yet, start transaction before committing or rolling it back.`);
    }
}
exports.TransactionNotStartedError = TransactionNotStartedError; //# sourceMappingURL=TransactionNotStartedError.js.map
}}),
"[project]/node_modules/typeorm/error/TransactionAlreadyStartedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TransactionAlreadyStartedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when transaction is already started and user tries to run it again.
 */ class TransactionAlreadyStartedError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`Transaction already started for the given connection, commit current transaction before starting a new one.`);
    }
}
exports.TransactionAlreadyStartedError = TransactionAlreadyStartedError; //# sourceMappingURL=TransactionAlreadyStartedError.js.map
}}),
"[project]/node_modules/typeorm/error/EntityNotFoundError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntityNotFoundError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Thrown when no result could be found in methods which are not allowed to return undefined or an empty set.
 */ class EntityNotFoundError extends TypeORMError_1.TypeORMError {
    constructor(entityClass, criteria){
        super();
        this.entityClass = entityClass;
        this.criteria = criteria;
        this.message = `Could not find any entity of type "${this.stringifyTarget(entityClass)}" ` + `matching: ${this.stringifyCriteria(criteria)}`;
    }
    stringifyTarget(target) {
        if (InstanceChecker_1.InstanceChecker.isEntitySchema(target)) {
            return target.options.name;
        } else if (typeof target === "function") {
            return target.name;
        } else if (ObjectUtils_1.ObjectUtils.isObject(target) && "name" in target) {
            return target.name;
        } else {
            return target;
        }
    }
    stringifyCriteria(criteria) {
        try {
            return JSON.stringify(criteria, null, 4);
        } catch (e) {}
        return "" + criteria;
    }
}
exports.EntityNotFoundError = EntityNotFoundError; //# sourceMappingURL=EntityNotFoundError.js.map
}}),
"[project]/node_modules/typeorm/error/EntityMetadataNotFoundError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntityMetadataNotFoundError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
class EntityMetadataNotFoundError extends TypeORMError_1.TypeORMError {
    constructor(target){
        super();
        this.message = `No metadata for "${this.stringifyTarget(target)}" was found.`;
    }
    stringifyTarget(target) {
        if (InstanceChecker_1.InstanceChecker.isEntitySchema(target)) {
            return target.options.name;
        } else if (typeof target === "function") {
            return target.name;
        } else if (ObjectUtils_1.ObjectUtils.isObject(target) && "name" in target) {
            return target.name;
        } else {
            return target;
        }
    }
}
exports.EntityMetadataNotFoundError = EntityMetadataNotFoundError; //# sourceMappingURL=EntityMetadataNotFoundError.js.map
}}),
"[project]/node_modules/typeorm/error/MustBeEntityError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MustBeEntityError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when method expects entity but instead something else is given.
 */ class MustBeEntityError extends TypeORMError_1.TypeORMError {
    constructor(operation, wrongValue){
        super(`Cannot ${operation}, given value must be an entity, instead "${wrongValue}" is given.`);
    }
}
exports.MustBeEntityError = MustBeEntityError; //# sourceMappingURL=MustBeEntityError.js.map
}}),
"[project]/node_modules/typeorm/error/OptimisticLockVersionMismatchError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OptimisticLockVersionMismatchError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when a version check on an object that uses optimistic locking through a version field fails.
 */ class OptimisticLockVersionMismatchError extends TypeORMError_1.TypeORMError {
    constructor(entity, expectedVersion, actualVersion){
        super(`The optimistic lock on entity ${entity} failed, version ${expectedVersion} was expected, but is actually ${actualVersion}.`);
    }
}
exports.OptimisticLockVersionMismatchError = OptimisticLockVersionMismatchError; //# sourceMappingURL=OptimisticLockVersionMismatchError.js.map
}}),
"[project]/node_modules/typeorm/error/LimitOnUpdateNotSupportedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LimitOnUpdateNotSupportedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when user tries to build an UPDATE query with LIMIT but the database does not support it.
 */ class LimitOnUpdateNotSupportedError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`Your database does not support LIMIT on UPDATE statements.`);
    }
}
exports.LimitOnUpdateNotSupportedError = LimitOnUpdateNotSupportedError; //# sourceMappingURL=LimitOnUpdateNotSupportedError.js.map
}}),
"[project]/node_modules/typeorm/error/PrimaryColumnCannotBeNullableError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PrimaryColumnCannotBeNullableError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class PrimaryColumnCannotBeNullableError extends TypeORMError_1.TypeORMError {
    constructor(object, propertyName){
        super(`Primary column ${object.constructor.name}#${propertyName} cannot be nullable. ` + `Its not allowed for primary keys. Try to remove nullable option.`);
    }
}
exports.PrimaryColumnCannotBeNullableError = PrimaryColumnCannotBeNullableError; //# sourceMappingURL=PrimaryColumnCannotBeNullableError.js.map
}}),
"[project]/node_modules/typeorm/error/CustomRepositoryCannotInheritRepositoryError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CustomRepositoryCannotInheritRepositoryError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown if custom repository inherits Repository class however entity is not set in @EntityRepository decorator.
 */ class CustomRepositoryCannotInheritRepositoryError extends TypeORMError_1.TypeORMError {
    constructor(repository){
        super(`Custom entity repository ${typeof repository === "function" ? repository.name : repository.constructor.name} ` + ` cannot inherit Repository class without entity being set in the @EntityRepository decorator.`);
    }
}
exports.CustomRepositoryCannotInheritRepositoryError = CustomRepositoryCannotInheritRepositoryError; //# sourceMappingURL=CustomRepositoryCannotInheritRepositoryError.js.map
}}),
"[project]/node_modules/typeorm/error/QueryRunnerProviderAlreadyReleasedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryRunnerProviderAlreadyReleasedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when consumer tries to use query runner from query runner provider after it was released.
 */ class QueryRunnerProviderAlreadyReleasedError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`Database connection provided by a query runner was already ` + `released, cannot continue to use its querying methods anymore.`);
    }
}
exports.QueryRunnerProviderAlreadyReleasedError = QueryRunnerProviderAlreadyReleasedError; //# sourceMappingURL=QueryRunnerProviderAlreadyReleasedError.js.map
}}),
"[project]/node_modules/typeorm/error/CannotAttachTreeChildrenEntityError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CannotAttachTreeChildrenEntityError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when user saves tree children entity but its parent is not saved yet.
 */ class CannotAttachTreeChildrenEntityError extends TypeORMError_1.TypeORMError {
    constructor(entityName){
        super(`Cannot attach entity "${entityName}" to its parent. Please make sure parent ` + `is saved in the database before saving children nodes.`);
    }
}
exports.CannotAttachTreeChildrenEntityError = CannotAttachTreeChildrenEntityError; //# sourceMappingURL=CannotAttachTreeChildrenEntityError.js.map
}}),
"[project]/node_modules/typeorm/error/CustomRepositoryDoesNotHaveEntityError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CustomRepositoryDoesNotHaveEntityError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown if custom repositories that extend AbstractRepository classes does not have managed entity.
 */ class CustomRepositoryDoesNotHaveEntityError extends TypeORMError_1.TypeORMError {
    constructor(repository){
        super(`Custom repository ${typeof repository === "function" ? repository.name : repository.constructor.name} does not have managed entity. ` + `Did you forget to specify entity for it @EntityRepository(MyEntity)? `);
    }
}
exports.CustomRepositoryDoesNotHaveEntityError = CustomRepositoryDoesNotHaveEntityError; //# sourceMappingURL=CustomRepositoryDoesNotHaveEntityError.js.map
}}),
"[project]/node_modules/typeorm/error/MissingDeleteDateColumnError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MissingDeleteDateColumnError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class MissingDeleteDateColumnError extends TypeORMError_1.TypeORMError {
    constructor(entityMetadata){
        super(`Entity "${entityMetadata.name}" does not have delete date columns.`);
    }
}
exports.MissingDeleteDateColumnError = MissingDeleteDateColumnError; //# sourceMappingURL=MissingDeleteDateColumnError.js.map
}}),
"[project]/node_modules/typeorm/error/NoConnectionForRepositoryError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoConnectionForRepositoryError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when consumer tries to access repository before connection is established.
 */ class NoConnectionForRepositoryError extends TypeORMError_1.TypeORMError {
    constructor(connectionName){
        super(`Cannot get a Repository for "${connectionName} connection, because connection with the database ` + `is not established yet. Call connection#connect method to establish connection.`);
    }
}
exports.NoConnectionForRepositoryError = NoConnectionForRepositoryError; //# sourceMappingURL=NoConnectionForRepositoryError.js.map
}}),
"[project]/node_modules/typeorm/error/CircularRelationsError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CircularRelationsError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when circular relations detected with nullable set to false.
 */ class CircularRelationsError extends TypeORMError_1.TypeORMError {
    constructor(path){
        super(`Circular relations detected: ${path}. To resolve this issue you need to ` + `set nullable: true somewhere in this dependency structure.`);
    }
}
exports.CircularRelationsError = CircularRelationsError; //# sourceMappingURL=CircularRelationsError.js.map
}}),
"[project]/node_modules/typeorm/error/ReturningStatementNotSupportedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReturningStatementNotSupportedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when user tries to build a query with RETURNING / OUTPUT statement,
 * but used database does not support it.
 */ class ReturningStatementNotSupportedError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`OUTPUT or RETURNING clause only supported by PostgreSQL, MariaDB, Microsoft SqlServer or Google Spanner.`);
    }
}
exports.ReturningStatementNotSupportedError = ReturningStatementNotSupportedError; //# sourceMappingURL=ReturningStatementNotSupportedError.js.map
}}),
"[project]/node_modules/typeorm/error/UsingJoinTableIsNotAllowedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UsingJoinTableIsNotAllowedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class UsingJoinTableIsNotAllowedError extends TypeORMError_1.TypeORMError {
    constructor(entityMetadata, relation){
        super(`Using JoinTable on ${entityMetadata.name}#${relation.propertyName} is wrong. ` + `${entityMetadata.name}#${relation.propertyName} has ${relation.relationType} relation, ` + `however you can use JoinTable only on many-to-many relations.`);
    }
}
exports.UsingJoinTableIsNotAllowedError = UsingJoinTableIsNotAllowedError; //# sourceMappingURL=UsingJoinTableIsNotAllowedError.js.map
}}),
"[project]/node_modules/typeorm/error/MissingJoinColumnError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MissingJoinColumnError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class MissingJoinColumnError extends TypeORMError_1.TypeORMError {
    constructor(entityMetadata, relation){
        super();
        if (relation.inverseRelation) {
            this.message = `JoinColumn is missing on both sides of ${entityMetadata.name}#${relation.propertyName} and ` + `${relation.inverseEntityMetadata.name}#${relation.inverseRelation.propertyName} one-to-one relationship. ` + `You need to put JoinColumn decorator on one of the sides.`;
        } else {
            this.message = `JoinColumn is missing on ${entityMetadata.name}#${relation.propertyName} one-to-one relationship. ` + `You need to put JoinColumn decorator on it.`;
        }
    }
}
exports.MissingJoinColumnError = MissingJoinColumnError; //# sourceMappingURL=MissingJoinColumnError.js.map
}}),
"[project]/node_modules/typeorm/error/MissingPrimaryColumnError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MissingPrimaryColumnError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class MissingPrimaryColumnError extends TypeORMError_1.TypeORMError {
    constructor(entityMetadata){
        super(`Entity "${entityMetadata.name}" does not have a primary column. Primary column is required to ` + `have in all your entities. Use @PrimaryColumn decorator to add a primary column to your entity.`);
    }
}
exports.MissingPrimaryColumnError = MissingPrimaryColumnError; //# sourceMappingURL=MissingPrimaryColumnError.js.map
}}),
"[project]/node_modules/typeorm/error/EntityPropertyNotFoundError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntityPropertyNotFoundError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when specified entity property was not found.
 */ class EntityPropertyNotFoundError extends TypeORMError_1.TypeORMError {
    constructor(propertyPath, metadata){
        super(propertyPath);
        Object.setPrototypeOf(this, EntityPropertyNotFoundError.prototype);
        this.message = `Property "${propertyPath}" was not found in "${metadata.targetName}". Make sure your query is correct.`;
    }
}
exports.EntityPropertyNotFoundError = EntityPropertyNotFoundError; //# sourceMappingURL=EntityPropertyNotFoundError.js.map
}}),
"[project]/node_modules/typeorm/error/MissingDriverError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MissingDriverError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when consumer specifies driver type that does not exist or supported.
 */ class MissingDriverError extends TypeORMError_1.TypeORMError {
    constructor(driverType, availableDrivers = []){
        super(`Wrong driver: "${driverType}" given. Supported drivers are: ` + `${availableDrivers.map((d)=>`"${d}"`).join(", ")}.`);
    }
}
exports.MissingDriverError = MissingDriverError; //# sourceMappingURL=MissingDriverError.js.map
}}),
"[project]/node_modules/typeorm/error/DriverPackageNotInstalledError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DriverPackageNotInstalledError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when required driver's package is not installed.
 */ class DriverPackageNotInstalledError extends TypeORMError_1.TypeORMError {
    constructor(driverName, packageName){
        super(`${driverName} package has not been found installed. ` + `Try to install it: npm install ${packageName} --save`);
    }
}
exports.DriverPackageNotInstalledError = DriverPackageNotInstalledError; //# sourceMappingURL=DriverPackageNotInstalledError.js.map
}}),
"[project]/node_modules/typeorm/error/CannotGetEntityManagerNotConnectedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CannotGetEntityManagerNotConnectedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when consumer tries to access entity manager before connection is established.
 */ class CannotGetEntityManagerNotConnectedError extends TypeORMError_1.TypeORMError {
    constructor(connectionName){
        super(`Cannot get entity manager for "${connectionName}" connection because connection is not yet established.`);
    }
}
exports.CannotGetEntityManagerNotConnectedError = CannotGetEntityManagerNotConnectedError; //# sourceMappingURL=CannotGetEntityManagerNotConnectedError.js.map
}}),
"[project]/node_modules/typeorm/error/ConnectionNotFoundError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionNotFoundError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when consumer tries to get connection that does not exist.
 */ class ConnectionNotFoundError extends TypeORMError_1.TypeORMError {
    constructor(name){
        super(`Connection "${name}" was not found.`);
    }
}
exports.ConnectionNotFoundError = ConnectionNotFoundError; //# sourceMappingURL=ConnectionNotFoundError.js.map
}}),
"[project]/node_modules/typeorm/error/NoVersionOrUpdateDateColumnError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoVersionOrUpdateDateColumnError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when an entity does not have no version and no update date column.
 */ class NoVersionOrUpdateDateColumnError extends TypeORMError_1.TypeORMError {
    constructor(entity){
        super(`Entity ${entity} does not have version or update date columns.`);
    }
}
exports.NoVersionOrUpdateDateColumnError = NoVersionOrUpdateDateColumnError; //# sourceMappingURL=NoVersionOrUpdateDateColumnError.js.map
}}),
"[project]/node_modules/typeorm/error/InsertValuesMissingError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InsertValuesMissingError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when user tries to insert using QueryBuilder but do not specify what to insert.
 */ class InsertValuesMissingError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`Cannot perform insert query because values are not defined. ` + `Call "qb.values(...)" method to specify inserted values.`);
    }
}
exports.InsertValuesMissingError = InsertValuesMissingError; //# sourceMappingURL=InsertValuesMissingError.js.map
}}),
"[project]/node_modules/typeorm/error/OptimisticLockCanNotBeUsedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OptimisticLockCanNotBeUsedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when an optimistic lock cannot be used in query builder.
 */ class OptimisticLockCanNotBeUsedError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`The optimistic lock can be used only with getOne() method.`);
    }
}
exports.OptimisticLockCanNotBeUsedError = OptimisticLockCanNotBeUsedError; //# sourceMappingURL=OptimisticLockCanNotBeUsedError.js.map
}}),
"[project]/node_modules/typeorm/error/MetadataWithSuchNameAlreadyExistsError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MetadataWithSuchNameAlreadyExistsError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class MetadataWithSuchNameAlreadyExistsError extends TypeORMError_1.TypeORMError {
    constructor(metadataType, name){
        super(metadataType + " metadata with such name " + name + " already exists. " + "Do you apply decorator twice? Or maybe try to change a name?");
    }
}
exports.MetadataWithSuchNameAlreadyExistsError = MetadataWithSuchNameAlreadyExistsError; //# sourceMappingURL=MetadataWithSuchNameAlreadyExistsError.js.map
}}),
"[project]/node_modules/typeorm/error/DriverOptionNotSetError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DriverOptionNotSetError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown if some required driver's option is not set.
 */ class DriverOptionNotSetError extends TypeORMError_1.TypeORMError {
    constructor(optionName){
        super(`Driver option (${optionName}) is not set. ` + `Please set it to perform connection to the database.`);
    }
}
exports.DriverOptionNotSetError = DriverOptionNotSetError; //# sourceMappingURL=DriverOptionNotSetError.js.map
}}),
"[project]/node_modules/typeorm/error/FindRelationsNotFoundError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FindRelationsNotFoundError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when relations specified in the find options were not found in the entities.
 */ class FindRelationsNotFoundError extends TypeORMError_1.TypeORMError {
    constructor(notFoundRelations){
        super();
        if (notFoundRelations.length === 1) {
            this.message = `Relation "${notFoundRelations[0]}" was not found; please check if it is correct and really exists in your entity.`;
        } else {
            this.message = `Relations ${notFoundRelations.map((relation)=>`"${relation}"`).join(", ")} were not found; please check if relations are correct and they exist in your entities.`;
        }
    }
}
exports.FindRelationsNotFoundError = FindRelationsNotFoundError; //# sourceMappingURL=FindRelationsNotFoundError.js.map
}}),
"[project]/node_modules/typeorm/error/PessimisticLockTransactionRequiredError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PessimisticLockTransactionRequiredError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when a transaction is required for the current operation, but there is none open.
 */ class PessimisticLockTransactionRequiredError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`An open transaction is required for pessimistic lock.`);
    }
}
exports.PessimisticLockTransactionRequiredError = PessimisticLockTransactionRequiredError; //# sourceMappingURL=PessimisticLockTransactionRequiredError.js.map
}}),
"[project]/node_modules/typeorm/error/RepositoryNotTreeError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RepositoryNotTreeError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Thrown when repository for the given class is not found.
 */ class RepositoryNotTreeError extends TypeORMError_1.TypeORMError {
    constructor(entityClass){
        super();
        let targetName;
        if (InstanceChecker_1.InstanceChecker.isEntitySchema(entityClass)) {
            targetName = entityClass.options.name;
        } else if (typeof entityClass === "function") {
            targetName = entityClass.name;
        } else if (ObjectUtils_1.ObjectUtils.isObject(entityClass) && "name" in entityClass) {
            targetName = entityClass.name;
        } else {
            targetName = entityClass;
        }
        this.message = `Repository of the "${targetName}" class is not a TreeRepository. Try to apply @Tree decorator on your entity.`;
    }
}
exports.RepositoryNotTreeError = RepositoryNotTreeError; //# sourceMappingURL=RepositoryNotTreeError.js.map
}}),
"[project]/node_modules/typeorm/error/DataTypeNotSupportedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataTypeNotSupportedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class DataTypeNotSupportedError extends TypeORMError_1.TypeORMError {
    constructor(column, dataType, database){
        super();
        const type = typeof dataType === "string" ? dataType : dataType.name;
        this.message = `Data type "${type}" in "${column.entityMetadata.targetName}.${column.propertyName}" is not supported by "${database}" database.`;
    }
}
exports.DataTypeNotSupportedError = DataTypeNotSupportedError; //# sourceMappingURL=DataTypeNotSupportedError.js.map
}}),
"[project]/node_modules/typeorm/error/InitializedRelationError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InitializedRelationError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when relation has array initialized which is forbidden my ORM.
 *
 * @see https://github.com/typeorm/typeorm/issues/1319
 * @see http://typeorm.io/#/relations-faq/avoid-relation-property-initializers
 */ class InitializedRelationError extends TypeORMError_1.TypeORMError {
    constructor(relation){
        super(`Array initializations are not allowed in entity relations. ` + `Please remove array initialization (= []) from "${relation.entityMetadata.targetName}#${relation.propertyPath}". ` + `This is ORM requirement to make relations to work properly. Refer docs for more information.`);
    }
}
exports.InitializedRelationError = InitializedRelationError; //# sourceMappingURL=InitializedRelationError.js.map
}}),
"[project]/node_modules/typeorm/error/MissingJoinTableError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MissingJoinTableError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class MissingJoinTableError extends TypeORMError_1.TypeORMError {
    constructor(entityMetadata, relation){
        super();
        if (relation.inverseRelation) {
            this.message = `JoinTable is missing on both sides of ${entityMetadata.name}#${relation.propertyName} and ` + `${relation.inverseEntityMetadata.name}#${relation.inverseRelation.propertyName} many-to-many relationship. ` + `You need to put decorator decorator on one of the sides.`;
        } else {
            this.message = `JoinTable is missing on ${entityMetadata.name}#${relation.propertyName} many-to-many relationship. ` + `You need to put JoinTable decorator on it.`;
        }
    }
}
exports.MissingJoinTableError = MissingJoinTableError; //# sourceMappingURL=MissingJoinTableError.js.map
}}),
"[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryFailedError = void 0;
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when query execution has failed.
 */ class QueryFailedError extends TypeORMError_1.TypeORMError {
    constructor(query, parameters, driverError){
        super(driverError.toString().replace(/^error: /, "").replace(/^Error: /, "").replace(/^Request/, ""));
        this.query = query;
        this.parameters = parameters;
        this.driverError = driverError;
        if (driverError) {
            const { name: _, ...otherProperties } = driverError;
            ObjectUtils_1.ObjectUtils.assign(this, {
                ...otherProperties
            });
        }
    }
}
exports.QueryFailedError = QueryFailedError; //# sourceMappingURL=QueryFailedError.js.map
}}),
"[project]/node_modules/typeorm/error/NoNeedToReleaseEntityManagerError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoNeedToReleaseEntityManagerError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when consumer tries to release entity manager that does not use single database connection.
 */ class NoNeedToReleaseEntityManagerError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`Entity manager is not using single database connection and cannot be released. ` + `Only entity managers created by connection#createEntityManagerWithSingleDatabaseConnection ` + `methods have a single database connection and they should be released.`);
    }
}
exports.NoNeedToReleaseEntityManagerError = NoNeedToReleaseEntityManagerError; //# sourceMappingURL=NoNeedToReleaseEntityManagerError.js.map
}}),
"[project]/node_modules/typeorm/error/UsingJoinColumnOnlyOnOneSideAllowedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UsingJoinColumnOnlyOnOneSideAllowedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class UsingJoinColumnOnlyOnOneSideAllowedError extends TypeORMError_1.TypeORMError {
    constructor(entityMetadata, relation){
        super(`Using JoinColumn is allowed only on one side of the one-to-one relationship. ` + `Both ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseEntityMetadata.name}#${relation.inverseRelation.propertyName} ` + `has JoinTable decorators. Choose one of them and left JoinTable decorator only on it.`);
    }
}
exports.UsingJoinColumnOnlyOnOneSideAllowedError = UsingJoinColumnOnlyOnOneSideAllowedError; //# sourceMappingURL=UsingJoinColumnOnlyOnOneSideAllowedError.js.map
}}),
"[project]/node_modules/typeorm/error/UsingJoinTableOnlyOnOneSideAllowedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UsingJoinTableOnlyOnOneSideAllowedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class UsingJoinTableOnlyOnOneSideAllowedError extends TypeORMError_1.TypeORMError {
    constructor(entityMetadata, relation){
        super(`Using JoinTable is allowed only on one side of the many-to-many relationship. ` + `Both ${entityMetadata.name}#${relation.propertyName} and ${relation.inverseEntityMetadata.name}#${relation.inverseRelation.propertyName} ` + `has JoinTable decorators. Choose one of them and left JoinColumn decorator only on it.`);
    }
}
exports.UsingJoinTableOnlyOnOneSideAllowedError = UsingJoinTableOnlyOnOneSideAllowedError; //# sourceMappingURL=UsingJoinTableOnlyOnOneSideAllowedError.js.map
}}),
"[project]/node_modules/typeorm/error/SubjectRemovedAndUpdatedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SubjectRemovedAndUpdatedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when same object is scheduled for remove and updation at the same time.
 */ class SubjectRemovedAndUpdatedError extends TypeORMError_1.TypeORMError {
    constructor(subject){
        super(`Removed entity "${subject.metadata.name}" is also scheduled for update operation. ` + `Make sure you are not updating and removing same object (note that update or remove may be executed by cascade operations).`);
    }
}
exports.SubjectRemovedAndUpdatedError = SubjectRemovedAndUpdatedError; //# sourceMappingURL=SubjectRemovedAndUpdatedError.js.map
}}),
"[project]/node_modules/typeorm/error/PersistedEntityNotFoundError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PersistedEntityNotFoundError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown . Theoretically can't be thrown.
 */ class PersistedEntityNotFoundError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`Internal error. Persisted entity was not found in the list of prepared operated entities.`);
    }
}
exports.PersistedEntityNotFoundError = PersistedEntityNotFoundError; //# sourceMappingURL=PersistedEntityNotFoundError.js.map
}}),
"[project]/node_modules/typeorm/error/UsingJoinColumnIsNotAllowedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UsingJoinColumnIsNotAllowedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class UsingJoinColumnIsNotAllowedError extends TypeORMError_1.TypeORMError {
    constructor(entityMetadata, relation){
        super(`Using JoinColumn on ${entityMetadata.name}#${relation.propertyName} is wrong. ` + `You can use JoinColumn only on one-to-one and many-to-one relations.`);
    }
}
exports.UsingJoinColumnIsNotAllowedError = UsingJoinColumnIsNotAllowedError; //# sourceMappingURL=UsingJoinColumnIsNotAllowedError.js.map
}}),
"[project]/node_modules/typeorm/error/ColumnTypeUndefinedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ColumnTypeUndefinedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when ORM cannot get column's type automatically.
 * Basically, when reflect-metadata is not available or tsconfig is not properly setup.
 */ class ColumnTypeUndefinedError extends TypeORMError_1.TypeORMError {
    constructor(object, propertyName){
        super(`Column type for ${object.constructor.name}#${propertyName} is not defined and cannot be guessed. ` + `Make sure you have turned on an "emitDecoratorMetadata": true option in tsconfig.json. ` + `Also make sure you have imported "reflect-metadata" on top of the main entry file in your application (before any entity imported).` + `If you are using JavaScript instead of TypeScript you must explicitly provide a column type.`);
    }
}
exports.ColumnTypeUndefinedError = ColumnTypeUndefinedError; //# sourceMappingURL=ColumnTypeUndefinedError.js.map
}}),
"[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryRunnerAlreadyReleasedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class QueryRunnerAlreadyReleasedError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`Query runner already released. Cannot run queries anymore.`);
    }
}
exports.QueryRunnerAlreadyReleasedError = QueryRunnerAlreadyReleasedError; //# sourceMappingURL=QueryRunnerAlreadyReleasedError.js.map
}}),
"[project]/node_modules/typeorm/error/OffsetWithoutLimitNotSupportedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OffsetWithoutLimitNotSupportedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when user tries to build SELECT query using OFFSET without LIMIT applied but database does not support it.
 */ class OffsetWithoutLimitNotSupportedError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`RDBMS does not support OFFSET without LIMIT in SELECT statements. You must use limit in ` + `conjunction with offset function (or take in conjunction with skip function if you are ` + `using pagination).`);
    }
}
exports.OffsetWithoutLimitNotSupportedError = OffsetWithoutLimitNotSupportedError; //# sourceMappingURL=OffsetWithoutLimitNotSupportedError.js.map
}}),
"[project]/node_modules/typeorm/error/CannotExecuteNotConnectedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CannotExecuteNotConnectedError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when consumer tries to execute operation allowed only if connection is opened.
 */ class CannotExecuteNotConnectedError extends TypeORMError_1.TypeORMError {
    constructor(connectionName){
        super(`Cannot execute operation on "${connectionName}" connection because connection is not yet established.`);
    }
}
exports.CannotExecuteNotConnectedError = CannotExecuteNotConnectedError; //# sourceMappingURL=CannotExecuteNotConnectedError.js.map
}}),
"[project]/node_modules/typeorm/error/NoConnectionOptionError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoConnectionOptionError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when some option is not set in the connection options.
 */ class NoConnectionOptionError extends TypeORMError_1.TypeORMError {
    constructor(optionName){
        super(`Option "${optionName}" is not set in your connection options, please ` + `define "${optionName}" option in your connection options or ormconfig.json`);
    }
}
exports.NoConnectionOptionError = NoConnectionOptionError; //# sourceMappingURL=NoConnectionOptionError.js.map
}}),
"[project]/node_modules/typeorm/error/ForbiddenTransactionModeOverrideError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ForbiddenTransactionModeOverrideError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Thrown when the per-migration transaction mode is overriden but the global transaction mode is set to "all".
 */ class ForbiddenTransactionModeOverrideError extends TypeORMError_1.TypeORMError {
    constructor(migrationsOverridingTransactionMode){
        const migrationNames = migrationsOverridingTransactionMode.map((migration)=>`"${migration.name}"`);
        super(`Migrations ${migrationNames.join(", ")} override the transaction mode, but the global transaction mode is "all"`);
    }
}
exports.ForbiddenTransactionModeOverrideError = ForbiddenTransactionModeOverrideError; //# sourceMappingURL=ForbiddenTransactionModeOverrideError.js.map
}}),
"[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/CannotReflectMethodParameterTypeError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/AlreadyHasActiveConnectionError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/SubjectWithoutIdentifierError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/CannotConnectAlreadyConnectedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/LockNotSupportedOnGivenDriverError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/ConnectionIsNotSetError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/CannotCreateEntityIdMapError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/MetadataAlreadyExistsError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/CannotDetermineEntityError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/UpdateValuesMissingError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/TreeRepositoryNotSupportedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/CustomRepositoryNotFoundError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/TransactionNotStartedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/TransactionAlreadyStartedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/EntityNotFoundError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/EntityMetadataNotFoundError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/MustBeEntityError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/OptimisticLockVersionMismatchError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/LimitOnUpdateNotSupportedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/PrimaryColumnCannotBeNullableError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/CustomRepositoryCannotInheritRepositoryError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerProviderAlreadyReleasedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/CannotAttachTreeChildrenEntityError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/CustomRepositoryDoesNotHaveEntityError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/MissingDeleteDateColumnError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/NoConnectionForRepositoryError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/CircularRelationsError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/ReturningStatementNotSupportedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/UsingJoinTableIsNotAllowedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/MissingJoinColumnError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/MissingPrimaryColumnError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/EntityPropertyNotFoundError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/MissingDriverError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/DriverPackageNotInstalledError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/CannotGetEntityManagerNotConnectedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/ConnectionNotFoundError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/NoVersionOrUpdateDateColumnError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/InsertValuesMissingError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/OptimisticLockCanNotBeUsedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/MetadataWithSuchNameAlreadyExistsError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/DriverOptionNotSetError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/FindRelationsNotFoundError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/PessimisticLockTransactionRequiredError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/RepositoryNotTreeError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/DataTypeNotSupportedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/InitializedRelationError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/MissingJoinTableError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/QueryFailedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/NoNeedToReleaseEntityManagerError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/UsingJoinColumnOnlyOnOneSideAllowedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/UsingJoinTableOnlyOnOneSideAllowedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/SubjectRemovedAndUpdatedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/PersistedEntityNotFoundError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/UsingJoinColumnIsNotAllowedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/ColumnTypeUndefinedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerAlreadyReleasedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/OffsetWithoutLimitNotSupportedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/CannotExecuteNotConnectedError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/NoConnectionOptionError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/ForbiddenTransactionModeOverrideError.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/typeorm/error/NestedSetMultipleRootError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NestedSetMultipleRootError = void 0;
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
class NestedSetMultipleRootError extends TypeORMError_1.TypeORMError {
    constructor(){
        super(`Nested sets do not support multiple root entities.`);
    }
}
exports.NestedSetMultipleRootError = NestedSetMultipleRootError; //# sourceMappingURL=NestedSetMultipleRootError.js.map
}}),
"[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ObjectUtils = void 0;
class ObjectUtils {
    /**
     * Checks if given value is an object.
     * We cannot use instanceof because it has problems when running on different contexts.
     * And we don't simply use typeof because typeof null === "object".
     */ static isObject(val) {
        return val !== null && typeof val === "object";
    }
    /**
     * Checks if given value is an object.
     * We cannot use instanceof because it has problems when running on different contexts.
     * And we don't simply use typeof because typeof null === "object".
     */ static isObjectWithName(val) {
        return val !== null && typeof val === "object" && val["name"] !== undefined;
    }
    /**
     * Copy the values of all of the enumerable own properties from one or more source objects to a
     * target object.
     * @param target The target object to copy to.
     * @param sources One or more source objects from which to copy properties
     */ static assign(target, ...sources) {
        for (const source of sources){
            for (const prop of Object.getOwnPropertyNames(source)){
                ;
                target[prop] = source[prop];
            }
        }
    }
    /**
     * Converts MixedList<T> to strictly an array of its T items.
     */ static mixedListToArray(list) {
        if (list !== null && typeof list === "object") {
            return Object.keys(list).map((key)=>list[key]);
        } else {
            return list;
        }
    }
}
exports.ObjectUtils = ObjectUtils; //# sourceMappingURL=ObjectUtils.js.map
}}),
"[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InstanceChecker = void 0;
class InstanceChecker {
    static isMssqlParameter(obj) {
        return this.check(obj, "MssqlParameter");
    }
    static isEntityMetadata(obj) {
        return this.check(obj, "EntityMetadata");
    }
    static isColumnMetadata(obj) {
        return this.check(obj, "ColumnMetadata");
    }
    static isSelectQueryBuilder(obj) {
        return this.check(obj, "SelectQueryBuilder");
    }
    static isInsertQueryBuilder(obj) {
        return this.check(obj, "InsertQueryBuilder");
    }
    static isDeleteQueryBuilder(obj) {
        return this.check(obj, "DeleteQueryBuilder");
    }
    static isUpdateQueryBuilder(obj) {
        return this.check(obj, "UpdateQueryBuilder");
    }
    static isSoftDeleteQueryBuilder(obj) {
        return this.check(obj, "SoftDeleteQueryBuilder");
    }
    static isRelationQueryBuilder(obj) {
        return this.check(obj, "RelationQueryBuilder");
    }
    static isBrackets(obj) {
        return this.check(obj, "Brackets") || this.check(obj, "NotBrackets");
    }
    static isNotBrackets(obj) {
        return this.check(obj, "NotBrackets");
    }
    static isSubject(obj) {
        return this.check(obj, "Subject");
    }
    static isRdbmsSchemaBuilder(obj) {
        return this.check(obj, "RdbmsSchemaBuilder");
    }
    static isMongoEntityManager(obj) {
        return this.check(obj, "MongoEntityManager");
    }
    static isSqljsEntityManager(obj) {
        return this.check(obj, "SqljsEntityManager");
    }
    static isEntitySchema(obj) {
        return this.check(obj, "EntitySchema");
    }
    static isBaseEntityConstructor(obj) {
        return typeof obj === "function" && typeof obj.hasId === "function" && typeof obj.save === "function" && typeof obj.useDataSource === "function";
    }
    static isFindOperator(obj) {
        return this.check(obj, "FindOperator") || this.check(obj, "EqualOperator");
    }
    static isEqualOperator(obj) {
        return this.check(obj, "EqualOperator");
    }
    static isQuery(obj) {
        return this.check(obj, "Query");
    }
    static isTable(obj) {
        return this.check(obj, "Table");
    }
    static isTableCheck(obj) {
        return this.check(obj, "TableCheck");
    }
    static isTableColumn(obj) {
        return this.check(obj, "TableColumn");
    }
    static isTableExclusion(obj) {
        return this.check(obj, "TableExclusion");
    }
    static isTableForeignKey(obj) {
        return this.check(obj, "TableForeignKey");
    }
    static isTableIndex(obj) {
        return this.check(obj, "TableIndex");
    }
    static isTableUnique(obj) {
        return this.check(obj, "TableUnique");
    }
    static isView(obj) {
        return this.check(obj, "View");
    }
    static isDataSource(obj) {
        return this.check(obj, "DataSource");
    }
    static check(obj, name) {
        return typeof obj === "object" && obj !== null && obj["@instanceof"] === Symbol.for(name);
    }
}
exports.InstanceChecker = InstanceChecker; //# sourceMappingURL=InstanceChecker.js.map
}}),
"[project]/node_modules/typeorm/util/ImportUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.importOrRequireFile = importOrRequireFile;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const promises_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/fs/promises [external] (fs/promises, cjs)"));
const path_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const url_1 = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
async function importOrRequireFile(filePath) {
    const tryToImport = async ()=>{
        // `Function` is required to make sure the `import` statement wil stay `import` after
        // transpilation and won't be converted to `require`
        return [
            await Function("return filePath => import(filePath)")()(filePath.startsWith("file://") ? filePath : (0, url_1.pathToFileURL)(filePath).toString()),
            "esm"
        ];
    };
    const tryToRequire = async ()=>{
        return [
            (()=>{
                const e = new Error("Cannot find module as expression is too dynamic");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })(),
            "commonjs"
        ];
    };
    const extension = filePath.substring(filePath.lastIndexOf(".") + ".".length);
    if (extension === "mjs" || extension === "mts") return tryToImport();
    else if (extension === "cjs" || extension === "cts") return tryToRequire();
    else if (extension === "js" || extension === "ts") {
        const packageJson = await getNearestPackageJson(filePath);
        if (packageJson != null) {
            const isModule = packageJson?.type === "module";
            if (isModule) return tryToImport();
            else return tryToRequire();
        } else return tryToRequire();
    }
    return tryToRequire();
}
async function getNearestPackageJson(filePath) {
    let currentPath = filePath;
    while(currentPath !== path_1.default.dirname(currentPath)){
        currentPath = path_1.default.dirname(currentPath);
        const potentialPackageJson = path_1.default.join(currentPath, "package.json");
        try {
            const stats = await promises_1.default.stat(potentialPackageJson);
            if (!stats.isFile()) {
                continue;
            }
            try {
                return JSON.parse(await promises_1.default.readFile(potentialPackageJson, "utf8"));
            } catch  {
                return null;
            }
        } catch  {
            continue;
        }
    }
    // the top of the file tree is reached
    return null;
} //# sourceMappingURL=ImportUtils.js.map
}}),
"[project]/node_modules/typeorm/util/StringUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.camelCase = camelCase;
exports.snakeCase = snakeCase;
exports.titleCase = titleCase;
exports.abbreviate = abbreviate;
exports.shorten = shorten;
exports.hash = hash;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const sha_js_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/sha.js/index.js [app-route] (ecmascript)"));
/**
 * Converts string into camelCase.
 *
 * @see http://stackoverflow.com/questions/2970525/converting-any-string-into-camel-case
 */ function camelCase(str, firstCapital = false) {
    if (firstCapital) str = " " + str;
    return str.replace(/^([A-Z])|[\s-_](\w)/g, function(match, p1, p2) {
        if (p2) return p2.toUpperCase();
        return p1.toLowerCase();
    });
}
/**
 * Converts string into snake_case.
 *
 */ function snakeCase(str) {
    return str// ABc -> a_bc
    .replace(/([A-Z])([A-Z])([a-z])/g, "$1_$2$3")// aC -> a_c
    .replace(/([a-z0-9])([A-Z])/g, "$1_$2").toLowerCase();
}
/**
 * Converts string into Title Case.
 *
 * @see http://stackoverflow.com/questions/196972/convert-string-to-title-case-with-javascript
 */ function titleCase(str) {
    return str.replace(/\w\S*/g, (txt)=>txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
}
/**
 * Builds abbreviated string from given string;
 */ function abbreviate(str, abbrLettersCount = 1) {
    const words = str.replace(/([a-z\xE0-\xFF])([A-Z\xC0\xDF])/g, "$1 $2").split(" ");
    return words.reduce((res, word)=>{
        res += word.substr(0, abbrLettersCount);
        return res;
    }, "");
}
/**
 * Shorten a given `input`. Useful for RDBMS imposing a limit on the
 * maximum length of aliases and column names in SQL queries.
 *
 * @param input String to be shortened.
 * @param options Default to `4` for segments length, `2` for terms length, `'__'` as a separator.
 *
 * @return Shortened `input`.
 *
 * @example
 * // returns: "UsShCa__orde__mark__dire"
 * shorten('UserShoppingCart__order__market__director')
 *
 * // returns: "cat_wit_ver_lon_nam_pos_wit_ver_lon_nam_pos_wit_ver_lon_nam"
 * shorten(
 *   'category_with_very_long_name_posts_with_very_long_name_post_with_very_long_name',
 *   { separator: '_', segmentLength: 3 }
 * )
 *
 * // equals: UsShCa__orde__mark_market_id
 * `${shorten('UserShoppingCart__order__market')}_market_id`
 */ function shorten(input, options = {}) {
    const { segmentLength = 4, separator = "__", termLength = 2 } = options;
    const segments = input.split(separator);
    const shortSegments = segments.reduce((acc, val)=>{
        // split the given segment into many terms based on an eventual camel cased name
        const segmentTerms = val.replace(/([a-z\xE0-\xFF])([A-Z\xC0-\xDF])/g, "$1 $2").split(" ");
        // "OrderItemList" becomes "OrItLi", while "company" becomes "comp"
        const length = segmentTerms.length > 1 ? termLength : segmentLength;
        const shortSegment = segmentTerms.map((term)=>term.substr(0, length)).join("");
        acc.push(shortSegment);
        return acc;
    }, []);
    return shortSegments.join(separator);
}
/**
 * Returns a hashed input.
 *
 * @param input String to be hashed.
 * @param options.length Optionally, shorten the output to desired length.
 */ function hash(input, options = {}) {
    const hashFunction = (0, sha_js_1.default)("sha1");
    hashFunction.update(input, "utf8");
    const hashedInput = hashFunction.digest("hex");
    if (options.length) {
        return hashedInput.slice(0, options.length);
    }
    return hashedInput;
} //# sourceMappingURL=StringUtils.js.map
}}),
"[project]/node_modules/typeorm/util/PathUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toPortablePath = toPortablePath;
exports.filepathToName = filepathToName;
exports.isAbsolute = isAbsolute;
const StringUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/StringUtils.js [app-route] (ecmascript)");
const WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
const UNC_WINDOWS_PATH_REGEXP = /^\\\\(\.\\)?(.*)$/;
function toPortablePath(filepath) {
    if ("TURBOPACK compile-time truthy", 1) return filepath;
    "TURBOPACK unreachable";
}
/**
 * Create deterministic valid database name (class, database) of fixed length from any filepath. Equivalent paths for windows/posix systems should
 * be equivalent to enable portability
 */ function filepathToName(filepath) {
    const uniq = toPortablePath(filepath).toLowerCase();
    return (0, StringUtils_1.hash)(uniq, {
        length: 63
    });
}
/**
 * Cross platform isAbsolute
 */ function isAbsolute(filepath) {
    return !!filepath.match(/^(?:[a-z]:|[\\]|[/])/i);
} //# sourceMappingURL=PathUtils.js.map
}}),
"[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OrmUtils = void 0;
class OrmUtils {
    // -------------------------------------------------------------------------
    // Public methods
    // -------------------------------------------------------------------------
    /**
     * Chunks array into pieces.
     */ static chunk(array, size) {
        return Array.from(Array(Math.ceil(array.length / size)), (_, i)=>{
            return array.slice(i * size, i * size + size);
        });
    }
    static splitClassesAndStrings(classesAndStrings) {
        return [
            classesAndStrings.filter((cls)=>typeof cls !== "string"),
            classesAndStrings.filter((str)=>typeof str === "string")
        ];
    }
    static groupBy(array, propertyCallback) {
        return array.reduce((groupedArray, value)=>{
            const key = propertyCallback(value);
            let grouped = groupedArray.find((i)=>i.id === key);
            if (!grouped) {
                grouped = {
                    id: key,
                    items: []
                };
                groupedArray.push(grouped);
            }
            grouped.items.push(value);
            return groupedArray;
        }, []);
    }
    static uniq(array, criteriaOrProperty) {
        return array.reduce((uniqueArray, item)=>{
            let found = false;
            if (typeof criteriaOrProperty === "function") {
                const itemValue = criteriaOrProperty(item);
                found = !!uniqueArray.find((uniqueItem)=>criteriaOrProperty(uniqueItem) === itemValue);
            } else if (typeof criteriaOrProperty === "string") {
                found = !!uniqueArray.find((uniqueItem)=>uniqueItem[criteriaOrProperty] === item[criteriaOrProperty]);
            } else {
                found = uniqueArray.indexOf(item) !== -1;
            }
            if (!found) uniqueArray.push(item);
            return uniqueArray;
        }, []);
    }
    /**
     * Deep Object.assign.
     */ static mergeDeep(target, ...sources) {
        if (!sources.length) {
            return target;
        }
        for (const source of sources){
            OrmUtils.merge(target, source);
        }
        return target;
    }
    /**
     * Deep compare objects.
     *
     * @see http://stackoverflow.com/a/1144249
     */ static deepCompare(...args) {
        let i, l, leftChain, rightChain;
        if (arguments.length < 1) {
            return true; // Die silently? Don't know how to handle such case, please help...
        // throw "Need two or more arguments to compare";
        }
        for(i = 1, l = arguments.length; i < l; i++){
            leftChain = []; // Todo: this can be cached
            rightChain = [];
            if (!this.compare2Objects(leftChain, rightChain, arguments[0], arguments[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Gets deeper value of object.
     */ static deepValue(obj, path) {
        const segments = path.split(".");
        for(let i = 0, len = segments.length; i < len; i++){
            obj = obj[segments[i]];
        }
        return obj;
    }
    static replaceEmptyObjectsWithBooleans(obj) {
        for(const key in obj){
            if (obj[key] && typeof obj[key] === "object") {
                if (Object.keys(obj[key]).length === 0) {
                    obj[key] = true;
                } else {
                    this.replaceEmptyObjectsWithBooleans(obj[key]);
                }
            }
        }
    }
    static propertyPathsToTruthyObject(paths) {
        const obj = {};
        for (const path of paths){
            const props = path.split(".");
            if (!props.length) continue;
            if (!obj[props[0]] || obj[props[0]] === true) {
                obj[props[0]] = {};
            }
            let recursiveChild = obj[props[0]];
            for (const [key, prop] of props.entries()){
                if (key === 0) continue;
                if (recursiveChild[prop]) {
                    recursiveChild = recursiveChild[prop];
                } else if (key === props.length - 1) {
                    recursiveChild[prop] = {};
                    recursiveChild = null;
                } else {
                    recursiveChild[prop] = {};
                    recursiveChild = recursiveChild[prop];
                }
            }
        }
        this.replaceEmptyObjectsWithBooleans(obj);
        return obj;
    }
    /**
     * Check if two entity-id-maps are the same
     */ static compareIds(firstId, secondId) {
        if (firstId === undefined || firstId === null || secondId === undefined || secondId === null) return false;
        // Optimized version for the common case
        if ((typeof firstId.id === "string" && typeof secondId.id === "string" || typeof firstId.id === "number" && typeof secondId.id === "number") && Object.keys(firstId).length === 1 && Object.keys(secondId).length === 1) {
            return firstId.id === secondId.id;
        }
        return OrmUtils.deepCompare(firstId, secondId);
    }
    /**
     * Transforms given value into boolean value.
     */ static toBoolean(value) {
        if (typeof value === "boolean") return value;
        if (typeof value === "string") return value === "true" || value === "1";
        if (typeof value === "number") return value > 0;
        return false;
    }
    /**
     * Composes an object from the given array of keys and values.
     */ static zipObject(keys, values) {
        return keys.reduce((object, column, index)=>{
            object[column] = values[index];
            return object;
        }, {});
    }
    /**
     * Compares two arrays.
     */ static isArraysEqual(arr1, arr2) {
        if (arr1.length !== arr2.length) return false;
        return arr1.every((element)=>{
            return arr2.indexOf(element) !== -1;
        });
    }
    static areMutuallyExclusive(...lists) {
        const haveSharedObjects = lists.some((list)=>{
            const otherLists = lists.filter((otherList)=>otherList !== list);
            return list.some((item)=>otherLists.some((otherList)=>otherList.includes(item)));
        });
        return !haveSharedObjects;
    }
    /**
     * Parses the CHECK constraint on the specified column and returns
     * all values allowed by the constraint or undefined if the constraint
     * is not present.
     */ static parseSqlCheckExpression(sql, columnName) {
        const enumMatch = sql.match(new RegExp(`"${columnName}" varchar CHECK\\s*\\(\\s*"${columnName}"\\s+IN\\s*`));
        if (enumMatch && enumMatch.index) {
            const afterMatch = sql.substring(enumMatch.index + enumMatch[0].length);
            // This is an enum
            // all enum values stored as a comma separated list
            const chars = afterMatch;
            /**
             * * When outside quotes: empty string
             * * When inside single quotes: `'`
             */ let currentQuotes = "";
            let nextValue = "";
            const enumValues = [];
            for(let idx = 0; idx < chars.length; idx++){
                const char = chars[idx];
                switch(char){
                    case ",":
                        if (currentQuotes == "") {
                            enumValues.push(nextValue);
                            nextValue = "";
                        } else {
                            nextValue += char;
                        }
                        break;
                    case "'":
                        if (currentQuotes == char) {
                            const isNextCharQuote = chars[idx + 1] === char;
                            if (isNextCharQuote) {
                                // double quote in sql should be treated as a
                                // single quote that's part of the quoted string
                                nextValue += char;
                                idx += 1; // skip that next quote
                            } else {
                                currentQuotes = "";
                            }
                        } else {
                            currentQuotes = char;
                        }
                        break;
                    case ")":
                        if (currentQuotes == "") {
                            enumValues.push(nextValue);
                            return enumValues;
                        } else {
                            nextValue += char;
                        }
                        break;
                    default:
                        if (currentQuotes != "") {
                            nextValue += char;
                        }
                }
            }
        }
        return undefined;
    }
    /**
     * Checks if given criteria is null or empty.
     */ static isCriteriaNullOrEmpty(criteria) {
        return criteria === undefined || criteria === null || criteria === "" || Array.isArray(criteria) && criteria.length === 0 || this.isPlainObject(criteria) && Object.keys(criteria).length === 0;
    }
    /**
     * Checks if given criteria is a primitive value.
     * Primitive values are strings, numbers and dates.
     */ static isSinglePrimitiveCriteria(criteria) {
        return typeof criteria === "string" || typeof criteria === "number" || criteria instanceof Date;
    }
    /**
     * Checks if given criteria is a primitive value or an array of primitive values.
     */ static isPrimitiveCriteria(criteria) {
        if (Array.isArray(criteria)) {
            return criteria.every((value)=>this.isSinglePrimitiveCriteria(value));
        }
        return this.isSinglePrimitiveCriteria(criteria);
    }
    // -------------------------------------------------------------------------
    // Private methods
    // -------------------------------------------------------------------------
    static compare2Objects(leftChain, rightChain, x, y) {
        let p;
        // remember that NaN === NaN returns false
        // and isNaN(undefined) returns true
        if (Number.isNaN(x) && Number.isNaN(y)) return true;
        // Compare primitives and functions.
        // Check if both arguments link to the same object.
        // Especially useful on the step where we compare prototypes
        if (x === y) return true;
        // Unequal, but either is null or undefined (use case: jsonb comparison)
        // PR #3776, todo: add tests
        if (x === null || y === null || x === undefined || y === undefined) return false;
        // Fix the buffer compare bug.
        // See: https://github.com/typeorm/typeorm/issues/3654
        if ((typeof x.equals === "function" || typeof x.equals === "function") && x.equals(y)) return true;
        // Works in case when functions are created in constructor.
        // Comparing dates is a common scenario. Another built-ins?
        // We can even handle functions passed across iframes
        if (typeof x === "function" && typeof y === "function" || x instanceof Date && y instanceof Date || x instanceof RegExp && y instanceof RegExp || typeof x === "string" && typeof y === "string" || typeof x === "number" && typeof y === "number") return x.toString() === y.toString();
        // At last checking prototypes as good as we can
        if (!(typeof x === "object" && typeof y === "object")) return false;
        if (Object.prototype.isPrototypeOf.call(x, y) || Object.prototype.isPrototypeOf.call(y, x)) return false;
        if (x.constructor !== y.constructor) return false;
        if (x.prototype !== y.prototype) return false;
        // Check for infinitive linking loops
        if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) return false;
        // Quick checking of one object being a subset of another.
        // todo: cache the structure of arguments[0] for performance
        for(p in y){
            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                return false;
            } else if (typeof y[p] !== typeof x[p]) {
                return false;
            }
        }
        for(p in x){
            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                return false;
            } else if (typeof y[p] !== typeof x[p]) {
                return false;
            }
            switch(typeof x[p]){
                case "object":
                case "function":
                    leftChain.push(x);
                    rightChain.push(y);
                    if (!this.compare2Objects(leftChain, rightChain, x[p], y[p])) {
                        return false;
                    }
                    leftChain.pop();
                    rightChain.pop();
                    break;
                default:
                    if (x[p] !== y[p]) {
                        return false;
                    }
                    break;
            }
        }
        return true;
    }
    // Checks if it's an object made by Object.create(null), {} or new Object()
    static isPlainObject(item) {
        if (item === null || item === undefined) {
            return false;
        }
        return !item.constructor || item.constructor === Object;
    }
    static mergeArrayKey(target, key, value, memo) {
        // Have we seen this before?  Prevent infinite recursion.
        if (memo.has(value)) {
            target[key] = memo.get(value);
            return;
        }
        if (value instanceof Promise) {
            // Skip promises entirely.
            // This is a hold-over from the old code & is because we don't want to pull in
            // the lazy fields.  Ideally we'd remove these promises via another function first
            // but for now we have to do it here.
            return;
        }
        if (!this.isPlainObject(value) && !Array.isArray(value)) {
            target[key] = value;
            return;
        }
        if (!target[key]) {
            target[key] = Array.isArray(value) ? [] : {};
        }
        memo.set(value, target[key]);
        this.merge(target[key], value, memo);
        memo.delete(value);
    }
    static mergeObjectKey(target, key, value, memo) {
        // Have we seen this before?  Prevent infinite recursion.
        if (memo.has(value)) {
            Object.assign(target, {
                [key]: memo.get(value)
            });
            return;
        }
        if (value instanceof Promise) {
            // Skip promises entirely.
            // This is a hold-over from the old code & is because we don't want to pull in
            // the lazy fields.  Ideally we'd remove these promises via another function first
            // but for now we have to do it here.
            return;
        }
        if (!this.isPlainObject(value) && !Array.isArray(value)) {
            Object.assign(target, {
                [key]: value
            });
            return;
        }
        if (!target[key]) {
            Object.assign(target, {
                [key]: Array.isArray(value) ? [] : {}
            });
        }
        memo.set(value, target[key]);
        this.merge(target[key], value, memo);
        memo.delete(value);
    }
    static merge(target, source, memo = new Map()) {
        if (this.isPlainObject(target) && this.isPlainObject(source)) {
            for (const key of Object.keys(source)){
                if (key === "__proto__") continue;
                this.mergeObjectKey(target, key, source[key], memo);
            }
        }
        if (Array.isArray(target) && Array.isArray(source)) {
            for(let key = 0; key < source.length; key++){
                this.mergeArrayKey(target, key, source[key], memo);
            }
        }
    }
}
exports.OrmUtils = OrmUtils; //# sourceMappingURL=OrmUtils.js.map
}}),
"[project]/node_modules/typeorm/util/VersionUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VersionUtils = void 0;
class VersionUtils {
    static isGreaterOrEqual(version, targetVersion) {
        if (!version) {
            return false;
        }
        const v1 = parseVersion(version);
        const v2 = parseVersion(targetVersion);
        for(let i = 0; i < v1.length && i < v2.length; i++){
            if (v1[i] > v2[i]) {
                return true;
            } else if (v1[i] < v2[i]) {
                return false;
            }
        }
        return true;
    }
}
exports.VersionUtils = VersionUtils;
function parseVersion(version) {
    return version.split(".").map((value)=>parseInt(value, 10));
} //# sourceMappingURL=VersionUtils.js.map
}}),
"[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApplyValueTransformers = void 0;
class ApplyValueTransformers {
    static transformFrom(transformer, databaseValue) {
        if (Array.isArray(transformer)) {
            const reverseTransformers = transformer.slice().reverse();
            return reverseTransformers.reduce((transformedValue, _transformer)=>{
                return _transformer.from(transformedValue);
            }, databaseValue);
        }
        return transformer.from(databaseValue);
    }
    static transformTo(transformer, entityValue) {
        if (Array.isArray(transformer)) {
            return transformer.reduce((transformedValue, _transformer)=>{
                return _transformer.to(transformedValue);
            }, entityValue);
        }
        return transformer.to(entityValue);
    }
}
exports.ApplyValueTransformers = ApplyValueTransformers; //# sourceMappingURL=ApplyValueTransformers.js.map
}}),
"[project]/node_modules/typeorm/util/escapeRegExp.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.escapeRegExp = void 0;
// Escape special characters in regular expressions
// Per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
const ESCAPE_REGEXP = /[.*+\-?^${}()|[\]\\]/g;
const escapeRegExp = (s)=>s.replace(ESCAPE_REGEXP, "\\$&");
exports.escapeRegExp = escapeRegExp; //# sourceMappingURL=escapeRegExp.js.map
}}),
"[project]/node_modules/typeorm/util/RandomGenerator.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RandomGenerator = void 0;
class RandomGenerator {
    /**
     *  discuss at: http://locutus.io/php/sha1/
     * original by: Webtoolkit.info (http://www.webtoolkit.info/)
     * improved by: Michael White (http://getsprink.com)
     * improved by: Kevin van Zonneveld (http://kvz.io)
     *    input by: Brett Zamir (http://brett-zamir.me)
     *      note 1: Keep in mind that in accordance with PHP, the whole string is buffered and then
     *      note 1: hashed. If available, we'd recommend using Node's native crypto modules directly
     *      note 1: in a steaming fashion for faster and more efficient hashing
     *   example 1: sha1('Kevin van Zonneveld')
     *   returns 1: '54916d2e62f65b3afa6e192e6a601cdbe5cb5897'
     */ static sha1(str) {
        const _rotLeft = function(n, s) {
            const t4 = n << s | n >>> 32 - s;
            return t4;
        };
        const _cvtHex = function(val) {
            let str = "";
            let i;
            let v;
            for(i = 7; i >= 0; i--){
                v = val >>> i * 4 & 0x0f;
                str += v.toString(16);
            }
            return str;
        };
        let blockstart;
        let i, j;
        const W = new Array(80);
        let H0 = 0x67452301;
        let H1 = 0xefcdab89;
        let H2 = 0x98badcfe;
        let H3 = 0x10325476;
        let H4 = 0xc3d2e1f0;
        let A, B, C, D, E;
        let temp;
        // utf8_encode
        str = /*unescape*/ encodeURIComponent(str);
        const strLen = str.length;
        const wordArray = [];
        for(i = 0; i < strLen - 3; i += 4){
            j = str.charCodeAt(i) << 24 | str.charCodeAt(i + 1) << 16 | str.charCodeAt(i + 2) << 8 | str.charCodeAt(i + 3);
            wordArray.push(j);
        }
        switch(strLen % 4){
            case 0:
                i = 0x080000000;
                break;
            case 1:
                i = str.charCodeAt(strLen - 1) << 24 | 0x0800000;
                break;
            case 2:
                i = str.charCodeAt(strLen - 2) << 24 | str.charCodeAt(strLen - 1) << 16 | 0x08000;
                break;
            case 3:
                i = str.charCodeAt(strLen - 3) << 24 | str.charCodeAt(strLen - 2) << 16 | str.charCodeAt(strLen - 1) << 8 | 0x80;
                break;
        }
        wordArray.push(i);
        while(wordArray.length % 16 !== 14){
            wordArray.push(0);
        }
        wordArray.push(strLen >>> 29);
        wordArray.push(strLen << 3 & 0x0ffffffff);
        for(blockstart = 0; blockstart < wordArray.length; blockstart += 16){
            for(i = 0; i < 16; i++){
                W[i] = wordArray[blockstart + i];
            }
            for(i = 16; i <= 79; i++){
                W[i] = _rotLeft(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
            }
            A = H0;
            B = H1;
            C = H2;
            D = H3;
            E = H4;
            for(i = 0; i <= 19; i++){
                temp = _rotLeft(A, 5) + (B & C | ~B & D) + E + W[i] + 0x5a827999 & 0x0ffffffff;
                E = D;
                D = C;
                C = _rotLeft(B, 30);
                B = A;
                A = temp;
            }
            for(i = 20; i <= 39; i++){
                temp = _rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ed9eba1 & 0x0ffffffff;
                E = D;
                D = C;
                C = _rotLeft(B, 30);
                B = A;
                A = temp;
            }
            for(i = 40; i <= 59; i++){
                temp = _rotLeft(A, 5) + (B & C | B & D | C & D) + E + W[i] + 0x8f1bbcdc & 0x0ffffffff;
                E = D;
                D = C;
                C = _rotLeft(B, 30);
                B = A;
                A = temp;
            }
            for(i = 60; i <= 79; i++){
                temp = _rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 0xca62c1d6 & 0x0ffffffff;
                E = D;
                D = C;
                C = _rotLeft(B, 30);
                B = A;
                A = temp;
            }
            H0 = H0 + A & 0x0ffffffff;
            H1 = H1 + B & 0x0ffffffff;
            H2 = H2 + C & 0x0ffffffff;
            H3 = H3 + D & 0x0ffffffff;
            H4 = H4 + E & 0x0ffffffff;
        }
        temp = _cvtHex(H0) + _cvtHex(H1) + _cvtHex(H2) + _cvtHex(H3) + _cvtHex(H4);
        return temp.toLowerCase();
    }
}
exports.RandomGenerator = RandomGenerator; //# sourceMappingURL=RandomGenerator.js.map
}}),
"[project]/node_modules/typeorm/util/DepGraph.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/**
 * This source code is from https://github.com/jriecken/dependency-graph
 * Just added "any" types here, wrapper everything into exported class.
 * We cant use a package itself because we want to package "everything-in-it" for the frontend users of TypeORM.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DepGraph = void 0;
/**
 * A simple dependency graph
 */ const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Helper for creating a Depth-First-Search on
 * a set of edges.
 *
 * Detects cycles and throws an Error if one is detected.
 *
 * @param edges The set of edges to DFS through
 * @param leavesOnly Whether to only return "leaf" nodes (ones who have no edges)
 * @param result An array in which the results will be populated
 */ function createDFS(edges, leavesOnly, result) {
    const currentPath = [];
    const visited = {};
    return function DFS(currentNode) {
        visited[currentNode] = true;
        currentPath.push(currentNode);
        edges[currentNode].forEach(function(node) {
            if (!visited[node]) {
                DFS(node);
            } else if (currentPath.indexOf(node) >= 0) {
                currentPath.push(node);
                throw new error_1.TypeORMError(`Dependency Cycle Found: ${currentPath.join(" -> ")}`);
            }
        });
        currentPath.pop();
        if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {
            result.push(currentNode);
        }
    };
}
class DepGraph {
    constructor(){
        this.nodes = {};
        this.outgoingEdges = {}; // Node -> [Dependency Node]
        this.incomingEdges = {}; // Node -> [Dependant Node]
    }
    /**
     * Add a node to the dependency graph. If a node already exists, this method will do nothing.
     */ addNode(node, data) {
        if (!this.hasNode(node)) {
            // Checking the arguments length allows the user to add a node with undefined data
            if (arguments.length === 2) {
                this.nodes[node] = data;
            } else {
                this.nodes[node] = node;
            }
            this.outgoingEdges[node] = [];
            this.incomingEdges[node] = [];
        }
    }
    /**
     * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.
     */ removeNode(node) {
        if (this.hasNode(node)) {
            delete this.nodes[node];
            delete this.outgoingEdges[node];
            delete this.incomingEdges[node];
            [
                this.incomingEdges,
                this.outgoingEdges
            ].forEach(function(edgeList) {
                Object.keys(edgeList).forEach(function(key) {
                    const idx = edgeList[key].indexOf(node);
                    if (idx >= 0) {
                        edgeList[key].splice(idx, 1);
                    }
                });
            });
        }
    }
    /**
     * Check if a node exists in the graph
     */ hasNode(node) {
        return this.nodes.hasOwnProperty(node);
    }
    /**
     * Get the data associated with a node name
     */ getNodeData(node) {
        if (this.hasNode(node)) {
            return this.nodes[node];
        } else {
            throw new error_1.TypeORMError(`Node does not exist: ${node}`);
        }
    }
    /**
     * Set the associated data for a given node name. If the node does not exist, this method will throw an error
     */ setNodeData(node, data) {
        if (this.hasNode(node)) {
            this.nodes[node] = data;
        } else {
            throw new error_1.TypeORMError(`Node does not exist: ${node}`);
        }
    }
    /**
     * Add a dependency between two nodes. If either of the nodes does not exist,
     * an Error will be thrown.
     */ addDependency(from, to) {
        if (!this.hasNode(from)) {
            throw new error_1.TypeORMError(`Node does not exist: ${from}`);
        }
        if (!this.hasNode(to)) {
            throw new error_1.TypeORMError(`Node does not exist: ${to}`);
        }
        if (this.outgoingEdges[from].indexOf(to) === -1) {
            this.outgoingEdges[from].push(to);
        }
        if (this.incomingEdges[to].indexOf(from) === -1) {
            this.incomingEdges[to].push(from);
        }
        return true;
    }
    /**
     * Remove a dependency between two nodes.
     */ removeDependency(from, to) {
        let idx;
        if (this.hasNode(from)) {
            idx = this.outgoingEdges[from].indexOf(to);
            if (idx >= 0) {
                this.outgoingEdges[from].splice(idx, 1);
            }
        }
        if (this.hasNode(to)) {
            idx = this.incomingEdges[to].indexOf(from);
            if (idx >= 0) {
                this.incomingEdges[to].splice(idx, 1);
            }
        }
    }
    /**
     * Get an array containing the nodes that the specified node depends on (transitively).
     *
     * Throws an Error if the graph has a cycle, or the specified node does not exist.
     *
     * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned
     * in the array.
     */ dependenciesOf(node, leavesOnly) {
        if (this.hasNode(node)) {
            const result = [];
            const DFS = createDFS(this.outgoingEdges, leavesOnly, result);
            DFS(node);
            const idx = result.indexOf(node);
            if (idx >= 0) {
                result.splice(idx, 1);
            }
            return result;
        } else {
            throw new error_1.TypeORMError(`Node does not exist: ${node}`);
        }
    }
    /**
     * get an array containing the nodes that depend on the specified node (transitively).
     *
     * Throws an Error if the graph has a cycle, or the specified node does not exist.
     *
     * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.
     */ dependantsOf(node, leavesOnly) {
        if (this.hasNode(node)) {
            const result = [];
            const DFS = createDFS(this.incomingEdges, leavesOnly, result);
            DFS(node);
            const idx = result.indexOf(node);
            if (idx >= 0) {
                result.splice(idx, 1);
            }
            return result;
        } else {
            throw new error_1.TypeORMError(`Node does not exist: ${node}`);
        }
    }
    /**
     * Construct the overall processing order for the dependency graph.
     *
     * Throws an Error if the graph has a cycle.
     *
     * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.
     */ overallOrder(leavesOnly) {
        const self = this;
        const result = [];
        const keys = Object.keys(this.nodes);
        if (keys.length === 0) {
            return result; // Empty graph
        } else {
            // Look for cycles - we run the DFS starting at all the nodes in case there
            // are several disconnected subgraphs inside this dependency graph.
            const CycleDFS = createDFS(this.outgoingEdges, false, []);
            keys.forEach(function(n) {
                CycleDFS(n);
            });
            const DFS = createDFS(this.outgoingEdges, leavesOnly, result);
            // Find all potential starting points (nodes with nothing depending on them) an
            // run a DFS starting at these points to get the order
            keys.filter(function(node) {
                return self.incomingEdges[node].length === 0;
            }).forEach(function(n) {
                DFS(n);
            });
            return result;
        }
    }
}
exports.DepGraph = DepGraph; //# sourceMappingURL=DepGraph.js.map
}}),
"[project]/node_modules/typeorm/util/SqlTagUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildSqlTag = buildSqlTag;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const dedent_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/dedent/dist/dedent.js [app-route] (ecmascript)"));
function buildSqlTag({ driver, strings, expressions }) {
    let query = "";
    const parameters = [];
    let idx = 0;
    for (const [expressionIdx, expression] of expressions.entries()){
        query += strings[expressionIdx];
        if (expression === null) {
            query += "NULL";
            continue;
        }
        if (typeof expression === "function") {
            const value = expression();
            if (typeof value === "string") {
                query += value;
                continue;
            }
            if (Array.isArray(value)) {
                if (value.length === 0) {
                    throw new Error(`Expression ${expressionIdx} in this sql tagged template is a function which returned an empty array. Empty arrays cannot safely be expanded into parameter lists.`);
                }
                const arrayParams = value.map(()=>{
                    return driver.createParameter(`param_${idx + 1}`, idx++);
                });
                query += arrayParams.join(", ");
                parameters.push(...value);
                continue;
            }
            throw new Error(`Expression ${expressionIdx} in this sql tagged template is a function which returned a value of type "${value === null ? "null" : typeof value}". Only array and string types are supported as function return values in sql tagged template expressions.`);
        }
        query += driver.createParameter(`param_${idx + 1}`, idx++);
        parameters.push(expression);
    }
    query += strings[strings.length - 1];
    query = (0, dedent_1.default)(query);
    return {
        query,
        parameters
    };
} //# sourceMappingURL=SqlTagUtils.js.map
}}),
"[project]/node_modules/typeorm/util/TreeRepositoryUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TreeRepositoryUtils = void 0;
/**
 * Provides utilities for manipulating tree structures.
 *
 */ class TreeRepositoryUtils {
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    static createRelationMaps(manager, metadata, alias, rawResults) {
        return rawResults.map((rawResult)=>{
            const joinColumn = metadata.treeParentRelation.joinColumns[0];
            const referencedColumn = joinColumn.referencedColumn ?? metadata.primaryColumns[0];
            // fixes issue #2518, default to databaseName property when givenDatabaseName is not set
            const joinColumnName = joinColumn.givenDatabaseName || joinColumn.databaseName;
            const referencedColumnName = referencedColumn.givenDatabaseName || referencedColumn.databaseName;
            const id = rawResult[alias + "_" + referencedColumnName];
            const parentId = rawResult[alias + "_" + joinColumnName];
            return {
                id: manager.connection.driver.prepareHydratedValue(id, referencedColumn),
                parentId: manager.connection.driver.prepareHydratedValue(parentId, joinColumn)
            };
        });
    }
    static buildChildrenEntityTree(metadata, entity, entities, relationMaps, options) {
        const childProperty = metadata.treeChildrenRelation.propertyName;
        if (options.depth === 0) {
            entity[childProperty] = [];
            return;
        }
        const joinColumn = metadata.treeParentRelation.joinColumns[0];
        const referencedColumn = joinColumn.referencedColumn ?? metadata.primaryColumns[0];
        const parentEntityId = referencedColumn.getEntityValue(entity);
        const childRelationMaps = relationMaps.filter((relationMap)=>relationMap.parentId === parentEntityId);
        const childIds = new Set(childRelationMaps.map((relationMap)=>relationMap.id));
        entity[childProperty] = entities.filter((entity)=>childIds.has(referencedColumn.getEntityValue(entity)));
        entity[childProperty].forEach((childEntity)=>{
            TreeRepositoryUtils.buildChildrenEntityTree(metadata, childEntity, entities, relationMaps, {
                ...options,
                depth: options.depth - 1
            });
        });
    }
    static buildParentEntityTree(metadata, entity, entities, relationMaps) {
        const parentProperty = metadata.treeParentRelation.propertyName;
        const joinColumn = metadata.treeParentRelation.joinColumns[0];
        const referencedColumn = joinColumn.referencedColumn ?? metadata.primaryColumns[0];
        const entityId = referencedColumn.getEntityValue(entity);
        const parentRelationMap = relationMaps.find((relationMap)=>relationMap.id === entityId);
        const parentEntity = entities.find((entity)=>{
            if (!parentRelationMap) return false;
            return referencedColumn.getEntityValue(entity) === parentRelationMap.parentId;
        });
        if (parentEntity) {
            entity[parentProperty] = parentEntity;
            TreeRepositoryUtils.buildParentEntityTree(metadata, entity[parentProperty], entities, relationMaps);
        }
    }
}
exports.TreeRepositoryUtils = TreeRepositoryUtils; //# sourceMappingURL=TreeRepositoryUtils.js.map
}}),
"[project]/node_modules/typeorm/util/DateUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DateUtils = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const dayjs_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/dayjs/dayjs.min.js [app-route] (ecmascript)"));
/**
 * Provides utilities to transform hydrated and persisted data.
 */ class DateUtils {
    // -------------------------------------------------------------------------
    // Public Static Methods
    // -------------------------------------------------------------------------
    /**
     * Normalizes date object hydrated from the database.
     */ static normalizeHydratedDate(mixedDate) {
        if (!mixedDate) return mixedDate;
        return typeof mixedDate === "string" ? new Date(mixedDate) : mixedDate;
    }
    /**
     * Converts given value into date string in a "YYYY-MM-DD" format.
     */ static mixedDateToDateString(value) {
        if (value instanceof Date) {
            return this.formatZerolessValue(value.getFullYear(), 4) + "-" + this.formatZerolessValue(value.getMonth() + 1) + "-" + this.formatZerolessValue(value.getDate());
        }
        return value;
    }
    /**
     * Converts given value into date object.
     */ static mixedDateToDate(mixedDate, toUtc = false, useMilliseconds = true) {
        /**
         * new Date(ISOString) is not a reliable parser to date strings.
         * It's better to use 'date-fns' parser to parser string in ISO Format.
         *
         * The problem here is with wrong timezone.
         *
         * For example:
         *
         * ``new Date('2021-04-28')`` will generate `2021-04-28T00:00:00.000Z`
         * in my timezone, which is not true for my timezone (GMT-0300). It should
         * be `2021-04-28T03:00:00.000Z` as `new Date(2021, 3, 28)` generates.
         *
         * https://stackoverflow.com/a/2587398
         */ let date = typeof mixedDate === "string" ? (0, dayjs_1.default)(mixedDate).toDate() : mixedDate;
        if (toUtc) date = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
        if (!useMilliseconds) date.setUTCMilliseconds(0);
        return date;
    }
    /**
     * Converts given value into time string in a "HH:mm:ss" format.
     */ static mixedDateToTimeString(value, skipSeconds = false) {
        if (value instanceof Date) return this.formatZerolessValue(value.getHours()) + ":" + this.formatZerolessValue(value.getMinutes()) + (!skipSeconds ? ":" + this.formatZerolessValue(value.getSeconds()) : "");
        return value;
    }
    /**
     * Converts given value into time string in a "HH:mm:ss" format.
     */ static mixedTimeToDate(value) {
        if (typeof value === "string") {
            const [hours, minutes, seconds] = value.split(":");
            const date = new Date();
            if (hours) date.setHours(parseInt(hours));
            if (minutes) date.setMinutes(parseInt(minutes));
            if (seconds) date.setSeconds(parseInt(seconds));
            return date;
        }
        return value;
    }
    /**
     * Converts given string value with "-" separator into a "HH:mm:ss" format.
     */ static mixedTimeToString(value, skipSeconds = false) {
        value = value instanceof Date ? value.getHours() + ":" + value.getMinutes() + (!skipSeconds ? ":" + value.getSeconds() : "") : value;
        if (typeof value === "string") {
            return value.split(":").map((v)=>v.length === 1 ? "0" + v : v) // append zero at beginning if we have a first-zero-less number
            .join(":");
        }
        return value;
    }
    /**
     * Converts given value into datetime string in a "YYYY-MM-DD HH-mm-ss" format.
     */ static mixedDateToDatetimeString(value, useMilliseconds) {
        if (typeof value === "string") {
            value = new Date(value);
        }
        if (value instanceof Date) {
            let finalValue = this.formatZerolessValue(value.getFullYear(), 4) + "-" + this.formatZerolessValue(value.getMonth() + 1) + "-" + this.formatZerolessValue(value.getDate()) + " " + this.formatZerolessValue(value.getHours()) + ":" + this.formatZerolessValue(value.getMinutes()) + ":" + this.formatZerolessValue(value.getSeconds());
            if (useMilliseconds) finalValue += `.${this.formatMilliseconds(value.getMilliseconds())}`;
            value = finalValue;
        }
        return value;
    }
    /**
     * Converts given value into utc datetime string in a "YYYY-MM-DD HH-mm-ss.sss" format.
     */ static mixedDateToUtcDatetimeString(value) {
        if (typeof value === "string") {
            value = new Date(value);
        }
        if (value instanceof Date) {
            return this.formatZerolessValue(value.getUTCFullYear(), 4) + "-" + this.formatZerolessValue(value.getUTCMonth() + 1) + "-" + this.formatZerolessValue(value.getUTCDate()) + " " + this.formatZerolessValue(value.getUTCHours()) + ":" + this.formatZerolessValue(value.getUTCMinutes()) + ":" + this.formatZerolessValue(value.getUTCSeconds()) + "." + this.formatMilliseconds(value.getUTCMilliseconds());
        }
        return value;
    }
    /**
     * Converts each item in the given array to string joined by "," separator.
     */ static simpleArrayToString(value) {
        if (Array.isArray(value)) {
            return value.map((i)=>String(i)).join(",");
        }
        return value;
    }
    /**
     * Converts given string to simple array split by "," separator.
     */ static stringToSimpleArray(value) {
        if (typeof value === "string") {
            if (value.length > 0) {
                return value.split(",");
            } else {
                return [];
            }
        }
        return value;
    }
    static simpleJsonToString(value) {
        return JSON.stringify(value);
    }
    static stringToSimpleJson(value) {
        return typeof value === "string" ? JSON.parse(value) : value;
    }
    static simpleEnumToString(value) {
        return "" + value;
    }
    static stringToSimpleEnum(value, columnMetadata) {
        if (columnMetadata.enum && !isNaN(value) && columnMetadata.enum.indexOf(parseInt(value)) >= 0) {
            // convert to number if that exists in poosible enum options
            value = parseInt(value);
        }
        return value;
    }
    // -------------------------------------------------------------------------
    // Private Static Methods
    // -------------------------------------------------------------------------
    /**
     * Formats given number to "0x" format, e.g. if the totalLength = 2 and the value is 1 then it will return "01".
     */ static formatZerolessValue(value, totalLength = 2) {
        const pad = "0".repeat(totalLength);
        return String(`${pad}${value}`).slice(-totalLength);
    }
    /**
     * Formats given number to "0x" format, e.g. if it is 1 then it will return "01".
     */ static formatMilliseconds(value) {
        if (value < 10) {
            return "00" + value;
        } else if (value < 100) {
            return "0" + value;
        } else {
            return String(value);
        }
    }
}
exports.DateUtils = DateUtils; //# sourceMappingURL=DateUtils.js.map
}}),
"[project]/node_modules/typeorm/util/DirectoryExportedClassesLoader.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.importClassesFromDirectories = importClassesFromDirectories;
exports.importJsonsFromDirectories = importJsonsFromDirectories;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const glob = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/glob/dist/commonjs/index.js [app-route] (ecmascript)"));
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const ImportUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ImportUtils.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Loads all exported classes from the given directory.
 */ async function importClassesFromDirectories(logger, directories, formats = [
    ".js",
    ".mjs",
    ".cjs",
    ".ts",
    ".mts",
    ".cts"
]) {
    const logLevel = "info";
    const classesNotFoundMessage = "No classes were found using the provided glob pattern: ";
    const classesFoundMessage = "All classes found using provided glob pattern";
    function loadFileClasses(exported, allLoaded) {
        if (typeof exported === "function" || InstanceChecker_1.InstanceChecker.isEntitySchema(exported)) {
            allLoaded.push(exported);
        } else if (Array.isArray(exported)) {
            exported.forEach((value)=>loadFileClasses(value, allLoaded));
        } else if (ObjectUtils_1.ObjectUtils.isObject(exported)) {
            Object.values(exported).forEach((value)=>loadFileClasses(value, allLoaded));
        }
        return allLoaded;
    }
    const allFiles = directories.reduce((allDirs, dir)=>{
        return allDirs.concat(glob.sync(PlatformTools_1.PlatformTools.pathNormalize(dir)));
    }, []);
    if (directories.length > 0 && allFiles.length === 0) {
        logger.log(logLevel, `${classesNotFoundMessage} "${directories}"`);
    } else if (allFiles.length > 0) {
        logger.log(logLevel, `${classesFoundMessage} "${directories}" : "${allFiles}"`);
    }
    const dirPromises = allFiles.filter((file)=>{
        const dtsExtension = file.substring(file.length - 5, file.length);
        return formats.indexOf(PlatformTools_1.PlatformTools.pathExtname(file)) !== -1 && dtsExtension !== ".d.ts";
    }).map(async (file)=>{
        const [importOrRequireResult] = await (0, ImportUtils_1.importOrRequireFile)(PlatformTools_1.PlatformTools.pathResolve(file));
        return importOrRequireResult;
    });
    const dirs = await Promise.all(dirPromises);
    return loadFileClasses(dirs, []);
}
/**
 * Loads all json files from the given directory.
 */ function importJsonsFromDirectories(directories, format = ".json") {
    const allFiles = directories.reduce((allDirs, dir)=>{
        return allDirs.concat(glob.sync(PlatformTools_1.PlatformTools.pathNormalize(dir)));
    }, []);
    return allFiles.filter((file)=>PlatformTools_1.PlatformTools.pathExtname(file) === format).map((file)=>(()=>{
            const e = new Error("Cannot find module as expression is too dynamic");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })());
} //# sourceMappingURL=DirectoryExportedClassesLoader.js.map
}}),
"[project]/node_modules/typeorm/connection/options-reader/ConnectionOptionsEnvReader.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionOptionsEnvReader = void 0;
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
/**
 * Reads connection options from environment variables.
 * Environment variables can have only a single connection.
 * Its strongly required to define TYPEORM_CONNECTION env variable.
 *
 * @deprecated
 */ class ConnectionOptionsEnvReader {
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Reads connection options from environment variables.
     */ async read() {
        return [
            {
                type: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CONNECTION") || (PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_URL") ? PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_URL").split("://")[0] : undefined),
                url: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_URL"),
                host: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_HOST"),
                port: this.stringToNumber(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_PORT")),
                username: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_USERNAME"),
                password: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_PASSWORD"),
                database: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_DATABASE"),
                sid: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_SID"),
                schema: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_SCHEMA"),
                extra: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_DRIVER_EXTRA") ? JSON.parse(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_DRIVER_EXTRA")) : undefined,
                synchronize: OrmUtils_1.OrmUtils.toBoolean(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_SYNCHRONIZE")),
                dropSchema: OrmUtils_1.OrmUtils.toBoolean(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_DROP_SCHEMA")),
                migrationsRun: OrmUtils_1.OrmUtils.toBoolean(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_MIGRATIONS_RUN")),
                entities: this.stringToArray(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_ENTITIES")),
                migrations: this.stringToArray(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_MIGRATIONS")),
                migrationsTableName: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_MIGRATIONS_TABLE_NAME"),
                metadataTableName: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_METADATA_TABLE_NAME"),
                subscribers: this.stringToArray(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_SUBSCRIBERS")),
                logging: this.transformLogging(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_LOGGING")),
                logger: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_LOGGER"),
                entityPrefix: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_ENTITY_PREFIX"),
                maxQueryExecutionTime: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_MAX_QUERY_EXECUTION_TIME"),
                debug: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_DEBUG"),
                cache: this.transformCaching(),
                uuidExtension: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_UUID_EXTENSION")
            }
        ];
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Transforms logging string into real logging value connection requires.
     */ transformLogging(logging) {
        if (logging === "true" || logging === "TRUE" || logging === "1") return true;
        if (logging === "all") return "all";
        return this.stringToArray(logging);
    }
    /**
     * Transforms caching option into real caching value option requires.
     */ transformCaching() {
        const caching = PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CACHE");
        if (caching === "true" || caching === "TRUE" || caching === "1") return true;
        if (caching === "false" || caching === "FALSE" || caching === "0") return false;
        if (caching === "redis" || caching === "ioredis" || caching === "database") return {
            type: caching,
            options: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CACHE_OPTIONS") ? JSON.parse(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CACHE_OPTIONS")) : undefined,
            alwaysEnabled: PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CACHE_ALWAYS_ENABLED"),
            duration: parseInt(PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CACHE_DURATION"))
        };
        return undefined;
    }
    /**
     * Converts a string which contains multiple elements split by comma into a string array of strings.
     */ stringToArray(variable) {
        if (!variable) return [];
        return variable.split(",").map((str)=>str.trim());
    }
    /**
     * Converts a string which contains a number into a javascript number
     */ stringToNumber(value) {
        if (!value) {
            return undefined;
        }
        return parseInt(value);
    }
}
exports.ConnectionOptionsEnvReader = ConnectionOptionsEnvReader; //# sourceMappingURL=ConnectionOptionsEnvReader.js.map
}}),
"[project]/node_modules/typeorm/connection/ConnectionOptionsReader.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionOptionsReader = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const app_root_path_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/app-root-path/index.js [app-route] (ecmascript)"));
const path_1 = tslib_1.__importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const ImportUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ImportUtils.js [app-route] (ecmascript)");
const PathUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/PathUtils.js [app-route] (ecmascript)");
const ConnectionOptionsEnvReader_1 = __turbopack_context__.r("[project]/node_modules/typeorm/connection/options-reader/ConnectionOptionsEnvReader.js [app-route] (ecmascript)");
/**
 * Reads connection options from the ormconfig.
 */ class ConnectionOptionsReader {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options){
        this.options = options;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Returns all connection options read from the ormconfig.
     */ async all() {
        const options = await this.load();
        if (!options) throw new error_1.TypeORMError(`No connection options were found in any orm configuration files.`);
        return options;
    }
    /**
     * Gets a connection with a given name read from ormconfig.
     * If connection with such name would not be found then it throw error.
     */ async get(name) {
        const allOptions = await this.all();
        const targetOptions = allOptions.find((options)=>options.name === name || name === "default" && !options.name);
        if (!targetOptions) throw new error_1.TypeORMError(`Cannot find connection ${name} because its not defined in any orm configuration files.`);
        return targetOptions;
    }
    /**
     * Checks if there is a TypeORM configuration file.
     */ async has(name) {
        const allOptions = await this.load();
        if (!allOptions) return false;
        const targetOptions = allOptions.find((options)=>options.name === name || name === "default" && !options.name);
        return !!targetOptions;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Loads all connection options from a configuration file.
     *
     * todo: get in count NODE_ENV somehow
     */ async load() {
        let connectionOptions = undefined;
        const fileFormats = [
            "env",
            "js",
            "mjs",
            "cjs",
            "ts",
            "mts",
            "cts",
            "json"
        ];
        // Detect if baseFilePath contains file extension
        const possibleExtension = this.baseFilePath.substr(this.baseFilePath.lastIndexOf("."));
        const fileExtension = fileFormats.find((extension)=>`.${extension}` === possibleExtension);
        // try to find any of following configuration formats
        const foundFileFormat = fileExtension || fileFormats.find((format)=>{
            return PlatformTools_1.PlatformTools.fileExist(this.baseFilePath + "." + format);
        });
        // Determine config file name
        const configFile = fileExtension ? this.baseFilePath : this.baseFilePath + "." + foundFileFormat;
        // if .env file found then load all its variables into process.env using dotenv package
        if (foundFileFormat === "env") {
            PlatformTools_1.PlatformTools.dotenv(configFile);
        } else if (PlatformTools_1.PlatformTools.fileExist(this.baseDirectory + "/.env")) {
            PlatformTools_1.PlatformTools.dotenv(this.baseDirectory + "/.env");
        }
        // try to find connection options from any of available sources of configuration
        if (PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_CONNECTION") || PlatformTools_1.PlatformTools.getEnvVariable("TYPEORM_URL")) {
            connectionOptions = await new ConnectionOptionsEnvReader_1.ConnectionOptionsEnvReader().read();
        } else if (foundFileFormat === "js" || foundFileFormat === "mjs" || foundFileFormat === "cjs" || foundFileFormat === "ts" || foundFileFormat === "mts" || foundFileFormat === "cts") {
            const [importOrRequireResult, moduleSystem] = await (0, ImportUtils_1.importOrRequireFile)(configFile);
            const configModule = await importOrRequireResult;
            if (moduleSystem === "esm" || configModule && "__esModule" in configModule && "default" in configModule) {
                connectionOptions = configModule.default;
            } else {
                connectionOptions = configModule;
            }
        } else if (foundFileFormat === "json") {
            connectionOptions = (()=>{
                const e = new Error("Cannot find module as expression is too dynamic");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        }
        // normalize and return connection options
        if (connectionOptions) {
            return this.normalizeConnectionOptions(connectionOptions);
        }
        return undefined;
    }
    /**
     * Normalize connection options.
     */ normalizeConnectionOptions(connectionOptions) {
        if (!Array.isArray(connectionOptions)) connectionOptions = [
            connectionOptions
        ];
        connectionOptions.forEach((options)=>{
            options.baseDirectory = this.baseDirectory;
            if (options.entities) {
                const entities = options.entities.map((entity)=>{
                    if (typeof entity === "string" && entity.substr(0, 1) !== "/") return this.baseDirectory + "/" + entity;
                    return entity;
                });
                Object.assign(connectionOptions, {
                    entities: entities
                });
            }
            if (options.subscribers) {
                const subscribers = options.subscribers.map((subscriber)=>{
                    if (typeof subscriber === "string" && subscriber.substr(0, 1) !== "/") return this.baseDirectory + "/" + subscriber;
                    return subscriber;
                });
                Object.assign(connectionOptions, {
                    subscribers: subscribers
                });
            }
            if (options.migrations) {
                const migrations = options.migrations.map((migration)=>{
                    if (typeof migration === "string" && migration.substr(0, 1) !== "/") return this.baseDirectory + "/" + migration;
                    return migration;
                });
                Object.assign(connectionOptions, {
                    migrations: migrations
                });
            }
            // make database path file in sqlite relative to package.json
            if (options.type === "sqlite" || options.type === "better-sqlite3") {
                if (typeof options.database === "string" && !(0, PathUtils_1.isAbsolute)(options.database) && options.database.substr(0, 1) !== "/" && // unix absolute
                options.database.substr(1, 2) !== ":\\" && // windows absolute
                options.database !== ":memory:") {
                    Object.assign(options, {
                        database: this.baseDirectory + "/" + options.database
                    });
                }
            }
        });
        return connectionOptions;
    }
    /**
     * Gets directory where configuration file should be located and configuration file name.
     */ get baseFilePath() {
        return path_1.default.resolve(this.baseDirectory, this.baseConfigName);
    }
    /**
     * Gets directory where configuration file should be located.
     */ get baseDirectory() {
        return this.options?.root ?? app_root_path_1.default.path;
    }
    /**
     * Gets configuration file name.
     */ get baseConfigName() {
        return this.options?.configName ?? "ormconfig";
    }
}
exports.ConnectionOptionsReader = ConnectionOptionsReader; //# sourceMappingURL=ConnectionOptionsReader.js.map
}}),
"[project]/node_modules/typeorm/connection/ConnectionMetadataBuilder.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionMetadataBuilder = void 0;
const DirectoryExportedClassesLoader_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/DirectoryExportedClassesLoader.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const container_1 = __turbopack_context__.r("[project]/node_modules/typeorm/container.js [app-route] (ecmascript)");
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const EntityMetadataBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata-builder/EntityMetadataBuilder.js [app-route] (ecmascript)");
const EntitySchemaTransformer_1 = __turbopack_context__.r("[project]/node_modules/typeorm/entity-schema/EntitySchemaTransformer.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Builds migration instances, subscriber instances and entity metadatas for the given classes.
 */ class ConnectionMetadataBuilder {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        this.connection = connection;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Builds migration instances for the given classes or directories.
     */ async buildMigrations(migrations) {
        const [migrationClasses, migrationDirectories] = OrmUtils_1.OrmUtils.splitClassesAndStrings(migrations);
        const allMigrationClasses = [
            ...migrationClasses,
            ...await (0, DirectoryExportedClassesLoader_1.importClassesFromDirectories)(this.connection.logger, migrationDirectories)
        ];
        return allMigrationClasses.map((migrationClass)=>(0, container_1.getFromContainer)(migrationClass));
    }
    /**
     * Builds subscriber instances for the given classes or directories.
     */ async buildSubscribers(subscribers) {
        const [subscriberClasses, subscriberDirectories] = OrmUtils_1.OrmUtils.splitClassesAndStrings(subscribers || []);
        const allSubscriberClasses = [
            ...subscriberClasses,
            ...await (0, DirectoryExportedClassesLoader_1.importClassesFromDirectories)(this.connection.logger, subscriberDirectories)
        ];
        return (0, globals_1.getMetadataArgsStorage)().filterSubscribers(allSubscriberClasses).map((metadata)=>(0, container_1.getFromContainer)(metadata.target));
    }
    /**
     * Builds entity metadatas for the given classes or directories.
     */ async buildEntityMetadatas(entities) {
        // todo: instead we need to merge multiple metadata args storages
        const [entityClassesOrSchemas, entityDirectories] = OrmUtils_1.OrmUtils.splitClassesAndStrings(entities || []);
        const entityClasses = entityClassesOrSchemas.filter((entityClass)=>!InstanceChecker_1.InstanceChecker.isEntitySchema(entityClass));
        const entitySchemas = entityClassesOrSchemas.filter((entityClass)=>InstanceChecker_1.InstanceChecker.isEntitySchema(entityClass));
        const allEntityClasses = [
            ...entityClasses,
            ...await (0, DirectoryExportedClassesLoader_1.importClassesFromDirectories)(this.connection.logger, entityDirectories)
        ];
        allEntityClasses.forEach((entityClass)=>{
            // if we have entity schemas loaded from directories
            if (InstanceChecker_1.InstanceChecker.isEntitySchema(entityClass)) {
                entitySchemas.push(entityClass);
            }
        });
        const decoratorEntityMetadatas = new EntityMetadataBuilder_1.EntityMetadataBuilder(this.connection, (0, globals_1.getMetadataArgsStorage)()).build(allEntityClasses);
        const metadataArgsStorageFromSchema = new EntitySchemaTransformer_1.EntitySchemaTransformer().transform(entitySchemas);
        const schemaEntityMetadatas = new EntityMetadataBuilder_1.EntityMetadataBuilder(this.connection, metadataArgsStorageFromSchema).build();
        return [
            ...decoratorEntityMetadatas,
            ...schemaEntityMetadatas
        ];
    }
}
exports.ConnectionMetadataBuilder = ConnectionMetadataBuilder; //# sourceMappingURL=ConnectionMetadataBuilder.js.map
}}),
"[project]/node_modules/typeorm/connection/ConnectionManager.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionManager = void 0;
const DataSource_1 = __turbopack_context__.r("[project]/node_modules/typeorm/data-source/DataSource.js [app-route] (ecmascript)");
const ConnectionNotFoundError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/ConnectionNotFoundError.js [app-route] (ecmascript)");
const AlreadyHasActiveConnectionError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/AlreadyHasActiveConnectionError.js [app-route] (ecmascript)");
/**
 * ConnectionManager is used to store and manage multiple orm connections.
 * It also provides useful factory methods to simplify connection creation.
 *
 * @deprecated
 */ class ConnectionManager {
    constructor(){
        /**
         * Internal lookup to quickly get from a connection name to the Connection object.
         */ this.connectionMap = new Map();
    }
    /**
     * List of connections registered in this connection manager.
     */ get connections() {
        return Array.from(this.connectionMap.values());
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Checks if connection with the given name exist in the manager.
     */ has(name) {
        return this.connectionMap.has(name);
    }
    /**
     * Gets registered connection with the given name.
     * If connection name is not given then it will get a default connection.
     * Throws error if connection with the given name was not found.
     */ get(name = "default") {
        const connection = this.connectionMap.get(name);
        if (!connection) throw new ConnectionNotFoundError_1.ConnectionNotFoundError(name);
        return connection;
    }
    /**
     * Creates a new connection based on the given connection options and registers it in the manager.
     * Connection won't be established, you'll need to manually call connect method to establish connection.
     */ create(options) {
        // check if such connection is already registered
        const existConnection = this.connectionMap.get(options.name || "default");
        if (existConnection) {
            // if connection is registered and its not closed then throw an error
            if (existConnection.isInitialized) throw new AlreadyHasActiveConnectionError_1.AlreadyHasActiveConnectionError(options.name || "default");
        }
        // create a new connection
        const connection = new DataSource_1.DataSource(options);
        this.connectionMap.set(connection.name, connection);
        return connection;
    }
}
exports.ConnectionManager = ConnectionManager; //# sourceMappingURL=ConnectionManager.js.map
}}),
"[project]/node_modules/typeorm/connection/Connection.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Connection = void 0;
const DataSource_1 = __turbopack_context__.r("[project]/node_modules/typeorm/data-source/DataSource.js [app-route] (ecmascript)");
/**
 * Connection is a single database ORM connection to a specific database.
 * Its not required to be a database connection, depend on database type it can create connection pool.
 * You can have multiple connections to multiple databases in your application.
 *
 * @deprecated
 */ class Connection extends DataSource_1.DataSource {
}
exports.Connection = Connection; //# sourceMappingURL=Connection.js.map
}}),
"[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FindOperator = void 0;
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
const ApplyValueTransformers_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)");
/**
 * Find Operator used in Find Conditions.
 */ class FindOperator {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(type, value, useParameter = true, multipleParameters = false, getSql, objectLiteralParameters){
        this["@instanceof"] = Symbol.for("FindOperator");
        this._type = type;
        this._value = value;
        this._useParameter = useParameter;
        this._multipleParameters = multipleParameters;
        this._getSql = getSql;
        this._objectLiteralParameters = objectLiteralParameters;
    }
    // -------------------------------------------------------------------------
    // Accessors
    // -------------------------------------------------------------------------
    /**
     * Indicates if parameter is used or not for this operator.
     * Extracts final value if value is another find operator.
     */ get useParameter() {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(this._value)) return this._value.useParameter;
        return this._useParameter;
    }
    /**
     * Indicates if multiple parameters must be used for this operator.
     * Extracts final value if value is another find operator.
     */ get multipleParameters() {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(this._value)) return this._value.multipleParameters;
        return this._multipleParameters;
    }
    /**
     * Gets the Type of this FindOperator
     */ get type() {
        return this._type;
    }
    /**
     * Gets the final value needs to be used as parameter value.
     */ get value() {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(this._value)) return this._value.value;
        return this._value;
    }
    /**
     * Gets ObjectLiteral parameters.
     */ get objectLiteralParameters() {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(this._value)) return this._value.objectLiteralParameters;
        return this._objectLiteralParameters;
    }
    /**
     * Gets the child FindOperator if it exists
     */ get child() {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(this._value)) return this._value;
        return undefined;
    }
    /**
     * Gets the SQL generator
     */ get getSql() {
        if (InstanceChecker_1.InstanceChecker.isFindOperator(this._value)) return this._value.getSql;
        return this._getSql;
    }
    transformValue(transformer) {
        if (this._value instanceof FindOperator) {
            this._value.transformValue(transformer);
        } else {
            this._value = Array.isArray(this._value) && this._multipleParameters ? this._value.map((v)=>transformer && ApplyValueTransformers_1.ApplyValueTransformers.transformTo(transformer, v)) : ApplyValueTransformers_1.ApplyValueTransformers.transformTo(transformer, this._value);
        }
    }
}
exports.FindOperator = FindOperator; //# sourceMappingURL=FindOperator.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/In.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.In = In;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * Find Options Operator.
 * Example: { someField: In([...]) }
 */ function In(value) {
    return new FindOperator_1.FindOperator("in", value, true, true);
} //# sourceMappingURL=In.js.map
}}),
"[project]/node_modules/typeorm/find-options/FindOptionsUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FindOptionsUtils = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const error_2 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Utilities to work with FindOptions.
 */ class FindOptionsUtils {
    // -------------------------------------------------------------------------
    // Public Static Methods
    // -------------------------------------------------------------------------
    /**
     * Checks if given object is really instance of FindOneOptions interface.
     */ static isFindOneOptions(obj) {
        const possibleOptions = obj;
        return possibleOptions && (Array.isArray(possibleOptions.select) || Array.isArray(possibleOptions.relations) || typeof possibleOptions.select === "object" || typeof possibleOptions.relations === "object" || typeof possibleOptions.where === "object" || // typeof possibleOptions.where === "string" ||
        typeof possibleOptions.join === "object" || typeof possibleOptions.order === "object" || typeof possibleOptions.cache === "object" || typeof possibleOptions.cache === "boolean" || typeof possibleOptions.cache === "number" || typeof possibleOptions.comment === "string" || typeof possibleOptions.lock === "object" || typeof possibleOptions.loadRelationIds === "object" || typeof possibleOptions.loadRelationIds === "boolean" || typeof possibleOptions.loadEagerRelations === "boolean" || typeof possibleOptions.withDeleted === "boolean" || typeof possibleOptions.relationLoadStrategy === "string" || typeof possibleOptions.transaction === "boolean");
    }
    /**
     * Checks if given object is really instance of FindManyOptions interface.
     */ static isFindManyOptions(obj) {
        const possibleOptions = obj;
        return possibleOptions && (this.isFindOneOptions(possibleOptions) || typeof possibleOptions.skip === "number" || typeof possibleOptions.take === "number" || typeof possibleOptions.skip === "string" || typeof possibleOptions.take === "string");
    }
    /**
     * Checks if given object is really instance of FindOptions interface.
     */ static extractFindManyOptionsAlias(object) {
        if (this.isFindManyOptions(object) && object.join) return object.join.alias;
        return undefined;
    }
    /**
     * Applies give find many options to the given query builder.

    static applyFindManyOptionsOrConditionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindManyOptions<T>|Partial<T>|undefined): SelectQueryBuilder<T> {
        if (this.isFindManyOptions(options))
            return this.applyOptionsToQueryBuilder(qb, options);

        if (options)
            return qb.where(options);

        return qb;
    }*/ /**
     * Applies give find options to the given query builder.

    static applyOptionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindOneOptions<T>|FindManyOptions<T>|undefined): SelectQueryBuilder<T> {

        // if options are not set then simply return query builder. This is made for simplicity of usage.
        if (!options || (!this.isFindOneOptions(options) && !this.isFindManyOptions(options)))
            return qb;

        if (options.transaction === true) {
            qb.expressionMap.useTransaction = true;
        }

        if (!qb.expressionMap.mainAlias || !qb.expressionMap.mainAlias.hasMetadata)
            return qb;

        const metadata = qb.expressionMap.mainAlias!.metadata;

        // apply all options from FindOptions
        if (options.comment) {
            qb.comment(options.comment);
        }

        if (options.withDeleted) {
            qb.withDeleted();
        }

        if (options.select) {
            qb.select([]);
            options.select.forEach(select => {
                if (!metadata.hasColumnWithPropertyPath(`${select}`))
                    throw new TypeORMError(`${select} column was not found in the ${metadata.name} entity.`);

                const columns = metadata.findColumnsWithPropertyPath(`${select}`);

                for (const column of columns) {
                    qb.addSelect(qb.alias + "." + column.propertyPath);
                }
            });
        }

        if (options.relations) {
            // Copy because `applyRelationsRecursively` modifies it
            const allRelations = [...options.relations];
            this.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias!.name, qb.expressionMap.mainAlias!.metadata, "");
            // recursive removes found relations from allRelations array
            // if there are relations left in this array it means those relations were not found in the entity structure
            // so, we give an exception about not found relations
            if (allRelations.length > 0)
                throw new FindRelationsNotFoundError(allRelations);
        }

        if (options.join) {
            if (options.join.leftJoin)
                Object.keys(options.join.leftJoin).forEach(key => {
                    qb.leftJoin(options.join!.leftJoin![key], key);
                });

            if (options.join.innerJoin)
                Object.keys(options.join.innerJoin).forEach(key => {
                    qb.innerJoin(options.join!.innerJoin![key], key);
                });

            if (options.join.leftJoinAndSelect)
                Object.keys(options.join.leftJoinAndSelect).forEach(key => {
                    qb.leftJoinAndSelect(options.join!.leftJoinAndSelect![key], key);
                });

            if (options.join.innerJoinAndSelect)
                Object.keys(options.join.innerJoinAndSelect).forEach(key => {
                    qb.innerJoinAndSelect(options.join!.innerJoinAndSelect![key], key);
                });
        }

        if (options.cache) {
            if (options.cache instanceof Object) {
                const cache = options.cache as { id: any, milliseconds: number };
                qb.cache(cache.id, cache.milliseconds);
            } else {
                qb.cache(options.cache);
            }
        }

        if (options.lock) {
            if (options.lock.mode === "optimistic") {
                qb.setLock(options.lock.mode, options.lock.version);
            } else if (
                options.lock.mode === "pessimistic_read" ||
                options.lock.mode === "pessimistic_write" ||
                options.lock.mode === "dirty_read" ||
                options.lock.mode === "pessimistic_partial_write" ||
                options.lock.mode === "pessimistic_write_or_fail" ||
                options.lock.mode === "for_no_key_update" ||
                options.lock.mode === "for_key_share"
            ) {
                const tableNames = options.lock.tables ? options.lock.tables.map((table) => {
                    const tableAlias = qb.expressionMap.aliases.find((alias) => {
                        return alias.metadata.tableNameWithoutPrefix === table;
                    });
                    if (!tableAlias) {
                        throw new TypeORMError(`"${table}" is not part of this query`);
                    }
                    return qb.escape(tableAlias.name);
                }) : undefined;
                qb.setLock(options.lock.mode, undefined, tableNames);
            }
        }

        if (options.loadRelationIds === true) {
            qb.loadAllRelationIds();

        } else if (options.loadRelationIds instanceof Object) {
            qb.loadAllRelationIds(options.loadRelationIds as any);
        }

        if (options.where)
            qb.where(options.where);

        if ((options as FindManyOptions<T>).skip)
            qb.skip((options as FindManyOptions<T>).skip!);

        if ((options as FindManyOptions<T>).take)
            qb.take((options as FindManyOptions<T>).take!);

        if (options.order)
            Object.keys(options.order).forEach(key => {
                const order = ((options as FindOneOptions<T>).order as any)[key as any];

                if (!metadata.findColumnWithPropertyPath(key))
                    throw new Error(`${key} column was not found in the ${metadata.name} entity.`);

                switch (order) {
                    case 1:
                        qb.addOrderBy(qb.alias + "." + key, "ASC");
                        break;
                    case -1:
                        qb.addOrderBy(qb.alias + "." + key, "DESC");
                        break;
                    case "ASC":
                        qb.addOrderBy(qb.alias + "." + key, "ASC");
                        break;
                    case "DESC":
                        qb.addOrderBy(qb.alias + "." + key, "DESC");
                        break;
                }
            });

        return qb;
    }*/ static applyOptionsToTreeQueryBuilder(qb, options) {
        if (options?.relations) {
            // Copy because `applyRelationsRecursively` modifies it
            const allRelations = [
                ...options.relations
            ];
            FindOptionsUtils.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias.name, qb.expressionMap.mainAlias.metadata, "");
            // recursive removes found relations from allRelations array
            // if there are relations left in this array it means those relations were not found in the entity structure
            // so, we give an exception about not found relations
            if (allRelations.length > 0) throw new error_1.FindRelationsNotFoundError(allRelations);
        }
        return qb;
    }
    // -------------------------------------------------------------------------
    // Protected Static Methods
    // -------------------------------------------------------------------------
    /**
     * Adds joins for all relations and sub-relations of the given relations provided in the find options.
     */ static applyRelationsRecursively(qb, allRelations, alias, metadata, prefix) {
        // find all relations that match given prefix
        let matchedBaseRelations = [];
        if (prefix) {
            const regexp = new RegExp("^" + prefix.replace(".", "\\.") + "\\.");
            matchedBaseRelations = allRelations.filter((relation)=>relation.match(regexp)).map((relation)=>metadata.findRelationWithPropertyPath(relation.replace(regexp, ""))).filter((entity)=>entity);
        } else {
            matchedBaseRelations = allRelations.map((relation)=>metadata.findRelationWithPropertyPath(relation)).filter((entity)=>entity);
        }
        // go through all matched relations and add join for them
        matchedBaseRelations.forEach((relation)=>{
            // generate a relation alias
            const relationAlias = DriverUtils_1.DriverUtils.buildAlias(qb.connection.driver, {
                joiner: "__"
            }, alias, relation.propertyPath);
            // add a join for the found relation
            const selection = alias + "." + relation.propertyPath;
            if (qb.expressionMap.relationLoadStrategy === "query") {
                qb.concatRelationMetadata(relation);
            } else {
                qb.leftJoinAndSelect(selection, relationAlias);
            }
            // remove added relations from the allRelations array, this is needed to find all not found relations at the end
            allRelations.splice(allRelations.indexOf(prefix ? prefix + "." + relation.propertyPath : relation.propertyPath), 1);
            // try to find sub-relations
            let relationMetadata;
            let relationName;
            if (qb.expressionMap.relationLoadStrategy === "query") {
                relationMetadata = relation.inverseEntityMetadata;
                relationName = relationAlias;
            } else {
                const join = qb.expressionMap.joinAttributes.find((join)=>join.entityOrProperty === selection);
                relationMetadata = join.metadata;
                relationName = join.alias.name;
            }
            if (!relationName || !relationMetadata) {
                throw new error_2.EntityPropertyNotFoundError(relation.propertyPath, metadata);
            }
            this.applyRelationsRecursively(qb, allRelations, relationName, relationMetadata, prefix ? prefix + "." + relation.propertyPath : relation.propertyPath);
            // join the eager relations of the found relation
            // Only supported for "join" relationLoadStrategy
            if (qb.expressionMap.relationLoadStrategy === "join") {
                const relMetadata = metadata.relations.find((metadata)=>metadata.propertyName === relation.propertyPath);
                if (relMetadata) {
                    this.joinEagerRelations(qb, relationAlias, relMetadata.inverseEntityMetadata);
                }
            }
        });
    }
    static joinEagerRelations(qb, alias, metadata) {
        metadata.eagerRelations.forEach((relation)=>{
            // generate a relation alias
            let relationAlias = DriverUtils_1.DriverUtils.buildAlias(qb.connection.driver, {
                joiner: "__"
            }, alias, relation.propertyName);
            // add a join for the relation
            // Checking whether the relation wasn't joined yet.
            let addJoin = true;
            // TODO: Review this validation
            for (const join of qb.expressionMap.joinAttributes){
                if (join.condition !== undefined || join.mapToProperty !== undefined || join.isMappingMany !== undefined || join.direction !== "LEFT" || join.entityOrProperty !== `${alias}.${relation.propertyPath}`) {
                    continue;
                }
                addJoin = false;
                relationAlias = join.alias.name;
                break;
            }
            const joinAlreadyAdded = Boolean(qb.expressionMap.joinAttributes.find((joinAttribute)=>joinAttribute.alias.name === relationAlias));
            if (addJoin && !joinAlreadyAdded) {
                qb.leftJoin(alias + "." + relation.propertyPath, relationAlias);
            }
            // Checking whether the relation wasn't selected yet.
            // This check shall be after the join check to detect relationAlias.
            let addSelect = true;
            for (const select of qb.expressionMap.selects){
                if (select.aliasName !== undefined || select.virtual !== undefined || select.selection !== relationAlias) {
                    continue;
                }
                addSelect = false;
                break;
            }
            if (addSelect) {
                qb.addSelect(relationAlias);
            }
            // (recursive) join the eager relations
            this.joinEagerRelations(qb, relationAlias, relation.inverseEntityMetadata);
        });
    }
}
exports.FindOptionsUtils = FindOptionsUtils; //# sourceMappingURL=FindOptionsUtils.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/And.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.And = And;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
function And(...values) {
    return new FindOperator_1.FindOperator("and", values, true, true);
} //# sourceMappingURL=And.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/Or.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Or = Or;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
function Or(...values) {
    return new FindOperator_1.FindOperator("or", values, true, true);
} //# sourceMappingURL=Or.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/Any.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Any = Any;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * Find Options Operator.
 * Example: { someField: Any([...]) }
 */ function Any(value) {
    return new FindOperator_1.FindOperator("any", value);
} //# sourceMappingURL=Any.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/ArrayContainedBy.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ArrayContainedBy = ArrayContainedBy;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * FindOptions Operator.
 * Example: { someField: ArrayContainedBy([...]) }
 */ function ArrayContainedBy(value) {
    return new FindOperator_1.FindOperator("arrayContainedBy", value);
} //# sourceMappingURL=ArrayContainedBy.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/ArrayContains.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ArrayContains = ArrayContains;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * FindOptions Operator.
 * Example: { someField: ArrayContains([...]) }
 */ function ArrayContains(value) {
    return new FindOperator_1.FindOperator("arrayContains", value);
} //# sourceMappingURL=ArrayContains.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/ArrayOverlap.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ArrayOverlap = ArrayOverlap;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * FindOptions Operator.
 * Example: { someField: ArrayOverlap([...]) }
 */ function ArrayOverlap(value) {
    return new FindOperator_1.FindOperator("arrayOverlap", value);
} //# sourceMappingURL=ArrayOverlap.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/Between.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Between = Between;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * Find Options Operator.
 * Example: { someField: Between(x, y) }
 */ function Between(from, to) {
    return new FindOperator_1.FindOperator("between", [
        from,
        to
    ], true, true);
} //# sourceMappingURL=Between.js.map
}}),
"[project]/node_modules/typeorm/find-options/EqualOperator.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EqualOperator = void 0;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
class EqualOperator extends FindOperator_1.FindOperator {
    constructor(value){
        super("equal", value);
        this["@instanceof"] = Symbol.for("EqualOperator");
    }
}
exports.EqualOperator = EqualOperator; //# sourceMappingURL=EqualOperator.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/Equal.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Equal = Equal;
const EqualOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/EqualOperator.js [app-route] (ecmascript)");
/**
 * Find Options Operator.
 * This operator is handy to provide object value for non-relational properties of the Entity.
 *
 * Examples:
 *      { someField: Equal("value") }
 *      { uuid: Equal(new UUID()) }
 */ function Equal(value) {
    return new EqualOperator_1.EqualOperator(value);
} //# sourceMappingURL=Equal.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/IsNull.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IsNull = IsNull;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * Find Options Operator.
 * Example: { someField: IsNull() }
 */ function IsNull() {
    return new FindOperator_1.FindOperator("isNull", undefined, false);
} //# sourceMappingURL=IsNull.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/LessThan.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LessThan = LessThan;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * Find Options Operator.
 * Example: { someField: LessThan(10) }
 */ function LessThan(value) {
    return new FindOperator_1.FindOperator("lessThan", value);
} //# sourceMappingURL=LessThan.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/LessThanOrEqual.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LessThanOrEqual = LessThanOrEqual;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * Find Options Operator.
 * Example: { someField: LessThanOrEqual(10) }
 */ function LessThanOrEqual(value) {
    return new FindOperator_1.FindOperator("lessThanOrEqual", value);
} //# sourceMappingURL=LessThanOrEqual.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/ILike.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ILike = ILike;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * Find Options Operator.
 * Example: { someField: ILike("%SOME string%") }
 */ function ILike(value) {
    return new FindOperator_1.FindOperator("ilike", value);
} //# sourceMappingURL=ILike.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/Like.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Like = Like;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * Find Options Operator.
 * Example: { someField: Like("%some string%") }
 */ function Like(value) {
    return new FindOperator_1.FindOperator("like", value);
} //# sourceMappingURL=Like.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/MoreThan.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MoreThan = MoreThan;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * Find Options Operator.
 * Example: { someField: MoreThan(10) }
 */ function MoreThan(value) {
    return new FindOperator_1.FindOperator("moreThan", value);
} //# sourceMappingURL=MoreThan.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/MoreThanOrEqual.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MoreThanOrEqual = MoreThanOrEqual;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * Find Options Operator.
 * Example: { someField: MoreThanOrEqual(10) }
 */ function MoreThanOrEqual(value) {
    return new FindOperator_1.FindOperator("moreThanOrEqual", value);
} //# sourceMappingURL=MoreThanOrEqual.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/Not.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Not = Not;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * Find Options Operator.
 * Used to negate expression.
 * Example: { title: not("hello") } will return entities where title not equal to "hello".
 */ function Not(value) {
    return new FindOperator_1.FindOperator("not", value);
} //# sourceMappingURL=Not.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/Raw.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Raw = Raw;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
function Raw(valueOrSqlGenerator, sqlGeneratorParameters) {
    if (typeof valueOrSqlGenerator !== "function") {
        return new FindOperator_1.FindOperator("raw", valueOrSqlGenerator, false);
    }
    return new FindOperator_1.FindOperator("raw", [], true, true, valueOrSqlGenerator, sqlGeneratorParameters);
} //# sourceMappingURL=Raw.js.map
}}),
"[project]/node_modules/typeorm/find-options/operator/JsonContains.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JsonContains = JsonContains;
const FindOperator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)");
/**
 * FindOptions Operator.
 * Example: { someField: JsonContains({...}) }
 */ function JsonContains(value) {
    return new FindOperator_1.FindOperator("jsonContains", value);
} //# sourceMappingURL=JsonContains.js.map
}}),
"[project]/node_modules/typeorm/find-options/FindManyOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=FindManyOptions.js.map
}}),
"[project]/node_modules/typeorm/find-options/FindOneOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=FindOneOptions.js.map
}}),
"[project]/node_modules/typeorm/find-options/FindOperatorType.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=FindOperatorType.js.map
}}),
"[project]/node_modules/typeorm/find-options/FindOptionsOrder.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=FindOptionsOrder.js.map
}}),
"[project]/node_modules/typeorm/find-options/FindOptionsRelations.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=FindOptionsRelations.js.map
}}),
"[project]/node_modules/typeorm/find-options/FindOptionsSelect.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=FindOptionsSelect.js.map
}}),
"[project]/node_modules/typeorm/find-options/FindOptionsWhere.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=FindOptionsWhere.js.map
}}),
"[project]/node_modules/typeorm/find-options/FindTreeOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=FindTreeOptions.js.map
}}),
"[project]/node_modules/typeorm/find-options/JoinOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=JoinOptions.js.map
}}),
"[project]/node_modules/typeorm/find-options/OrderByCondition.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=OrderByCondition.js.map
}}),
"[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BroadcasterResult = void 0;
/**
 * Broadcaster execution result - promises executed by operations and number of executed listeners and subscribers.
 */ class BroadcasterResult {
    constructor(){
        /**
         * Number of executed listeners and subscribers.
         */ this.count = 0;
        /**
         * Promises returned by listeners and subscribers which needs to be awaited.
         */ this.promises = [];
    }
    /**
     * Wait for all promises to settle
     */ async wait() {
        if (this.promises.length > 0) {
            await Promise.all(this.promises);
        }
        return this;
    }
}
exports.BroadcasterResult = BroadcasterResult; //# sourceMappingURL=BroadcasterResult.js.map
}}),
"[project]/node_modules/typeorm/subscriber/Broadcaster.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Broadcaster = void 0;
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const BroadcasterResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/subscriber/BroadcasterResult.js [app-route] (ecmascript)");
/**
 * Broadcaster provides a helper methods to broadcast events to the subscribers.
 */ class Broadcaster {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(queryRunner){
        this.queryRunner = queryRunner;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    async broadcast(event, ...args) {
        const result = new BroadcasterResult_1.BroadcasterResult();
        const broadcastFunction = this[`broadcast${event}Event`];
        if (typeof broadcastFunction === "function") {
            ;
            broadcastFunction.call(this, result, ...args);
        }
        await result.wait();
    }
    /**
     * Broadcasts "BEFORE_INSERT" event.
     * Before insert event is executed before entity is being inserted to the database for the first time.
     * All subscribers and entity listeners who listened to this event will be executed at this point.
     * Subscribers and entity listeners can return promises, it will wait until they are resolved.
     *
     * Note: this method has a performance-optimized code organization, do not change code structure.
     */ broadcastBeforeInsertEvent(result, metadata, entity) {
        if (entity && metadata.beforeInsertListeners.length) {
            metadata.beforeInsertListeners.forEach((listener)=>{
                if (listener.isAllowed(entity)) {
                    const executionResult = listener.execute(entity);
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeInsert) {
                    const executionResult = subscriber.beforeInsert({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager,
                        entity: entity,
                        metadata: metadata
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "BEFORE_UPDATE" event.
     * Before update event is executed before entity is being updated in the database.
     * All subscribers and entity listeners who listened to this event will be executed at this point.
     * Subscribers and entity listeners can return promises, it will wait until they are resolved.
     *
     * Note: this method has a performance-optimized code organization, do not change code structure.
     */ broadcastBeforeUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {
        // todo: send relations too?
        if (entity && metadata.beforeUpdateListeners.length) {
            metadata.beforeUpdateListeners.forEach((listener)=>{
                if (listener.isAllowed(entity)) {
                    const executionResult = listener.execute(entity);
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeUpdate) {
                    const executionResult = subscriber.beforeUpdate({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager,
                        entity: entity,
                        metadata: metadata,
                        databaseEntity: databaseEntity,
                        updatedColumns: updatedColumns || [],
                        updatedRelations: updatedRelations || []
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "BEFORE_REMOVE" event.
     * Before remove event is executed before entity is being removed from the database.
     * All subscribers and entity listeners who listened to this event will be executed at this point.
     * Subscribers and entity listeners can return promises, it will wait until they are resolved.
     *
     * Note: this method has a performance-optimized code organization, do not change code structure.
     */ broadcastBeforeRemoveEvent(result, metadata, entity, databaseEntity, identifier) {
        if (entity && metadata.beforeRemoveListeners.length) {
            metadata.beforeRemoveListeners.forEach((listener)=>{
                if (listener.isAllowed(entity)) {
                    const executionResult = listener.execute(entity);
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRemove) {
                    const executionResult = subscriber.beforeRemove({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager,
                        entity: entity,
                        metadata: metadata,
                        databaseEntity: databaseEntity,
                        entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "BEFORE_SOFT_REMOVE" event.
     * Before soft remove event is executed before entity is being soft removed from the database.
     * All subscribers and entity listeners who listened to this event will be executed at this point.
     * Subscribers and entity listeners can return promises, it will wait until they are resolved.
     *
     * Note: this method has a performance-optimized code organization, do not change code structure.
     */ broadcastBeforeSoftRemoveEvent(result, metadata, entity, databaseEntity, identifier) {
        if (entity && metadata.beforeSoftRemoveListeners.length) {
            metadata.beforeSoftRemoveListeners.forEach((listener)=>{
                if (listener.isAllowed(entity)) {
                    const executionResult = listener.execute(entity);
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeSoftRemove) {
                    const executionResult = subscriber.beforeSoftRemove({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager,
                        entity: entity,
                        metadata: metadata,
                        databaseEntity: databaseEntity,
                        entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "BEFORE_RECOVER" event.
     * Before recover event is executed before entity is being recovered in the database.
     * All subscribers and entity listeners who listened to this event will be executed at this point.
     * Subscribers and entity listeners can return promises, it will wait until they are resolved.
     *
     * Note: this method has a performance-optimized code organization, do not change code structure.
     */ broadcastBeforeRecoverEvent(result, metadata, entity, databaseEntity, identifier) {
        if (entity && metadata.beforeRecoverListeners.length) {
            metadata.beforeRecoverListeners.forEach((listener)=>{
                if (listener.isAllowed(entity)) {
                    const executionResult = listener.execute(entity);
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRecover) {
                    const executionResult = subscriber.beforeRecover({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager,
                        entity: entity,
                        metadata: metadata,
                        databaseEntity: databaseEntity,
                        entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "AFTER_INSERT" event.
     * After insert event is executed after entity is being persisted to the database for the first time.
     * All subscribers and entity listeners who listened to this event will be executed at this point.
     * Subscribers and entity listeners can return promises, it will wait until they are resolved.
     *
     * Note: this method has a performance-optimized code organization, do not change code structure.
     */ broadcastAfterInsertEvent(result, metadata, entity, identifier) {
        if (entity && metadata.afterInsertListeners.length) {
            metadata.afterInsertListeners.forEach((listener)=>{
                if (listener.isAllowed(entity)) {
                    const executionResult = listener.execute(entity);
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterInsert) {
                    const executionResult = subscriber.afterInsert({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager,
                        entity: entity,
                        metadata: metadata,
                        entityId: metadata.getEntityIdMixedMap(identifier)
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "BEFORE_QUERY" event.
     */ broadcastBeforeQueryEvent(result, query, parameters) {
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (subscriber.beforeQuery) {
                    const executionResult = subscriber.beforeQuery({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager,
                        query: query,
                        parameters: parameters
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "AFTER_QUERY" event.
     */ broadcastAfterQueryEvent(result, query, parameters, success, executionTime, rawResults, error) {
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (subscriber.afterQuery) {
                    const executionResult = subscriber.afterQuery({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager,
                        query: query,
                        parameters: parameters,
                        success: success,
                        executionTime: executionTime,
                        rawResults: rawResults,
                        error: error
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "BEFORE_TRANSACTION_START" event.
     */ broadcastBeforeTransactionStartEvent(result) {
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (subscriber.beforeTransactionStart) {
                    const executionResult = subscriber.beforeTransactionStart({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "AFTER_TRANSACTION_START" event.
     */ broadcastAfterTransactionStartEvent(result) {
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (subscriber.afterTransactionStart) {
                    const executionResult = subscriber.afterTransactionStart({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "BEFORE_TRANSACTION_COMMIT" event.
     */ broadcastBeforeTransactionCommitEvent(result) {
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (subscriber.beforeTransactionCommit) {
                    const executionResult = subscriber.beforeTransactionCommit({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "AFTER_TRANSACTION_COMMIT" event.
     */ broadcastAfterTransactionCommitEvent(result) {
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (subscriber.afterTransactionCommit) {
                    const executionResult = subscriber.afterTransactionCommit({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "BEFORE_TRANSACTION_ROLLBACK" event.
     */ broadcastBeforeTransactionRollbackEvent(result) {
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (subscriber.beforeTransactionRollback) {
                    const executionResult = subscriber.beforeTransactionRollback({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "AFTER_TRANSACTION_ROLLBACK" event.
     */ broadcastAfterTransactionRollbackEvent(result) {
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (subscriber.afterTransactionRollback) {
                    const executionResult = subscriber.afterTransactionRollback({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "AFTER_UPDATE" event.
     * After update event is executed after entity is being updated in the database.
     * All subscribers and entity listeners who listened to this event will be executed at this point.
     * Subscribers and entity listeners can return promises, it will wait until they are resolved.
     *
     * Note: this method has a performance-optimized code organization, do not change code structure.
     */ broadcastAfterUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {
        if (entity && metadata.afterUpdateListeners.length) {
            metadata.afterUpdateListeners.forEach((listener)=>{
                if (listener.isAllowed(entity)) {
                    const executionResult = listener.execute(entity);
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterUpdate) {
                    const executionResult = subscriber.afterUpdate({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager,
                        entity: entity,
                        metadata: metadata,
                        databaseEntity: databaseEntity,
                        updatedColumns: updatedColumns || [],
                        updatedRelations: updatedRelations || []
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "AFTER_REMOVE" event.
     * After remove event is executed after entity is being removed from the database.
     * All subscribers and entity listeners who listened to this event will be executed at this point.
     * Subscribers and entity listeners can return promises, it will wait until they are resolved.
     *
     * Note: this method has a performance-optimized code organization, do not change code structure.
     */ broadcastAfterRemoveEvent(result, metadata, entity, databaseEntity, identifier) {
        if (entity && metadata.afterRemoveListeners.length) {
            metadata.afterRemoveListeners.forEach((listener)=>{
                if (listener.isAllowed(entity)) {
                    const executionResult = listener.execute(entity);
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRemove) {
                    const executionResult = subscriber.afterRemove({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager,
                        entity: entity,
                        metadata: metadata,
                        databaseEntity: databaseEntity,
                        entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "AFTER_SOFT_REMOVE" event.
     * After soft remove event is executed after entity is being soft removed from the database.
     * All subscribers and entity listeners who listened to this event will be executed at this point.
     * Subscribers and entity listeners can return promises, it will wait until they are resolved.
     *
     * Note: this method has a performance-optimized code organization, do not change code structure.
     */ broadcastAfterSoftRemoveEvent(result, metadata, entity, databaseEntity, identifier) {
        if (entity && metadata.afterSoftRemoveListeners.length) {
            metadata.afterSoftRemoveListeners.forEach((listener)=>{
                if (listener.isAllowed(entity)) {
                    const executionResult = listener.execute(entity);
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterSoftRemove) {
                    const executionResult = subscriber.afterSoftRemove({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager,
                        entity: entity,
                        metadata: metadata,
                        databaseEntity: databaseEntity,
                        entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * Broadcasts "AFTER_RECOVER" event.
     * After recover event is executed after entity is being recovered in the database.
     * All subscribers and entity listeners who listened to this event will be executed at this point.
     * Subscribers and entity listeners can return promises, it will wait until they are resolved.
     *
     * Note: this method has a performance-optimized code organization, do not change code structure.
     */ broadcastAfterRecoverEvent(result, metadata, entity, databaseEntity, identifier) {
        if (entity && metadata.afterRecoverListeners.length) {
            metadata.afterRecoverListeners.forEach((listener)=>{
                if (listener.isAllowed(entity)) {
                    const executionResult = listener.execute(entity);
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
        if (this.queryRunner.connection.subscribers.length) {
            this.queryRunner.connection.subscribers.forEach((subscriber)=>{
                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRecover) {
                    const executionResult = subscriber.afterRecover({
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager,
                        entity: entity,
                        metadata: metadata,
                        databaseEntity: databaseEntity,
                        entityId: metadata.getEntityIdMixedMap(databaseEntity ?? identifier)
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                }
            });
        }
    }
    /**
     * @deprecated Use `broadcastLoadForAllEvent`
     */ broadcastLoadEventsForAll(result, metadata, entities) {
        return this.broadcastLoadEvent(result, metadata, entities);
    }
    /**
     * Broadcasts "AFTER_LOAD" event for all given entities, and their sub-entities.
     * After load event is executed after entity has been loaded from the database.
     * All subscribers and entity listeners who listened to this event will be executed at this point.
     * Subscribers and entity listeners can return promises, it will wait until they are resolved.
     *
     * Note: this method has a performance-optimized code organization, do not change code structure.
     */ broadcastLoadEvent(result, metadata, entities) {
        // Calculate which subscribers are fitting for the given entity type
        const fittingSubscribers = this.queryRunner.connection.subscribers.filter((subscriber)=>this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterLoad);
        if (metadata.relations.length || metadata.afterLoadListeners.length || fittingSubscribers.length) {
            // todo: check why need this?
            const nonPromiseEntities = entities.filter((entity)=>!(entity instanceof Promise));
            // collect load events for all children entities that were loaded with the main entity
            if (metadata.relations.length) {
                metadata.relations.forEach((relation)=>{
                    nonPromiseEntities.forEach((entity)=>{
                        // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query
                        if (relation.isLazy && !entity.hasOwnProperty(relation.propertyName)) return;
                        const value = relation.getEntityValue(entity);
                        if (ObjectUtils_1.ObjectUtils.isObject(value)) this.broadcastLoadEvent(result, relation.inverseEntityMetadata, Array.isArray(value) ? value : [
                            value
                        ]);
                    });
                });
            }
            if (metadata.afterLoadListeners.length) {
                metadata.afterLoadListeners.forEach((listener)=>{
                    nonPromiseEntities.forEach((entity)=>{
                        if (listener.isAllowed(entity)) {
                            const executionResult = listener.execute(entity);
                            if (executionResult instanceof Promise) result.promises.push(executionResult);
                            result.count++;
                        }
                    });
                });
            }
            fittingSubscribers.forEach((subscriber)=>{
                nonPromiseEntities.forEach((entity)=>{
                    const executionResult = subscriber.afterLoad(entity, {
                        entity,
                        metadata,
                        connection: this.queryRunner.connection,
                        queryRunner: this.queryRunner,
                        manager: this.queryRunner.manager
                    });
                    if (executionResult instanceof Promise) result.promises.push(executionResult);
                    result.count++;
                });
            });
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,
     * or listens our entity.
     */ isAllowedSubscriber(subscriber, target) {
        return !subscriber.listenTo || !subscriber.listenTo() || subscriber.listenTo() === Object || subscriber.listenTo() === target || subscriber.listenTo().isPrototypeOf(target);
    }
}
exports.Broadcaster = Broadcaster; //# sourceMappingURL=Broadcaster.js.map
}}),
"[project]/node_modules/typeorm/subscriber/event/QueryEvent.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=QueryEvent.js.map
}}),
"[project]/node_modules/typeorm/naming-strategy/DefaultNamingStrategy.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DefaultNamingStrategy = void 0;
const RandomGenerator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/RandomGenerator.js [app-route] (ecmascript)");
const StringUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/StringUtils.js [app-route] (ecmascript)");
/**
 * Naming strategy that is used by default.
 */ class DefaultNamingStrategy {
    constructor(){
        this.nestedSetColumnNames = {
            left: "nsleft",
            right: "nsright"
        };
        this.materializedPathColumnName = "mpath";
    }
    getTableName(tableOrName) {
        if (typeof tableOrName !== "string") {
            tableOrName = tableOrName.name;
        }
        return tableOrName.split(".").pop();
    }
    /**
     * Normalizes table name.
     *
     * @param targetName Name of the target entity that can be used to generate a table name.
     * @param userSpecifiedName For example if user specified a table name in a decorator, e.g. @Entity("name")
     */ tableName(targetName, userSpecifiedName) {
        return userSpecifiedName ? userSpecifiedName : (0, StringUtils_1.snakeCase)(targetName);
    }
    /**
     * Creates a table name for a junction table of a closure table.
     *
     * @param originalClosureTableName Name of the closure table which owns this junction table.
     */ closureJunctionTableName(originalClosureTableName) {
        return originalClosureTableName + "_closure";
    }
    columnName(propertyName, customName, embeddedPrefixes) {
        const name = customName || propertyName;
        if (embeddedPrefixes.length) return (0, StringUtils_1.camelCase)(embeddedPrefixes.join("_")) + (0, StringUtils_1.titleCase)(name);
        return name;
    }
    relationName(propertyName) {
        return propertyName;
    }
    primaryKeyName(tableOrName, columnNames) {
        // sort incoming column names to avoid issue when ["id", "name"] and ["name", "id"] arrays
        const clonedColumnNames = [
            ...columnNames
        ];
        clonedColumnNames.sort();
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        const key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
        return "PK_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27);
    }
    uniqueConstraintName(tableOrName, columnNames) {
        // sort incoming column names to avoid issue when ["id", "name"] and ["name", "id"] arrays
        const clonedColumnNames = [
            ...columnNames
        ];
        clonedColumnNames.sort();
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        const key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
        return "UQ_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27);
    }
    relationConstraintName(tableOrName, columnNames, where) {
        // sort incoming column names to avoid issue when ["id", "name"] and ["name", "id"] arrays
        const clonedColumnNames = [
            ...columnNames
        ];
        clonedColumnNames.sort();
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        let key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
        if (where) key += `_${where}`;
        return "REL_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 26);
    }
    defaultConstraintName(tableOrName, columnName) {
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        const key = `${replacedTableName}_${columnName}`;
        return "DF_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27);
    }
    foreignKeyName(tableOrName, columnNames, _referencedTablePath, _referencedColumnNames) {
        // sort incoming column names to avoid issue when ["id", "name"] and ["name", "id"] arrays
        const clonedColumnNames = [
            ...columnNames
        ];
        clonedColumnNames.sort();
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        const key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
        return "FK_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27);
    }
    indexName(tableOrName, columnNames, where) {
        // sort incoming column names to avoid issue when ["id", "name"] and ["name", "id"] arrays
        const clonedColumnNames = [
            ...columnNames
        ];
        clonedColumnNames.sort();
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        let key = `${replacedTableName}_${clonedColumnNames.join("_")}`;
        if (where) key += `_${where}`;
        return "IDX_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 26);
    }
    checkConstraintName(tableOrName, expression, isEnum) {
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        const key = `${replacedTableName}_${expression}`;
        const name = "CHK_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 26);
        return isEnum ? `${name}_ENUM` : name;
    }
    exclusionConstraintName(tableOrName, expression) {
        const tableName = this.getTableName(tableOrName);
        const replacedTableName = tableName.replace(".", "_");
        const key = `${replacedTableName}_${expression}`;
        return "XCL_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 26);
    }
    joinColumnName(relationName, referencedColumnName) {
        return (0, StringUtils_1.camelCase)(relationName + "_" + referencedColumnName);
    }
    joinTableName(firstTableName, secondTableName, firstPropertyName, secondPropertyName) {
        return (0, StringUtils_1.snakeCase)(firstTableName + "_" + firstPropertyName.replace(/\./gi, "_") + "_" + secondTableName);
    }
    joinTableColumnDuplicationPrefix(columnName, index) {
        return columnName + "_" + index;
    }
    joinTableColumnName(tableName, propertyName, columnName) {
        return (0, StringUtils_1.camelCase)(tableName + "_" + (columnName ? columnName : propertyName));
    }
    joinTableInverseColumnName(tableName, propertyName, columnName) {
        return this.joinTableColumnName(tableName, propertyName, columnName);
    }
    /**
     * Adds globally set prefix to the table name.
     * This method is executed no matter if prefix was set or not.
     * Table name is either user's given table name, either name generated from entity target.
     * Note that table name comes here already normalized by #tableName method.
     */ prefixTableName(prefix, tableName) {
        return prefix + tableName;
    }
}
exports.DefaultNamingStrategy = DefaultNamingStrategy; //# sourceMappingURL=DefaultNamingStrategy.js.map
}}),
"[project]/node_modules/typeorm/naming-strategy/LegacyOracleNamingStrategy.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LegacyOracleNamingStrategy = void 0;
const RandomGenerator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/RandomGenerator.js [app-route] (ecmascript)");
const DefaultNamingStrategy_1 = __turbopack_context__.r("[project]/node_modules/typeorm/naming-strategy/DefaultNamingStrategy.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Naming strategy for legacy Oracle database with 30 bytes identifier limit.
 *
 * Currently, only column name must be shorten in order to avoid ORA-00972.
 * Issues with other identifiers were fixed.
 */ class LegacyOracleNamingStrategy extends DefaultNamingStrategy_1.DefaultNamingStrategy {
    constructor(shortenStrategy = "hash"){
        super();
        this.IDENTIFIER_MAX_SIZE = 30;
        this.DEFAULT_COLUMN_PREFIX = "COL_";
        this.shortenStrategy = shortenStrategy;
    }
    columnName(propertyName, customName, embeddedPrefixes) {
        const longName = super.columnName(propertyName, customName, embeddedPrefixes);
        if (this.shortenStrategy === "truncate") {
            return this.truncateIdentifier(longName);
        } else if (this.shortenStrategy === "hash") {
            return this.hashIdentifier(longName, this.DEFAULT_COLUMN_PREFIX);
        } else {
            throw new error_1.TypeORMError(`Invalid shortenStrategy`);
        }
    }
    hashIdentifier(input, prefix) {
        if (prefix.length >= this.IDENTIFIER_MAX_SIZE) {
            throw new error_1.TypeORMError(`Prefix must be shorter than IDENTIFIER_MAX_SIZE`);
        }
        return prefix + RandomGenerator_1.RandomGenerator.sha1(input).substring(0, this.IDENTIFIER_MAX_SIZE - prefix.length);
    }
    truncateIdentifier(input) {
        if (input.length > this.IDENTIFIER_MAX_SIZE) {
            return input.substring(0, this.IDENTIFIER_MAX_SIZE);
        } else {
            return input;
        }
    }
}
exports.LegacyOracleNamingStrategy = LegacyOracleNamingStrategy; //# sourceMappingURL=LegacyOracleNamingStrategy.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/table/TableColumn.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TableColumn = void 0;
/**
 * Table's columns in the database represented in this class.
 */ class TableColumn {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("TableColumn");
        /**
         * Indicates if column is NULL, or is NOT NULL in the database.
         */ this.isNullable = false;
        /**
         * Indicates if column is auto-generated sequence.
         */ this.isGenerated = false;
        /**
         * Indicates if column is a primary key.
         */ this.isPrimary = false;
        /**
         * Indicates if column has unique value.
         */ this.isUnique = false;
        /**
         * Indicates if column stores array.
         */ this.isArray = false;
        /**
         * Column type's length. Used only on some column types.
         * For example type = "string" and length = "100" means that ORM will create a column with type varchar(100).
         */ this.length = "";
        /**
         * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.
         * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column
         */ this.zerofill = false;
        /**
         * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.
         */ this.unsigned = false;
        if (options) {
            this.name = options.name;
            this.type = options.type || "";
            this.length = options.length || "";
            this.width = options.width;
            this.charset = options.charset;
            this.collation = options.collation;
            this.precision = options.precision;
            this.scale = options.scale;
            this.zerofill = options.zerofill || false;
            this.unsigned = this.zerofill ? true : options.unsigned || false;
            this.default = options.default;
            this.onUpdate = options.onUpdate;
            this.isNullable = options.isNullable || false;
            this.isGenerated = options.isGenerated || false;
            this.generationStrategy = options.generationStrategy;
            this.generatedIdentity = options.generatedIdentity;
            this.isPrimary = options.isPrimary || false;
            this.isUnique = options.isUnique || false;
            this.isArray = options.isArray || false;
            this.comment = options.comment;
            this.enum = options.enum;
            this.enumName = options.enumName;
            this.primaryKeyConstraintName = options.primaryKeyConstraintName;
            this.asExpression = options.asExpression;
            this.generatedType = options.generatedType;
            this.spatialFeatureType = options.spatialFeatureType;
            this.srid = options.srid;
        }
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Clones this column to a new column with exact same properties as this column has.
     */ clone() {
        return new TableColumn({
            name: this.name,
            type: this.type,
            length: this.length,
            width: this.width,
            charset: this.charset,
            collation: this.collation,
            precision: this.precision,
            scale: this.scale,
            zerofill: this.zerofill,
            unsigned: this.unsigned,
            enum: this.enum,
            enumName: this.enumName,
            primaryKeyConstraintName: this.primaryKeyConstraintName,
            asExpression: this.asExpression,
            generatedType: this.generatedType,
            default: this.default,
            onUpdate: this.onUpdate,
            isNullable: this.isNullable,
            isGenerated: this.isGenerated,
            generationStrategy: this.generationStrategy,
            generatedIdentity: this.generatedIdentity,
            isPrimary: this.isPrimary,
            isUnique: this.isUnique,
            isArray: this.isArray,
            comment: this.comment,
            spatialFeatureType: this.spatialFeatureType,
            srid: this.srid
        });
    }
}
exports.TableColumn = TableColumn; //# sourceMappingURL=TableColumn.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/table/TableIndex.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TableIndex = void 0;
/**
 * Database's table index stored in this class.
 */ class TableIndex {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("TableIndex");
        /**
         * Columns included in this index.
         */ this.columnNames = [];
        this.name = options.name;
        this.columnNames = options.columnNames;
        this.isUnique = !!options.isUnique;
        this.isSpatial = !!options.isSpatial;
        this.isConcurrent = !!options.isConcurrent;
        this.isFulltext = !!options.isFulltext;
        this.isNullFiltered = !!options.isNullFiltered;
        this.parser = options.parser;
        this.where = options.where ? options.where : "";
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a new copy of this index with exactly same properties.
     */ clone() {
        return new TableIndex({
            name: this.name,
            columnNames: [
                ...this.columnNames
            ],
            isUnique: this.isUnique,
            isSpatial: this.isSpatial,
            isConcurrent: this.isConcurrent,
            isFulltext: this.isFulltext,
            isNullFiltered: this.isNullFiltered,
            parser: this.parser,
            where: this.where
        });
    }
    // -------------------------------------------------------------------------
    // Static Methods
    // -------------------------------------------------------------------------
    /**
     * Creates index from the index metadata object.
     */ static create(indexMetadata) {
        return new TableIndex({
            name: indexMetadata.name,
            columnNames: indexMetadata.columns.map((column)=>column.databaseName),
            isUnique: indexMetadata.isUnique,
            isSpatial: indexMetadata.isSpatial,
            isConcurrent: indexMetadata.isConcurrent,
            isFulltext: indexMetadata.isFulltext,
            isNullFiltered: indexMetadata.isNullFiltered,
            parser: indexMetadata.parser,
            where: indexMetadata.where
        });
    }
}
exports.TableIndex = TableIndex; //# sourceMappingURL=TableIndex.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/table/TableForeignKey.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TableForeignKey = void 0;
/**
 * Foreign key from the database stored in this class.
 */ class TableForeignKey {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("TableForeignKey");
        /**
         * Column names which included by this foreign key.
         */ this.columnNames = [];
        /**
         * Column names which included by this foreign key.
         */ this.referencedColumnNames = [];
        this.name = options.name;
        this.columnNames = options.columnNames;
        this.referencedColumnNames = options.referencedColumnNames;
        this.referencedDatabase = options.referencedDatabase;
        this.referencedSchema = options.referencedSchema;
        this.referencedTableName = options.referencedTableName;
        this.onDelete = options.onDelete;
        this.onUpdate = options.onUpdate;
        this.deferrable = options.deferrable;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a new copy of this foreign key with exactly same properties.
     */ clone() {
        return new TableForeignKey({
            name: this.name,
            columnNames: [
                ...this.columnNames
            ],
            referencedColumnNames: [
                ...this.referencedColumnNames
            ],
            referencedDatabase: this.referencedDatabase,
            referencedSchema: this.referencedSchema,
            referencedTableName: this.referencedTableName,
            onDelete: this.onDelete,
            onUpdate: this.onUpdate,
            deferrable: this.deferrable
        });
    }
    // -------------------------------------------------------------------------
    // Static Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a new table foreign key from the given foreign key metadata.
     */ static create(metadata, driver) {
        return new TableForeignKey({
            name: metadata.name,
            columnNames: metadata.columnNames,
            referencedColumnNames: metadata.referencedColumnNames,
            referencedDatabase: metadata.referencedEntityMetadata.database,
            referencedSchema: metadata.referencedEntityMetadata.schema,
            referencedTableName: metadata.referencedTablePath,
            onDelete: metadata.onDelete,
            onUpdate: metadata.onUpdate,
            deferrable: metadata.deferrable
        });
    }
}
exports.TableForeignKey = TableForeignKey; //# sourceMappingURL=TableForeignKey.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/util/TableUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TableUtils = void 0;
class TableUtils {
    static createTableColumnOptions(columnMetadata, driver) {
        return {
            name: columnMetadata.databaseName,
            length: driver.getColumnLength(columnMetadata),
            width: columnMetadata.width,
            charset: columnMetadata.charset,
            collation: columnMetadata.collation,
            precision: columnMetadata.precision,
            scale: columnMetadata.scale,
            zerofill: columnMetadata.zerofill,
            unsigned: columnMetadata.unsigned,
            asExpression: columnMetadata.asExpression,
            generatedType: columnMetadata.generatedType,
            default: driver.normalizeDefault(columnMetadata),
            onUpdate: columnMetadata.onUpdate,
            comment: columnMetadata.comment,
            isGenerated: columnMetadata.isGenerated,
            generationStrategy: columnMetadata.generationStrategy,
            generatedIdentity: columnMetadata.generatedIdentity,
            isNullable: columnMetadata.isNullable,
            type: driver.normalizeType(columnMetadata),
            isPrimary: columnMetadata.isPrimary,
            isUnique: driver.normalizeIsUnique(columnMetadata),
            isArray: columnMetadata.isArray || false,
            enum: columnMetadata.enum ? columnMetadata.enum.map((val)=>val + "") : columnMetadata.enum,
            enumName: columnMetadata.enumName,
            primaryKeyConstraintName: columnMetadata.primaryKeyConstraintName,
            spatialFeatureType: columnMetadata.spatialFeatureType,
            srid: columnMetadata.srid
        };
    }
}
exports.TableUtils = TableUtils; //# sourceMappingURL=TableUtils.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/table/TableUnique.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TableUnique = void 0;
/**
 * Database's table unique constraint stored in this class.
 */ class TableUnique {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("TableUnique");
        /**
         * Columns that contains this constraint.
         */ this.columnNames = [];
        this.name = options.name;
        this.columnNames = options.columnNames;
        this.deferrable = options.deferrable;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a new copy of this constraint with exactly same properties.
     */ clone() {
        return new TableUnique({
            name: this.name,
            columnNames: [
                ...this.columnNames
            ],
            deferrable: this.deferrable
        });
    }
    // -------------------------------------------------------------------------
    // Static Methods
    // -------------------------------------------------------------------------
    /**
     * Creates unique from the unique metadata object.
     */ static create(uniqueMetadata) {
        return new TableUnique({
            name: uniqueMetadata.name,
            columnNames: uniqueMetadata.columns.map((column)=>column.databaseName),
            deferrable: uniqueMetadata.deferrable
        });
    }
}
exports.TableUnique = TableUnique; //# sourceMappingURL=TableUnique.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/table/TableCheck.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TableCheck = void 0;
/**
 * Database's table check constraint stored in this class.
 */ class TableCheck {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("TableCheck");
        /**
         * Column that contains this constraint.
         */ this.columnNames = [];
        this.name = options.name;
        this.columnNames = options.columnNames;
        this.expression = options.expression;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a new copy of this constraint with exactly same properties.
     */ clone() {
        return new TableCheck({
            name: this.name,
            columnNames: this.columnNames ? [
                ...this.columnNames
            ] : [],
            expression: this.expression
        });
    }
    // -------------------------------------------------------------------------
    // Static Methods
    // -------------------------------------------------------------------------
    /**
     * Creates checks from the check metadata object.
     */ static create(checkMetadata) {
        return new TableCheck({
            name: checkMetadata.name,
            expression: checkMetadata.expression
        });
    }
}
exports.TableCheck = TableCheck; //# sourceMappingURL=TableCheck.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/table/TableExclusion.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TableExclusion = void 0;
/**
 * Database's table exclusion constraint stored in this class.
 */ class TableExclusion {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("TableExclusion");
        this.name = options.name;
        this.expression = options.expression;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a new copy of this constraint with exactly same properties.
     */ clone() {
        return new TableExclusion({
            name: this.name,
            expression: this.expression
        });
    }
    // -------------------------------------------------------------------------
    // Static Methods
    // -------------------------------------------------------------------------
    /**
     * Creates exclusions from the exclusion metadata object.
     */ static create(exclusionMetadata) {
        return new TableExclusion({
            name: exclusionMetadata.name,
            expression: exclusionMetadata.expression
        });
    }
}
exports.TableExclusion = TableExclusion; //# sourceMappingURL=TableExclusion.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/table/Table.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Table = void 0;
const TableColumn_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableColumn.js [app-route] (ecmascript)");
const TableIndex_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableIndex.js [app-route] (ecmascript)");
const TableForeignKey_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableForeignKey.js [app-route] (ecmascript)");
const TableUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/util/TableUtils.js [app-route] (ecmascript)");
const TableUnique_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableUnique.js [app-route] (ecmascript)");
const TableCheck_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableCheck.js [app-route] (ecmascript)");
const TableExclusion_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableExclusion.js [app-route] (ecmascript)");
/**
 * Table in the database represented in this class.
 */ class Table {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("Table");
        /**
         * Table columns.
         */ this.columns = [];
        /**
         * Table indices.
         */ this.indices = [];
        /**
         * Table foreign keys.
         */ this.foreignKeys = [];
        /**
         * Table unique constraints.
         */ this.uniques = [];
        /**
         * Table check constraints.
         */ this.checks = [];
        /**
         * Table exclusion constraints.
         */ this.exclusions = [];
        /**
         * Indicates if table was just created.
         * This is needed, for example to check if we need to skip primary keys creation
         * for new tables.
         */ this.justCreated = false;
        /**
         * Enables Sqlite "WITHOUT ROWID" modifier for the "CREATE TABLE" statement
         */ this.withoutRowid = false;
        if (options) {
            this.database = options.database;
            this.schema = options.schema;
            this.name = options.name;
            if (options.columns) this.columns = options.columns.map((column)=>new TableColumn_1.TableColumn(column));
            if (options.indices) this.indices = options.indices.map((index)=>new TableIndex_1.TableIndex(index));
            if (options.foreignKeys) this.foreignKeys = options.foreignKeys.map((foreignKey)=>new TableForeignKey_1.TableForeignKey({
                    ...foreignKey,
                    referencedDatabase: foreignKey?.referencedDatabase || options.database,
                    referencedSchema: foreignKey?.referencedSchema || options.schema
                }));
            if (options.uniques) this.uniques = options.uniques.map((unique)=>new TableUnique_1.TableUnique(unique));
            if (options.checks) this.checks = options.checks.map((check)=>new TableCheck_1.TableCheck(check));
            if (options.exclusions) this.exclusions = options.exclusions.map((exclusion)=>new TableExclusion_1.TableExclusion(exclusion));
            if (options.justCreated !== undefined) this.justCreated = options.justCreated;
            if (options.withoutRowid) this.withoutRowid = options.withoutRowid;
            this.engine = options.engine;
            this.comment = options.comment;
        }
    }
    // -------------------------------------------------------------------------
    // Accessors
    // -------------------------------------------------------------------------
    get primaryColumns() {
        return this.columns.filter((column)=>column.isPrimary);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Clones this table to a new table with all properties cloned.
     */ clone() {
        return new Table({
            schema: this.schema,
            database: this.database,
            name: this.name,
            columns: this.columns.map((column)=>column.clone()),
            indices: this.indices.map((constraint)=>constraint.clone()),
            foreignKeys: this.foreignKeys.map((constraint)=>constraint.clone()),
            uniques: this.uniques.map((constraint)=>constraint.clone()),
            checks: this.checks.map((constraint)=>constraint.clone()),
            exclusions: this.exclusions.map((constraint)=>constraint.clone()),
            justCreated: this.justCreated,
            withoutRowid: this.withoutRowid,
            engine: this.engine,
            comment: this.comment
        });
    }
    /**
     * Add column and creates its constraints.
     */ addColumn(column) {
        this.columns.push(column);
    }
    /**
     * Remove column and its constraints.
     */ removeColumn(column) {
        const foundColumn = this.columns.find((c)=>c.name === column.name);
        if (foundColumn) this.columns.splice(this.columns.indexOf(foundColumn), 1);
    }
    /**
     * Adds unique constraint.
     */ addUniqueConstraint(uniqueConstraint) {
        this.uniques.push(uniqueConstraint);
        if (uniqueConstraint.columnNames.length === 1) {
            const uniqueColumn = this.columns.find((column)=>column.name === uniqueConstraint.columnNames[0]);
            if (uniqueColumn) uniqueColumn.isUnique = true;
        }
    }
    /**
     * Removes unique constraint.
     */ removeUniqueConstraint(removedUnique) {
        const foundUnique = this.uniques.find((unique)=>unique.name === removedUnique.name);
        if (foundUnique) {
            this.uniques.splice(this.uniques.indexOf(foundUnique), 1);
            if (foundUnique.columnNames.length === 1) {
                const uniqueColumn = this.columns.find((column)=>column.name === foundUnique.columnNames[0]);
                if (uniqueColumn) uniqueColumn.isUnique = false;
            }
        }
    }
    /**
     * Adds check constraint.
     */ addCheckConstraint(checkConstraint) {
        this.checks.push(checkConstraint);
    }
    /**
     * Removes check constraint.
     */ removeCheckConstraint(removedCheck) {
        const foundCheck = this.checks.find((check)=>check.name === removedCheck.name);
        if (foundCheck) {
            this.checks.splice(this.checks.indexOf(foundCheck), 1);
        }
    }
    /**
     * Adds exclusion constraint.
     */ addExclusionConstraint(exclusionConstraint) {
        this.exclusions.push(exclusionConstraint);
    }
    /**
     * Removes exclusion constraint.
     */ removeExclusionConstraint(removedExclusion) {
        const foundExclusion = this.exclusions.find((exclusion)=>exclusion.name === removedExclusion.name);
        if (foundExclusion) {
            this.exclusions.splice(this.exclusions.indexOf(foundExclusion), 1);
        }
    }
    /**
     * Adds foreign keys.
     */ addForeignKey(foreignKey) {
        this.foreignKeys.push(foreignKey);
    }
    /**
     * Removes foreign key.
     */ removeForeignKey(removedForeignKey) {
        const fk = this.foreignKeys.find((foreignKey)=>foreignKey.name === removedForeignKey.name);
        if (fk) this.foreignKeys.splice(this.foreignKeys.indexOf(fk), 1);
    }
    /**
     * Adds index.
     */ addIndex(index, isMysql = false) {
        this.indices.push(index);
        // in Mysql unique indices and unique constraints are the same thing
        // if index is unique and have only one column, we mark this column as unique
        if (index.columnNames.length === 1 && index.isUnique && isMysql) {
            const column = this.columns.find((c)=>c.name === index.columnNames[0]);
            if (column) column.isUnique = true;
        }
    }
    /**
     * Removes index.
     */ removeIndex(tableIndex, isMysql = false) {
        const index = this.indices.find((index)=>index.name === tableIndex.name);
        if (index) {
            this.indices.splice(this.indices.indexOf(index), 1);
            // in Mysql unique indices and unique constraints are the same thing
            // if index is unique and have only one column, we move `unique` attribute from its column
            if (index.columnNames.length === 1 && index.isUnique && isMysql) {
                const column = this.columns.find((c)=>c.name === index.columnNames[0]);
                if (column) column.isUnique = this.indices.some((ind)=>ind.columnNames.length === 1 && ind.columnNames[0] === column.name && !!index.isUnique);
            }
        }
    }
    findColumnByName(name) {
        return this.columns.find((column)=>column.name === name);
    }
    /**
     * Returns all column indices.
     */ findColumnIndices(column) {
        return this.indices.filter((index)=>{
            return !!index.columnNames.find((columnName)=>columnName === column.name);
        });
    }
    /**
     * Returns all column foreign keys.
     */ findColumnForeignKeys(column) {
        return this.foreignKeys.filter((foreignKey)=>{
            return !!foreignKey.columnNames.find((columnName)=>columnName === column.name);
        });
    }
    /**
     * Returns all column uniques.
     */ findColumnUniques(column) {
        return this.uniques.filter((unique)=>{
            return !!unique.columnNames.find((columnName)=>columnName === column.name);
        });
    }
    /**
     * Returns all column checks.
     */ findColumnChecks(column) {
        return this.checks.filter((check)=>{
            return !!check.columnNames.find((columnName)=>columnName === column.name);
        });
    }
    // -------------------------------------------------------------------------
    // Static Methods
    // -------------------------------------------------------------------------
    /**
     * Creates table from a given entity metadata.
     */ static create(entityMetadata, driver) {
        const database = entityMetadata.database === driver.database ? undefined : entityMetadata.database;
        const schema = entityMetadata.schema === driver.options.schema ? undefined : entityMetadata.schema;
        const options = {
            database: entityMetadata.database,
            schema: entityMetadata.schema,
            name: driver.buildTableName(entityMetadata.tableName, schema, database),
            withoutRowid: entityMetadata.withoutRowid,
            engine: entityMetadata.engine,
            columns: entityMetadata.columns.filter((column)=>column && !column.isVirtualProperty).map((column)=>TableUtils_1.TableUtils.createTableColumnOptions(column, driver)),
            indices: entityMetadata.indices.filter((index)=>index.synchronize === true).map((index)=>TableIndex_1.TableIndex.create(index)),
            uniques: entityMetadata.uniques.map((unique)=>TableUnique_1.TableUnique.create(unique)),
            checks: entityMetadata.checks.map((check)=>TableCheck_1.TableCheck.create(check)),
            exclusions: entityMetadata.exclusions.map((exclusion)=>TableExclusion_1.TableExclusion.create(exclusion)),
            comment: entityMetadata.comment
        };
        return new Table(options);
    }
}
exports.Table = Table; //# sourceMappingURL=Table.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/view/View.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.View = void 0;
/**
 * View in the database represented in this class.
 */ class View {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("View");
        this.indices = [];
        if (options) {
            this.database = options.database;
            this.schema = options.schema;
            this.name = options.name;
            this.expression = options.expression;
            this.materialized = !!options.materialized;
        }
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Clones this table to a new table with all properties cloned.
     */ clone() {
        return new View({
            database: this.database,
            schema: this.schema,
            name: this.name,
            expression: this.expression,
            materialized: this.materialized
        });
    }
    /**
     * Add index
     */ addIndex(index) {
        this.indices.push(index);
    }
    /**
     * Remove index
     */ removeIndex(viewIndex) {
        const index = this.indices.find((index)=>index.name === viewIndex.name);
        if (index) {
            this.indices.splice(this.indices.indexOf(index), 1);
        }
    }
    // -------------------------------------------------------------------------
    // Static Methods
    // -------------------------------------------------------------------------
    /**
     * Creates view from a given entity metadata.
     */ static create(entityMetadata, driver) {
        const options = {
            database: entityMetadata.database,
            schema: entityMetadata.schema,
            name: driver.buildTableName(entityMetadata.tableName, entityMetadata.schema, entityMetadata.database),
            expression: entityMetadata.expression,
            materialized: entityMetadata.tableMetadataArgs.materialized
        };
        return new View(options);
    }
}
exports.View = View; //# sourceMappingURL=View.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/util/ViewUtils.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewUtils = void 0;
class ViewUtils {
    /**
     * Comparator for .sort() that will order views bases on dependencies in creation order
     */ static viewMetadataCmp(metadataA, metadataB) {
        if (!metadataA || !metadataB) {
            return 0;
        }
        if (metadataA.dependsOn && (metadataA.dependsOn.has(metadataB.target) || metadataA.dependsOn.has(metadataB.name))) {
            return 1;
        }
        if (metadataB.dependsOn && (metadataB.dependsOn.has(metadataA.target) || metadataB.dependsOn.has(metadataA.name))) {
            return -1;
        }
        return 0;
    }
}
exports.ViewUtils = ViewUtils; //# sourceMappingURL=ViewUtils.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/RdbmsSchemaBuilder.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RdbmsSchemaBuilder = void 0;
const Table_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/Table.js [app-route] (ecmascript)");
const TableColumn_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableColumn.js [app-route] (ecmascript)");
const TableForeignKey_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableForeignKey.js [app-route] (ecmascript)");
const TableIndex_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableIndex.js [app-route] (ecmascript)");
const TableUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/util/TableUtils.js [app-route] (ecmascript)");
const TableUnique_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableUnique.js [app-route] (ecmascript)");
const TableCheck_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableCheck.js [app-route] (ecmascript)");
const TableExclusion_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableExclusion.js [app-route] (ecmascript)");
const View_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/view/View.js [app-route] (ecmascript)");
const ViewUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/util/ViewUtils.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
/**
 * Creates complete tables schemas in the database based on the entity metadatas.
 *
 * Steps how schema is being built:
 * 1. load list of all tables with complete column and keys information from the db
 * 2. drop all (old) foreign keys that exist in the table, but does not exist in the metadata
 * 3. create new tables that does not exist in the db, but exist in the metadata
 * 4. drop all columns exist (left old) in the db table, but does not exist in the metadata
 * 5. add columns from metadata which does not exist in the table
 * 6. update all exist columns which metadata has changed
 * 7. update primary keys - update old and create new primary key from changed columns
 * 8. create foreign keys which does not exist in the table yet
 * 9. create indices which are missing in db yet, and drops indices which exist in the db, but does not exist in the metadata anymore
 */ class RdbmsSchemaBuilder {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        this.connection = connection;
        this["@instanceof"] = Symbol.for("RdbmsSchemaBuilder");
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates complete schemas for the given entity metadatas.
     */ async build() {
        this.queryRunner = this.connection.createQueryRunner();
        // this.connection.driver.database || this.currentDatabase;
        this.currentDatabase = this.connection.driver.database;
        this.currentSchema = this.connection.driver.schema;
        // CockroachDB implements asynchronous schema sync operations which can not been executed in transaction.
        // E.g. if you try to DROP column and ADD it again in the same transaction, crdb throws error.
        // In Spanner queries against the INFORMATION_SCHEMA can be used in a read-only transaction,
        // but not in a read-write transaction.
        const isUsingTransactions = !(this.connection.driver.options.type === "cockroachdb") && !(this.connection.driver.options.type === "spanner") && this.connection.options.migrationsTransactionMode !== "none";
        await this.queryRunner.beforeMigration();
        if (isUsingTransactions) {
            await this.queryRunner.startTransaction();
        }
        try {
            await this.createMetadataTableIfNecessary(this.queryRunner);
            // Flush the queryrunner table & view cache
            const tablePaths = this.entityToSyncMetadatas.map((metadata)=>this.getTablePath(metadata));
            const viewPaths = this.viewEntityToSyncMetadatas.map((metadata)=>this.getTablePath(metadata));
            await this.queryRunner.getTables(tablePaths);
            await this.queryRunner.getViews(viewPaths);
            await this.executeSchemaSyncOperationsInProperOrder();
            // if cache is enabled then perform cache-synchronization as well
            if (this.connection.queryResultCache) await this.connection.queryResultCache.synchronize(this.queryRunner);
            if (isUsingTransactions) {
                await this.queryRunner.commitTransaction();
            }
        } catch (error) {
            try {
                // we throw original error even if rollback thrown an error
                if (isUsingTransactions) {
                    await this.queryRunner.rollbackTransaction();
                }
            } catch (rollbackError) {}
            throw error;
        } finally{
            await this.queryRunner.afterMigration();
            await this.queryRunner.release();
        }
    }
    /**
     * Create the typeorm_metadata table if necessary.
     */ async createMetadataTableIfNecessary(queryRunner) {
        if (this.viewEntityToSyncMetadatas.length > 0 || this.hasGeneratedColumns()) {
            await this.createTypeormMetadataTable(queryRunner);
        }
    }
    /**
     * Returns sql queries to be executed by schema builder.
     */ async log() {
        this.queryRunner = this.connection.createQueryRunner();
        try {
            // Flush the queryrunner table & view cache
            const tablePaths = this.entityToSyncMetadatas.map((metadata)=>this.getTablePath(metadata));
            const viewPaths = this.viewEntityToSyncMetadatas.map((metadata)=>this.getTablePath(metadata));
            await this.queryRunner.getTables(tablePaths);
            await this.queryRunner.getViews(viewPaths);
            this.queryRunner.enableSqlMemory();
            await this.executeSchemaSyncOperationsInProperOrder();
            // if cache is enabled then perform cache-synchronization as well
            if (this.connection.queryResultCache) // todo: check this functionality
            await this.connection.queryResultCache.synchronize(this.queryRunner);
            return this.queryRunner.getMemorySql();
        } finally{
            // its important to disable this mode despite the fact we are release query builder
            // because there exist drivers which reuse same query runner. Also its important to disable
            // sql memory after call of getMemorySql() method because last one flushes sql memory.
            this.queryRunner.disableSqlMemory();
            await this.queryRunner.release();
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Returns only entities that should be synced in the database.
     */ get entityToSyncMetadatas() {
        return this.connection.entityMetadatas.filter((metadata)=>metadata.synchronize && metadata.tableType !== "entity-child" && metadata.tableType !== "view");
    }
    /**
     * Returns only entities that should be synced in the database.
     */ get viewEntityToSyncMetadatas() {
        return this.connection.entityMetadatas.filter((metadata)=>metadata.tableType === "view" && metadata.synchronize)// sort views in creation order by dependencies
        .sort(ViewUtils_1.ViewUtils.viewMetadataCmp);
    }
    /**
     * Checks if there are at least one generated column.
     */ hasGeneratedColumns() {
        return this.connection.entityMetadatas.some((entityMetadata)=>{
            return entityMetadata.columns.some((column)=>column.generatedType);
        });
    }
    /**
     * Executes schema sync operations in a proper order.
     * Order of operations matter here.
     */ async executeSchemaSyncOperationsInProperOrder() {
        await this.dropOldViews();
        await this.dropOldForeignKeys();
        await this.dropOldIndices();
        await this.dropOldChecks();
        await this.dropOldExclusions();
        await this.dropCompositeUniqueConstraints();
        // await this.renameTables();
        await this.renameColumns();
        await this.changeTableComment();
        await this.createNewTables();
        await this.dropRemovedColumns();
        await this.addNewColumns();
        await this.updatePrimaryKeys();
        await this.updateExistColumns();
        await this.createNewIndices();
        await this.createNewChecks();
        await this.createNewExclusions();
        await this.createCompositeUniqueConstraints();
        await this.createForeignKeys();
        await this.createViews();
        await this.createNewViewIndices();
    }
    getTablePath(target) {
        const parsed = this.connection.driver.parseTableName(target);
        return this.connection.driver.buildTableName(parsed.tableName, parsed.schema || this.currentSchema, parsed.database || this.currentDatabase);
    }
    /**
     * Drops all (old) foreign keys that exist in the tables, but do not exist in the entity metadata.
     */ async dropOldForeignKeys() {
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            // find foreign keys that exist in the schemas but does not exist in the entity metadata
            const tableForeignKeysToDrop = table.foreignKeys.filter((tableForeignKey)=>{
                const metadataFK = metadata.foreignKeys.find((metadataForeignKey)=>tableForeignKey.name === metadataForeignKey.name && this.getTablePath(tableForeignKey) === this.getTablePath(metadataForeignKey.referencedEntityMetadata));
                return !metadataFK || metadataFK.onDelete && metadataFK.onDelete !== tableForeignKey.onDelete || metadataFK.onUpdate && metadataFK.onUpdate !== tableForeignKey.onUpdate;
            });
            if (tableForeignKeysToDrop.length === 0) continue;
            this.connection.logger.logSchemaBuild(`dropping old foreign keys of ${table.name}: ${tableForeignKeysToDrop.map((dbForeignKey)=>dbForeignKey.name).join(", ")}`);
            // drop foreign keys from the database
            await this.queryRunner.dropForeignKeys(table, tableForeignKeysToDrop);
        }
    }
    /**
     * Rename tables
     */ async renameTables() {
    // for (const metadata of this.entityToSyncMetadatas) {
    //     const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));
    // }
    }
    /**
     * Renames columns.
     * Works if only one column per table was changed.
     * Changes only column name. If something besides name was changed, these changes will be ignored.
     */ async renameColumns() {
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            if (metadata.columns.length !== table.columns.length) continue;
            const renamedMetadataColumns = metadata.columns.filter((c)=>!c.isVirtualProperty).filter((column)=>{
                return !table.columns.find((tableColumn)=>{
                    return tableColumn.name === column.databaseName && tableColumn.type === this.connection.driver.normalizeType(column) && tableColumn.isNullable === column.isNullable && tableColumn.isUnique === this.connection.driver.normalizeIsUnique(column);
                });
            });
            if (renamedMetadataColumns.length === 0 || renamedMetadataColumns.length > 1) continue;
            const renamedTableColumns = table.columns.filter((tableColumn)=>{
                return !metadata.columns.find((column)=>{
                    return !column.isVirtualProperty && column.databaseName === tableColumn.name && this.connection.driver.normalizeType(column) === tableColumn.type && column.isNullable === tableColumn.isNullable && this.connection.driver.normalizeIsUnique(column) === tableColumn.isUnique;
                });
            });
            if (renamedTableColumns.length === 0 || renamedTableColumns.length > 1) continue;
            const renamedColumn = renamedTableColumns[0].clone();
            renamedColumn.name = renamedMetadataColumns[0].databaseName;
            this.connection.logger.logSchemaBuild(`renaming column "${renamedTableColumns[0].name}" in "${table.name}" to "${renamedColumn.name}"`);
            await this.queryRunner.renameColumn(table, renamedTableColumns[0], renamedColumn);
        }
    }
    async dropOldIndices() {
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            const dropQueries = table.indices.filter((tableIndex)=>{
                const indexMetadata = metadata.indices.find((index)=>index.name === tableIndex.name);
                if (indexMetadata) {
                    if (indexMetadata.synchronize === false) return false;
                    if (indexMetadata.isUnique !== tableIndex.isUnique) return true;
                    if (indexMetadata.isSpatial !== tableIndex.isSpatial) return true;
                    if (this.connection.driver.isFullTextColumnTypeSupported() && indexMetadata.isFulltext !== tableIndex.isFulltext) return true;
                    if (indexMetadata.columns.length !== tableIndex.columnNames.length) return true;
                    return !indexMetadata.columns.every((column)=>tableIndex.columnNames.indexOf(column.databaseName) !== -1);
                }
                return true;
            }).map(async (tableIndex)=>{
                this.connection.logger.logSchemaBuild(`dropping an index: "${tableIndex.name}" from table ${table.name}`);
                await this.queryRunner.dropIndex(table, tableIndex);
            });
            await Promise.all(dropQueries);
        }
        if (this.connection.options.type === "postgres") {
            const postgresQueryRunner = this.queryRunner;
            for (const metadata of this.viewEntityToSyncMetadatas){
                const view = this.queryRunner.loadedViews.find((view)=>this.getTablePath(view) === this.getTablePath(metadata));
                if (!view) continue;
                const dropQueries = view.indices.filter((tableIndex)=>{
                    const indexMetadata = metadata.indices.find((index)=>index.name === tableIndex.name);
                    if (indexMetadata) {
                        if (indexMetadata.synchronize === false) return false;
                        if (indexMetadata.isUnique !== tableIndex.isUnique) return true;
                        if (indexMetadata.isSpatial !== tableIndex.isSpatial) return true;
                        if (this.connection.driver.isFullTextColumnTypeSupported() && indexMetadata.isFulltext !== tableIndex.isFulltext) return true;
                        if (indexMetadata.columns.length !== tableIndex.columnNames.length) return true;
                        return !indexMetadata.columns.every((column)=>tableIndex.columnNames.indexOf(column.databaseName) !== -1);
                    }
                    return true;
                }).map(async (tableIndex)=>{
                    this.connection.logger.logSchemaBuild(`dropping an index: "${tableIndex.name}" from view ${view.name}`);
                    await postgresQueryRunner.dropViewIndex(view, tableIndex);
                });
                await Promise.all(dropQueries);
            }
        }
    }
    async dropOldChecks() {
        // Mysql does not support check constraints
        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") return;
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            const oldChecks = table.checks.filter((tableCheck)=>{
                return !metadata.checks.find((checkMetadata)=>checkMetadata.name === tableCheck.name);
            });
            if (oldChecks.length === 0) continue;
            this.connection.logger.logSchemaBuild(`dropping old check constraint: ${oldChecks.map((check)=>`"${check.name}"`).join(", ")} from table "${table.name}"`);
            await this.queryRunner.dropCheckConstraints(table, oldChecks);
        }
    }
    async dropCompositeUniqueConstraints() {
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            const compositeUniques = table.uniques.filter((tableUnique)=>{
                return tableUnique.columnNames.length > 1 && !metadata.uniques.find((uniqueMetadata)=>uniqueMetadata.name === tableUnique.name);
            });
            if (compositeUniques.length === 0) continue;
            this.connection.logger.logSchemaBuild(`dropping old unique constraint: ${compositeUniques.map((unique)=>`"${unique.name}"`).join(", ")} from table "${table.name}"`);
            await this.queryRunner.dropUniqueConstraints(table, compositeUniques);
        }
    }
    async dropOldExclusions() {
        // Only PostgreSQL supports exclusion constraints
        if (!(this.connection.driver.options.type === "postgres")) return;
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            const oldExclusions = table.exclusions.filter((tableExclusion)=>{
                return !metadata.exclusions.find((exclusionMetadata)=>exclusionMetadata.name === tableExclusion.name);
            });
            if (oldExclusions.length === 0) continue;
            this.connection.logger.logSchemaBuild(`dropping old exclusion constraint: ${oldExclusions.map((exclusion)=>`"${exclusion.name}"`).join(", ")} from table "${table.name}"`);
            await this.queryRunner.dropExclusionConstraints(table, oldExclusions);
        }
    }
    /**
     * change table comment
     */ async changeTableComment() {
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "postgres") {
                const newComment = metadata.comment;
                await this.queryRunner.changeTableComment(table, newComment);
            }
        }
    }
    /**
     * Creates tables that do not exist in the database yet.
     * New tables are created without foreign and primary keys.
     * Primary key only can be created in conclusion with auto generated column.
     */ async createNewTables() {
        for (const metadata of this.entityToSyncMetadatas){
            // check if table does not exist yet
            const existTable = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (existTable) continue;
            this.connection.logger.logSchemaBuild(`creating a new table: ${this.getTablePath(metadata)}`);
            // create a new table and sync it in the database
            const table = Table_1.Table.create(metadata, this.connection.driver);
            await this.queryRunner.createTable(table, false, false);
            this.queryRunner.loadedTables.push(table);
        }
    }
    async createViews() {
        for (const metadata of this.viewEntityToSyncMetadatas){
            // check if view does not exist yet
            const existView = this.queryRunner.loadedViews.find((view)=>{
                const viewExpression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
                const metadataExpression = typeof metadata.expression === "string" ? metadata.expression.trim() : metadata.expression(this.connection).getQuery();
                return this.getTablePath(view) === this.getTablePath(metadata) && viewExpression === metadataExpression;
            });
            if (existView) continue;
            this.connection.logger.logSchemaBuild(`creating a new view: ${this.getTablePath(metadata)}`);
            // create a new view and sync it in the database
            const view = View_1.View.create(metadata, this.connection.driver);
            await this.queryRunner.createView(view, true);
            this.queryRunner.loadedViews.push(view);
        }
    }
    async dropOldViews() {
        const droppedViews = [];
        const viewEntityToSyncMetadatas = this.viewEntityToSyncMetadatas;
        // BuIld lookup cache for finding views metadata
        const viewToMetadata = new Map();
        for (const view of this.queryRunner.loadedViews){
            const viewMetadata = viewEntityToSyncMetadatas.find((metadata)=>{
                return this.getTablePath(view) === this.getTablePath(metadata);
            });
            if (viewMetadata) {
                viewToMetadata.set(view, viewMetadata);
            }
        }
        // Gather all changed view, that need a drop
        for (const view of this.queryRunner.loadedViews){
            const viewMetadata = viewToMetadata.get(view);
            if (!viewMetadata) {
                continue;
            }
            const viewExpression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
            const metadataExpression = typeof viewMetadata.expression === "string" ? viewMetadata.expression.trim() : viewMetadata.expression(this.connection).getQuery();
            if (viewExpression === metadataExpression) continue;
            this.connection.logger.logSchemaBuild(`dropping an old view: ${view.name}`);
            // Collect view to be dropped
            droppedViews.push(view);
        }
        // Helper function that for a given view, will recursively return list of the view and all views that depend on it
        const viewDependencyChain = (view)=>{
            // Get the view metadata
            const viewMetadata = viewToMetadata.get(view);
            let viewWithDependencies = [
                view
            ];
            // If no metadata is known for the view, simply return the view itself
            if (!viewMetadata) {
                return viewWithDependencies;
            }
            // Iterate over all known views
            for (const [currentView, currentMetadata] of viewToMetadata.entries()){
                // Ignore self reference
                if (currentView === view) {
                    continue;
                }
                // If the currently iterated view depends on the passed in view
                if (currentMetadata.dependsOn && (currentMetadata.dependsOn.has(viewMetadata.target) || currentMetadata.dependsOn.has(viewMetadata.name))) {
                    // Recursively add currently iterate view and its dependents
                    viewWithDependencies = viewWithDependencies.concat(viewDependencyChain(currentView));
                }
            }
            // Return all collected views
            return viewWithDependencies;
        };
        // Collect final list of views to be dropped in a Set so there are no duplicates
        const droppedViewsWithDependencies = new Set(// Collect all dropped views, and their dependencies
        droppedViews.map((view)=>viewDependencyChain(view))// Flattened to single Array ( can be replaced with flatMap, once supported)
        .reduce((all, segment)=>{
            return all.concat(segment);
        }, [])// Sort the views to be dropped in creation order
        .sort((a, b)=>{
            return ViewUtils_1.ViewUtils.viewMetadataCmp(viewToMetadata.get(a), viewToMetadata.get(b));
        })// reverse order to get drop order
        .reverse());
        // Finally emit all drop views
        for (const view of droppedViewsWithDependencies){
            await this.queryRunner.dropView(view);
        }
        this.queryRunner.loadedViews = this.queryRunner.loadedViews.filter((view)=>!droppedViewsWithDependencies.has(view));
    }
    /**
     * Drops all columns that exist in the table, but does not exist in the metadata (left old).
     * We drop their keys too, since it should be safe.
     */ async dropRemovedColumns() {
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            // find columns that exist in the database but does not exist in the metadata
            const droppedTableColumns = table.columns.filter((tableColumn)=>{
                return !metadata.columns.find((columnMetadata)=>columnMetadata.isVirtualProperty || columnMetadata.databaseName === tableColumn.name);
            });
            if (droppedTableColumns.length === 0) continue;
            this.connection.logger.logSchemaBuild(`columns dropped in ${table.name}: ` + droppedTableColumns.map((column)=>column.name).join(", "));
            // drop columns from the database
            await this.queryRunner.dropColumns(table, droppedTableColumns);
        }
    }
    /**
     * Adds columns from metadata which does not exist in the table.
     * Columns are created without keys.
     */ async addNewColumns() {
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            // find which columns are new
            const newColumnMetadatas = metadata.columns.filter((columnMetadata)=>{
                return !columnMetadata.isVirtualProperty && !table.columns.find((tableColumn)=>tableColumn.name === columnMetadata.databaseName);
            });
            if (newColumnMetadatas.length === 0) continue;
            // create columns in the database
            const newTableColumnOptions = this.metadataColumnsToTableColumnOptions(newColumnMetadatas);
            const newTableColumns = newTableColumnOptions.map((option)=>new TableColumn_1.TableColumn(option));
            if (newTableColumns.length === 0) continue;
            this.connection.logger.logSchemaBuild(`new columns added: ` + newColumnMetadatas.map((column)=>column.databaseName).join(", "));
            await this.queryRunner.addColumns(table, newTableColumns);
        }
    }
    /**
     * Updates composite primary keys.
     */ async updatePrimaryKeys() {
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            const primaryMetadataColumns = metadata.columns.filter((column)=>column.isPrimary);
            const primaryTableColumns = table.columns.filter((column)=>column.isPrimary);
            if (primaryTableColumns.length !== primaryMetadataColumns.length && primaryMetadataColumns.length > 1) {
                const changedPrimaryColumns = primaryMetadataColumns.map((primaryMetadataColumn)=>{
                    return new TableColumn_1.TableColumn(TableUtils_1.TableUtils.createTableColumnOptions(primaryMetadataColumn, this.connection.driver));
                });
                await this.queryRunner.updatePrimaryKeys(table, changedPrimaryColumns);
            }
        }
    }
    /**
     * Update all exist columns which metadata has changed.
     * Still don't create keys. Also we don't touch foreign keys of the changed columns.
     */ async updateExistColumns() {
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            const changedColumns = this.connection.driver.findChangedColumns(table.columns, metadata.columns);
            if (changedColumns.length === 0) continue;
            // drop all foreign keys that point to this column
            for (const changedColumn of changedColumns){
                await this.dropColumnReferencedForeignKeys(this.getTablePath(metadata), changedColumn.databaseName);
            }
            // drop all composite indices related to this column
            for (const changedColumn of changedColumns){
                await this.dropColumnCompositeIndices(this.getTablePath(metadata), changedColumn.databaseName);
            }
            // drop all composite uniques related to this column
            // Mysql does not support unique constraints.
            if (!(DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql" || this.connection.driver.options.type === "spanner")) {
                for (const changedColumn of changedColumns){
                    await this.dropColumnCompositeUniques(this.getTablePath(metadata), changedColumn.databaseName);
                }
            }
            // generate a map of new/old columns
            const newAndOldTableColumns = changedColumns.map((changedColumn)=>{
                const oldTableColumn = table.columns.find((column)=>column.name === changedColumn.databaseName);
                const newTableColumnOptions = TableUtils_1.TableUtils.createTableColumnOptions(changedColumn, this.connection.driver);
                const newTableColumn = new TableColumn_1.TableColumn(newTableColumnOptions);
                return {
                    oldColumn: oldTableColumn,
                    newColumn: newTableColumn
                };
            });
            if (newAndOldTableColumns.length === 0) continue;
            this.connection.logger.logSchemaBuild(`columns changed in "${table.name}". updating: ` + changedColumns.map((column)=>column.databaseName).join(", "));
            await this.queryRunner.changeColumns(table, newAndOldTableColumns);
        }
    }
    /**
     * Creates composite indices which are missing in db yet.
     */ async createNewIndices() {
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            const newIndices = metadata.indices.filter((indexMetadata)=>!table.indices.find((tableIndex)=>tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true).map((indexMetadata)=>TableIndex_1.TableIndex.create(indexMetadata));
            if (newIndices.length === 0) continue;
            this.connection.logger.logSchemaBuild(`adding new indices ${newIndices.map((index)=>`"${index.name}"`).join(", ")} in table "${table.name}"`);
            await this.queryRunner.createIndices(table, newIndices);
        }
    }
    /**
     * Creates indices for materialized views.
     */ async createNewViewIndices() {
        // Only PostgreSQL supports indices for materialized views.
        if (this.connection.options.type !== "postgres" || !DriverUtils_1.DriverUtils.isPostgresFamily(this.connection.driver)) {
            return;
        }
        const postgresQueryRunner = this.queryRunner;
        for (const metadata of this.viewEntityToSyncMetadatas){
            // check if view does not exist yet
            const view = this.queryRunner.loadedViews.find((view)=>{
                const viewExpression = typeof view.expression === "string" ? view.expression.trim() : view.expression(this.connection).getQuery();
                const metadataExpression = typeof metadata.expression === "string" ? metadata.expression.trim() : metadata.expression(this.connection).getQuery();
                return this.getTablePath(view) === this.getTablePath(metadata) && viewExpression === metadataExpression;
            });
            if (!view || !view.materialized) continue;
            const newIndices = metadata.indices.filter((indexMetadata)=>!view.indices.find((tableIndex)=>tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true).map((indexMetadata)=>TableIndex_1.TableIndex.create(indexMetadata));
            if (newIndices.length === 0) continue;
            this.connection.logger.logSchemaBuild(`adding new indices ${newIndices.map((index)=>`"${index.name}"`).join(", ")} in view "${view.name}"`);
            await postgresQueryRunner.createViewIndices(view, newIndices);
        }
    }
    async createNewChecks() {
        // Mysql does not support check constraints
        if (DriverUtils_1.DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === "aurora-mysql") return;
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            const newChecks = metadata.checks.filter((checkMetadata)=>!table.checks.find((tableCheck)=>tableCheck.name === checkMetadata.name)).map((checkMetadata)=>TableCheck_1.TableCheck.create(checkMetadata));
            if (newChecks.length === 0) continue;
            this.connection.logger.logSchemaBuild(`adding new check constraints: ${newChecks.map((index)=>`"${index.name}"`).join(", ")} in table "${table.name}"`);
            await this.queryRunner.createCheckConstraints(table, newChecks);
        }
    }
    /**
     * Creates composite uniques which are missing in db yet.
     */ async createCompositeUniqueConstraints() {
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            const compositeUniques = metadata.uniques.filter((uniqueMetadata)=>uniqueMetadata.columns.length > 1 && !table.uniques.find((tableUnique)=>tableUnique.name === uniqueMetadata.name)).map((uniqueMetadata)=>TableUnique_1.TableUnique.create(uniqueMetadata));
            if (compositeUniques.length === 0) continue;
            this.connection.logger.logSchemaBuild(`adding new unique constraints: ${compositeUniques.map((unique)=>`"${unique.name}"`).join(", ")} in table "${table.name}"`);
            await this.queryRunner.createUniqueConstraints(table, compositeUniques);
        }
    }
    /**
     * Creates exclusions which are missing in db yet.
     */ async createNewExclusions() {
        // Only PostgreSQL supports exclusion constraints
        if (!(this.connection.driver.options.type === "postgres")) return;
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            const newExclusions = metadata.exclusions.filter((exclusionMetadata)=>!table.exclusions.find((tableExclusion)=>tableExclusion.name === exclusionMetadata.name)).map((exclusionMetadata)=>TableExclusion_1.TableExclusion.create(exclusionMetadata));
            if (newExclusions.length === 0) continue;
            this.connection.logger.logSchemaBuild(`adding new exclusion constraints: ${newExclusions.map((exclusion)=>`"${exclusion.name}"`).join(", ")} in table "${table.name}"`);
            await this.queryRunner.createExclusionConstraints(table, newExclusions);
        }
    }
    /**
     * Creates foreign keys which does not exist in the table yet.
     */ async createForeignKeys() {
        for (const metadata of this.entityToSyncMetadatas){
            const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === this.getTablePath(metadata));
            if (!table) continue;
            const newKeys = metadata.foreignKeys.filter((foreignKey)=>{
                return !table.foreignKeys.find((dbForeignKey)=>dbForeignKey.name === foreignKey.name && this.getTablePath(dbForeignKey) === this.getTablePath(foreignKey.referencedEntityMetadata));
            });
            if (newKeys.length === 0) continue;
            const dbForeignKeys = newKeys.map((foreignKeyMetadata)=>TableForeignKey_1.TableForeignKey.create(foreignKeyMetadata, this.connection.driver));
            this.connection.logger.logSchemaBuild(`creating a foreign keys: ${newKeys.map((key)=>key.name).join(", ")} on table "${table.name}"`);
            await this.queryRunner.createForeignKeys(table, dbForeignKeys);
        }
    }
    /**
     * Drops all foreign keys where given column of the given table is being used.
     */ async dropColumnReferencedForeignKeys(tablePath, columnName) {
        const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === tablePath);
        if (!table) return;
        const tablesWithFK = [];
        const columnForeignKey = table.foreignKeys.find((foreignKey)=>foreignKey.columnNames.indexOf(columnName) !== -1);
        if (columnForeignKey) {
            const clonedTable = table.clone();
            clonedTable.foreignKeys = [
                columnForeignKey
            ];
            tablesWithFK.push(clonedTable);
            table.removeForeignKey(columnForeignKey);
        }
        for (const loadedTable of this.queryRunner.loadedTables){
            const dependForeignKeys = loadedTable.foreignKeys.filter((foreignKey)=>{
                return this.getTablePath(foreignKey) === tablePath && foreignKey.referencedColumnNames.indexOf(columnName) !== -1;
            });
            if (dependForeignKeys.length > 0) {
                const clonedTable = loadedTable.clone();
                clonedTable.foreignKeys = dependForeignKeys;
                tablesWithFK.push(clonedTable);
                dependForeignKeys.forEach((dependForeignKey)=>loadedTable.removeForeignKey(dependForeignKey));
            }
        }
        if (tablesWithFK.length > 0) {
            for (const tableWithFK of tablesWithFK){
                this.connection.logger.logSchemaBuild(`dropping related foreign keys of ${tableWithFK.name}: ${tableWithFK.foreignKeys.map((foreignKey)=>foreignKey.name).join(", ")}`);
                await this.queryRunner.dropForeignKeys(tableWithFK, tableWithFK.foreignKeys);
            }
        }
    }
    /**
     * Drops all composite indices, related to given column.
     */ async dropColumnCompositeIndices(tablePath, columnName) {
        const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === tablePath);
        if (!table) return;
        const relatedIndices = table.indices.filter((index)=>index.columnNames.length > 1 && index.columnNames.indexOf(columnName) !== -1);
        if (relatedIndices.length === 0) return;
        this.connection.logger.logSchemaBuild(`dropping related indices of "${tablePath}"."${columnName}": ${relatedIndices.map((index)=>index.name).join(", ")}`);
        await this.queryRunner.dropIndices(table, relatedIndices);
    }
    /**
     * Drops all composite uniques, related to given column.
     */ async dropColumnCompositeUniques(tablePath, columnName) {
        const table = this.queryRunner.loadedTables.find((table)=>this.getTablePath(table) === tablePath);
        if (!table) return;
        const relatedUniques = table.uniques.filter((unique)=>unique.columnNames.length > 1 && unique.columnNames.indexOf(columnName) !== -1);
        if (relatedUniques.length === 0) return;
        this.connection.logger.logSchemaBuild(`dropping related unique constraints of "${tablePath}"."${columnName}": ${relatedUniques.map((unique)=>unique.name).join(", ")}`);
        await this.queryRunner.dropUniqueConstraints(table, relatedUniques);
    }
    /**
     * Creates new columns from the given column metadatas.
     */ metadataColumnsToTableColumnOptions(columns) {
        return columns.map((columnMetadata)=>TableUtils_1.TableUtils.createTableColumnOptions(columnMetadata, this.connection.driver));
    }
    /**
     * Creates typeorm service table for storing user defined Views and generate columns.
     */ async createTypeormMetadataTable(queryRunner) {
        const schema = this.currentSchema;
        const database = this.currentDatabase;
        const typeormMetadataTable = this.connection.driver.buildTableName(this.connection.metadataTableName, schema, database);
        // Spanner requires at least one primary key in a table.
        // Since we don't have unique column in "typeorm_metadata" table
        // and we should avoid breaking changes, we mark all columns as primary for Spanner driver.
        const isPrimary = this.connection.driver.options.type === "spanner";
        await queryRunner.createTable(new Table_1.Table({
            database: database,
            schema: schema,
            name: typeormMetadataTable,
            columns: [
                {
                    name: "type",
                    type: this.connection.driver.normalizeType({
                        type: this.connection.driver.mappedDataTypes.metadataType
                    }),
                    isNullable: false,
                    isPrimary
                },
                {
                    name: "database",
                    type: this.connection.driver.normalizeType({
                        type: this.connection.driver.mappedDataTypes.metadataDatabase
                    }),
                    isNullable: true,
                    isPrimary
                },
                {
                    name: "schema",
                    type: this.connection.driver.normalizeType({
                        type: this.connection.driver.mappedDataTypes.metadataSchema
                    }),
                    isNullable: true,
                    isPrimary
                },
                {
                    name: "table",
                    type: this.connection.driver.normalizeType({
                        type: this.connection.driver.mappedDataTypes.metadataTable
                    }),
                    isNullable: true,
                    isPrimary
                },
                {
                    name: "name",
                    type: this.connection.driver.normalizeType({
                        type: this.connection.driver.mappedDataTypes.metadataName
                    }),
                    isNullable: true,
                    isPrimary
                },
                {
                    name: "value",
                    type: this.connection.driver.normalizeType({
                        type: this.connection.driver.mappedDataTypes.metadataValue
                    }),
                    isNullable: true,
                    isPrimary
                }
            ]
        }), true);
    }
}
exports.RdbmsSchemaBuilder = RdbmsSchemaBuilder; //# sourceMappingURL=RdbmsSchemaBuilder.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/MongoSchemaBuilder.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MongoSchemaBuilder = void 0;
const SqlInMemory_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/SqlInMemory.js [app-route] (ecmascript)");
/**
 * Creates complete tables schemas in the database based on the entity metadatas.
 *
 * Steps how schema is being built:
 * 1. load list of all tables with complete column and keys information from the db
 * 2. drop all (old) foreign keys that exist in the table, but does not exist in the metadata
 * 3. create new tables that does not exist in the db, but exist in the metadata
 * 4. drop all columns exist (left old) in the db table, but does not exist in the metadata
 * 5. add columns from metadata which does not exist in the table
 * 6. update all exist columns which metadata has changed
 * 7. update primary keys - update old and create new primary key from changed columns
 * 8. create foreign keys which does not exist in the table yet
 * 9. create indices which are missing in db yet, and drops indices which exist in the db, but does not exist in the metadata anymore
 */ class MongoSchemaBuilder {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        this.connection = connection;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates complete schemas for the given entity metadatas.
     */ async build() {
        const queryRunner = this.connection.createQueryRunner();
        const promises = [];
        this.connection.entityMetadatas.forEach((metadata)=>{
            metadata.indices.forEach((index)=>{
                const options = Object.assign({}, {
                    name: index.name,
                    unique: index.isUnique,
                    sparse: index.isSparse,
                    background: index.isBackground
                }, index.expireAfterSeconds === undefined ? {} : {
                    expireAfterSeconds: index.expireAfterSeconds
                });
                promises.push(queryRunner.createCollectionIndex(metadata.tableName, index.columnNamesWithOrderingMap, options));
            });
            metadata.uniques.forEach((unique)=>{
                const options = {
                    name: unique.name,
                    unique: true
                };
                promises.push(queryRunner.createCollectionIndex(metadata.tableName, unique.columnNamesWithOrderingMap, options));
            });
        });
        await Promise.all(promises);
    }
    /**
     * Returns query to be executed by schema builder.
     */ log() {
        return Promise.resolve(new SqlInMemory_1.SqlInMemory());
    }
}
exports.MongoSchemaBuilder = MongoSchemaBuilder; //# sourceMappingURL=MongoSchemaBuilder.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/options/TableCheckOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=TableCheckOptions.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/options/TableColumnOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=TableColumnOptions.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/options/TableExclusionOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=TableExclusionOptions.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/options/TableForeignKeyOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=TableForeignKeyOptions.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/options/TableIndexOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=TableIndexOptions.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/options/TableOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=TableOptions.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/options/TableUniqueOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=TableUniqueOptions.js.map
}}),
"[project]/node_modules/typeorm/schema-builder/options/ViewOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=ViewOptions.js.map
}}),
"[project]/node_modules/typeorm/migration/Migration.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Migration = void 0;
/**
 * Represents entity of the migration in the database.
 */ class Migration {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(id, timestamp, name, instance, transaction){
        this.id = id;
        this.timestamp = timestamp;
        this.name = name;
        this.instance = instance;
        this.transaction = transaction;
    }
}
exports.Migration = Migration; //# sourceMappingURL=Migration.js.map
}}),
"[project]/node_modules/typeorm/migration/MigrationExecutor.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MigrationExecutor = void 0;
const Table_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/Table.js [app-route] (ecmascript)");
const Migration_1 = __turbopack_context__.r("[project]/node_modules/typeorm/migration/Migration.js [app-route] (ecmascript)");
const MssqlParameter_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlserver/MssqlParameter.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Executes migrations: runs pending and reverts previously executed migrations.
 */ class MigrationExecutor {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection, queryRunner){
        this.connection = connection;
        this.queryRunner = queryRunner;
        // -------------------------------------------------------------------------
        // Public Properties
        // -------------------------------------------------------------------------
        /**
         * Indicates how migrations should be run in transactions.
         *   all: all migrations are run in a single transaction
         *   none: all migrations are run without a transaction
         *   each: each migration is run in a separate transaction
         */ this.transaction = "all";
        const { schema } = this.connection.driver.options;
        const database = this.connection.driver.database;
        this.migrationsDatabase = database;
        this.migrationsSchema = schema;
        this.migrationsTableName = connection.options.migrationsTableName || "migrations";
        this.migrationsTable = this.connection.driver.buildTableName(this.migrationsTableName, schema, database);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Tries to execute a single migration given.
     */ async executeMigration(migration) {
        return this.withQueryRunner(async (queryRunner)=>{
            await this.createMigrationsTableIfNotExist(queryRunner);
            // create typeorm_metadata table if it's not created yet
            const schemaBuilder = this.connection.driver.createSchemaBuilder();
            if (InstanceChecker_1.InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {
                await schemaBuilder.createMetadataTableIfNecessary(queryRunner);
            }
            await queryRunner.beforeMigration();
            await migration.instance.up(queryRunner);
            await queryRunner.afterMigration();
            await this.insertExecutedMigration(queryRunner, migration);
            return migration;
        });
    }
    /**
     * Returns an array of all migrations.
     */ async getAllMigrations() {
        return Promise.resolve(this.getMigrations());
    }
    /**
     * Returns an array of all executed migrations.
     */ async getExecutedMigrations() {
        return this.withQueryRunner(async (queryRunner)=>{
            await this.createMigrationsTableIfNotExist(queryRunner);
            return await this.loadExecutedMigrations(queryRunner);
        });
    }
    /**
     * Returns an array of all pending migrations.
     */ async getPendingMigrations() {
        const allMigrations = await this.getAllMigrations();
        const executedMigrations = await this.getExecutedMigrations();
        return allMigrations.filter((migration)=>!executedMigrations.find((executedMigration)=>executedMigration.name === migration.name));
    }
    /**
     * Inserts an executed migration.
     */ insertMigration(migration) {
        return this.withQueryRunner((q)=>this.insertExecutedMigration(q, migration));
    }
    /**
     * Deletes an executed migration.
     */ deleteMigration(migration) {
        return this.withQueryRunner((q)=>this.deleteExecutedMigration(q, migration));
    }
    /**
     * Lists all migrations and whether they have been executed or not
     * returns true if there are unapplied migrations
     */ async showMigrations() {
        let hasUnappliedMigrations = false;
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        // create migrations table if its not created yet
        await this.createMigrationsTableIfNotExist(queryRunner);
        // get all migrations that are executed and saved in the database
        const executedMigrations = await this.loadExecutedMigrations(queryRunner);
        // get all user's migrations in the source code
        const allMigrations = this.getMigrations();
        for (const migration of allMigrations){
            const executedMigration = executedMigrations.find((executedMigration)=>executedMigration.name === migration.name);
            if (executedMigration) {
                this.connection.logger.logSchemaBuild(`[X] ${executedMigration.id} ${migration.name}`);
            } else {
                hasUnappliedMigrations = true;
                this.connection.logger.logSchemaBuild(`[ ] ${migration.name}`);
            }
        }
        // if query runner was created by us then release it
        if (!this.queryRunner) {
            await queryRunner.release();
        }
        return hasUnappliedMigrations;
    }
    /**
     * Executes all pending migrations. Pending migrations are migrations that are not yet executed,
     * thus not saved in the database.
     */ async executePendingMigrations() {
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        // create migrations table if it's not created yet
        await this.createMigrationsTableIfNotExist(queryRunner);
        // create the typeorm_metadata table if it's not created yet
        const schemaBuilder = this.connection.driver.createSchemaBuilder();
        if (InstanceChecker_1.InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {
            await schemaBuilder.createMetadataTableIfNecessary(queryRunner);
        }
        // get all migrations that are executed and saved in the database
        const executedMigrations = await this.loadExecutedMigrations(queryRunner);
        // get the time when last migration was executed
        const lastTimeExecutedMigration = this.getLatestTimestampMigration(executedMigrations);
        // get all user's migrations in the source code
        const allMigrations = this.getMigrations();
        // variable to store all migrations we did successfully
        const successMigrations = [];
        // find all migrations that needs to be executed
        const pendingMigrations = allMigrations.filter((migration)=>{
            // check if we already have executed migration
            const executedMigration = executedMigrations.find((executedMigration)=>executedMigration.name === migration.name);
            if (executedMigration) return false;
            // migration is new and not executed. now check if its timestamp is correct
            // if (lastTimeExecutedMigration && migration.timestamp < lastTimeExecutedMigration.timestamp)
            //     throw new TypeORMError(`New migration found: ${migration.name}, however this migration's timestamp is not valid. Migration's timestamp should not be older then migrations already executed in the database.`);
            // every check is passed means that migration was not run yet and we need to run it
            return true;
        });
        // if no migrations are pending then nothing to do here
        if (!pendingMigrations.length) {
            this.connection.logger.logSchemaBuild(`No migrations are pending`);
            // if query runner was created by us then release it
            if (!this.queryRunner) await queryRunner.release();
            return [];
        }
        // log information about migration execution
        this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);
        this.connection.logger.logSchemaBuild(`${allMigrations.length} migrations were found in the source code.`);
        if (lastTimeExecutedMigration) this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);
        this.connection.logger.logSchemaBuild(`${pendingMigrations.length} migrations are new migrations must be executed.`);
        if (this.transaction === "all") {
            // If we desire to run all migrations in a single transaction
            // but there is a migration that explicitly overrides the transaction mode
            // then we have to fail since we cannot properly resolve that intent
            // In theory we could support overrides that are set to `true`,
            // however to keep the interface more rigid, we fail those too
            const migrationsOverridingTransactionMode = pendingMigrations.filter((migration)=>!(migration.instance?.transaction === undefined));
            if (migrationsOverridingTransactionMode.length > 0) {
                const error = new error_1.ForbiddenTransactionModeOverrideError(migrationsOverridingTransactionMode);
                this.connection.logger.logMigration(`Migrations failed, error: ${error.message}`);
                throw error;
            }
        }
        // Set the per-migration defaults for the transaction mode
        // so that we have one centralized place that controls this behavior
        // When transaction mode is `each` the default is to run in a transaction
        // When transaction mode is `none` the default is to not run in a transaction
        // When transaction mode is `all` the default is to not run in a transaction
        // since all the migrations are already running in one single transaction
        const txModeDefault = {
            each: true,
            none: false,
            all: false
        }[this.transaction];
        for (const migration of pendingMigrations){
            if (migration.instance) {
                const instanceTx = migration.instance.transaction;
                if (instanceTx === undefined) {
                    migration.transaction = txModeDefault;
                } else {
                    migration.transaction = instanceTx;
                }
            }
        }
        // start transaction if its not started yet
        let transactionStartedByUs = false;
        if (this.transaction === "all" && !queryRunner.isTransactionActive) {
            await queryRunner.beforeMigration();
            await queryRunner.startTransaction();
            transactionStartedByUs = true;
        }
        // run all pending migrations in a sequence
        try {
            for (const migration of pendingMigrations){
                if (this.fake) {
                    // directly insert migration record into the database if it is fake
                    await this.insertExecutedMigration(queryRunner, migration);
                    continue;
                }
                if (migration.transaction && !queryRunner.isTransactionActive) {
                    await queryRunner.beforeMigration();
                    await queryRunner.startTransaction();
                    transactionStartedByUs = true;
                }
                await migration.instance.up(queryRunner).catch((error)=>{
                    // informative log about migration failure
                    this.connection.logger.logMigration(`Migration "${migration.name}" failed, error: ${error?.message}`);
                    throw error;
                }).then(async ()=>{
                    // now when migration is executed we need to insert record about it into the database
                    await this.insertExecutedMigration(queryRunner, migration);
                    // commit transaction if we started it
                    if (migration.transaction && transactionStartedByUs) {
                        await queryRunner.commitTransaction();
                        await queryRunner.afterMigration();
                    }
                }).then(()=>{
                    // informative log about migration success
                    successMigrations.push(migration);
                    this.connection.logger.logSchemaBuild(`Migration ${migration.name} has been ${this.fake ? "(fake) " : ""}executed successfully.`);
                });
            }
            // commit transaction if we started it
            if (this.transaction === "all" && transactionStartedByUs) {
                await queryRunner.commitTransaction();
                await queryRunner.afterMigration();
            }
        } catch (err) {
            // rollback transaction if we started it
            if (transactionStartedByUs) {
                try {
                    // we throw original error even if rollback thrown an error
                    await queryRunner.rollbackTransaction();
                } catch (rollbackError) {}
            }
            throw err;
        } finally{
            // if query runner was created by us then release it
            if (!this.queryRunner) await queryRunner.release();
        }
        return successMigrations;
    }
    /**
     * Reverts last migration that were run.
     */ async undoLastMigration() {
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        // create migrations table if it's not created yet
        await this.createMigrationsTableIfNotExist(queryRunner);
        // create typeorm_metadata table if it's not created yet
        const schemaBuilder = this.connection.driver.createSchemaBuilder();
        if (InstanceChecker_1.InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {
            await schemaBuilder.createMetadataTableIfNecessary(queryRunner);
        }
        // get all migrations that are executed and saved in the database
        const executedMigrations = await this.loadExecutedMigrations(queryRunner);
        // get the time when last migration was executed
        const lastTimeExecutedMigration = this.getLatestExecutedMigration(executedMigrations);
        // if no migrations found in the database then nothing to revert
        if (!lastTimeExecutedMigration) {
            this.connection.logger.logSchemaBuild(`No migrations were found in the database. Nothing to revert!`);
            return;
        }
        // get all user's migrations in the source code
        const allMigrations = this.getMigrations();
        // find the instance of the migration we need to remove
        const migrationToRevert = allMigrations.find((migration)=>migration.name === lastTimeExecutedMigration.name);
        // if no migrations found in the database then nothing to revert
        if (!migrationToRevert) throw new error_1.TypeORMError(`No migration ${lastTimeExecutedMigration.name} was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.`);
        // log information about migration execution
        this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);
        this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);
        this.connection.logger.logSchemaBuild(`Now reverting it...`);
        // start transaction if its not started yet
        let transactionStartedByUs = false;
        if (this.transaction !== "none" && !queryRunner.isTransactionActive) {
            await queryRunner.startTransaction();
            transactionStartedByUs = true;
        }
        try {
            if (!this.fake) {
                await queryRunner.beforeMigration();
                await migrationToRevert.instance.down(queryRunner);
                await queryRunner.afterMigration();
            }
            await this.deleteExecutedMigration(queryRunner, migrationToRevert);
            this.connection.logger.logSchemaBuild(`Migration ${migrationToRevert.name} has been ${this.fake ? "(fake) " : ""}reverted successfully.`);
            // commit transaction if we started it
            if (transactionStartedByUs) await queryRunner.commitTransaction();
        } catch (err) {
            // rollback transaction if we started it
            if (transactionStartedByUs) {
                try {
                    // we throw original error even if rollback thrown an error
                    await queryRunner.rollbackTransaction();
                } catch (rollbackError) {}
            }
            throw err;
        } finally{
            // if query runner was created by us then release it
            if (!this.queryRunner) await queryRunner.release();
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates table "migrations" that will store information about executed migrations.
     */ async createMigrationsTableIfNotExist(queryRunner) {
        // If driver is mongo no need to create
        if (this.connection.driver.options.type === "mongodb") {
            return;
        }
        const tableExist = await queryRunner.hasTable(this.migrationsTable); // todo: table name should be configurable
        if (!tableExist) {
            await queryRunner.createTable(new Table_1.Table({
                database: this.migrationsDatabase,
                schema: this.migrationsSchema,
                name: this.migrationsTable,
                columns: [
                    {
                        name: "id",
                        type: this.connection.driver.normalizeType({
                            type: this.connection.driver.mappedDataTypes.migrationId
                        }),
                        isGenerated: true,
                        generationStrategy: "increment",
                        isPrimary: true,
                        isNullable: false
                    },
                    {
                        name: "timestamp",
                        type: this.connection.driver.normalizeType({
                            type: this.connection.driver.mappedDataTypes.migrationTimestamp
                        }),
                        isPrimary: false,
                        isNullable: false
                    },
                    {
                        name: "name",
                        type: this.connection.driver.normalizeType({
                            type: this.connection.driver.mappedDataTypes.migrationName
                        }),
                        isNullable: false
                    }
                ]
            }));
        }
    }
    /**
     * Loads all migrations that were executed and saved into the database (sorts by id).
     */ async loadExecutedMigrations(queryRunner) {
        if (this.connection.driver.options.type === "mongodb") {
            const mongoRunner = queryRunner;
            return mongoRunner.cursor(this.migrationsTableName, {}).sort({
                _id: -1
            }).toArray();
        } else {
            const migrationsRaw = await this.connection.manager.createQueryBuilder(queryRunner).select().orderBy(this.connection.driver.escape("id"), "DESC").from(this.migrationsTable, this.migrationsTableName).getRawMany();
            return migrationsRaw.map((migrationRaw)=>{
                return new Migration_1.Migration(parseInt(migrationRaw["id"]), parseInt(migrationRaw["timestamp"]), migrationRaw["name"]);
            });
        }
    }
    /**
     * Gets all migrations that setup for this connection.
     */ getMigrations() {
        const migrations = this.connection.migrations.map((migration)=>{
            const migrationClassName = migration.name || migration.constructor.name;
            const migrationTimestamp = parseInt(migrationClassName.substr(-13), 10);
            if (!migrationTimestamp || isNaN(migrationTimestamp)) {
                throw new error_1.TypeORMError(`${migrationClassName} migration name is wrong. Migration class name should have a JavaScript timestamp appended.`);
            }
            return new Migration_1.Migration(undefined, migrationTimestamp, migrationClassName, migration);
        });
        this.checkForDuplicateMigrations(migrations);
        // sort them by timestamp
        return migrations.sort((a, b)=>a.timestamp - b.timestamp);
    }
    checkForDuplicateMigrations(migrations) {
        const migrationNames = migrations.map((migration)=>migration.name);
        const duplicates = Array.from(new Set(migrationNames.filter((migrationName, index)=>migrationNames.indexOf(migrationName) < index)));
        if (duplicates.length > 0) {
            throw Error(`Duplicate migrations: ${duplicates.join(", ")}`);
        }
    }
    /**
     * Finds the latest migration (sorts by timestamp) in the given array of migrations.
     */ getLatestTimestampMigration(migrations) {
        const sortedMigrations = migrations.map((migration)=>migration).sort((a, b)=>(a.timestamp - b.timestamp) * -1);
        return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;
    }
    /**
     * Finds the latest migration in the given array of migrations.
     * PRE: Migration array must be sorted by descending id.
     */ getLatestExecutedMigration(sortedMigrations) {
        return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;
    }
    /**
     * Inserts new executed migration's data into migrations table.
     */ async insertExecutedMigration(queryRunner, migration) {
        const values = {};
        if (this.connection.driver.options.type === "mssql") {
            values["timestamp"] = new MssqlParameter_1.MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({
                type: this.connection.driver.mappedDataTypes.migrationTimestamp
            }));
            values["name"] = new MssqlParameter_1.MssqlParameter(migration.name, this.connection.driver.normalizeType({
                type: this.connection.driver.mappedDataTypes.migrationName
            }));
        } else {
            values["timestamp"] = migration.timestamp;
            values["name"] = migration.name;
        }
        if (this.connection.driver.options.type === "mongodb") {
            const mongoRunner = queryRunner;
            await mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).insertOne(values);
        } else {
            const qb = queryRunner.manager.createQueryBuilder();
            await qb.insert().into(this.migrationsTable).values(values).execute();
        }
    }
    /**
     * Delete previously executed migration's data from the migrations table.
     */ async deleteExecutedMigration(queryRunner, migration) {
        const conditions = {};
        if (this.connection.driver.options.type === "mssql") {
            conditions["timestamp"] = new MssqlParameter_1.MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({
                type: this.connection.driver.mappedDataTypes.migrationTimestamp
            }));
            conditions["name"] = new MssqlParameter_1.MssqlParameter(migration.name, this.connection.driver.normalizeType({
                type: this.connection.driver.mappedDataTypes.migrationName
            }));
        } else {
            conditions["timestamp"] = migration.timestamp;
            conditions["name"] = migration.name;
        }
        if (this.connection.driver.options.type === "mongodb") {
            const mongoRunner = queryRunner;
            await mongoRunner.databaseConnection.db(this.connection.driver.database).collection(this.migrationsTableName).deleteOne(conditions);
        } else {
            const qb = queryRunner.manager.createQueryBuilder();
            await qb.delete().from(this.migrationsTable).where(`${qb.escape("timestamp")} = :timestamp`).andWhere(`${qb.escape("name")} = :name`).setParameters(conditions).execute();
        }
    }
    async withQueryRunner(callback) {
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        try {
            return await callback(queryRunner);
        } finally{
            if (!this.queryRunner) {
                await queryRunner.release();
            }
        }
    }
}
exports.MigrationExecutor = MigrationExecutor; //# sourceMappingURL=MigrationExecutor.js.map
}}),
"[project]/node_modules/typeorm/repository/Repository.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Repository = void 0;
const SqlTagUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/SqlTagUtils.js [app-route] (ecmascript)");
/**
 * Repository is supposed to work with your entity objects. Find entities, insert, update, delete, etc.
 */ class Repository {
    // -------------------------------------------------------------------------
    // Accessors
    // -------------------------------------------------------------------------
    /**
     * Entity metadata of the entity current repository manages.
     */ get metadata() {
        return this.manager.connection.getMetadata(this.target);
    }
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(target, manager, queryRunner){
        this.target = target;
        this.manager = manager;
        this.queryRunner = queryRunner;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a new query builder that can be used to build a SQL query.
     */ createQueryBuilder(alias, queryRunner) {
        return this.manager.createQueryBuilder(this.metadata.target, alias || this.metadata.targetName, queryRunner || this.queryRunner);
    }
    /**
     * Checks if entity has an id.
     * If entity composite compose ids, it will check them all.
     */ hasId(entity) {
        return this.manager.hasId(this.metadata.target, entity);
    }
    /**
     * Gets entity mixed id.
     */ getId(entity) {
        return this.manager.getId(this.metadata.target, entity);
    }
    /**
     * Creates a new entity instance or instances.
     * Can copy properties from the given object into new entities.
     */ create(plainEntityLikeOrPlainEntityLikes) {
        return this.manager.create(this.metadata.target, plainEntityLikeOrPlainEntityLikes);
    }
    /**
     * Merges multiple entities (or entity-like objects) into a given entity.
     */ merge(mergeIntoEntity, ...entityLikes) {
        return this.manager.merge(this.metadata.target, mergeIntoEntity, ...entityLikes);
    }
    /**
     * Creates a new entity from the given plain javascript object. If entity already exist in the database, then
     * it loads it (and everything related to it), replaces all values with the new ones from the given object
     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
     * replaced from the new object.
     *
     * Note that given entity-like object must have an entity id / primary key to find entity by.
     * Returns undefined if entity with given id was not found.
     */ preload(entityLike) {
        return this.manager.preload(this.metadata.target, entityLike);
    }
    /**
     * Saves one or many given entities.
     */ save(entityOrEntities, options) {
        return this.manager.save(this.metadata.target, entityOrEntities, options);
    }
    /**
     * Removes one or many given entities.
     */ remove(entityOrEntities, options) {
        return this.manager.remove(this.metadata.target, entityOrEntities, options);
    }
    /**
     * Records the delete date of one or many given entities.
     */ softRemove(entityOrEntities, options) {
        return this.manager.softRemove(this.metadata.target, entityOrEntities, options);
    }
    /**
     * Recovers one or many given entities.
     */ recover(entityOrEntities, options) {
        return this.manager.recover(this.metadata.target, entityOrEntities, options);
    }
    /**
     * Inserts a given entity into the database.
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient INSERT query.
     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
     */ insert(entity) {
        return this.manager.insert(this.metadata.target, entity);
    }
    /**
     * Updates entity partially. Entity can be found by a given conditions.
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient UPDATE query.
     * Does not check if entity exist in the database.
     */ update(criteria, partialEntity) {
        return this.manager.update(this.metadata.target, criteria, partialEntity);
    }
    /**
     * Updates all entities of target type, setting fields from supplied partial entity.
     * This is a primitive operation without cascades, relations or other operations included.
     * Executes fast and efficient UPDATE query without WHERE clause.
     *
     * WARNING! This method updates ALL rows in the target table.
     */ updateAll(partialEntity) {
        return this.manager.updateAll(this.metadata.target, partialEntity);
    }
    /**
     * Inserts a given entity into the database, unless a unique constraint conflicts then updates the entity
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient INSERT ... ON CONFLICT DO UPDATE/ON DUPLICATE KEY UPDATE query.
     */ upsert(entityOrEntities, conflictPathsOrOptions) {
        return this.manager.upsert(this.metadata.target, entityOrEntities, conflictPathsOrOptions);
    }
    /**
     * Deletes entities by a given criteria.
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient DELETE query.
     * Does not check if entity exist in the database.
     */ delete(criteria) {
        return this.manager.delete(this.metadata.target, criteria);
    }
    /**
     * Deletes all entities of target type.
     * This is a primitive operation without cascades, relations or other operations included.
     * Executes fast and efficient DELETE query without WHERE clause.
     *
     * WARNING! This method deletes ALL rows in the target table.
     */ deleteAll() {
        return this.manager.deleteAll(this.metadata.target);
    }
    /**
     * Records the delete date of entities by a given criteria.
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient SOFT-DELETE query.
     * Does not check if entity exist in the database.
     */ softDelete(criteria) {
        return this.manager.softDelete(this.metadata.target, criteria);
    }
    /**
     * Restores entities by a given criteria.
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient SOFT-DELETE query.
     * Does not check if entity exist in the database.
     */ restore(criteria) {
        return this.manager.restore(this.metadata.target, criteria);
    }
    /**
     * Checks whether any entity exists that matches the given options.
     *
     * @deprecated use `exists` method instead, for example:
     *
     * .exists()
     */ exist(options) {
        return this.manager.exists(this.metadata.target, options);
    }
    /**
     * Checks whether any entity exists that matches the given options.
     */ exists(options) {
        return this.manager.exists(this.metadata.target, options);
    }
    /**
     * Checks whether any entity exists that matches the given conditions.
     */ existsBy(where) {
        return this.manager.existsBy(this.metadata.target, where);
    }
    /**
     * Counts entities that match given options.
     * Useful for pagination.
     */ count(options) {
        return this.manager.count(this.metadata.target, options);
    }
    /**
     * Counts entities that match given conditions.
     * Useful for pagination.
     */ countBy(where) {
        return this.manager.countBy(this.metadata.target, where);
    }
    /**
     * Return the SUM of a column
     */ sum(columnName, where) {
        return this.manager.sum(this.metadata.target, columnName, where);
    }
    /**
     * Return the AVG of a column
     */ average(columnName, where) {
        return this.manager.average(this.metadata.target, columnName, where);
    }
    /**
     * Return the MIN of a column
     */ minimum(columnName, where) {
        return this.manager.minimum(this.metadata.target, columnName, where);
    }
    /**
     * Return the MAX of a column
     */ maximum(columnName, where) {
        return this.manager.maximum(this.metadata.target, columnName, where);
    }
    /**
     * Finds entities that match given find options.
     */ async find(options) {
        return this.manager.find(this.metadata.target, options);
    }
    /**
     * Finds entities that match given find options.
     */ async findBy(where) {
        return this.manager.findBy(this.metadata.target, where);
    }
    /**
     * Finds entities that match given find options.
     * Also counts all entities that match given conditions,
     * but ignores pagination settings (from and take options).
     */ findAndCount(options) {
        return this.manager.findAndCount(this.metadata.target, options);
    }
    /**
     * Finds entities that match given WHERE conditions.
     * Also counts all entities that match given conditions,
     * but ignores pagination settings (from and take options).
     */ findAndCountBy(where) {
        return this.manager.findAndCountBy(this.metadata.target, where);
    }
    /**
     * Finds entities with ids.
     * Optionally find options or conditions can be applied.
     *
     * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:
     *
     * .findBy({
     *     id: In([1, 2, 3])
     * })
     */ async findByIds(ids) {
        return this.manager.findByIds(this.metadata.target, ids);
    }
    /**
     * Finds first entity by a given find options.
     * If entity was not found in the database - returns null.
     */ async findOne(options) {
        return this.manager.findOne(this.metadata.target, options);
    }
    /**
     * Finds first entity that matches given where condition.
     * If entity was not found in the database - returns null.
     */ async findOneBy(where) {
        return this.manager.findOneBy(this.metadata.target, where);
    }
    /**
     * Finds first entity that matches given id.
     * If entity was not found in the database - returns null.
     *
     * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
     *
     * .findOneBy({
     *     id: 1 // where "id" is your primary column name
     * })
     */ async findOneById(id) {
        return this.manager.findOneById(this.metadata.target, id);
    }
    /**
     * Finds first entity by a given find options.
     * If entity was not found in the database - rejects with error.
     */ async findOneOrFail(options) {
        return this.manager.findOneOrFail(this.metadata.target, options);
    }
    /**
     * Finds first entity that matches given where condition.
     * If entity was not found in the database - rejects with error.
     */ async findOneByOrFail(where) {
        return this.manager.findOneByOrFail(this.metadata.target, where);
    }
    /**
     * Executes a raw SQL query and returns a raw database results.
     * Raw query execution is supported only by relational databases (MongoDB is not supported).
     *
     * @see [Official docs](https://typeorm.io/repository-api) for examples.
     */ query(query, parameters) {
        return this.manager.query(query, parameters);
    }
    /**
     * Tagged template function that executes raw SQL query and returns raw database results.
     * Template expressions are automatically transformed into database parameters.
     * Raw query execution is supported only by relational databases (MongoDB is not supported).
     * Note: Don't call this as a regular function, it is meant to be used with backticks to tag a template literal.
     * Example: repository.sql`SELECT * FROM table_name WHERE id = ${id}`
     */ async sql(strings, ...values) {
        const { query, parameters } = (0, SqlTagUtils_1.buildSqlTag)({
            driver: this.manager.connection.driver,
            strings: strings,
            expressions: values
        });
        return await this.query(query, parameters);
    }
    /**
     * Clears all the data from the given table/collection (truncates/drops it).
     *
     * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.
     * @see https://stackoverflow.com/a/5972738/925151
     */ clear() {
        return this.manager.clear(this.metadata.target);
    }
    /**
     * Increments some column by provided value of the entities matched given conditions.
     */ increment(conditions, propertyPath, value) {
        return this.manager.increment(this.metadata.target, conditions, propertyPath, value);
    }
    /**
     * Decrements some column by provided value of the entities matched given conditions.
     */ decrement(conditions, propertyPath, value) {
        return this.manager.decrement(this.metadata.target, conditions, propertyPath, value);
    }
    /**
     * Extends repository with provided functions.
     */ extend(customs) {
        // return {
        //     ...this,
        //     ...custom
        // };
        const thisRepo = this.constructor;
        const { target, manager, queryRunner } = this;
        const ChildClass = class extends thisRepo {
            constructor(target, manager, queryRunner){
                super(target, manager, queryRunner);
            }
        };
        for(const custom in customs)ChildClass.prototype[custom] = customs[custom];
        return new ChildClass(target, manager, queryRunner);
    }
}
exports.Repository = Repository; //# sourceMappingURL=Repository.js.map
}}),
"[project]/node_modules/typeorm/repository/MongoRepository.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MongoRepository = void 0;
const Repository_1 = __turbopack_context__.r("[project]/node_modules/typeorm/repository/Repository.js [app-route] (ecmascript)");
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Repository used to manage mongodb documents of a single entity type.
 */ class MongoRepository extends Repository_1.Repository {
    // -------------------------------------------------------------------------
    // Overridden Methods
    // -------------------------------------------------------------------------
    /**
     * Raw SQL query execution is not supported by MongoDB.
     * Calling this method will return an error.
     */ query(query, parameters) {
        throw new TypeORMError_1.TypeORMError(`Queries aren't supported by MongoDB.`);
    }
    /**
     * Using Query Builder with MongoDB is not supported yet.
     * Calling this method will return an error.
     */ createQueryBuilder(alias, queryRunner) {
        throw new TypeORMError_1.TypeORMError(`Query Builder is not supported by MongoDB.`);
    }
    /**
     * Finds entities that match given find options or conditions.
     */ find(options) {
        return this.manager.find(this.metadata.target, options);
    }
    /**
     * Finds entities that match given find options or conditions.
     */ findBy(where) {
        return this.manager.findBy(this.metadata.target, where);
    }
    /**
     * Finds entities that match given find options or conditions.
     * Also counts all entities that match given conditions,
     * but ignores pagination settings (from and take options).
     */ findAndCount(options) {
        return this.manager.findAndCount(this.metadata.target, options);
    }
    /**
     * Finds entities that match given find options or conditions.
     * Also counts all entities that match given conditions,
     * but ignores pagination settings (from and take options).
     */ findAndCountBy(where) {
        return this.manager.findAndCountBy(this.metadata.target, where);
    }
    /**
     * Finds entities by ids.
     * Optionally find options can be applied.
     *
     * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:
     *
     * .findBy({
     *     id: In([1, 2, 3])
     * })
     */ findByIds(ids, options) {
        return this.manager.findByIds(this.metadata.target, ids, options);
    }
    /**
     * Finds first entity that matches given find options.
     */ async findOne(options) {
        return this.manager.findOne(this.metadata.target, options);
    }
    /**
     * Finds first entity that matches given WHERE conditions.
     */ async findOneBy(where) {
        return this.manager.findOneBy(this.metadata.target, where);
    }
    /**
     * Finds entity that matches given id.
     *
     * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
     *
     * .findOneBy({
     *     id: 1 // where "id" is your primary column name
     * })
     */ async findOneById(id) {
        return this.manager.findOneById(this.metadata.target, id);
    }
    /**
     * Finds first entity by a given find options.
     * If entity was not found in the database - rejects with error.
     */ async findOneOrFail(options) {
        return this.manager.findOneOrFail(this.metadata.target, options);
    }
    /**
     * Finds first entity that matches given where condition.
     * If entity was not found in the database - rejects with error.
     */ async findOneByOrFail(where) {
        return this.manager.findOneByOrFail(this.metadata.target, where);
    }
    /**
     * Creates a cursor for a query that can be used to iterate over results from MongoDB.
     */ createCursor(query) {
        return this.manager.createCursor(this.metadata.target, query);
    }
    /**
     * Creates a cursor for a query that can be used to iterate over results from MongoDB.
     * This returns modified version of cursor that transforms each result into Entity model.
     */ createEntityCursor(query) {
        return this.manager.createEntityCursor(this.metadata.target, query);
    }
    /**
     * Execute an aggregation framework pipeline against the collection.
     */ aggregate(pipeline, options) {
        return this.manager.aggregate(this.metadata.target, pipeline, options);
    }
    /**
     * Execute an aggregation framework pipeline against the collection.
     * This returns modified version of cursor that transforms each result into Entity model.
     */ aggregateEntity(pipeline, options) {
        return this.manager.aggregateEntity(this.metadata.target, pipeline, options);
    }
    /**
     * Perform a bulkWrite operation without a fluent API.
     */ bulkWrite(operations, options) {
        return this.manager.bulkWrite(this.metadata.target, operations, options);
    }
    /**
     * Count number of matching documents in the db to a query.
     */ count(query, options) {
        return this.manager.count(this.metadata.target, query || {}, options);
    }
    /**
     * Count number of matching documents in the db to a query.
     */ countDocuments(query, options) {
        return this.manager.countDocuments(this.metadata.target, query || {}, options);
    }
    /**
     * Count number of matching documents in the db to a query.
     */ countBy(query, options) {
        return this.manager.countBy(this.metadata.target, query, options);
    }
    /**
     * Creates an index on the db and collection.
     */ createCollectionIndex(fieldOrSpec, options) {
        return this.manager.createCollectionIndex(this.metadata.target, fieldOrSpec, options);
    }
    /**
     * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.
     * Earlier version of MongoDB will throw a command not supported error.
     * Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
     */ createCollectionIndexes(indexSpecs) {
        return this.manager.createCollectionIndexes(this.metadata.target, indexSpecs);
    }
    /**
     * Delete multiple documents on MongoDB.
     */ deleteMany(query, options) {
        return this.manager.deleteMany(this.metadata.tableName, query, options);
    }
    /**
     * Delete a document on MongoDB.
     */ deleteOne(query, options) {
        return this.manager.deleteOne(this.metadata.tableName, query, options);
    }
    /**
     * The distinct command returns returns a list of distinct values for the given key across a collection.
     */ distinct(key, query, options) {
        return this.manager.distinct(this.metadata.tableName, key, query, options);
    }
    /**
     * Drops an index from this collection.
     */ dropCollectionIndex(indexName, options) {
        return this.manager.dropCollectionIndex(this.metadata.tableName, indexName, options);
    }
    /**
     * Drops all indexes from the collection.
     */ dropCollectionIndexes() {
        return this.manager.dropCollectionIndexes(this.metadata.tableName);
    }
    /**
     * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
     */ findOneAndDelete(query, options) {
        return this.manager.findOneAndDelete(this.metadata.tableName, query, options);
    }
    /**
     * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
     */ findOneAndReplace(query, replacement, options) {
        return this.manager.findOneAndReplace(this.metadata.tableName, query, replacement, options);
    }
    /**
     * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
     */ findOneAndUpdate(query, update, options) {
        return this.manager.findOneAndUpdate(this.metadata.tableName, query, update, options);
    }
    /**
     * Retrieve all the indexes on the collection.
     */ collectionIndexes() {
        return this.manager.collectionIndexes(this.metadata.tableName);
    }
    /**
     * Retrieve all the indexes on the collection.
     */ collectionIndexExists(indexes) {
        return this.manager.collectionIndexExists(this.metadata.tableName, indexes);
    }
    /**
     * Retrieves this collections index info.
     */ collectionIndexInformation(options) {
        return this.manager.collectionIndexInformation(this.metadata.tableName, options);
    }
    /**
     * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
     */ initializeOrderedBulkOp(options) {
        return this.manager.initializeOrderedBulkOp(this.metadata.tableName, options);
    }
    /**
     * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
     */ initializeUnorderedBulkOp(options) {
        return this.manager.initializeUnorderedBulkOp(this.metadata.tableName, options);
    }
    /**
     * Inserts an array of documents into MongoDB.
     */ insertMany(docs, options) {
        return this.manager.insertMany(this.metadata.tableName, docs, options);
    }
    /**
     * Inserts a single document into MongoDB.
     */ insertOne(doc, options) {
        return this.manager.insertOne(this.metadata.tableName, doc, options);
    }
    /**
     * Returns if the collection is a capped collection.
     */ isCapped() {
        return this.manager.isCapped(this.metadata.tableName);
    }
    /**
     * Get the list of all indexes information for the collection.
     */ listCollectionIndexes(options) {
        return this.manager.listCollectionIndexes(this.metadata.tableName, options);
    }
    /**
     * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
     */ rename(newName, options) {
        return this.manager.rename(this.metadata.tableName, newName, options);
    }
    /**
     * Replace a document on MongoDB.
     */ replaceOne(query, doc, options) {
        return this.manager.replaceOne(this.metadata.tableName, query, doc, options);
    }
    /**
     * Get all the collection statistics.
     */ stats(options) {
        return this.manager.stats(this.metadata.tableName, options);
    }
    /**
     * Update multiple documents on MongoDB.
     */ updateMany(query, update, options) {
        return this.manager.updateMany(this.metadata.tableName, query, update, options);
    }
    /**
     * Update a single document on MongoDB.
     */ updateOne(query, update, options) {
        return this.manager.updateOne(this.metadata.tableName, query, update, options);
    }
}
exports.MongoRepository = MongoRepository; //# sourceMappingURL=MongoRepository.js.map
}}),
"[project]/node_modules/typeorm/repository/TreeRepository.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TreeRepository = void 0;
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
const FindOptionsUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOptionsUtils.js [app-route] (ecmascript)");
const TreeRepositoryUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/TreeRepositoryUtils.js [app-route] (ecmascript)");
const Repository_1 = __turbopack_context__.r("[project]/node_modules/typeorm/repository/Repository.js [app-route] (ecmascript)");
/**
 * Repository with additional functions to work with trees.
 *
 * @see Repository
 */ class TreeRepository extends Repository_1.Repository {
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Gets complete trees for all roots in the table.
     */ async findTrees(options) {
        const roots = await this.findRoots(options);
        await Promise.all(roots.map((root)=>this.findDescendantsTree(root, options)));
        return roots;
    }
    /**
     * Roots are entities that have no ancestors. Finds them all.
     */ findRoots(options) {
        const escapeAlias = (alias)=>this.manager.connection.driver.escape(alias);
        const escapeColumn = (column)=>this.manager.connection.driver.escape(column);
        const joinColumn = this.metadata.treeParentRelation.joinColumns[0];
        const parentPropertyName = joinColumn.givenDatabaseName || joinColumn.databaseName;
        const qb = this.createQueryBuilder("treeEntity");
        FindOptionsUtils_1.FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
        return qb.where(`${escapeAlias("treeEntity")}.${escapeColumn(parentPropertyName)} IS NULL`).getMany();
    }
    /**
     * Gets all children (descendants) of the given entity. Returns them all in a flat array.
     */ findDescendants(entity, options) {
        const qb = this.createDescendantsQueryBuilder("treeEntity", "treeClosure", entity);
        FindOptionsUtils_1.FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
        return qb.getMany();
    }
    /**
     * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.
     */ async findDescendantsTree(entity, options) {
        // todo: throw exception if there is no column of this relation?
        const qb = this.createDescendantsQueryBuilder("treeEntity", "treeClosure", entity);
        FindOptionsUtils_1.FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
        const entities = await qb.getRawAndEntities();
        const relationMaps = TreeRepositoryUtils_1.TreeRepositoryUtils.createRelationMaps(this.manager, this.metadata, "treeEntity", entities.raw);
        TreeRepositoryUtils_1.TreeRepositoryUtils.buildChildrenEntityTree(this.metadata, entity, entities.entities, relationMaps, {
            depth: -1,
            ...options
        });
        return entity;
    }
    /**
     * Gets number of descendants of the entity.
     */ countDescendants(entity) {
        return this.createDescendantsQueryBuilder("treeEntity", "treeClosure", entity).getCount();
    }
    /**
     * Creates a query builder used to get descendants of the entities in a tree.
     */ createDescendantsQueryBuilder(alias, closureTableAlias, entity) {
        // create shortcuts for better readability
        const escape = (alias)=>this.manager.connection.driver.escape(alias);
        if (this.metadata.treeType === "closure-table") {
            const joinCondition = this.metadata.closureJunctionTable.descendantColumns.map((column)=>{
                return escape(closureTableAlias) + "." + escape(column.propertyPath) + " = " + escape(alias) + "." + escape(column.referencedColumn.propertyPath);
            }).join(" AND ");
            const parameters = {};
            const whereCondition = this.metadata.closureJunctionTable.ancestorColumns.map((column)=>{
                parameters[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);
                return escape(closureTableAlias) + "." + escape(column.propertyPath) + " = :" + column.referencedColumn.propertyName;
            }).join(" AND ");
            return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters);
        } else if (this.metadata.treeType === "nested-set") {
            const whereCondition = alias + "." + this.metadata.nestedSetLeftColumn.propertyPath + " BETWEEN " + "joined." + this.metadata.nestedSetLeftColumn.propertyPath + " AND joined." + this.metadata.nestedSetRightColumn.propertyPath;
            const parameters = {};
            const joinCondition = this.metadata.treeParentRelation.joinColumns.map((joinColumn)=>{
                const parameterName = joinColumn.referencedColumn.propertyPath.replace(".", "_");
                parameters[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);
                return "joined." + joinColumn.referencedColumn.propertyPath + " = :" + parameterName;
            }).join(" AND ");
            return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, "joined", whereCondition).where(joinCondition, parameters);
        } else if (this.metadata.treeType === "materialized-path") {
            return this.createQueryBuilder(alias).where((qb)=>{
                const subQuery = qb.subQuery().select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, "path").from(this.metadata.target, this.metadata.targetName).whereInIds(this.metadata.getEntityIdMap(entity));
                if (DriverUtils_1.DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {
                    return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE ${subQuery.getQuery()} || '%'`;
                } else {
                    return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE NULLIF(CONCAT(${subQuery.getQuery()}, '%'), '%')`;
                }
            });
        }
        throw new TypeORMError_1.TypeORMError(`Supported only in tree entities`);
    }
    /**
     * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.
     */ findAncestors(entity, options) {
        const qb = this.createAncestorsQueryBuilder("treeEntity", "treeClosure", entity);
        FindOptionsUtils_1.FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
        return qb.getMany();
    }
    /**
     * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.
     */ async findAncestorsTree(entity, options) {
        // todo: throw exception if there is no column of this relation?
        const qb = this.createAncestorsQueryBuilder("treeEntity", "treeClosure", entity);
        FindOptionsUtils_1.FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);
        const entities = await qb.getRawAndEntities();
        const relationMaps = TreeRepositoryUtils_1.TreeRepositoryUtils.createRelationMaps(this.manager, this.metadata, "treeEntity", entities.raw);
        TreeRepositoryUtils_1.TreeRepositoryUtils.buildParentEntityTree(this.metadata, entity, entities.entities, relationMaps);
        return entity;
    }
    /**
     * Gets number of ancestors of the entity.
     */ countAncestors(entity) {
        return this.createAncestorsQueryBuilder("treeEntity", "treeClosure", entity).getCount();
    }
    /**
     * Creates a query builder used to get ancestors of the entities in the tree.
     */ createAncestorsQueryBuilder(alias, closureTableAlias, entity) {
        // create shortcuts for better readability
        // const escape = (alias: string) => this.manager.connection.driver.escape(alias);
        if (this.metadata.treeType === "closure-table") {
            const joinCondition = this.metadata.closureJunctionTable.ancestorColumns.map((column)=>{
                return closureTableAlias + "." + column.propertyPath + " = " + alias + "." + column.referencedColumn.propertyPath;
            }).join(" AND ");
            const parameters = {};
            const whereCondition = this.metadata.closureJunctionTable.descendantColumns.map((column)=>{
                parameters[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);
                return closureTableAlias + "." + column.propertyPath + " = :" + column.referencedColumn.propertyName;
            }).join(" AND ");
            return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters);
        } else if (this.metadata.treeType === "nested-set") {
            const joinCondition = "joined." + this.metadata.nestedSetLeftColumn.propertyPath + " BETWEEN " + alias + "." + this.metadata.nestedSetLeftColumn.propertyPath + " AND " + alias + "." + this.metadata.nestedSetRightColumn.propertyPath;
            const parameters = {};
            const whereCondition = this.metadata.treeParentRelation.joinColumns.map((joinColumn)=>{
                const parameterName = joinColumn.referencedColumn.propertyPath.replace(".", "_");
                parameters[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);
                return "joined." + joinColumn.referencedColumn.propertyPath + " = :" + parameterName;
            }).join(" AND ");
            return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, "joined", joinCondition).where(whereCondition, parameters);
        } else if (this.metadata.treeType === "materialized-path") {
            // example: SELECT * FROM category category WHERE (SELECT mpath FROM `category` WHERE id = 2) LIKE CONCAT(category.mpath, '%');
            return this.createQueryBuilder(alias).where((qb)=>{
                const subQuery = qb.subQuery().select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, "path").from(this.metadata.target, this.metadata.targetName).whereInIds(this.metadata.getEntityIdMap(entity));
                if (DriverUtils_1.DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {
                    return `${subQuery.getQuery()} LIKE ${alias}.${this.metadata.materializedPathColumn.propertyPath} || '%'`;
                } else {
                    return `${subQuery.getQuery()} LIKE CONCAT(${alias}.${this.metadata.materializedPathColumn.propertyPath}, '%')`;
                }
            });
        }
        throw new TypeORMError_1.TypeORMError(`Supported only in tree entities`);
    }
}
exports.TreeRepository = TreeRepository; //# sourceMappingURL=TreeRepository.js.map
}}),
"[project]/node_modules/typeorm/repository/AbstractRepository.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AbstractRepository = void 0;
const CustomRepositoryDoesNotHaveEntityError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/CustomRepositoryDoesNotHaveEntityError.js [app-route] (ecmascript)");
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const CustomRepositoryNotFoundError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/CustomRepositoryNotFoundError.js [app-route] (ecmascript)");
/**
 * Provides abstract class for custom repositories that do not inherit from original orm Repository.
 * Contains all most-necessary methods to simplify code in the custom repository.
 * All methods are protected thus not exposed and it allows to create encapsulated custom repository.
 *
 * @deprecated use Repository.extend function to create a custom repository
 */ class AbstractRepository {
    // -------------------------------------------------------------------------
    // Protected Accessors
    // -------------------------------------------------------------------------
    /**
     * Gets the original ORM repository for the entity that is managed by this repository.
     * If current repository does not manage any entity, then exception will be thrown.
     */ get repository() {
        const target = this.getCustomRepositoryTarget(this);
        if (!target) throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
        return this.manager.getRepository(target);
    }
    /**
     * Gets the original ORM tree repository for the entity that is managed by this repository.
     * If current repository does not manage any entity, then exception will be thrown.
     */ get treeRepository() {
        const target = this.getCustomRepositoryTarget(this);
        if (!target) throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
        return this.manager.getTreeRepository(target);
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a new query builder for the repository's entity that can be used to build a SQL query.
     * If current repository does not manage any entity, then exception will be thrown.
     */ createQueryBuilder(alias) {
        const target = this.getCustomRepositoryTarget(this.constructor);
        if (!target) throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
        return this.manager.getRepository(target).createQueryBuilder(alias);
    }
    /**
     * Creates a new query builder for the given entity that can be used to build a SQL query.
     */ createQueryBuilderFor(entity, alias) {
        return this.getRepositoryFor(entity).createQueryBuilder(alias);
    }
    /**
     * Gets the original ORM repository for the given entity class.
     */ getRepositoryFor(entity) {
        return this.manager.getRepository(entity);
    }
    /**
     * Gets the original ORM tree repository for the given entity class.
     */ getTreeRepositoryFor(entity) {
        return this.manager.getTreeRepository(entity);
    }
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    /**
     * Gets custom repository's managed entity.
     * If given custom repository does not manage any entity then undefined will be returned.
     */ getCustomRepositoryTarget(customRepository) {
        const entityRepositoryMetadataArgs = (0, globals_1.getMetadataArgsStorage)().entityRepositories.find((repository)=>{
            return repository.target === (typeof customRepository === "function" ? customRepository : customRepository.constructor);
        });
        if (!entityRepositoryMetadataArgs) throw new CustomRepositoryNotFoundError_1.CustomRepositoryNotFoundError(customRepository);
        return entityRepositoryMetadataArgs.entity;
    }
}
exports.AbstractRepository = AbstractRepository; //# sourceMappingURL=AbstractRepository.js.map
}}),
"[project]/node_modules/typeorm/repository/BaseEntity.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaseEntity = void 0;
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Base abstract entity for all entities, used in ActiveRecord patterns.
 */ class BaseEntity {
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Checks if entity has an id.
     * If entity composite compose ids, it will check them all.
     */ hasId() {
        const baseEntity = this.constructor;
        return baseEntity.getRepository().hasId(this);
    }
    /**
     * Saves current entity in the database.
     * If entity does not exist in the database then inserts, otherwise updates.
     */ save(options) {
        const baseEntity = this.constructor;
        return baseEntity.getRepository().save(this, options);
    }
    /**
     * Removes current entity from the database.
     */ remove(options) {
        const baseEntity = this.constructor;
        return baseEntity.getRepository().remove(this, options);
    }
    /**
     * Records the delete date of current entity.
     */ softRemove(options) {
        const baseEntity = this.constructor;
        return baseEntity.getRepository().softRemove(this, options);
    }
    /**
     * Recovers a given entity in the database.
     */ recover(options) {
        const baseEntity = this.constructor;
        return baseEntity.getRepository().recover(this, options);
    }
    /**
     * Reloads entity data from the database.
     */ async reload() {
        const baseEntity = this.constructor;
        const id = baseEntity.getRepository().metadata.getEntityIdMap(this);
        if (!id) {
            throw new Error(`Entity doesn't have id-s set, cannot reload entity`);
        }
        const reloadedEntity = await baseEntity.getRepository().findOneByOrFail(id);
        ObjectUtils_1.ObjectUtils.assign(this, reloadedEntity);
    }
    // -------------------------------------------------------------------------
    // Public Static Methods
    // -------------------------------------------------------------------------
    /**
     * Sets DataSource to be used by entity.
     */ static useDataSource(dataSource) {
        this.dataSource = dataSource;
    }
    /**
     * Gets current entity's Repository.
     */ static getRepository() {
        const dataSource = this.dataSource;
        if (!dataSource) throw new Error(`DataSource is not set for this entity.`);
        return dataSource.getRepository(this);
    }
    /**
     * Returns object that is managed by this repository.
     * If this repository manages entity from schema,
     * then it returns a name of that schema instead.
     */ static get target() {
        return this.getRepository().target;
    }
    /**
     * Checks entity has an id.
     * If entity composite compose ids, it will check them all.
     */ static hasId(entity) {
        return this.getRepository().hasId(entity);
    }
    /**
     * Gets entity mixed id.
     */ static getId(entity) {
        return this.getRepository().getId(entity);
    }
    /**
     * Creates a new query builder that can be used to build a SQL query.
     */ static createQueryBuilder(alias) {
        return this.getRepository().createQueryBuilder(alias);
    }
    /**
     * Creates a new entity instance and copies all entity properties from this object into a new entity.
     * Note that it copies only properties that present in entity schema.
     */ static create(entityOrEntities) {
        return this.getRepository().create(entityOrEntities);
    }
    /**
     * Merges multiple entities (or entity-like objects) into a given entity.
     */ static merge(mergeIntoEntity, ...entityLikes) {
        return this.getRepository().merge(mergeIntoEntity, ...entityLikes);
    }
    /**
     * Creates a new entity from the given plain javascript object. If entity already exist in the database, then
     * it loads it (and everything related to it), replaces all values with the new ones from the given object
     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
     * replaced from the new object.
     *
     * Note that given entity-like object must have an entity id / primary key to find entity by.
     * Returns undefined if entity with given id was not found.
     */ static preload(entityLike) {
        const thisRepository = this.getRepository();
        return thisRepository.preload(entityLike);
    }
    /**
     * Saves one or many given entities.
     */ static save(entityOrEntities, options) {
        return this.getRepository().save(entityOrEntities, options);
    }
    /**
     * Removes one or many given entities.
     */ static remove(entityOrEntities, options) {
        return this.getRepository().remove(entityOrEntities, options);
    }
    /**
     * Records the delete date of one or many given entities.
     */ static softRemove(entityOrEntities, options) {
        return this.getRepository().softRemove(entityOrEntities, options);
    }
    /**
     * Inserts a given entity into the database.
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient INSERT query.
     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
     */ static insert(entity) {
        return this.getRepository().insert(entity);
    }
    /**
     * Updates entity partially. Entity can be found by a given conditions.
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient UPDATE query.
     * Does not check if entity exist in the database.
     */ static update(criteria, partialEntity) {
        return this.getRepository().update(criteria, partialEntity);
    }
    /**
     * Inserts a given entity into the database, unless a unique constraint conflicts then updates the entity
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient INSERT ... ON CONFLICT DO UPDATE/ON DUPLICATE KEY UPDATE query.
     */ static upsert(entityOrEntities, conflictPathsOrOptions) {
        return this.getRepository().upsert(entityOrEntities, conflictPathsOrOptions);
    }
    /**
     * Deletes entities by a given criteria.
     * Unlike remove method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient DELETE query.
     * Does not check if entity exist in the database.
     */ static delete(criteria) {
        return this.getRepository().delete(criteria);
    }
    /**
     * Checks whether any entity exists that matches the given options.
     */ static exists(options) {
        return this.getRepository().exists(options);
    }
    /**
     * Checks whether any entity exists that matches the given conditions.
     */ static existsBy(where) {
        return this.getRepository().existsBy(where);
    }
    /**
     * Counts entities that match given options.
     */ static count(options) {
        return this.getRepository().count(options);
    }
    /**
     * Counts entities that match given WHERE conditions.
     */ static countBy(where) {
        return this.getRepository().countBy(where);
    }
    /**
     * Return the SUM of a column
     */ static sum(columnName, where) {
        return this.getRepository().sum(columnName, where);
    }
    /**
     * Return the AVG of a column
     */ static average(columnName, where) {
        return this.getRepository().average(columnName, where);
    }
    /**
     * Return the MIN of a column
     */ static minimum(columnName, where) {
        return this.getRepository().minimum(columnName, where);
    }
    /**
     * Return the MAX of a column
     */ static maximum(columnName, where) {
        return this.getRepository().maximum(columnName, where);
    }
    /**
     * Finds entities that match given options.
     */ static find(options) {
        return this.getRepository().find(options);
    }
    /**
     * Finds entities that match given WHERE conditions.
     */ static findBy(where) {
        return this.getRepository().findBy(where);
    }
    /**
     * Finds entities that match given find options.
     * Also counts all entities that match given conditions,
     * but ignores pagination settings (from and take options).
     */ static findAndCount(options) {
        return this.getRepository().findAndCount(options);
    }
    /**
     * Finds entities that match given WHERE conditions.
     * Also counts all entities that match given conditions,
     * but ignores pagination settings (from and take options).
     */ static findAndCountBy(where) {
        return this.getRepository().findAndCountBy(where);
    }
    /**
     * Finds entities by ids.
     * Optionally find options can be applied.
     *
     * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:
     *
     * .findBy({
     *     id: In([1, 2, 3])
     * })
     */ static findByIds(ids) {
        return this.getRepository().findByIds(ids);
    }
    /**
     * Finds first entity that matches given conditions.
     */ static findOne(options) {
        return this.getRepository().findOne(options);
    }
    /**
     * Finds first entity that matches given conditions.
     */ static findOneBy(where) {
        return this.getRepository().findOneBy(where);
    }
    /**
     * Finds first entity that matches given options.
     *
     * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
     *
     * .findOneBy({
     *     id: 1 // where "id" is your primary column name
     * })
     */ static findOneById(id) {
        return this.getRepository().findOneById(id);
    }
    /**
     * Finds first entity that matches given conditions.
     */ static findOneOrFail(options) {
        return this.getRepository().findOneOrFail(options);
    }
    /**
     * Finds first entity that matches given conditions.
     */ static findOneByOrFail(where) {
        return this.getRepository().findOneByOrFail(where);
    }
    /**
     * Executes a raw SQL query and returns a raw database results.
     * Raw query execution is supported only by relational databases (MongoDB is not supported).
     */ static query(query, parameters) {
        return this.getRepository().query(query, parameters);
    }
    /**
     * Clears all the data from the given table/collection (truncates/drops it).
     */ static clear() {
        return this.getRepository().clear();
    }
}
exports.BaseEntity = BaseEntity; //# sourceMappingURL=BaseEntity.js.map
}}),
"[project]/node_modules/typeorm/repository/RemoveOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=RemoveOptions.js.map
}}),
"[project]/node_modules/typeorm/repository/SaveOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=SaveOptions.js.map
}}),
"[project]/node_modules/typeorm/metadata/EntityMetadata.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntityMetadata = void 0;
const CannotCreateEntityIdMapError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/CannotCreateEntityIdMapError.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const EntityPropertyNotFoundError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/EntityPropertyNotFoundError.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const StringUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/StringUtils.js [app-route] (ecmascript)");
/**
 * Contains all entity metadata.
 */ class EntityMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("EntityMetadata");
        /**
         * Children entity metadatas. Used in inheritance patterns.
         */ this.childEntityMetadatas = [];
        /**
         * All "inheritance tree" from a target entity.
         * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].
         * It also contains child entities for single table inheritance.
         */ this.inheritanceTree = [];
        /**
         * Table type. Tables can be closure, junction, etc.
         */ this.tableType = "regular";
        /**
         * Enables Sqlite "WITHOUT ROWID" modifier for the "CREATE TABLE" statement
         */ this.withoutRowid = false;
        /**
         * Indicates if schema will be synchronized for this entity or not.
         */ this.synchronize = true;
        /**
         * Checks if there any non-nullable column exist in this entity.
         */ this.hasNonNullableRelations = false;
        /**
         * Indicates if this entity metadata of a junction table, or not.
         * Junction table is a table created by many-to-many relationship.
         *
         * Its also possible to understand if entity is junction via tableType.
         */ this.isJunction = false;
        /**
         * Indicates if the entity should be instantiated using the constructor
         * or via allocating a new object via `Object.create()`.
         */ this.isAlwaysUsingConstructor = true;
        /**
         * Checks if this table is a junction table of the closure table.
         * This type is for tables that contain junction metadata of the closure tables.
         */ this.isClosureJunction = false;
        /**
         * Checks if entity's table has multiple primary columns.
         */ this.hasMultiplePrimaryKeys = false;
        /**
         * Indicates if this entity metadata has uuid generated columns.
         */ this.hasUUIDGeneratedColumns = false;
        /**
         * Entity's column metadatas defined by user.
         */ this.ownColumns = [];
        /**
         * Columns of the entity, including columns that are coming from the embeddeds of this entity.
         */ this.columns = [];
        /**
         * Ancestor columns used only in closure junction tables.
         */ this.ancestorColumns = [];
        /**
         * Descendant columns used only in closure junction tables.
         */ this.descendantColumns = [];
        /**
         * All columns except for virtual columns.
         */ this.nonVirtualColumns = [];
        /**
         * In the case if this entity metadata is junction table's entity metadata,
         * this will contain all referenced columns of owner entity.
         */ this.ownerColumns = [];
        /**
         * In the case if this entity metadata is junction table's entity metadata,
         * this will contain all referenced columns of inverse entity.
         */ this.inverseColumns = [];
        /**
         * Gets the column with generated flag.
         */ this.generatedColumns = [];
        /**
         * Gets the primary columns.
         */ this.primaryColumns = [];
        /**
         * Entity's relation metadatas.
         */ this.ownRelations = [];
        /**
         * Relations of the entity, including relations that are coming from the embeddeds of this entity.
         */ this.relations = [];
        /**
         * List of eager relations this metadata has.
         */ this.eagerRelations = [];
        /**
         * List of eager relations this metadata has.
         */ this.lazyRelations = [];
        /**
         * Gets only one-to-one relations of the entity.
         */ this.oneToOneRelations = [];
        /**
         * Gets only owner one-to-one relations of the entity.
         */ this.ownerOneToOneRelations = [];
        /**
         * Gets only one-to-many relations of the entity.
         */ this.oneToManyRelations = [];
        /**
         * Gets only many-to-one relations of the entity.
         */ this.manyToOneRelations = [];
        /**
         * Gets only many-to-many relations of the entity.
         */ this.manyToManyRelations = [];
        /**
         * Gets only owner many-to-many relations of the entity.
         */ this.ownerManyToManyRelations = [];
        /**
         * Gets only owner one-to-one and many-to-one relations.
         */ this.relationsWithJoinColumns = [];
        /**
         * Entity's relation id metadatas.
         */ this.relationIds = [];
        /**
         * Entity's relation id metadatas.
         */ this.relationCounts = [];
        /**
         * Entity's foreign key metadatas.
         */ this.foreignKeys = [];
        /**
         * Entity's embedded metadatas.
         */ this.embeddeds = [];
        /**
         * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.
         */ this.allEmbeddeds = [];
        /**
         * Entity's own indices.
         */ this.ownIndices = [];
        /**
         * Entity's index metadatas.
         */ this.indices = [];
        /**
         * Entity's unique metadatas.
         */ this.uniques = [];
        /**
         * Entity's own uniques.
         */ this.ownUniques = [];
        /**
         * Entity's check metadatas.
         */ this.checks = [];
        /**
         * Entity's exclusion metadatas.
         */ this.exclusions = [];
        /**
         * Entity's own listener metadatas.
         */ this.ownListeners = [];
        /**
         * Entity listener metadatas.
         */ this.listeners = [];
        /**
         * Listener metadatas with "AFTER LOAD" type.
         */ this.afterLoadListeners = [];
        /**
         * Listener metadatas with "BEFORE INSERT" type.
         */ this.beforeInsertListeners = [];
        /**
         * Listener metadatas with "AFTER INSERT" type.
         */ this.afterInsertListeners = [];
        /**
         * Listener metadatas with "BEFORE UPDATE" type.
         */ this.beforeUpdateListeners = [];
        /**
         * Listener metadatas with "AFTER UPDATE" type.
         */ this.afterUpdateListeners = [];
        /**
         * Listener metadatas with "BEFORE REMOVE" type.
         */ this.beforeRemoveListeners = [];
        /**
         * Listener metadatas with "BEFORE SOFT REMOVE" type.
         */ this.beforeSoftRemoveListeners = [];
        /**
         * Listener metadatas with "BEFORE RECOVER" type.
         */ this.beforeRecoverListeners = [];
        /**
         * Listener metadatas with "AFTER REMOVE" type.
         */ this.afterRemoveListeners = [];
        /**
         * Listener metadatas with "AFTER SOFT REMOVE" type.
         */ this.afterSoftRemoveListeners = [];
        /**
         * Listener metadatas with "AFTER RECOVER" type.
         */ this.afterRecoverListeners = [];
        this.connection = options.connection;
        this.inheritanceTree = options.inheritanceTree || [];
        this.inheritancePattern = options.inheritancePattern;
        this.treeType = options.tableTree ? options.tableTree.type : undefined;
        this.treeOptions = options.tableTree ? options.tableTree.options : undefined;
        this.parentClosureEntityMetadata = options.parentClosureEntityMetadata;
        this.tableMetadataArgs = options.args;
        this.target = this.tableMetadataArgs.target;
        this.tableType = this.tableMetadataArgs.type;
        this.expression = this.tableMetadataArgs.expression;
        this.withoutRowid = this.tableMetadataArgs.withoutRowid;
        this.dependsOn = this.tableMetadataArgs.dependsOn;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a new entity.
     */ create(queryRunner, options) {
        const pojo = options && options.pojo === true ? true : false;
        // if target is set to a function (e.g. class) that can be created then create it
        let ret;
        if (typeof this.target === "function" && !pojo) {
            if (!options?.fromDeserializer || this.isAlwaysUsingConstructor) {
                ret = new this.target();
            } else {
                ret = Object.create(this.target.prototype);
            }
        } else {
            // otherwise simply return a new empty object
            ret = {};
        }
        // add "typename" property
        if (this.connection.options.typename) {
            ret[this.connection.options.typename] = this.targetName;
        }
        this.lazyRelations.forEach((relation)=>this.connection.relationLoader.enableLazyLoad(relation, ret, queryRunner));
        return ret;
    }
    /**
     * Checks if given entity has an id.
     */ hasId(entity) {
        if (!entity) return false;
        return this.primaryColumns.every((primaryColumn)=>{
            const value = primaryColumn.getEntityValue(entity);
            return value !== null && value !== undefined && value !== "";
        });
    }
    /**
     * Checks if given entity / object contains ALL primary keys entity must have.
     * Returns true if it contains all of them, false if at least one of them is not defined.
     */ hasAllPrimaryKeys(entity) {
        return this.primaryColumns.every((primaryColumn)=>{
            const value = primaryColumn.getEntityValue(entity);
            return value !== null && value !== undefined;
        });
    }
    /**
     * Ensures that given object is an entity id map.
     * If given id is an object then it means its already id map.
     * If given id isn't an object then it means its a value of the id column
     * and it creates a new id map with this value and name of the primary column.
     */ ensureEntityIdMap(id) {
        if (ObjectUtils_1.ObjectUtils.isObject(id)) return id;
        if (this.hasMultiplePrimaryKeys) throw new CannotCreateEntityIdMapError_1.CannotCreateEntityIdMapError(this, id);
        return this.primaryColumns[0].createValueMap(id);
    }
    /**
     * Gets primary keys of the entity and returns them in a literal object.
     * For example, for Post{ id: 1, title: "hello" } where id is primary it will return { id: 1 }
     * For multiple primary keys it returns multiple keys in object.
     * For primary keys inside embeds it returns complex object literal with keys in them.
     */ getEntityIdMap(entity) {
        if (!entity) return undefined;
        return EntityMetadata.getValueMap(entity, this.primaryColumns, {
            skipNulls: true
        });
    }
    /**
     * Creates a "mixed id map".
     * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.
     * But if entity has a single primary key then it will return just value of the id column of the entity, just value.
     * This is called mixed id map.
     */ getEntityIdMixedMap(entity) {
        if (!entity) return entity;
        const idMap = this.getEntityIdMap(entity);
        if (this.hasMultiplePrimaryKeys) {
            return idMap;
        } else if (idMap) {
            return this.primaryColumns[0].getEntityValue(idMap); // todo: what about parent primary column?
        }
        return idMap;
    }
    /**
     * Compares two different entities by their ids.
     * Returns true if they match, false otherwise.
     */ compareEntities(firstEntity, secondEntity) {
        const firstEntityIdMap = this.getEntityIdMap(firstEntity);
        if (!firstEntityIdMap) return false;
        const secondEntityIdMap = this.getEntityIdMap(secondEntity);
        if (!secondEntityIdMap) return false;
        return OrmUtils_1.OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap);
    }
    /**
     * Finds column with a given property name.
     */ findColumnWithPropertyName(propertyName) {
        return this.columns.find((column)=>column.propertyName === propertyName);
    }
    /**
     * Finds column with a given database name.
     */ findColumnWithDatabaseName(databaseName) {
        return this.columns.find((column)=>column.databaseName === databaseName);
    }
    /**
     * Checks if there is a column or relationship with a given property path.
     */ hasColumnWithPropertyPath(propertyPath) {
        const hasColumn = this.columns.some((column)=>column.propertyPath === propertyPath);
        return hasColumn || this.hasRelationWithPropertyPath(propertyPath);
    }
    /**
     * Finds column with a given property path.
     */ findColumnWithPropertyPath(propertyPath) {
        const column = this.columns.find((column)=>column.propertyPath === propertyPath);
        if (column) return column;
        // in the case if column with property path was not found, try to find a relation with such property path
        // if we find relation and it has a single join column then its the column user was seeking
        const relation = this.relations.find((relation)=>relation.propertyPath === propertyPath);
        if (relation && relation.joinColumns.length === 1) return relation.joinColumns[0];
        return undefined;
    }
    /**
     * Finds column with a given property path.
     * Does not search in relation unlike findColumnWithPropertyPath.
     */ findColumnWithPropertyPathStrict(propertyPath) {
        return this.columns.find((column)=>column.propertyPath === propertyPath);
    }
    /**
     * Finds columns with a given property path.
     * Property path can match a relation, and relations can contain multiple columns.
     */ findColumnsWithPropertyPath(propertyPath) {
        const column = this.columns.find((column)=>column.propertyPath === propertyPath);
        if (column) return [
            column
        ];
        // in the case if column with property path was not found, try to find a relation with such property path
        // if we find relation and it has a single join column then its the column user was seeking
        const relation = this.findRelationWithPropertyPath(propertyPath);
        if (relation && relation.joinColumns) return relation.joinColumns;
        return [];
    }
    /**
     * Checks if there is a relation with the given property path.
     */ hasRelationWithPropertyPath(propertyPath) {
        return this.relations.some((relation)=>relation.propertyPath === propertyPath);
    }
    /**
     * Finds relation with the given property path.
     */ findRelationWithPropertyPath(propertyPath) {
        return this.relations.find((relation)=>relation.propertyPath === propertyPath);
    }
    /**
     * Checks if there is an embedded with a given property path.
     */ hasEmbeddedWithPropertyPath(propertyPath) {
        return this.allEmbeddeds.some((embedded)=>embedded.propertyPath === propertyPath);
    }
    /**
     * Finds embedded with a given property path.
     */ findEmbeddedWithPropertyPath(propertyPath) {
        return this.allEmbeddeds.find((embedded)=>embedded.propertyPath === propertyPath);
    }
    /**
     * Returns an array of databaseNames mapped from provided propertyPaths
     */ mapPropertyPathsToColumns(propertyPaths) {
        return propertyPaths.map((propertyPath)=>{
            const column = this.findColumnWithPropertyPath(propertyPath);
            if (column == null) {
                throw new EntityPropertyNotFoundError_1.EntityPropertyNotFoundError(propertyPath, this);
            }
            return column;
        });
    }
    /**
     * Iterates through entity and finds and extracts all values from relations in the entity.
     * If relation value is an array its being flattened.
     */ extractRelationValuesFromEntity(entity, relations) {
        const relationsAndValues = [];
        relations.forEach((relation)=>{
            const value = relation.getEntityValue(entity);
            if (Array.isArray(value)) {
                value.forEach((subValue)=>relationsAndValues.push([
                        relation,
                        subValue,
                        EntityMetadata.getInverseEntityMetadata(subValue, relation)
                    ]));
            } else if (value) {
                relationsAndValues.push([
                    relation,
                    value,
                    EntityMetadata.getInverseEntityMetadata(value, relation)
                ]);
            }
        });
        return relationsAndValues;
    }
    /**
     * In the case of SingleTableInheritance, find the correct metadata
     * for a given value.
     *
     * @param value The value to find the metadata for.
     * @returns The found metadata for the entity or the base metadata if no matching metadata
     *          was found in the whole inheritance tree.
     */ findInheritanceMetadata(value) {
        // Check for single table inheritance and find the correct metadata in that case.
        // Goal is to use the correct discriminator as we could have a repository
        // for an (abstract) base class and thus the target would not match.
        if (this.inheritancePattern === "STI" && this.childEntityMetadatas.length > 0) {
            // There could be a column on the base class that can manually be set to override the type.
            let manuallySetDiscriminatorValue;
            if (this.discriminatorColumn) {
                manuallySetDiscriminatorValue = value[this.discriminatorColumn.propertyName];
            }
            return this.childEntityMetadatas.find((meta)=>manuallySetDiscriminatorValue === meta.discriminatorValue || value.constructor === meta.target) || this;
        }
        return this;
    }
    // -------------------------------------------------------------------------
    // Private Static Methods
    // -------------------------------------------------------------------------
    static getInverseEntityMetadata(value, relation) {
        return relation.inverseEntityMetadata.findInheritanceMetadata(value);
    }
    // -------------------------------------------------------------------------
    // Public Static Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a property paths for a given entity.
     *
     * @deprecated
     */ static createPropertyPath(metadata, entity, prefix = "") {
        const paths = [];
        Object.keys(entity).forEach((key)=>{
            // check for function is needed in the cases when createPropertyPath used on values contain a function as a value
            // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })
            const parentPath = prefix ? prefix + "." + key : key;
            if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {
                const subPaths = this.createPropertyPath(metadata, entity[key], parentPath);
                paths.push(...subPaths);
            } else {
                const path = prefix ? prefix + "." + key : key;
                paths.push(path);
            }
        });
        return paths;
    }
    /**
     * Finds difference between two entity id maps.
     * Returns items that exist in the first array and absent in the second array.
     */ static difference(firstIdMaps, secondIdMaps) {
        return firstIdMaps.filter((firstIdMap)=>{
            return !secondIdMaps.find((secondIdMap)=>OrmUtils_1.OrmUtils.compareIds(firstIdMap, secondIdMap));
        });
    }
    /**
     * Creates value map from the given values and columns.
     * Examples of usages are primary columns map and join columns map.
     */ static getValueMap(entity, columns, options) {
        return columns.reduce((map, column)=>{
            const value = column.getEntityValueMap(entity, options);
            // make sure that none of the values of the columns are not missing
            if (map === undefined || value === null || value === undefined) return undefined;
            return OrmUtils_1.OrmUtils.mergeDeep(map, value);
        }, {});
    }
    // ---------------------------------------------------------------------
    // Public Builder Methods
    // ---------------------------------------------------------------------
    build() {
        const namingStrategy = this.connection.namingStrategy;
        const entityPrefix = this.connection.options.entityPrefix;
        const entitySkipConstructor = this.connection.options.entitySkipConstructor;
        this.engine = this.tableMetadataArgs.engine;
        this.database = this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata ? this.parentEntityMetadata.database : this.tableMetadataArgs.database;
        if (this.tableMetadataArgs.schema) {
            this.schema = this.tableMetadataArgs.schema;
        } else if (this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata) {
            this.schema = this.parentEntityMetadata.schema;
        } else if (this.connection.options?.hasOwnProperty("schema")) {
            this.schema = this.connection.options.schema;
        }
        this.givenTableName = this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata ? this.parentEntityMetadata.givenTableName : this.tableMetadataArgs.name;
        this.synchronize = this.tableMetadataArgs.synchronize === false ? false : true;
        this.targetName = typeof this.tableMetadataArgs.target === "function" ? this.tableMetadataArgs.target.name : this.tableMetadataArgs.target;
        if (this.tableMetadataArgs.type === "closure-junction") {
            this.tableNameWithoutPrefix = namingStrategy.closureJunctionTableName(this.givenTableName);
        } else if (this.tableMetadataArgs.type === "entity-child" && this.parentEntityMetadata) {
            this.tableNameWithoutPrefix = namingStrategy.tableName(this.parentEntityMetadata.targetName, this.parentEntityMetadata.givenTableName);
        } else {
            this.tableNameWithoutPrefix = namingStrategy.tableName(this.targetName, this.givenTableName);
            if (this.tableMetadataArgs.type === "junction" && this.connection.driver.maxAliasLength && this.connection.driver.maxAliasLength > 0 && this.tableNameWithoutPrefix.length > this.connection.driver.maxAliasLength) {
                // note: we are not using DriverUtils.buildAlias here because we would like to avoid
                // hashed table names. However, current algorithm also isn't perfect, but we cannot
                // change it, since it's a big breaking change. Planned to 0.4.0
                this.tableNameWithoutPrefix = (0, StringUtils_1.shorten)(this.tableNameWithoutPrefix, {
                    separator: "_",
                    segmentLength: 3
                });
            }
        }
        this.tableName = entityPrefix ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;
        this.target = this.target ? this.target : this.tableName;
        this.name = this.targetName ? this.targetName : this.tableName;
        this.expression = this.tableMetadataArgs.expression;
        this.withoutRowid = this.tableMetadataArgs.withoutRowid === true ? true : false;
        this.tablePath = this.connection.driver.buildTableName(this.tableName, this.schema, this.database);
        this.orderBy = typeof this.tableMetadataArgs.orderBy === "function" ? this.tableMetadataArgs.orderBy(this.propertiesMap) : this.tableMetadataArgs.orderBy; // todo: is propertiesMap available here? Looks like its not
        if (entitySkipConstructor !== undefined) {
            this.isAlwaysUsingConstructor = !entitySkipConstructor;
        }
        this.isJunction = this.tableMetadataArgs.type === "closure-junction" || this.tableMetadataArgs.type === "junction";
        this.isClosureJunction = this.tableMetadataArgs.type === "closure-junction";
        this.comment = this.tableMetadataArgs.comment;
    }
    /**
     * Registers a new column in the entity and recomputes all depend properties.
     */ registerColumn(column) {
        if (this.ownColumns.indexOf(column) !== -1) return;
        this.ownColumns.push(column);
        this.columns = this.embeddeds.reduce((columns, embedded)=>columns.concat(embedded.columnsFromTree), this.ownColumns);
        this.primaryColumns = this.columns.filter((column)=>column.isPrimary);
        this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;
        this.hasUUIDGeneratedColumns = this.columns.filter((column)=>column.isGenerated || column.generationStrategy === "uuid").length > 0;
        this.propertiesMap = this.createPropertiesMap();
        if (this.childEntityMetadatas) this.childEntityMetadatas.forEach((entityMetadata)=>entityMetadata.registerColumn(column));
    }
    /**
     * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)
     * in a special format - { propertyName: propertyName }.
     *
     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.
     * This method will create following object:
     * { id: "id", counterEmbed: { count: "counterEmbed.count" }, category: "category" }
     */ createPropertiesMap() {
        const map = {};
        this.columns.forEach((column)=>OrmUtils_1.OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)));
        this.relations.forEach((relation)=>OrmUtils_1.OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)));
        return map;
    }
    /**
     * Checks if entity has any column which rely on returning data,
     * e.g. columns with auto generated value, DEFAULT values considered as dependant of returning data.
     * For example, if we need to have RETURNING after INSERT (or we need returned id for DBs not supporting RETURNING),
     * it means we cannot execute bulk inserts in some cases.
     */ getInsertionReturningColumns() {
        return this.columns.filter((column)=>{
            return column.default !== undefined || column.asExpression !== undefined || column.isGenerated || column.isCreateDate || column.isUpdateDate || column.isDeleteDate || column.isVersion;
        });
    }
}
exports.EntityMetadata = EntityMetadata; //# sourceMappingURL=EntityMetadata.js.map
}}),
"[project]/node_modules/typeorm/metadata/ColumnMetadata.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ColumnMetadata = void 0;
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const ApplyValueTransformers_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ApplyValueTransformers.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * This metadata contains all information about entity's column.
 */ class ColumnMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("ColumnMetadata");
        /**
         * Type's length in the database.
         */ this.length = "";
        /**
         * Indicates if this column is a primary key.
         */ this.isPrimary = false;
        /**
         * Indicates if this column is generated (auto increment or generated other way).
         */ this.isGenerated = false;
        /**
         * Indicates if column can contain nulls or not.
         */ this.isNullable = false;
        /**
         * Indicates if column is selected by query builder or not.
         */ this.isSelect = true;
        /**
         * Indicates if column is inserted by default or not.
         */ this.isInsert = true;
        /**
         * Indicates if column allows updates or not.
         */ this.isUpdate = true;
        /**
         * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.
         * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column
         */ this.zerofill = false;
        /**
         * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.
         */ this.unsigned = false;
        /**
         * Indicates if this column is an array.
         */ this.isArray = false;
        /**
         * Indicates if column is virtual. Virtual columns are not mapped to the entity.
         */ this.isVirtual = false;
        /**
         * Indicates if column is a virtual property. Virtual properties are not mapped to the entity.
         * This property is used in tandem the virtual column decorator.
         * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.
         */ this.isVirtualProperty = false;
        /**
         * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.
         */ this.isDiscriminator = false;
        /**
         * Indicates if column is tree-level column. Tree-level columns are used in closure entities.
         */ this.isTreeLevel = false;
        /**
         * Indicates if this column contains an entity creation date.
         */ this.isCreateDate = false;
        /**
         * Indicates if this column contains an entity update date.
         */ this.isUpdateDate = false;
        /**
         * Indicates if this column contains an entity delete date.
         */ this.isDeleteDate = false;
        /**
         * Indicates if this column contains an entity version.
         */ this.isVersion = false;
        /**
         * Indicates if this column contains an object id.
         */ this.isObjectId = false;
        /**
         * Indicates if this column is nested set's left column.
         * Used only in tree entities with nested-set type.
         */ this.isNestedSetLeft = false;
        /**
         * Indicates if this column is nested set's right column.
         * Used only in tree entities with nested-set type.
         */ this.isNestedSetRight = false;
        /**
         * Indicates if this column is materialized path's path column.
         * Used only in tree entities with materialized path type.
         */ this.isMaterializedPath = false;
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        this.referencedColumn = options.referencedColumn;
        if (options.args.target) this.target = options.args.target;
        if (options.args.propertyName) this.propertyName = options.args.propertyName;
        if (options.args.options.name) this.givenDatabaseName = options.args.options.name;
        if (options.args.options.type) this.type = options.args.options.type;
        if (options.args.options.length) this.length = options.args.options.length ? options.args.options.length.toString() : "";
        if (options.args.options.width) this.width = options.args.options.width;
        if (options.args.options.charset) this.charset = options.args.options.charset;
        if (options.args.options.collation) this.collation = options.args.options.collation;
        if (options.args.options.primary) this.isPrimary = options.args.options.primary;
        if (options.args.options.default === null) // to make sure default: null is the same as nullable: true
        this.isNullable = true;
        if (options.args.options.nullable !== undefined) this.isNullable = options.args.options.nullable;
        if (options.args.options.select !== undefined) this.isSelect = options.args.options.select;
        if (options.args.options.insert !== undefined) this.isInsert = options.args.options.insert;
        if (options.args.options.update !== undefined) this.isUpdate = options.args.options.update;
        if (options.args.options.readonly !== undefined) this.isUpdate = !options.args.options.readonly;
        if (options.args.options.comment) this.comment = options.args.options.comment;
        if (options.args.options.default !== undefined) this.default = options.args.options.default;
        if (options.args.options.onUpdate) this.onUpdate = options.args.options.onUpdate;
        if (options.args.options.generatedIdentity) this.generatedIdentity = options.args.options.generatedIdentity;
        if (options.args.options.scale !== null && options.args.options.scale !== undefined) this.scale = options.args.options.scale;
        if (options.args.options.zerofill) {
            this.zerofill = options.args.options.zerofill;
            this.unsigned = true; // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column
        }
        if (options.args.options.unsigned) this.unsigned = options.args.options.unsigned;
        if (options.args.options.precision !== null) this.precision = options.args.options.precision;
        if (options.args.options.enum) {
            if (ObjectUtils_1.ObjectUtils.isObject(options.args.options.enum) && !Array.isArray(options.args.options.enum)) {
                this.enum = Object.keys(options.args.options.enum)// remove numeric keys - typescript numeric enum types generate them
                // From the documentation: “declaration merging” means that the compiler merges two separate declarations
                // declared with the same name into a single definition. This concept is often used to merge enum with namespace
                // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages
                // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise
                // generated SQL statements contains string representation of that function which leads into syntax error
                // at database side.
                .filter((key)=>isNaN(+key) && typeof options.args.options.enum[key] !== "function").map((key)=>options.args.options.enum[key]);
            } else {
                this.enum = options.args.options.enum;
            }
        }
        if (options.args.options.enumName) {
            this.enumName = options.args.options.enumName;
        }
        if (options.args.options.primaryKeyConstraintName) {
            this.primaryKeyConstraintName = options.args.options.primaryKeyConstraintName;
        }
        if (options.args.options.foreignKeyConstraintName) {
            this.foreignKeyConstraintName = options.args.options.foreignKeyConstraintName;
        }
        if (options.args.options.asExpression) {
            this.asExpression = options.args.options.asExpression;
            this.generatedType = options.args.options.generatedType ? options.args.options.generatedType : "VIRTUAL";
        }
        if (options.args.options.hstoreType) this.hstoreType = options.args.options.hstoreType;
        if (options.args.options.array) this.isArray = options.args.options.array;
        if (options.args.mode) {
            this.isVirtualProperty = options.args.mode === "virtual-property";
            this.isVirtual = options.args.mode === "virtual";
            this.isTreeLevel = options.args.mode === "treeLevel";
            this.isCreateDate = options.args.mode === "createDate";
            this.isUpdateDate = options.args.mode === "updateDate";
            this.isDeleteDate = options.args.mode === "deleteDate";
            this.isVersion = options.args.mode === "version";
            this.isObjectId = options.args.mode === "objectId";
        }
        if (this.isVirtualProperty) {
            this.isInsert = false;
            this.isUpdate = false;
        }
        if (options.args.options.transformer) this.transformer = options.args.options.transformer;
        if (options.args.options.spatialFeatureType) this.spatialFeatureType = options.args.options.spatialFeatureType;
        if (options.args.options.srid !== undefined) this.srid = options.args.options.srid;
        if (options.args.options.query) this.query = options.args.options.query;
        if (this.isTreeLevel) this.type = options.connection.driver.mappedDataTypes.treeLevel;
        if (this.isCreateDate) {
            if (!this.type) this.type = options.connection.driver.mappedDataTypes.createDate;
            if (!this.default) this.default = ()=>options.connection.driver.mappedDataTypes.createDateDefault;
            // skip precision if it was explicitly set to "null" in column options. Otherwise use default precision if it exist.
            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.createDatePrecision) this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;
        }
        if (this.isUpdateDate) {
            if (!this.type) this.type = options.connection.driver.mappedDataTypes.updateDate;
            if (!this.default) this.default = ()=>options.connection.driver.mappedDataTypes.updateDateDefault;
            if (!this.onUpdate) this.onUpdate = options.connection.driver.mappedDataTypes.updateDateDefault;
            // skip precision if it was explicitly set to "null" in column options. Otherwise use default precision if it exist.
            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.updateDatePrecision) this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;
        }
        if (this.isDeleteDate) {
            if (!this.type) this.type = options.connection.driver.mappedDataTypes.deleteDate;
            if (!this.isNullable) this.isNullable = options.connection.driver.mappedDataTypes.deleteDateNullable;
            // skip precision if it was explicitly set to "null" in column options. Otherwise use default precision if it exist.
            if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.deleteDatePrecision) this.precision = options.connection.driver.mappedDataTypes.deleteDatePrecision;
        }
        if (this.isVersion) this.type = options.connection.driver.mappedDataTypes.version;
        if (options.closureType) this.closureType = options.closureType;
        if (options.nestedSetLeft) this.isNestedSetLeft = options.nestedSetLeft;
        if (options.nestedSetRight) this.isNestedSetRight = options.nestedSetRight;
        if (options.materializedPath) this.isMaterializedPath = options.materializedPath;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Creates entity id map from the given entity ids array.
     */ createValueMap(value, useDatabaseName = false) {
        // extract column value from embeds of entity if column is in embedded
        if (this.embeddedMetadata) {
            // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
            // we need to get value of "id" column from the post real entity object and return it in a
            // { data: { information: { counters: { id: ... } } } } format
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const propertyNames = [
                ...this.embeddedMetadata.parentPropertyNames
            ];
            // now need to access post[data][information][counters] to get column value from the counters
            // and on each step we need to create complex literal object, e.g. first { data },
            // then { data: { information } }, then { data: { information: { counters } } },
            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }
            // this recursive function helps doing that
            const extractEmbeddedColumnValue = (propertyNames, map)=>{
                const propertyName = propertyNames.shift();
                if (propertyName) {
                    map[propertyName] = {};
                    extractEmbeddedColumnValue(propertyNames, map[propertyName]);
                    return map;
                }
                // this is bugfix for #720 when increment number is bigint we need to make sure its a string
                if ((this.generationStrategy === "increment" || this.generationStrategy === "rowid") && this.type === "bigint" && value !== null) value = String(value);
                map[useDatabaseName ? this.databaseName : this.propertyName] = value;
                return map;
            };
            return extractEmbeddedColumnValue(propertyNames, {});
        } else {
            // no embeds - no problems. Simply return column property name and its value of the entity
            // this is bugfix for #720 when increment number is bigint we need to make sure its a string
            if ((this.generationStrategy === "increment" || this.generationStrategy === "rowid") && this.type === "bigint" && value !== null) value = String(value);
            return {
                [useDatabaseName ? this.databaseName : this.propertyName]: value
            };
        }
    }
    /**
     * Extracts column value and returns its column name with this value in a literal object.
     * If column is in embedded (or recursive embedded) it returns complex literal object.
     *
     * Examples what this method can return depend if this column is in embeds.
     * { id: 1 } or { title: "hello" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }
     */ getEntityValueMap(entity, options) {
        const returnNulls = false; // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.
        // extract column value from embeds of entity if column is in embedded
        if (this.embeddedMetadata) {
            // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
            // we need to get value of "id" column from the post real entity object and return it in a
            // { data: { information: { counters: { id: ... } } } } format
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const propertyNames = [
                ...this.embeddedMetadata.parentPropertyNames
            ];
            const isEmbeddedArray = this.embeddedMetadata.isArray;
            // now need to access post[data][information][counters] to get column value from the counters
            // and on each step we need to create complex literal object, e.g. first { data },
            // then { data: { information } }, then { data: { information: { counters } } },
            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }
            // this recursive function helps doing that
            const extractEmbeddedColumnValue = (propertyNames, value)=>{
                if (value === undefined) {
                    return {};
                }
                const propertyName = propertyNames.shift();
                if (propertyName) {
                    const submap = extractEmbeddedColumnValue(propertyNames, value[propertyName]);
                    if (Object.keys(submap).length > 0) {
                        return {
                            [propertyName]: submap
                        };
                    }
                    return {};
                }
                if (isEmbeddedArray && Array.isArray(value)) {
                    return value.map((v)=>({
                            [this.propertyName]: v[this.propertyName]
                        }));
                }
                if (value[this.propertyName] !== undefined && (returnNulls === false || value[this.propertyName] !== null)) {
                    return {
                        [this.propertyName]: value[this.propertyName]
                    };
                }
                return {};
            };
            const map = extractEmbeddedColumnValue(propertyNames, entity);
            return Object.keys(map).length > 0 ? map : undefined;
        } else {
            // no embeds - no problems. Simply return column property name and its value of the entity
            /**
             * Object.getOwnPropertyDescriptor checks if the relation is lazy, in which case value is a Promise
             * DO NOT use `entity[
                this.relationMetadata.propertyName] instanceof Promise`, which will invoke property getter and make unwanted DB request
             * refer: https://github.com/typeorm/typeorm/pull/8676#issuecomment-1049906331
             */ if (this.relationMetadata && !Object.getOwnPropertyDescriptor(entity, this.relationMetadata.propertyName)?.get && entity[this.relationMetadata.propertyName] && ObjectUtils_1.ObjectUtils.isObject(entity[this.relationMetadata.propertyName])) {
                if (this.relationMetadata.joinColumns.length > 1) {
                    const map = this.relationMetadata.joinColumns.reduce((map, joinColumn)=>{
                        const value = joinColumn.referencedColumn.getEntityValueMap(entity[this.relationMetadata.propertyName]);
                        if (value === undefined) return map;
                        return OrmUtils_1.OrmUtils.mergeDeep(map, value);
                    }, {});
                    if (Object.keys(map).length > 0) return {
                        [this.propertyName]: map
                    };
                } else {
                    const value = this.relationMetadata.joinColumns[0].referencedColumn.getEntityValue(entity[this.relationMetadata.propertyName]);
                    if (value) {
                        return {
                            [this.propertyName]: value
                        };
                    }
                }
                return undefined;
            } else {
                if (entity[this.propertyName] !== undefined && (returnNulls === false || entity[this.propertyName] !== null)) {
                    return {
                        [this.propertyName]: entity[this.propertyName]
                    };
                }
                return undefined;
            }
        }
    }
    /**
     * Extracts column value from the given entity.
     * If column is in embedded (or recursive embedded) it extracts its value from there.
     */ getEntityValue(entity, transform = false) {
        if (entity === undefined || entity === null) return undefined;
        // extract column value from embeddeds of entity if column is in embedded
        let value = undefined;
        if (this.embeddedMetadata) {
            // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
            // we need to get value of "id" column from the post real entity object
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const propertyNames = [
                ...this.embeddedMetadata.parentPropertyNames
            ];
            const isEmbeddedArray = this.embeddedMetadata.isArray;
            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters
            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed
            const extractEmbeddedColumnValue = (propertyNames, value)=>{
                const propertyName = propertyNames.shift();
                return propertyName && value ? extractEmbeddedColumnValue(propertyNames, value[propertyName]) : value;
            };
            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]
            const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);
            if (embeddedObject) {
                if (this.relationMetadata && this.referencedColumn) {
                    const relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);
                    if (relatedEntity && ObjectUtils_1.ObjectUtils.isObject(relatedEntity) && !InstanceChecker_1.InstanceChecker.isFindOperator(relatedEntity) && !Buffer.isBuffer(relatedEntity)) {
                        value = this.referencedColumn.getEntityValue(relatedEntity);
                    } else if (embeddedObject[this.propertyName] && ObjectUtils_1.ObjectUtils.isObject(embeddedObject[this.propertyName]) && !InstanceChecker_1.InstanceChecker.isFindOperator(embeddedObject[this.propertyName]) && !Buffer.isBuffer(embeddedObject[this.propertyName]) && !(embeddedObject[this.propertyName] instanceof Date)) {
                        value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);
                    } else {
                        value = embeddedObject[this.propertyName];
                    }
                } else if (this.referencedColumn) {
                    value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);
                } else if (isEmbeddedArray && Array.isArray(embeddedObject)) {
                    value = embeddedObject.map((o)=>o[this.propertyName]);
                } else {
                    value = embeddedObject[this.propertyName];
                }
            }
        } else {
            // no embeds - no problems. Simply return column name by property name of the entity
            if (this.relationMetadata && this.referencedColumn) {
                const relatedEntity = this.relationMetadata.getEntityValue(entity);
                if (relatedEntity && ObjectUtils_1.ObjectUtils.isObject(relatedEntity) && !InstanceChecker_1.InstanceChecker.isFindOperator(relatedEntity) && !(typeof relatedEntity === "function") && !Buffer.isBuffer(relatedEntity)) {
                    value = this.referencedColumn.getEntityValue(relatedEntity);
                } else if (entity[this.propertyName] && ObjectUtils_1.ObjectUtils.isObject(entity[this.propertyName]) && !InstanceChecker_1.InstanceChecker.isFindOperator(entity[this.propertyName]) && !(typeof entity[this.propertyName] === "function") && !Buffer.isBuffer(entity[this.propertyName]) && !(entity[this.propertyName] instanceof Date)) {
                    value = this.referencedColumn.getEntityValue(entity[this.propertyName]);
                } else {
                    value = entity[this.propertyName];
                }
            } else if (this.referencedColumn) {
                value = this.referencedColumn.getEntityValue(entity[this.propertyName]);
            } else {
                value = entity[this.propertyName];
            }
        }
        if (transform && this.transformer) value = ApplyValueTransformers_1.ApplyValueTransformers.transformTo(this.transformer, value);
        return value;
    }
    /**
     * Sets given entity's column value.
     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.
     */ setEntityValue(entity, value) {
        if (this.embeddedMetadata) {
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const extractEmbeddedColumnValue = (embeddedMetadatas, map)=>{
                // if (!object[embeddedMetadata.propertyName])
                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();
                const embeddedMetadata = embeddedMetadatas.shift();
                if (embeddedMetadata) {
                    if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();
                    extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);
                    return map;
                }
                map[this.propertyName] = value;
                return map;
            };
            return extractEmbeddedColumnValue([
                ...this.embeddedMetadata.embeddedMetadataTree
            ], entity);
        } else {
            // we write a deep object in this entity only if the column is virtual
            // because if its not virtual it means the user defined a real column for this relation
            // also we don't do it if column is inside a junction table
            if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) {
                if (!(this.propertyName in entity)) {
                    entity[this.propertyName] = {};
                }
                entity[this.propertyName][this.referencedColumn.propertyName] = value;
            } else {
                entity[this.propertyName] = value;
            }
        }
    }
    /**
     * Compares given entity's column value with a given value.
     */ compareEntityValue(entity, valueToCompareWith) {
        const columnValue = this.getEntityValue(entity);
        if (typeof columnValue?.equals === "function") {
            return columnValue.equals(valueToCompareWith);
        }
        return columnValue === valueToCompareWith;
    }
    // ---------------------------------------------------------------------
    // Builder Methods
    // ---------------------------------------------------------------------
    build(connection) {
        this.propertyPath = this.buildPropertyPath();
        this.propertyAliasName = this.propertyPath.replace(".", "_");
        this.databaseName = this.buildDatabaseName(connection);
        this.databasePath = this.buildDatabasePath();
        this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);
        return this;
    }
    buildPropertyPath() {
        let path = "";
        if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(".") + ".";
        path += this.propertyName;
        // we add reference column to property path only if this column is virtual
        // because if its not virtual it means user defined a real column for this relation
        // also we don't do it if column is inside a junction table
        if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) path += "." + this.referencedColumn.propertyName;
        return path;
    }
    buildDatabasePath() {
        let path = "";
        if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(".") + ".";
        path += this.databaseName;
        // we add reference column to property path only if this column is virtual
        // because if its not virtual it means user defined a real column for this relation
        // also we don't do it if column is inside a junction table
        if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.databaseName !== this.databaseName) path += "." + this.referencedColumn.databaseName;
        return path;
    }
    buildDatabaseName(connection) {
        let propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPrefixes : [];
        if (connection.driver.options.type === "mongodb") // we don't need to include embedded name for the mongodb column names
        propertyNames = [];
        return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);
    }
}
exports.ColumnMetadata = ColumnMetadata; //# sourceMappingURL=ColumnMetadata.js.map
}}),
"[project]/node_modules/typeorm/metadata/IndexMetadata.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IndexMetadata = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Index metadata contains all information about table's index.
 */ class IndexMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        /**
         * Indicates if this index must be unique.
         */ this.isUnique = false;
        /**
         * The SPATIAL modifier indexes the entire column and does not allow indexed columns to contain NULL values.
         * Works only in MySQL.
         */ this.isSpatial = false;
        /**
         * The FULLTEXT modifier indexes the entire column and does not allow prefixing.
         * Works only in MySQL.
         */ this.isFulltext = false;
        /**
         * NULL_FILTERED indexes are particularly useful for indexing sparse columns, where most rows contain a NULL value.
         * In these cases, the NULL_FILTERED index can be considerably smaller and more efficient to maintain than
         * a normal index that includes NULL values.
         *
         * Works only in Spanner.
         */ this.isNullFiltered = false;
        /**
         * Indicates if this index must synchronize with database index.
         */ this.synchronize = true;
        /**
         * Indexed columns.
         */ this.columns = [];
        /**
         * Map of column names with order set.
         * Used only by MongoDB driver.
         */ this.columnNamesWithOrderingMap = {};
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        if (options.columns) this.columns = options.columns;
        if (options.args) {
            this.target = options.args.target;
            if (options.args.synchronize !== null && options.args.synchronize !== undefined) this.synchronize = options.args.synchronize;
            this.isUnique = !!options.args.unique;
            this.isSpatial = !!options.args.spatial;
            this.isFulltext = !!options.args.fulltext;
            this.isNullFiltered = !!options.args.nullFiltered;
            this.parser = options.args.parser;
            this.where = options.args.where;
            this.isSparse = options.args.sparse;
            this.isBackground = options.args.background;
            this.isConcurrent = options.args.concurrent;
            this.expireAfterSeconds = options.args.expireAfterSeconds;
            this.givenName = options.args.name;
            this.givenColumnNames = options.args.columns;
        }
    }
    // ---------------------------------------------------------------------
    // Public Build Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend index properties.
     * Must be called after all entity metadata's properties map, columns and relations are built.
     */ build(namingStrategy) {
        if (this.synchronize === false) {
            this.name = this.givenName;
            return this;
        }
        const map = {};
        // if columns already an array of string then simply return it
        if (this.givenColumnNames) {
            let columnPropertyPaths = [];
            if (Array.isArray(this.givenColumnNames)) {
                columnPropertyPaths = this.givenColumnNames.map((columnName)=>{
                    if (this.embeddedMetadata) return this.embeddedMetadata.propertyPath + "." + columnName;
                    return columnName.trim();
                });
                columnPropertyPaths.forEach((propertyPath)=>map[propertyPath] = 1);
            } else {
                // todo: indices in embeds are not implemented in this syntax. deprecate this syntax?
                // if columns is a function that returns array of field names then execute it and get columns names from it
                const columnsFnResult = this.givenColumnNames(this.entityMetadata.propertiesMap);
                if (Array.isArray(columnsFnResult)) {
                    columnPropertyPaths = columnsFnResult.map((i)=>String(i));
                    columnPropertyPaths.forEach((name)=>map[name] = 1);
                } else {
                    columnPropertyPaths = Object.keys(columnsFnResult).map((i)=>String(i));
                    Object.keys(columnsFnResult).forEach((columnName)=>map[columnName] = columnsFnResult[columnName]);
                }
            }
            this.columns = columnPropertyPaths.map((propertyPath)=>{
                const columnWithSameName = this.entityMetadata.columns.find((column)=>column.propertyPath === propertyPath);
                if (columnWithSameName) {
                    return [
                        columnWithSameName
                    ];
                }
                const relationWithSameName = this.entityMetadata.relations.find((relation)=>relation.isWithJoinColumn && relation.propertyName === propertyPath);
                if (relationWithSameName) {
                    return relationWithSameName.joinColumns;
                }
                const indexName = this.givenName ? '"' + this.givenName + '" ' : "";
                const entityName = this.entityMetadata.targetName;
                throw new error_1.TypeORMError(`Index ${indexName}contains column that is missing in the entity (${entityName}): ` + propertyPath);
            }).reduce((a, b)=>a.concat(b));
        }
        this.columnNamesWithOrderingMap = Object.keys(map).reduce((updatedMap, key)=>{
            const column = this.entityMetadata.columns.find((column)=>column.propertyPath === key);
            if (column) updatedMap[column.databasePath] = map[key];
            return updatedMap;
        }, {});
        this.name = this.givenName ? this.givenName : namingStrategy.indexName(this.entityMetadata.tableName, this.columns.map((column)=>column.databaseName), this.where);
        return this;
    }
}
exports.IndexMetadata = IndexMetadata; //# sourceMappingURL=IndexMetadata.js.map
}}),
"[project]/node_modules/typeorm/metadata/RelationMetadata.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationMetadata = void 0;
const EntityMetadata_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/EntityMetadata.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
/**
 * Contains all information about some entity's relation.
 */ class RelationMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        /**
         * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.
         */ this.isTreeParent = false;
        /**
         * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.
         */ this.isTreeChildren = false;
        /**
         * Indicates if this relation's column is a primary key.
         * Can be used only for many-to-one and owner one-to-one relations.
         */ this.isPrimary = false;
        /**
         * Indicates if this relation is lazily loaded.
         */ this.isLazy = false;
        /**
         * Indicates if this relation is eagerly loaded.
         */ this.isEager = false;
        /**
         * Indicates if persistence is enabled for the relation.
         * By default its enabled, but if you want to avoid any changes in the relation to be reflected in the database you can disable it.
         * If its disabled you can only change a relation from inverse side of a relation or using relation query builder functionality.
         * This is useful for performance optimization since its disabling avoid multiple extra queries during entity save.
         */ this.persistenceEnabled = true;
        /**
         * If set to true then related objects are allowed to be inserted to the database.
         */ this.isCascadeInsert = false;
        /**
         * If set to true then related objects are allowed to be updated in the database.
         */ this.isCascadeUpdate = false;
        /**
         * If set to true then related objects are allowed to be remove from the database.
         */ this.isCascadeRemove = false;
        /**
         * If set to true then related objects are allowed to be soft-removed from the database.
         */ this.isCascadeSoftRemove = false;
        /**
         * If set to true then related objects are allowed to be recovered from the database.
         */ this.isCascadeRecover = false;
        /**
         * Indicates if relation column value can be nullable or not.
         */ this.isNullable = true;
        /**
         * Indicates whether foreign key constraints will be created for join columns.
         * Can be used only for many-to-one and owner one-to-one relations.
         * Defaults to true.
         */ this.createForeignKeyConstraints = true;
        /**
         * Indicates if this side is an owner of this relation.
         */ this.isOwning = false;
        /**
         * Checks if this relation's type is "one-to-one".
         */ this.isOneToOne = false;
        /**
         * Checks if this relation is owner side of the "one-to-one" relation.
         * Owner side means this side of relation has a join column in the table.
         */ this.isOneToOneOwner = false;
        /**
         * Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).
         */ this.isWithJoinColumn = false;
        /**
         * Checks if this relation is NOT owner side of the "one-to-one" relation.
         * NOT owner side means this side of relation does not have a join column in the table.
         */ this.isOneToOneNotOwner = false;
        /**
         * Checks if this relation's type is "one-to-many".
         */ this.isOneToMany = false;
        /**
         * Checks if this relation's type is "many-to-one".
         */ this.isManyToOne = false;
        /**
         * Checks if this relation's type is "many-to-many".
         */ this.isManyToMany = false;
        /**
         * Checks if this relation's type is "many-to-many", and is owner side of the relationship.
         * Owner side means this side of relation has a join table.
         */ this.isManyToManyOwner = false;
        /**
         * Checks if this relation's type is "many-to-many", and is NOT owner side of the relationship.
         * Not owner side means this side of relation does not have a join table.
         */ this.isManyToManyNotOwner = false;
        /**
         * Foreign keys created for this relation.
         */ this.foreignKeys = [];
        /**
         * Join table columns.
         * Join columns can be obtained only from owner side of the relation.
         * From non-owner side of the relation join columns will be empty.
         * If this relation is a many-to-one/one-to-one then it takes join columns from the current entity.
         * If this relation is many-to-many then it takes all owner join columns from the junction entity.
         */ this.joinColumns = [];
        /**
         * Inverse join table columns.
         * Inverse join columns are supported only for many-to-many relations
         * and can be obtained only from owner side of the relation.
         * From non-owner side of the relation join columns will be undefined.
         */ this.inverseJoinColumns = [];
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        const args = options.args;
        this.target = args.target;
        this.propertyName = args.propertyName;
        this.relationType = args.relationType;
        if (args.inverseSideProperty) this.givenInverseSidePropertyFactory = args.inverseSideProperty;
        this.isLazy = args.isLazy || false;
        // this.isCascadeInsert = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf("insert") !== -1);
        // this.isCascadeUpdate = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf("update") !== -1);
        // this.isCascadeRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf("remove") !== -1);
        // this.isCascadeSoftRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf("soft-remove") !== -1);
        // this.isCascadeRecover = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf("recover") !== -1);
        this.isCascadeInsert = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("insert") !== -1;
        this.isCascadeUpdate = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("update") !== -1;
        this.isCascadeRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("remove") !== -1;
        this.isCascadeSoftRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("soft-remove") !== -1;
        this.isCascadeRecover = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf("recover") !== -1;
        // this.isPrimary = args.options.primary || false;
        this.isNullable = args.options.nullable === false || this.isPrimary ? false : true;
        this.onDelete = args.options.onDelete;
        this.onUpdate = args.options.onUpdate;
        this.deferrable = args.options.deferrable;
        this.createForeignKeyConstraints = args.options.createForeignKeyConstraints === false ? false : true;
        this.isEager = args.options.eager || false;
        this.persistenceEnabled = args.options.persistence === false ? false : true;
        this.orphanedRowAction = args.options.orphanedRowAction || "nullify";
        this.isTreeParent = args.isTreeParent || false;
        this.isTreeChildren = args.isTreeChildren || false;
        if (typeof args.type === "function") {
            this.type = typeof args.type === "function" ? args.type() : args.type;
        } else if (InstanceChecker_1.InstanceChecker.isEntitySchema(args.type)) {
            this.type = args.type.options.name;
        } else if (ObjectUtils_1.ObjectUtils.isObject(args.type) && typeof args.type.name === "string") {
            this.type = args.type.name;
        } else {
            this.type = args.type;
        }
        this.isOneToOne = this.relationType === "one-to-one";
        this.isOneToMany = this.relationType === "one-to-many";
        this.isManyToOne = this.relationType === "many-to-one";
        this.isManyToMany = this.relationType === "many-to-many";
        this.isOneToOneNotOwner = this.isOneToOne ? true : false;
        this.isManyToManyNotOwner = this.isManyToMany ? true : false;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Creates join column ids map from the given related entity ids array.
     */ getRelationIdMap(entity) {
        const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;
        const referencedColumns = joinColumns.map((joinColumn)=>joinColumn.referencedColumn);
        // console.log("entity", entity);
        // console.log("referencedColumns", referencedColumns);
        return EntityMetadata_1.EntityMetadata.getValueMap(entity, referencedColumns);
    }
    /**
     * Ensures that given object is an entity id map.
     * If given id is an object then it means its already id map.
     * If given id isn't an object then it means its a value of the id column
     * and it creates a new id map with this value and name of the primary column.
     */ ensureRelationIdMap(id) {
        if (ObjectUtils_1.ObjectUtils.isObject(id)) return id;
        const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;
        const referencedColumns = joinColumns.map((joinColumn)=>joinColumn.referencedColumn);
        if (referencedColumns.length > 1) throw new error_1.TypeORMError(`Cannot create relation id map for a single value because relation contains multiple referenced columns.`);
        return referencedColumns[0].createValueMap(id);
    }
    /**
     * Extracts column value from the given entity.
     * If column is in embedded (or recursive embedded) it extracts its value from there.
     */ getEntityValue(entity, getLazyRelationsPromiseValue = false) {
        if (entity === null || entity === undefined) return undefined;
        // extract column value from embeddeds of entity if column is in embedded
        if (this.embeddedMetadata) {
            // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
            // we need to get value of "id" column from the post real entity object
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const propertyNames = [
                ...this.embeddedMetadata.parentPropertyNames
            ];
            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters
            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed
            const extractEmbeddedColumnValue = (propertyNames, value)=>{
                const propertyName = propertyNames.shift();
                if (propertyName) {
                    if (value[propertyName]) {
                        return extractEmbeddedColumnValue(propertyNames, value[propertyName]);
                    }
                    return undefined;
                }
                return value;
            };
            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]
            const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);
            if (this.isLazy) {
                if (embeddedObject["__" + this.propertyName + "__"] !== undefined) return embeddedObject["__" + this.propertyName + "__"];
                if (getLazyRelationsPromiseValue === true) return embeddedObject[this.propertyName];
                return undefined;
            }
            return embeddedObject ? embeddedObject[this.isLazy ? "__" + this.propertyName + "__" : this.propertyName] : undefined;
        } else {
            // no embeds - no problems. Simply return column name by property name of the entity
            if (this.isLazy) {
                if (entity["__" + this.propertyName + "__"] !== undefined) return entity["__" + this.propertyName + "__"];
                if (getLazyRelationsPromiseValue === true) return entity[this.propertyName];
                return undefined;
            }
            return entity[this.propertyName];
        }
    }
    /**
     * Sets given entity's relation's value.
     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.
     *
     * If merge is set to true, it merges given value into currently
     */ setEntityValue(entity, value) {
        const propertyName = this.isLazy ? "__" + this.propertyName + "__" : this.propertyName;
        if (this.embeddedMetadata) {
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const extractEmbeddedColumnValue = (embeddedMetadatas, map)=>{
                // if (!object[embeddedMetadata.propertyName])
                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();
                const embeddedMetadata = embeddedMetadatas.shift();
                if (embeddedMetadata) {
                    if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();
                    extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);
                    return map;
                }
                map[propertyName] = value;
                return map;
            };
            return extractEmbeddedColumnValue([
                ...this.embeddedMetadata.embeddedMetadataTree
            ], entity);
        } else {
            entity[propertyName] = value;
        }
    }
    /**
     * Creates entity id map from the given entity ids array.
     */ createValueMap(value) {
        // extract column value from embeds of entity if column is in embedded
        if (this.embeddedMetadata) {
            // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
            // we need to get value of "id" column from the post real entity object and return it in a
            // { data: { information: { counters: { id: ... } } } } format
            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
            const propertyNames = [
                ...this.embeddedMetadata.parentPropertyNames
            ];
            // now need to access post[data][information][counters] to get column value from the counters
            // and on each step we need to create complex literal object, e.g. first { data },
            // then { data: { information } }, then { data: { information: { counters } } },
            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }
            // this recursive function helps doing that
            const extractEmbeddedColumnValue = (propertyNames, map)=>{
                const propertyName = propertyNames.shift();
                if (propertyName) {
                    map[propertyName] = {};
                    extractEmbeddedColumnValue(propertyNames, map[propertyName]);
                    return map;
                }
                map[this.propertyName] = value;
                return map;
            };
            return extractEmbeddedColumnValue(propertyNames, {});
        } else {
            // no embeds - no problems. Simply return column property name and its value of the entity
            return {
                [this.propertyName]: value
            };
        }
    }
    // ---------------------------------------------------------------------
    // Builder Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend relation metadata properties.
     * This builder method should be used only after embedded metadata tree was build.
     */ build() {
        this.propertyPath = this.buildPropertyPath();
    }
    /**
     * Registers given foreign keys in the relation.
     * This builder method should be used to register foreign key in the relation.
     */ registerForeignKeys(...foreignKeys) {
        this.foreignKeys.push(...foreignKeys);
    }
    /**
     * Registers given join columns in the relation.
     * This builder method should be used to register join column in the relation.
     */ registerJoinColumns(joinColumns = [], inverseJoinColumns = []) {
        this.joinColumns = joinColumns;
        this.inverseJoinColumns = inverseJoinColumns;
        this.isOwning = this.isManyToOne || (this.isManyToMany || this.isOneToOne) && this.joinColumns.length > 0;
        this.isOneToOneOwner = this.isOneToOne && this.isOwning;
        this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning;
        this.isManyToManyOwner = this.isManyToMany && this.isOwning;
        this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning;
        this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner;
    }
    /**
     * Registers a given junction entity metadata.
     * This builder method can be called after junction entity metadata for the many-to-many relation was created.
     */ registerJunctionEntityMetadata(junctionEntityMetadata) {
        this.junctionEntityMetadata = junctionEntityMetadata;
        this.joinTableName = junctionEntityMetadata.tableName;
        if (this.inverseRelation) {
            this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;
            this.joinTableName = junctionEntityMetadata.tableName;
        }
    }
    /**
     * Builds inverse side property path based on given inverse side property factory.
     * This builder method should be used only after properties map of the inverse entity metadata was build.
     */ buildInverseSidePropertyPath() {
        if (this.givenInverseSidePropertyFactory) {
            const ownerEntityPropertiesMap = this.inverseEntityMetadata.propertiesMap;
            if (typeof this.givenInverseSidePropertyFactory === "function") return this.givenInverseSidePropertyFactory(ownerEntityPropertiesMap);
            if (typeof this.givenInverseSidePropertyFactory === "string") return this.givenInverseSidePropertyFactory;
        } else if (this.isTreeParent && this.entityMetadata.treeChildrenRelation) {
            return this.entityMetadata.treeChildrenRelation.propertyName;
        } else if (this.isTreeChildren && this.entityMetadata.treeParentRelation) {
            return this.entityMetadata.treeParentRelation.propertyName;
        }
        return "";
    }
    /**
     * Builds relation's property path based on its embedded tree.
     */ buildPropertyPath() {
        if (!this.embeddedMetadata || !this.embeddedMetadata.parentPropertyNames.length) return this.propertyName;
        return this.embeddedMetadata.parentPropertyNames.join(".") + "." + this.propertyName;
    }
}
exports.RelationMetadata = RelationMetadata; //# sourceMappingURL=RelationMetadata.js.map
}}),
"[project]/node_modules/typeorm/metadata/EmbeddedMetadata.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EmbeddedMetadata = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Contains all information about entity's embedded property.
 */ class EmbeddedMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        /**
         * Columns inside this embed.
         */ this.columns = [];
        /**
         * Relations inside this embed.
         */ this.relations = [];
        /**
         * Entity listeners inside this embed.
         */ this.listeners = [];
        /**
         * Indices applied to the embed columns.
         */ this.indices = [];
        /**
         * Uniques applied to the embed columns.
         */ this.uniques = [];
        /**
         * Relation ids inside this embed.
         */ this.relationIds = [];
        /**
         * Relation counts inside this embed.
         */ this.relationCounts = [];
        /**
         * Nested embeddable in this embeddable (which has current embedded as parent embedded).
         */ this.embeddeds = [];
        /**
         * Indicates if the entity should be instantiated using the constructor
         * or via allocating a new object via `Object.create()`.
         */ this.isAlwaysUsingConstructor = true;
        /**
         * Indicates if this embedded is in array mode.
         *
         * This option works only in mongodb.
         */ this.isArray = false;
        /**
         * Returns array of property names of current embed and all its parent embeds.
         *
         * example: post[data][information][counters].id where "data", "information" and "counters" are embeds
         * we need to get value of "id" column from the post real entity object.
         * this method will return ["data", "information", "counters"]
         */ this.parentPropertyNames = [];
        /**
         * Returns array of prefixes of current embed and all its parent embeds.
         */ this.parentPrefixes = [];
        /**
         * Returns embed metadatas from all levels of the parent tree.
         *
         * example: post[data][information][counters].id where "data", "information" and "counters" are embeds
         * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]
         */ this.embeddedMetadataTree = [];
        /**
         * Embed metadatas from all levels of the parent tree.
         *
         * example: post[data][information][counters].id where "data", "information" and "counters" are embeds
         * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]
         */ this.columnsFromTree = [];
        /**
         * Relations of this embed and all relations from its child embeds.
         */ this.relationsFromTree = [];
        /**
         * Relations of this embed and all relations from its child embeds.
         */ this.listenersFromTree = [];
        /**
         * Indices of this embed and all indices from its child embeds.
         */ this.indicesFromTree = [];
        /**
         * Uniques of this embed and all uniques from its child embeds.
         */ this.uniquesFromTree = [];
        /**
         * Relation ids of this embed and all relation ids from its child embeds.
         */ this.relationIdsFromTree = [];
        /**
         * Relation counts of this embed and all relation counts from its child embeds.
         */ this.relationCountsFromTree = [];
        this.entityMetadata = options.entityMetadata;
        this.type = options.args.type();
        this.propertyName = options.args.propertyName;
        this.customPrefix = options.args.prefix;
        this.isArray = options.args.isArray;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Creates a new embedded object.
     */ create(options) {
        if (!(typeof this.type === "function")) {
            return {};
        }
        if (options?.fromDeserializer || !this.isAlwaysUsingConstructor) {
            return Object.create(this.type.prototype);
        } else {
            return new this.type();
        }
    }
    // ---------------------------------------------------------------------
    // Builder Methods
    // ---------------------------------------------------------------------
    build(connection) {
        this.embeddeds.forEach((embedded)=>embedded.build(connection));
        this.prefix = this.buildPrefix(connection);
        this.parentPropertyNames = this.buildParentPropertyNames();
        this.parentPrefixes = this.buildParentPrefixes();
        this.propertyPath = this.parentPropertyNames.join(".");
        this.embeddedMetadataTree = this.buildEmbeddedMetadataTree();
        this.columnsFromTree = this.buildColumnsFromTree();
        this.relationsFromTree = this.buildRelationsFromTree();
        this.listenersFromTree = this.buildListenersFromTree();
        this.indicesFromTree = this.buildIndicesFromTree();
        this.uniquesFromTree = this.buildUniquesFromTree();
        this.relationIdsFromTree = this.buildRelationIdsFromTree();
        this.relationCountsFromTree = this.buildRelationCountsFromTree();
        if (connection.options.entitySkipConstructor) {
            this.isAlwaysUsingConstructor = !connection.options.entitySkipConstructor;
        }
        return this;
    }
    // ---------------------------------------------------------------------
    // Protected Methods
    // ---------------------------------------------------------------------
    buildPartialPrefix() {
        // if prefix option was not set or explicitly set to true - default prefix
        if (this.customPrefix === undefined || this.customPrefix === true) {
            return [
                this.propertyName
            ];
        }
        // if prefix option was set to empty string or explicity set to false - disable prefix
        if (this.customPrefix === "" || this.customPrefix === false) {
            return [];
        }
        // use custom prefix
        if (typeof this.customPrefix === "string") {
            return [
                this.customPrefix
            ];
        }
        throw new error_1.TypeORMError(`Invalid prefix option given for ${this.entityMetadata.targetName}#${this.propertyName}`);
    }
    buildPrefix(connection) {
        if (connection.driver.options.type === "mongodb") return this.propertyName;
        const prefixes = [];
        if (this.parentEmbeddedMetadata) prefixes.push(this.parentEmbeddedMetadata.buildPrefix(connection));
        prefixes.push(...this.buildPartialPrefix());
        return prefixes.join("_"); // todo: use naming strategy instead of "_"  !!!
    }
    buildParentPropertyNames() {
        return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPropertyNames().concat(this.propertyName) : [
            this.propertyName
        ];
    }
    buildParentPrefixes() {
        return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPrefixes().concat(this.buildPartialPrefix()) : this.buildPartialPrefix();
    }
    buildEmbeddedMetadataTree() {
        return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildEmbeddedMetadataTree().concat(this) : [
            this
        ];
    }
    buildColumnsFromTree() {
        return this.embeddeds.reduce((columns, embedded)=>columns.concat(embedded.buildColumnsFromTree()), this.columns);
    }
    buildRelationsFromTree() {
        return this.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.buildRelationsFromTree()), this.relations);
    }
    buildListenersFromTree() {
        return this.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.buildListenersFromTree()), this.listeners);
    }
    buildIndicesFromTree() {
        return this.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.buildIndicesFromTree()), this.indices);
    }
    buildUniquesFromTree() {
        return this.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.buildUniquesFromTree()), this.uniques);
    }
    buildRelationIdsFromTree() {
        return this.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.buildRelationIdsFromTree()), this.relationIds);
    }
    buildRelationCountsFromTree() {
        return this.embeddeds.reduce((relations, embedded)=>relations.concat(embedded.buildRelationCountsFromTree()), this.relationCounts);
    }
}
exports.EmbeddedMetadata = EmbeddedMetadata; //# sourceMappingURL=EmbeddedMetadata.js.map
}}),
"[project]/node_modules/typeorm/metadata/RelationIdMetadata.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationIdMetadata = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Contains all information about entity's relation count.
 */ class RelationIdMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this.entityMetadata = options.entityMetadata;
        this.target = options.args.target;
        this.propertyName = options.args.propertyName;
        this.relationNameOrFactory = options.args.relation;
        this.alias = options.args.alias;
        this.queryBuilderFactory = options.args.queryBuilderFactory;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Sets relation id value from the given entity.
     *
     * todo: make it to work in embeds as well.
     */ setValue(entity) {
        const inverseEntity = this.relation.getEntityValue(entity);
        if (Array.isArray(inverseEntity)) {
            entity[this.propertyName] = inverseEntity.map((item)=>{
                return this.relation.inverseEntityMetadata.getEntityIdMixedMap(item);
            }).filter((item)=>item !== null && item !== undefined);
        } else {
            const value = this.relation.inverseEntityMetadata.getEntityIdMixedMap(inverseEntity);
            if (value !== undefined) entity[this.propertyName] = value;
        }
    }
    // ---------------------------------------------------------------------
    // Public Builder Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend relation id properties.
     * This builder method should be used only after entity metadata, its properties map and all relations are build.
     */ build() {
        const propertyPath = typeof this.relationNameOrFactory === "function" ? this.relationNameOrFactory(this.entityMetadata.propertiesMap) : this.relationNameOrFactory;
        const relation = this.entityMetadata.findRelationWithPropertyPath(propertyPath);
        if (!relation) throw new error_1.TypeORMError(`Cannot find relation ${propertyPath}. Wrong relation specified for @RelationId decorator.`);
        this.relation = relation;
    }
}
exports.RelationIdMetadata = RelationIdMetadata; //# sourceMappingURL=RelationIdMetadata.js.map
}}),
"[project]/node_modules/typeorm/metadata/RelationCountMetadata.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationCountMetadata = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Contains all information about entity's relation count.
 */ class RelationCountMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this.entityMetadata = options.entityMetadata;
        this.target = options.args.target;
        this.propertyName = options.args.propertyName;
        this.relationNameOrFactory = options.args.relation;
        this.alias = options.args.alias;
        this.queryBuilderFactory = options.args.queryBuilderFactory;
    }
    // ---------------------------------------------------------------------
    // Public Builder Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend relation count metadata properties.
     * This builder method should be used only after entity metadata, its properties map and all relations are build.
     */ build() {
        const propertyPath = typeof this.relationNameOrFactory === "function" ? this.relationNameOrFactory(this.entityMetadata.propertiesMap) : this.relationNameOrFactory;
        const relation = this.entityMetadata.findRelationWithPropertyPath(propertyPath);
        if (!relation) throw new error_1.TypeORMError(`Cannot find relation ${propertyPath}. Wrong relation specified for @RelationCount decorator.`);
        this.relation = relation;
    }
}
exports.RelationCountMetadata = RelationCountMetadata; //# sourceMappingURL=RelationCountMetadata.js.map
}}),
"[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EventListenerTypes = void 0;
/**
 * Provides a constants for each entity listener type.
 */ class EventListenerTypes {
}
exports.EventListenerTypes = EventListenerTypes;
EventListenerTypes.AFTER_LOAD = "after-load";
EventListenerTypes.BEFORE_INSERT = "before-insert";
EventListenerTypes.AFTER_INSERT = "after-insert";
EventListenerTypes.BEFORE_UPDATE = "before-update";
EventListenerTypes.AFTER_UPDATE = "after-update";
EventListenerTypes.BEFORE_REMOVE = "before-remove";
EventListenerTypes.AFTER_REMOVE = "after-remove";
EventListenerTypes.BEFORE_SOFT_REMOVE = "before-soft-remove";
EventListenerTypes.AFTER_SOFT_REMOVE = "after-soft-remove";
EventListenerTypes.BEFORE_RECOVER = "before-recover";
EventListenerTypes.AFTER_RECOVER = "after-recover"; //# sourceMappingURL=EventListenerTypes.js.map
}}),
"[project]/node_modules/typeorm/metadata/ForeignKeyMetadata.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ForeignKeyMetadata = void 0;
/**
 * Contains all information about entity's foreign key.
 */ class ForeignKeyMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        /**
         * Array of columns of this foreign key.
         */ this.columns = [];
        /**
         * Array of referenced columns.
         */ this.referencedColumns = [];
        /**
         * Gets array of column names.
         */ this.columnNames = [];
        /**
         * Gets array of referenced column names.
         */ this.referencedColumnNames = [];
        this.entityMetadata = options.entityMetadata;
        this.referencedEntityMetadata = options.referencedEntityMetadata;
        this.columns = options.columns;
        this.referencedColumns = options.referencedColumns;
        this.onDelete = options.onDelete || "NO ACTION";
        this.onUpdate = options.onUpdate || "NO ACTION";
        this.deferrable = options.deferrable;
        this.givenName = options.name;
        if (options.namingStrategy) this.build(options.namingStrategy);
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend foreign key properties.
     * Must be called after all entity metadatas and their columns are built.
     */ build(namingStrategy) {
        this.columnNames = this.columns.map((column)=>column.databaseName);
        this.referencedColumnNames = this.referencedColumns.map((column)=>column.databaseName);
        this.referencedTablePath = this.referencedEntityMetadata.tablePath;
        this.name = this.givenName ? this.givenName : namingStrategy.foreignKeyName(this.entityMetadata.tableName, this.columnNames, this.referencedEntityMetadata.tableName, this.referencedColumnNames);
    }
}
exports.ForeignKeyMetadata = ForeignKeyMetadata; //# sourceMappingURL=ForeignKeyMetadata.js.map
}}),
"[project]/node_modules/typeorm/metadata/UniqueMetadata.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UniqueMetadata = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Unique metadata contains all information about table's unique constraints.
 */ class UniqueMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        /**
         * Unique columns.
         */ this.columns = [];
        /**
         * Map of column names with order set.
         * Used only by MongoDB driver.
         */ this.columnNamesWithOrderingMap = {};
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        if (options.columns) this.columns = options.columns;
        if (options.args) {
            this.target = options.args.target;
            this.givenName = options.args.name;
            this.givenColumnNames = options.args.columns;
            this.deferrable = options.args.deferrable;
        }
    }
    // ---------------------------------------------------------------------
    // Public Build Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend unique constraint properties.
     * Must be called after all entity metadata's properties map, columns and relations are built.
     */ build(namingStrategy) {
        const map = {};
        // if columns already an array of string then simply return it
        if (this.givenColumnNames) {
            let columnPropertyPaths = [];
            if (Array.isArray(this.givenColumnNames)) {
                columnPropertyPaths = this.givenColumnNames.map((columnName)=>{
                    if (this.embeddedMetadata) return this.embeddedMetadata.propertyPath + "." + columnName;
                    return columnName.trim();
                });
                columnPropertyPaths.forEach((propertyPath)=>map[propertyPath] = 1);
            } else {
                // if columns is a function that returns array of field names then execute it and get columns names from it
                const columnsFnResult = this.givenColumnNames(this.entityMetadata.propertiesMap);
                if (Array.isArray(columnsFnResult)) {
                    columnPropertyPaths = columnsFnResult.map((i)=>String(i));
                    columnPropertyPaths.forEach((name)=>map[name] = 1);
                } else {
                    columnPropertyPaths = Object.keys(columnsFnResult).map((i)=>String(i));
                    Object.keys(columnsFnResult).forEach((columnName)=>map[columnName] = columnsFnResult[columnName]);
                }
            }
            this.columns = columnPropertyPaths.map((propertyName)=>{
                const columnWithSameName = this.entityMetadata.columns.find((column)=>column.propertyPath === propertyName);
                if (columnWithSameName) {
                    return [
                        columnWithSameName
                    ];
                }
                const relationWithSameName = this.entityMetadata.relations.find((relation)=>relation.isWithJoinColumn && relation.propertyName === propertyName);
                if (relationWithSameName) {
                    return relationWithSameName.joinColumns;
                }
                const indexName = this.givenName ? '"' + this.givenName + '" ' : "";
                const entityName = this.entityMetadata.targetName;
                throw new error_1.TypeORMError(`Unique constraint ${indexName}contains column that is missing in the entity (${entityName}): ` + propertyName);
            }).reduce((a, b)=>a.concat(b));
        }
        this.columnNamesWithOrderingMap = Object.keys(map).reduce((updatedMap, key)=>{
            const column = this.entityMetadata.columns.find((column)=>column.propertyPath === key);
            if (column) updatedMap[column.databasePath] = map[key];
            return updatedMap;
        }, {});
        this.name = this.givenName ? this.givenName : namingStrategy.uniqueConstraintName(this.entityMetadata.tableName, this.columns.map((column)=>column.databaseName));
        return this;
    }
}
exports.UniqueMetadata = UniqueMetadata; //# sourceMappingURL=UniqueMetadata.js.map
}}),
"[project]/node_modules/typeorm/metadata/EntityListenerMetadata.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntityListenerMetadata = void 0;
/**
 * This metadata contains all information about entity's listeners.
 */ class EntityListenerMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this.entityMetadata = options.entityMetadata;
        this.embeddedMetadata = options.embeddedMetadata;
        this.target = options.args.target;
        this.propertyName = options.args.propertyName;
        this.type = options.args.type;
    }
    // ---------------------------------------------------------------------
    // Public Methods
    // ---------------------------------------------------------------------
    /**
     * Checks if entity listener is allowed to be executed on the given entity.
     */ isAllowed(entity) {
        // todo: create in entity metadata method like isInherited?
        return this.entityMetadata.target === entity.constructor || typeof this.entityMetadata.target === "function" && entity.constructor.prototype instanceof this.entityMetadata.target; // todo: also need to implement entity schema inheritance
    }
    /**
     * Executes listener method of the given entity.
     */ execute(entity) {
        // Check if the Embedded Metadata does not exist
        if (!this.embeddedMetadata) {
            // Get the Entity's Method
            const entityMethod = entity[this.propertyName];
            // Check if the Entity Method does not exist
            if (!entityMethod) throw new Error(`Entity listener method "${this.propertyName}" does not exist in entity "${entity.constructor.name}".`);
            // Check if the Entity Method is not a function
            if (typeof entityMethod !== "function") throw new Error(`Entity listener method "${this.propertyName}" in entity "${entity.constructor.name}" must be a function but got "${typeof entityMethod}".`);
            // Call and return the Entity Method
            return entityMethod.call(entity);
        }
        // Call the Embedded Method
        this.callEntityEmbeddedMethod(entity, this.embeddedMetadata.propertyPath.split("."));
    }
    // ---------------------------------------------------------------------
    // Protected Methods
    // ---------------------------------------------------------------------
    /**
     * Calls embedded entity listener method no matter how nested it is.
     */ callEntityEmbeddedMethod(entity, propertyPaths) {
        const propertyPath = propertyPaths.shift();
        if (!propertyPath || !entity[propertyPath]) return;
        if (propertyPaths.length === 0) {
            if (Array.isArray(entity[propertyPath])) {
                entity[propertyPath].map((embedded)=>embedded[this.propertyName]());
            } else {
                entity[propertyPath][this.propertyName]();
            }
        } else {
            if (entity[propertyPath]) this.callEntityEmbeddedMethod(entity[propertyPath], propertyPaths);
        }
    }
}
exports.EntityListenerMetadata = EntityListenerMetadata; //# sourceMappingURL=EntityListenerMetadata.js.map
}}),
"[project]/node_modules/typeorm/metadata/CheckMetadata.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CheckMetadata = void 0;
/**
 * Check metadata contains all information about table's check constraints.
 */ class CheckMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this.entityMetadata = options.entityMetadata;
        if (options.args) {
            this.target = options.args.target;
            this.expression = options.args.expression;
            this.givenName = options.args.name;
        }
    }
    // ---------------------------------------------------------------------
    // Public Build Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend check constraint properties.
     * Must be called after all entity metadata's properties map, columns and relations are built.
     */ build(namingStrategy) {
        this.name = this.givenName ? this.givenName : namingStrategy.checkConstraintName(this.entityMetadata.tableName, this.expression);
        return this;
    }
}
exports.CheckMetadata = CheckMetadata; //# sourceMappingURL=CheckMetadata.js.map
}}),
"[project]/node_modules/typeorm/metadata/ExclusionMetadata.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExclusionMetadata = void 0;
/**
 * Exclusion metadata contains all information about table's exclusion constraints.
 */ class ExclusionMetadata {
    // ---------------------------------------------------------------------
    // Constructor
    // ---------------------------------------------------------------------
    constructor(options){
        this.entityMetadata = options.entityMetadata;
        if (options.args) {
            this.target = options.args.target;
            this.expression = options.args.expression;
            this.givenName = options.args.name;
        }
    }
    // ---------------------------------------------------------------------
    // Public Build Methods
    // ---------------------------------------------------------------------
    /**
     * Builds some depend exclusion constraint properties.
     * Must be called after all entity metadata's properties map, columns and relations are built.
     */ build(namingStrategy) {
        this.name = this.givenName ? this.givenName : namingStrategy.exclusionConstraintName(this.entityMetadata.tableName, this.expression);
        return this;
    }
}
exports.ExclusionMetadata = ExclusionMetadata; //# sourceMappingURL=ExclusionMetadata.js.map
}}),
"[project]/node_modules/typeorm/entity-manager/EntityManager.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntityManager = void 0;
const EntityNotFoundError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/EntityNotFoundError.js [app-route] (ecmascript)");
const QueryRunnerProviderAlreadyReleasedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/QueryRunnerProviderAlreadyReleasedError.js [app-route] (ecmascript)");
const NoNeedToReleaseEntityManagerError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/NoNeedToReleaseEntityManagerError.js [app-route] (ecmascript)");
const MongoRepository_1 = __turbopack_context__.r("[project]/node_modules/typeorm/repository/MongoRepository.js [app-route] (ecmascript)");
const TreeRepository_1 = __turbopack_context__.r("[project]/node_modules/typeorm/repository/TreeRepository.js [app-route] (ecmascript)");
const Repository_1 = __turbopack_context__.r("[project]/node_modules/typeorm/repository/Repository.js [app-route] (ecmascript)");
const FindOptionsUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOptionsUtils.js [app-route] (ecmascript)");
const PlainObjectToNewEntityTransformer_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/transformer/PlainObjectToNewEntityTransformer.js [app-route] (ecmascript)");
const PlainObjectToDatabaseEntityTransformer_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/transformer/PlainObjectToDatabaseEntityTransformer.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const AbstractRepository_1 = __turbopack_context__.r("[project]/node_modules/typeorm/repository/AbstractRepository.js [app-route] (ecmascript)");
const EntityPersistExecutor_1 = __turbopack_context__.r("[project]/node_modules/typeorm/persistence/EntityPersistExecutor.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
const SqlTagUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/SqlTagUtils.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
/**
 * Entity manager supposed to work with any entity, automatically find its repository and call its methods,
 * whatever entity type are you passing.
 */ class EntityManager {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection, queryRunner){
        this["@instanceof"] = Symbol.for("EntityManager");
        // -------------------------------------------------------------------------
        // Protected Properties
        // -------------------------------------------------------------------------
        /**
         * Once created and then reused by repositories.
         * Created as a future replacement for the #repositories to provide a bit more perf optimization.
         */ this.repositories = new Map();
        /**
         * Once created and then reused by repositories.
         */ this.treeRepositories = [];
        /**
         * Plain to object transformer used in create and merge operations.
         */ this.plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer_1.PlainObjectToNewEntityTransformer();
        this.connection = connection;
        if (queryRunner) {
            this.queryRunner = queryRunner;
            // dynamic: this.queryRunner = manager;
            ObjectUtils_1.ObjectUtils.assign(this.queryRunner, {
                manager: this
            });
        }
    }
    /**
     * Wraps given function execution (and all operations made there) in a transaction.
     * All database operations must be executed using provided entity manager.
     */ async transaction(isolationOrRunInTransaction, runInTransactionParam) {
        const isolation = typeof isolationOrRunInTransaction === "string" ? isolationOrRunInTransaction : undefined;
        const runInTransaction = typeof isolationOrRunInTransaction === "function" ? isolationOrRunInTransaction : runInTransactionParam;
        if (!runInTransaction) {
            throw new error_1.TypeORMError(`Transaction method requires callback in second parameter if isolation level is supplied.`);
        }
        if (this.queryRunner && this.queryRunner.isReleased) throw new QueryRunnerProviderAlreadyReleasedError_1.QueryRunnerProviderAlreadyReleasedError();
        // if query runner is already defined in this class, it means this entity manager was already created for a single connection
        // if its not defined we create a new query runner - single connection where we'll execute all our operations
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        try {
            await queryRunner.startTransaction(isolation);
            const result = await runInTransaction(queryRunner.manager);
            await queryRunner.commitTransaction();
            return result;
        } catch (err) {
            try {
                // we throw original error even if rollback thrown an error
                await queryRunner.rollbackTransaction();
            } catch (rollbackError) {}
            throw err;
        } finally{
            if (!this.queryRunner) // if we used a new query runner provider then release it
            await queryRunner.release();
        }
    }
    /**
     * Executes raw SQL query and returns raw database results.
     *
     * @see [Official docs](https://typeorm.io/entity-manager-api) for examples.
     */ async query(query, parameters) {
        return this.connection.query(query, parameters, this.queryRunner);
    }
    /**
     * Tagged template function that executes raw SQL query and returns raw database results.
     * Template expressions are automatically transformed into database parameters.
     * Raw query execution is supported only by relational databases (MongoDB is not supported).
     * Note: Don't call this as a regular function, it is meant to be used with backticks to tag a template literal.
     * Example: entityManager.sql`SELECT * FROM table_name WHERE id = ${id}`
     */ async sql(strings, ...values) {
        const { query, parameters } = (0, SqlTagUtils_1.buildSqlTag)({
            driver: this.connection.driver,
            strings: strings,
            expressions: values
        });
        return await this.query(query, parameters);
    }
    /**
     * Creates a new query builder that can be used to build a SQL query.
     */ createQueryBuilder(entityClass, alias, queryRunner) {
        if (alias) {
            return this.connection.createQueryBuilder(entityClass, alias, queryRunner || this.queryRunner);
        } else {
            return this.connection.createQueryBuilder(entityClass || queryRunner || this.queryRunner);
        }
    }
    /**
     * Checks if entity has an id by its Function type or schema name.
     */ hasId(targetOrEntity, maybeEntity) {
        const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;
        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
        const metadata = this.connection.getMetadata(target);
        return metadata.hasId(entity);
    }
    /**
     * Gets entity mixed id.
     */ getId(targetOrEntity, maybeEntity) {
        const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;
        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
        const metadata = this.connection.getMetadata(target);
        return metadata.getEntityIdMixedMap(entity);
    }
    /**
     * Creates a new entity instance or instances.
     * Can copy properties from the given object into new entities.
     */ create(entityClass, plainObjectOrObjects) {
        const metadata = this.connection.getMetadata(entityClass);
        if (!plainObjectOrObjects) return metadata.create(this.queryRunner);
        if (Array.isArray(plainObjectOrObjects)) return plainObjectOrObjects.map((plainEntityLike)=>this.create(entityClass, plainEntityLike));
        const mergeIntoEntity = metadata.create(this.queryRunner);
        this.plainObjectToEntityTransformer.transform(mergeIntoEntity, plainObjectOrObjects, metadata, true);
        return mergeIntoEntity;
    }
    /**
     * Merges two entities into one new entity.
     */ merge(entityClass, mergeIntoEntity, ...entityLikes) {
        // todo: throw exception if entity manager is released
        const metadata = this.connection.getMetadata(entityClass);
        entityLikes.forEach((object)=>this.plainObjectToEntityTransformer.transform(mergeIntoEntity, object, metadata));
        return mergeIntoEntity;
    }
    /**
     * Creates a new entity from the given plain javascript object. If entity already exist in the database, then
     * it loads it (and everything related to it), replaces all values with the new ones from the given object
     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
     * replaced from the new object.
     */ async preload(entityClass, entityLike) {
        const metadata = this.connection.getMetadata(entityClass);
        const plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer_1.PlainObjectToDatabaseEntityTransformer(this.connection.manager);
        const transformedEntity = await plainObjectToDatabaseEntityTransformer.transform(entityLike, metadata);
        if (transformedEntity) return this.merge(entityClass, transformedEntity, entityLike);
        return undefined;
    }
    /**
     * Saves a given entity in the database.
     */ save(targetOrEntity, maybeEntityOrOptions, maybeOptions) {
        // normalize mixed parameters
        let target = arguments.length > 1 && (typeof targetOrEntity === "function" || InstanceChecker_1.InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === "string") ? targetOrEntity : undefined;
        const entity = target ? maybeEntityOrOptions : targetOrEntity;
        const options = target ? maybeOptions : maybeEntityOrOptions;
        if (InstanceChecker_1.InstanceChecker.isEntitySchema(target)) target = target.options.name;
        // if user passed empty array of entities then we don't need to do anything
        if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);
        // execute save operation
        return new EntityPersistExecutor_1.EntityPersistExecutor(this.connection, this.queryRunner, "save", target, entity, options).execute().then(()=>entity);
    }
    /**
     * Removes a given entity from the database.
     */ remove(targetOrEntity, maybeEntityOrOptions, maybeOptions) {
        // normalize mixed parameters
        const target = arguments.length > 1 && (typeof targetOrEntity === "function" || InstanceChecker_1.InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === "string") ? targetOrEntity : undefined;
        const entity = target ? maybeEntityOrOptions : targetOrEntity;
        const options = target ? maybeOptions : maybeEntityOrOptions;
        // if user passed empty array of entities then we don't need to do anything
        if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);
        // execute save operation
        return new EntityPersistExecutor_1.EntityPersistExecutor(this.connection, this.queryRunner, "remove", target, entity, options).execute().then(()=>entity);
    }
    /**
     * Records the delete date of one or many given entities.
     */ softRemove(targetOrEntity, maybeEntityOrOptions, maybeOptions) {
        // normalize mixed parameters
        let target = arguments.length > 1 && (typeof targetOrEntity === "function" || InstanceChecker_1.InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === "string") ? targetOrEntity : undefined;
        const entity = target ? maybeEntityOrOptions : targetOrEntity;
        const options = target ? maybeOptions : maybeEntityOrOptions;
        if (InstanceChecker_1.InstanceChecker.isEntitySchema(target)) target = target.options.name;
        // if user passed empty array of entities then we don't need to do anything
        if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);
        // execute soft-remove operation
        return new EntityPersistExecutor_1.EntityPersistExecutor(this.connection, this.queryRunner, "soft-remove", target, entity, options).execute().then(()=>entity);
    }
    /**
     * Recovers one or many given entities.
     */ recover(targetOrEntity, maybeEntityOrOptions, maybeOptions) {
        // normalize mixed parameters
        let target = arguments.length > 1 && (typeof targetOrEntity === "function" || InstanceChecker_1.InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === "string") ? targetOrEntity : undefined;
        const entity = target ? maybeEntityOrOptions : targetOrEntity;
        const options = target ? maybeOptions : maybeEntityOrOptions;
        if (InstanceChecker_1.InstanceChecker.isEntitySchema(target)) target = target.options.name;
        // if user passed empty array of entities then we don't need to do anything
        if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);
        // execute recover operation
        return new EntityPersistExecutor_1.EntityPersistExecutor(this.connection, this.queryRunner, "recover", target, entity, options).execute().then(()=>entity);
    }
    /**
     * Inserts a given entity into the database.
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient INSERT query.
     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
     * You can execute bulk inserts using this method.
     */ async insert(target, entity) {
        return this.createQueryBuilder().insert().into(target).values(entity).execute();
    }
    async upsert(target, entityOrEntities, conflictPathsOrOptions) {
        const metadata = this.connection.getMetadata(target);
        let options;
        if (Array.isArray(conflictPathsOrOptions)) {
            options = {
                conflictPaths: conflictPathsOrOptions
            };
        } else {
            options = conflictPathsOrOptions;
        }
        let entities;
        if (!Array.isArray(entityOrEntities)) {
            entities = [
                entityOrEntities
            ];
        } else {
            entities = entityOrEntities;
        }
        const conflictColumns = metadata.mapPropertyPathsToColumns(Array.isArray(options.conflictPaths) ? options.conflictPaths : Object.keys(options.conflictPaths));
        const overwriteColumns = metadata.columns.filter((col)=>!conflictColumns.includes(col) && entities.some((entity)=>typeof col.getEntityValue(entity) !== "undefined"));
        return this.createQueryBuilder().insert().into(target).values(entities).orUpdate([
            ...conflictColumns,
            ...overwriteColumns
        ].map((col)=>col.databaseName), conflictColumns.map((col)=>col.databaseName), {
            skipUpdateIfNoValuesChanged: options.skipUpdateIfNoValuesChanged,
            indexPredicate: options.indexPredicate,
            upsertType: options.upsertType || this.connection.driver.supportedUpsertTypes[0]
        }).execute();
    }
    /**
     * Updates entity partially. Entity can be found by a given condition(s).
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient UPDATE query.
     * Does not check if entity exist in the database.
     * Condition(s) cannot be empty.
     */ update(target, criteria, partialEntity) {
        // if user passed empty criteria or empty list of criterias, then throw an error
        if (OrmUtils_1.OrmUtils.isCriteriaNullOrEmpty(criteria)) {
            return Promise.reject(new error_1.TypeORMError(`Empty criteria(s) are not allowed for the update method.`));
        }
        if (OrmUtils_1.OrmUtils.isPrimitiveCriteria(criteria)) {
            return this.createQueryBuilder().update(target).set(partialEntity).whereInIds(criteria).execute();
        } else {
            return this.createQueryBuilder().update(target).set(partialEntity).where(criteria).execute();
        }
    }
    /**
     * Updates all entities of target type, setting fields from supplied partial entity.
     * This is a primitive operation without cascades, relations or other operations included.
     * Executes fast and efficient UPDATE query without WHERE clause.
     *
     * WARNING! This method updates ALL rows in the target table.
     */ updateAll(target, partialEntity) {
        return this.createQueryBuilder().update(target).set(partialEntity).execute();
    }
    /**
     * Deletes entities by a given condition(s).
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient DELETE query.
     * Does not check if entity exist in the database.
     * Condition(s) cannot be empty.
     */ delete(targetOrEntity, criteria) {
        // if user passed empty criteria or empty list of criterias, then throw an error
        if (OrmUtils_1.OrmUtils.isCriteriaNullOrEmpty(criteria)) {
            return Promise.reject(new error_1.TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));
        }
        if (OrmUtils_1.OrmUtils.isPrimitiveCriteria(criteria)) {
            return this.createQueryBuilder().delete().from(targetOrEntity).whereInIds(criteria).execute();
        } else {
            return this.createQueryBuilder().delete().from(targetOrEntity).where(criteria).execute();
        }
    }
    /**
     * Deletes all entities of target type.
     * This is a primitive operation without cascades, relations or other operations included.
     * Executes fast and efficient DELETE query without WHERE clause.
     *
     * WARNING! This method deletes ALL rows in the target table.
     */ deleteAll(targetOrEntity) {
        return this.createQueryBuilder().delete().from(targetOrEntity).execute();
    }
    /**
     * Records the delete date of entities by a given condition(s).
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient UPDATE query.
     * Does not check if entity exist in the database.
     * Condition(s) cannot be empty.
     */ softDelete(targetOrEntity, criteria) {
        // if user passed empty criteria or empty list of criterias, then throw an error
        if (OrmUtils_1.OrmUtils.isCriteriaNullOrEmpty(criteria)) {
            return Promise.reject(new error_1.TypeORMError(`Empty criteria(s) are not allowed for the softDelete method.`));
        }
        if (OrmUtils_1.OrmUtils.isPrimitiveCriteria(criteria)) {
            return this.createQueryBuilder().softDelete().from(targetOrEntity).whereInIds(criteria).execute();
        } else {
            return this.createQueryBuilder().softDelete().from(targetOrEntity).where(criteria).execute();
        }
    }
    /**
     * Restores entities by a given condition(s).
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient DELETE query.
     * Does not check if entity exist in the database.
     * Condition(s) cannot be empty.
     */ restore(targetOrEntity, criteria) {
        // if user passed empty criteria or empty list of criterias, then throw an error
        if (OrmUtils_1.OrmUtils.isCriteriaNullOrEmpty(criteria)) {
            return Promise.reject(new error_1.TypeORMError(`Empty criteria(s) are not allowed for the restore method.`));
        }
        if (OrmUtils_1.OrmUtils.isPrimitiveCriteria(criteria)) {
            return this.createQueryBuilder().restore().from(targetOrEntity).whereInIds(criteria).execute();
        } else {
            return this.createQueryBuilder().restore().from(targetOrEntity).where(criteria).execute();
        }
    }
    /**
     * Checks whether any entity exists with the given options.
     */ exists(entityClass, options) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, FindOptionsUtils_1.FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getExists();
    }
    /**
     * Checks whether any entity exists with the given conditions.
     */ async existsBy(entityClass, where) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
            where
        }).getExists();
    }
    /**
     * Counts entities that match given options.
     * Useful for pagination.
     */ count(entityClass, options) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, FindOptionsUtils_1.FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getCount();
    }
    /**
     * Counts entities that match given conditions.
     * Useful for pagination.
     */ countBy(entityClass, where) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
            where
        }).getCount();
    }
    /**
     * Return the SUM of a column
     */ sum(entityClass, columnName, where) {
        return this.callAggregateFun(entityClass, "SUM", columnName, where);
    }
    /**
     * Return the AVG of a column
     */ average(entityClass, columnName, where) {
        return this.callAggregateFun(entityClass, "AVG", columnName, where);
    }
    /**
     * Return the MIN of a column
     */ minimum(entityClass, columnName, where) {
        return this.callAggregateFun(entityClass, "MIN", columnName, where);
    }
    /**
     * Return the MAX of a column
     */ maximum(entityClass, columnName, where) {
        return this.callAggregateFun(entityClass, "MAX", columnName, where);
    }
    async callAggregateFun(entityClass, fnName, columnName, where = {}) {
        const metadata = this.connection.getMetadata(entityClass);
        const column = metadata.columns.find((item)=>item.propertyPath === columnName);
        if (!column) {
            throw new error_1.TypeORMError(`Column "${columnName}" was not found in table "${metadata.name}"`);
        }
        const result = await this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
            where
        }).select(`${fnName}(${this.connection.driver.escape(column.databaseName)})`, fnName).getRawOne();
        return result[fnName] === null ? null : parseFloat(result[fnName]);
    }
    /**
     * Finds entities that match given find options.
     */ async find(entityClass, options) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, FindOptionsUtils_1.FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getMany();
    }
    /**
     * Finds entities that match given find options.
     */ async findBy(entityClass, where) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
            where: where
        }).getMany();
    }
    /**
     * Finds entities that match given find options.
     * Also counts all entities that match given conditions,
     * but ignores pagination settings (from and take options).
     */ findAndCount(entityClass, options) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, FindOptionsUtils_1.FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getManyAndCount();
    }
    /**
     * Finds entities that match given WHERE conditions.
     * Also counts all entities that match given conditions,
     * but ignores pagination settings (from and take options).
     */ findAndCountBy(entityClass, where) {
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
            where
        }).getManyAndCount();
    }
    /**
     * Finds entities with ids.
     * Optionally find options or conditions can be applied.
     *
     * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:
     *
     * .findBy({
     *     id: In([1, 2, 3])
     * })
     */ async findByIds(entityClass, ids) {
        // if no ids passed, no need to execute a query - just return an empty array of values
        if (!ids.length) return Promise.resolve([]);
        const metadata = this.connection.getMetadata(entityClass);
        return this.createQueryBuilder(entityClass, metadata.name).andWhereInIds(ids).getMany();
    }
    /**
     * Finds first entity by a given find options.
     * If entity was not found in the database - returns null.
     */ async findOne(entityClass, options) {
        const metadata = this.connection.getMetadata(entityClass);
        // prepare alias for built query
        let alias = metadata.name;
        if (options && options.join) {
            alias = options.join.alias;
        }
        if (!options.where) {
            throw new Error(`You must provide selection conditions in order to find a single row.`);
        }
        // create query builder and apply find options
        return this.createQueryBuilder(entityClass, alias).setFindOptions({
            ...options,
            take: 1
        }).getOne();
    }
    /**
     * Finds first entity that matches given where condition.
     * If entity was not found in the database - returns null.
     */ async findOneBy(entityClass, where) {
        const metadata = this.connection.getMetadata(entityClass);
        // create query builder and apply find options
        return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
            where,
            take: 1
        }).getOne();
    }
    /**
     * Finds first entity that matches given id.
     * If entity was not found in the database - returns null.
     *
     * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
     *
     * .findOneBy({
     *     id: 1 // where "id" is your primary column name
     * })
     */ async findOneById(entityClass, id) {
        const metadata = this.connection.getMetadata(entityClass);
        // create query builder and apply find options
        return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({
            take: 1
        }).whereInIds(metadata.ensureEntityIdMap(id)).getOne();
    }
    /**
     * Finds first entity by a given find options.
     * If entity was not found in the database - rejects with error.
     */ async findOneOrFail(entityClass, options) {
        return this.findOne(entityClass, options).then((value)=>{
            if (value === null) {
                return Promise.reject(new EntityNotFoundError_1.EntityNotFoundError(entityClass, options));
            }
            return Promise.resolve(value);
        });
    }
    /**
     * Finds first entity that matches given where condition.
     * If entity was not found in the database - rejects with error.
     */ async findOneByOrFail(entityClass, where) {
        return this.findOneBy(entityClass, where).then((value)=>{
            if (value === null) {
                return Promise.reject(new EntityNotFoundError_1.EntityNotFoundError(entityClass, where));
            }
            return Promise.resolve(value);
        });
    }
    /**
     * Clears all the data from the given table (truncates/drops it).
     *
     * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.
     * @see https://stackoverflow.com/a/5972738/925151
     */ async clear(entityClass) {
        const metadata = this.connection.getMetadata(entityClass);
        const queryRunner = this.queryRunner || this.connection.createQueryRunner();
        try {
            return await queryRunner.clearTable(metadata.tablePath); // await is needed here because we are using finally
        } finally{
            if (!this.queryRunner) await queryRunner.release();
        }
    }
    /**
     * Increments some column by provided value of the entities matched given conditions.
     */ async increment(entityClass, conditions, propertyPath, value) {
        const metadata = this.connection.getMetadata(entityClass);
        const column = metadata.findColumnWithPropertyPath(propertyPath);
        if (!column) throw new error_1.TypeORMError(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);
        if (isNaN(Number(value))) throw new error_1.TypeORMError(`Value "${value}" is not a number.`);
        // convert possible embedded path "social.likes" into object { social: { like: () => value } }
        const values = propertyPath.split(".").reduceRight((value, key)=>({
                [key]: value
            }), ()=>this.connection.driver.escape(column.databaseName) + " + " + value);
        return this.createQueryBuilder(entityClass, "entity").update(entityClass).set(values).where(conditions).execute();
    }
    /**
     * Decrements some column by provided value of the entities matched given conditions.
     */ async decrement(entityClass, conditions, propertyPath, value) {
        const metadata = this.connection.getMetadata(entityClass);
        const column = metadata.findColumnWithPropertyPath(propertyPath);
        if (!column) throw new error_1.TypeORMError(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);
        if (isNaN(Number(value))) throw new error_1.TypeORMError(`Value "${value}" is not a number.`);
        // convert possible embedded path "social.likes" into object { social: { like: () => value } }
        const values = propertyPath.split(".").reduceRight((value, key)=>({
                [key]: value
            }), ()=>this.connection.driver.escape(column.databaseName) + " - " + value);
        return this.createQueryBuilder(entityClass, "entity").update(entityClass).set(values).where(conditions).execute();
    }
    /**
     * Gets repository for the given entity class or name.
     * If single database connection mode is used, then repository is obtained from the
     * repository aggregator, where each repository is individually created for this entity manager.
     * When single database connection is not used, repository is being obtained from the connection.
     */ getRepository(target) {
        // find already created repository instance and return it if found
        const repoFromMap = this.repositories.get(target);
        if (repoFromMap) return repoFromMap;
        // if repository was not found then create it, store its instance and return it
        if (this.connection.driver.options.type === "mongodb") {
            const newRepository = new MongoRepository_1.MongoRepository(target, this, this.queryRunner);
            this.repositories.set(target, newRepository);
            return newRepository;
        } else {
            const newRepository = new Repository_1.Repository(target, this, this.queryRunner);
            this.repositories.set(target, newRepository);
            return newRepository;
        }
    }
    /**
     * Gets tree repository for the given entity class or name.
     * If single database connection mode is used, then repository is obtained from the
     * repository aggregator, where each repository is individually created for this entity manager.
     * When single database connection is not used, repository is being obtained from the connection.
     */ getTreeRepository(target) {
        // tree tables aren't supported by some drivers (mongodb)
        if (this.connection.driver.treeSupport === false) throw new error_1.TreeRepositoryNotSupportedError(this.connection.driver);
        // find already created repository instance and return it if found
        const repository = this.treeRepositories.find((repository)=>repository.target === target);
        if (repository) return repository;
        // check if repository is real tree repository
        const newRepository = new TreeRepository_1.TreeRepository(target, this, this.queryRunner);
        this.treeRepositories.push(newRepository);
        return newRepository;
    }
    /**
     * Gets mongodb repository for the given entity class.
     */ getMongoRepository(target) {
        return this.connection.getMongoRepository(target);
    }
    /**
     * Creates a new repository instance out of a given Repository and
     * sets current EntityManager instance to it. Used to work with custom repositories
     * in transactions.
     */ withRepository(repository) {
        const repositoryConstructor = repository.constructor;
        const { target, manager, queryRunner, ...otherRepositoryProperties } = repository;
        return Object.assign(new repositoryConstructor(repository.target, this), {
            ...otherRepositoryProperties
        });
    }
    /**
     * Gets custom entity repository marked with @EntityRepository decorator.
     *
     * @deprecated use Repository.extend to create custom repositories
     */ getCustomRepository(customRepository) {
        const entityRepositoryMetadataArgs = (0, globals_1.getMetadataArgsStorage)().entityRepositories.find((repository)=>{
            return repository.target === (typeof customRepository === "function" ? customRepository : customRepository.constructor);
        });
        if (!entityRepositoryMetadataArgs) throw new error_1.CustomRepositoryNotFoundError(customRepository);
        const entityMetadata = entityRepositoryMetadataArgs.entity ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity) : undefined;
        const entityRepositoryInstance = new entityRepositoryMetadataArgs.target(this, entityMetadata);
        // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,
        // however we need these properties for internal work of the class
        if (entityRepositoryInstance instanceof AbstractRepository_1.AbstractRepository) {
            if (!entityRepositoryInstance["manager"]) entityRepositoryInstance["manager"] = this;
        } else {
            if (!entityMetadata) throw new error_1.CustomRepositoryCannotInheritRepositoryError(customRepository);
            entityRepositoryInstance["manager"] = this;
            entityRepositoryInstance["metadata"] = entityMetadata;
        }
        return entityRepositoryInstance;
    }
    /**
     * Releases all resources used by entity manager.
     * This is used when entity manager is created with a single query runner,
     * and this single query runner needs to be released after job with entity manager is done.
     */ async release() {
        if (!this.queryRunner) throw new NoNeedToReleaseEntityManagerError_1.NoNeedToReleaseEntityManagerError();
        return this.queryRunner.release();
    }
}
exports.EntityManager = EntityManager; //# sourceMappingURL=EntityManager.js.map
}}),
"[project]/node_modules/typeorm/entity-manager/MongoEntityManager.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MongoEntityManager = void 0;
const EntityManager_1 = __turbopack_context__.r("[project]/node_modules/typeorm/entity-manager/EntityManager.js [app-route] (ecmascript)");
const DocumentToEntityTransformer_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/transformer/DocumentToEntityTransformer.js [app-route] (ecmascript)");
const FindOptionsUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOptionsUtils.js [app-route] (ecmascript)");
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const InsertResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/result/InsertResult.js [app-route] (ecmascript)");
const UpdateResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/result/UpdateResult.js [app-route] (ecmascript)");
const DeleteResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/result/DeleteResult.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Entity manager supposed to work with any entity, automatically find its repository and call its methods,
 * whatever entity type are you passing.
 *
 * This implementation is used for MongoDB driver which has some specifics in its EntityManager.
 */ class MongoEntityManager extends EntityManager_1.EntityManager {
    get mongoQueryRunner() {
        return this.connection.driver.queryRunner;
    }
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        super(connection);
        this["@instanceof"] = Symbol.for("MongoEntityManager");
    }
    // -------------------------------------------------------------------------
    // Overridden Methods
    // -------------------------------------------------------------------------
    /**
     * Finds entities that match given find options.
     */ /**
     * Finds entities that match given find options or conditions.
     */ async find(entityClassOrName, optionsOrConditions) {
        const query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions);
        const cursor = this.createEntityCursor(entityClassOrName, query);
        const deleteDateColumn = this.connection.getMetadata(entityClassOrName).deleteDateColumn;
        if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
            if (optionsOrConditions.select) cursor.project(this.convertFindOptionsSelectToProjectCriteria(optionsOrConditions.select));
            if (optionsOrConditions.skip) cursor.skip(optionsOrConditions.skip);
            if (optionsOrConditions.take) cursor.limit(optionsOrConditions.take);
            if (optionsOrConditions.order) cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
            if (deleteDateColumn && !optionsOrConditions.withDeleted) {
                this.filterSoftDeleted(cursor, deleteDateColumn, query);
            }
        } else if (deleteDateColumn) {
            this.filterSoftDeleted(cursor, deleteDateColumn, query);
        }
        return cursor.toArray();
    }
    /**
     * Finds entities that match given find options or conditions.
     * Also counts all entities that match given conditions,
     * but ignores pagination settings (from and take options).
     */ async findAndCount(entityClassOrName, options) {
        return this.executeFindAndCount(entityClassOrName, options);
    }
    /**
     * Finds entities that match given where conditions.
     */ async findAndCountBy(entityClassOrName, where) {
        return this.executeFindAndCount(entityClassOrName, where);
    }
    /**
     * Finds entities by ids.
     * Optionally find options can be applied.
     *
     * @deprecated use `findBy` method instead.
     */ async findByIds(entityClassOrName, ids, optionsOrConditions) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        const query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions) || {};
        const objectIdInstance = PlatformTools_1.PlatformTools.load("mongodb").ObjectId;
        query["_id"] = {
            $in: ids.map((id)=>{
                if (typeof id === "string") {
                    return new objectIdInstance(id);
                }
                if (typeof id === "object") {
                    if (id instanceof objectIdInstance) {
                        return id;
                    }
                    const propertyName = metadata.objectIdColumn.propertyName;
                    if (id[propertyName] instanceof objectIdInstance) {
                        return id[propertyName];
                    }
                }
            })
        };
        const cursor = this.createEntityCursor(entityClassOrName, query);
        if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
            if (optionsOrConditions.select) cursor.project(this.convertFindOptionsSelectToProjectCriteria(optionsOrConditions.select));
            if (optionsOrConditions.skip) cursor.skip(optionsOrConditions.skip);
            if (optionsOrConditions.take) cursor.limit(optionsOrConditions.take);
            if (optionsOrConditions.order) cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
        }
        return cursor.toArray();
    }
    /**
     * Finds first entity that matches given conditions and/or find options.
     */ async findOne(entityClassOrName, options) {
        return this.executeFindOne(entityClassOrName, options);
    }
    /**
     * Finds first entity that matches given WHERE conditions.
     */ async findOneBy(entityClassOrName, where) {
        return this.executeFindOne(entityClassOrName, where);
    }
    /**
     * Finds entity that matches given id.
     *
     * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:
     *
     * .findOneBy({
     *     id: 1 // where "id" is your primary column name
     * })
     */ async findOneById(entityClassOrName, id) {
        return this.executeFindOne(entityClassOrName, id);
    }
    /**
     * Inserts a given entity into the database.
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient INSERT query.
     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
     * You can execute bulk inserts using this method.
     */ async insert(target, entity) {
        // todo: convert entity to its database name
        const result = new InsertResult_1.InsertResult();
        if (Array.isArray(entity)) {
            result.raw = await this.insertMany(target, entity);
            Object.keys(result.raw.insertedIds).forEach((key)=>{
                const insertedId = result.raw.insertedIds[key];
                result.generatedMaps.push(this.connection.driver.createGeneratedMap(this.connection.getMetadata(target), insertedId));
                result.identifiers.push(this.connection.driver.createGeneratedMap(this.connection.getMetadata(target), insertedId));
            });
        } else {
            result.raw = await this.insertOne(target, entity);
            result.generatedMaps.push(this.connection.driver.createGeneratedMap(this.connection.getMetadata(target), result.raw.insertedId));
            result.identifiers.push(this.connection.driver.createGeneratedMap(this.connection.getMetadata(target), result.raw.insertedId));
        }
        return result;
    }
    /**
     * Updates entity partially. Entity can be found by a given conditions.
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient UPDATE query.
     * Does not check if entity exist in the database.
     */ async update(target, criteria, partialEntity) {
        const result = new UpdateResult_1.UpdateResult();
        if (Array.isArray(criteria)) {
            const updateResults = await Promise.all(criteria.map((criteriaItem)=>{
                return this.update(target, criteriaItem, partialEntity);
            }));
            result.raw = updateResults.map((r)=>r.raw);
            result.affected = updateResults.map((r)=>r.affected || 0).reduce((c, r)=>c + r, 0);
            result.generatedMaps = updateResults.reduce((c, r)=>c.concat(r.generatedMaps), []);
        } else {
            const metadata = this.connection.getMetadata(target);
            const mongoResult = await this.updateMany(target, this.convertMixedCriteria(metadata, criteria), {
                $set: partialEntity
            });
            result.raw = mongoResult;
            result.affected = mongoResult.modifiedCount;
        }
        return result;
    }
    /**
     * Deletes entities by a given conditions.
     * Unlike save method executes a primitive operation without cascades, relations and other operations included.
     * Executes fast and efficient DELETE query.
     * Does not check if entity exist in the database.
     */ async delete(target, criteria) {
        const result = new DeleteResult_1.DeleteResult();
        if (Array.isArray(criteria)) {
            const deleteResults = await Promise.all(criteria.map((criteriaItem)=>{
                return this.delete(target, criteriaItem);
            }));
            result.raw = deleteResults.map((r)=>r.raw);
            result.affected = deleteResults.map((r)=>r.affected || 0).reduce((c, r)=>c + r, 0);
        } else {
            const mongoResult = await this.deleteMany(target, this.convertMixedCriteria(this.connection.getMetadata(target), criteria));
            result.raw = mongoResult;
            result.affected = mongoResult.deletedCount;
        }
        return result;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a cursor for a query that can be used to iterate over results from MongoDB.
     */ createCursor(entityClassOrName, query = {}) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.cursor(metadata.tableName, query);
    }
    /**
     * Creates a cursor for a query that can be used to iterate over results from MongoDB.
     * This returns modified version of cursor that transforms each result into Entity model.
     */ createEntityCursor(entityClassOrName, query = {}) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        const cursor = this.createCursor(entityClassOrName, query);
        this.applyEntityTransformationToCursor(metadata, cursor);
        return cursor;
    }
    /**
     * Execute an aggregation framework pipeline against the collection.
     */ aggregate(entityClassOrName, pipeline, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.aggregate(metadata.tableName, pipeline, options);
    }
    /**
     * Execute an aggregation framework pipeline against the collection.
     * This returns modified version of cursor that transforms each result into Entity model.
     */ aggregateEntity(entityClassOrName, pipeline, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        const cursor = this.mongoQueryRunner.aggregate(metadata.tableName, pipeline, options);
        this.applyEntityTransformationToCursor(metadata, cursor);
        return cursor;
    }
    /**
     * Perform a bulkWrite operation without a fluent API.
     */ bulkWrite(entityClassOrName, operations, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.bulkWrite(metadata.tableName, operations, options);
    }
    /**
     * Count number of matching documents in the db to a query.
     */ count(entityClassOrName, query = {}, options = {}) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.count(metadata.tableName, query, options);
    }
    /**
     * Count number of matching documents in the db to a query.
     */ countDocuments(entityClassOrName, query = {}, options = {}) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.countDocuments(metadata.tableName, query, options);
    }
    /**
     * Count number of matching documents in the db to a query.
     */ countBy(entityClassOrName, query, options) {
        return this.count(entityClassOrName, query, options);
    }
    /**
     * Creates an index on the db and collection.
     */ createCollectionIndex(entityClassOrName, fieldOrSpec, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.createCollectionIndex(metadata.tableName, fieldOrSpec, options);
    }
    /**
     * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.
     * Earlier version of MongoDB will throw a command not supported error.
     * Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
     */ createCollectionIndexes(entityClassOrName, indexSpecs) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.createCollectionIndexes(metadata.tableName, indexSpecs);
    }
    /**
     * Delete multiple documents on MongoDB.
     */ deleteMany(entityClassOrName, query, options = {}) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.deleteMany(metadata.tableName, query, options);
    }
    /**
     * Delete a document on MongoDB.
     */ deleteOne(entityClassOrName, query, options = {}) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.deleteOne(metadata.tableName, query, options);
    }
    /**
     * The distinct command returns returns a list of distinct values for the given key across a collection.
     */ distinct(entityClassOrName, key, query, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.distinct(metadata.tableName, key, query, options);
    }
    /**
     * Drops an index from this collection.
     */ dropCollectionIndex(entityClassOrName, indexName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.dropCollectionIndex(metadata.tableName, indexName, options);
    }
    /**
     * Drops all indexes from the collection.
     */ dropCollectionIndexes(entityClassOrName) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.dropCollectionIndexes(metadata.tableName);
    }
    /**
     * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
     */ findOneAndDelete(entityClassOrName, query, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.findOneAndDelete(metadata.tableName, query, options);
    }
    /**
     * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
     */ findOneAndReplace(entityClassOrName, query, replacement, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.findOneAndReplace(metadata.tableName, query, replacement, options);
    }
    /**
     * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
     */ findOneAndUpdate(entityClassOrName, query, update, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.findOneAndUpdate(metadata.tableName, query, update, options);
    }
    /**
     * Retrieve all the indexes on the collection.
     */ collectionIndexes(entityClassOrName) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.collectionIndexes(metadata.tableName);
    }
    /**
     * Retrieve all the indexes on the collection.
     */ collectionIndexExists(entityClassOrName, indexes) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.collectionIndexExists(metadata.tableName, indexes);
    }
    /**
     * Retrieves this collections index info.
     */ collectionIndexInformation(entityClassOrName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.collectionIndexInformation(metadata.tableName, options);
    }
    /**
     * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
     */ initializeOrderedBulkOp(entityClassOrName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.initializeOrderedBulkOp(metadata.tableName, options);
    }
    /**
     * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
     */ initializeUnorderedBulkOp(entityClassOrName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.initializeUnorderedBulkOp(metadata.tableName, options);
    }
    /**
     * Inserts an array of documents into MongoDB.
     */ insertMany(entityClassOrName, docs, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.insertMany(metadata.tableName, docs, options);
    }
    /**
     * Inserts a single document into MongoDB.
     */ insertOne(entityClassOrName, doc, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.insertOne(metadata.tableName, doc, options);
    }
    /**
     * Returns if the collection is a capped collection.
     */ isCapped(entityClassOrName) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.isCapped(metadata.tableName);
    }
    /**
     * Get the list of all indexes information for the collection.
     */ listCollectionIndexes(entityClassOrName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.listCollectionIndexes(metadata.tableName, options);
    }
    /**
     * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
     */ rename(entityClassOrName, newName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.rename(metadata.tableName, newName, options);
    }
    /**
     * Replace a document on MongoDB.
     */ replaceOne(entityClassOrName, query, doc, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.replaceOne(metadata.tableName, query, doc, options);
    }
    /**
     * Get all the collection statistics.
     */ stats(entityClassOrName, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.stats(metadata.tableName, options);
    }
    watch(entityClassOrName, pipeline, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.watch(metadata.tableName, pipeline, options);
    }
    /**
     * Update multiple documents on MongoDB.
     */ updateMany(entityClassOrName, query, update, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.updateMany(metadata.tableName, query, update, options);
    }
    /**
     * Update a single document on MongoDB.
     */ updateOne(entityClassOrName, query, update, options) {
        const metadata = this.connection.getMetadata(entityClassOrName);
        return this.mongoQueryRunner.updateOne(metadata.tableName, query, update, options);
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Converts FindManyOptions to mongodb query.
     */ convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions) {
        if (!optionsOrConditions) return undefined;
        if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) // If where condition is passed as a string which contains sql we have to ignore
        // as mongo is not a sql database
        return typeof optionsOrConditions.where === "string" ? {} : optionsOrConditions.where;
        return optionsOrConditions;
    }
    /**
     * Converts FindOneOptions to mongodb query.
     */ convertFindOneOptionsOrConditionsToMongodbQuery(optionsOrConditions) {
        if (!optionsOrConditions) return undefined;
        if (FindOptionsUtils_1.FindOptionsUtils.isFindOneOptions(optionsOrConditions)) // If where condition is passed as a string which contains sql we have to ignore
        // as mongo is not a sql database
        return typeof optionsOrConditions.where === "string" ? {} : optionsOrConditions.where;
        return optionsOrConditions;
    }
    /**
     * Converts FindOptions into mongodb order by criteria.
     */ convertFindOptionsOrderToOrderCriteria(order) {
        return Object.keys(order).reduce((orderCriteria, key)=>{
            switch(order[key]){
                case "DESC":
                    orderCriteria[key] = -1;
                    break;
                case "ASC":
                    orderCriteria[key] = 1;
                    break;
                default:
                    orderCriteria[key] = order[key];
            }
            return orderCriteria;
        }, {});
    }
    /**
     * Converts FindOptions into mongodb select by criteria.
     */ convertFindOptionsSelectToProjectCriteria(selects) {
        if (Array.isArray(selects)) {
            return selects.reduce((projectCriteria, key)=>{
                projectCriteria[key] = 1;
                return projectCriteria;
            }, {});
        } else {
            // todo: implement
            return {};
        }
    }
    /**
     * Ensures given id is an id for query.
     */ convertMixedCriteria(metadata, idMap) {
        const objectIdInstance = PlatformTools_1.PlatformTools.load("mongodb").ObjectId;
        // check first if it's ObjectId compatible:
        // string, number, Buffer, ObjectId or ObjectId-like
        if (objectIdInstance.isValid(idMap)) {
            return {
                _id: new objectIdInstance(idMap)
            };
        }
        // if it's some other type of object build a query from the columns
        // this check needs to be after the ObjectId check, because a valid ObjectId is also an Object instance
        if (ObjectUtils_1.ObjectUtils.isObject(idMap)) {
            return metadata.columns.reduce((query, column)=>{
                const columnValue = column.getEntityValue(idMap);
                if (columnValue !== undefined) query[column.databasePath] = columnValue;
                return query;
            }, {});
        }
        // last resort: try to convert it to an ObjectId anyway
        // most likely it will fail, but we want to be backwards compatible and keep the same thrown Errors.
        // it can still pass with null/undefined
        return {
            _id: new objectIdInstance(idMap)
        };
    }
    /**
     * Overrides cursor's toArray and next methods to convert results to entity automatically.
     */ applyEntityTransformationToCursor(metadata, cursor) {
        const queryRunner = this.mongoQueryRunner;
        cursor["__to_array_func"] = cursor.toArray;
        cursor.toArray = async ()=>cursor["__to_array_func"]().then(async (results)=>{
                const transformer = new DocumentToEntityTransformer_1.DocumentToEntityTransformer();
                const entities = transformer.transformAll(results, metadata);
                // broadcast "load" events
                await queryRunner.broadcaster.broadcast("Load", metadata, entities);
                return entities;
            });
        cursor["__next_func"] = cursor.next;
        cursor.next = async ()=>cursor["__next_func"]().then(async (result)=>{
                if (!result) {
                    return result;
                }
                const transformer = new DocumentToEntityTransformer_1.DocumentToEntityTransformer();
                const entity = transformer.transform(result, metadata);
                // broadcast "load" events
                await queryRunner.broadcaster.broadcast("Load", metadata, [
                    entity
                ]);
                return entity;
            });
    }
    filterSoftDeleted(cursor, deleteDateColumn, query) {
        const { $or, ...restQuery } = query ?? {};
        cursor.filter({
            $or: [
                {
                    [deleteDateColumn.propertyName]: {
                        $eq: null
                    }
                },
                ...Array.isArray($or) ? $or : []
            ],
            ...restQuery
        });
    }
    /**
     * Finds first entity that matches given conditions and/or find options.
     */ async executeFindOne(entityClassOrName, optionsOrConditions, maybeOptions) {
        const objectIdInstance = PlatformTools_1.PlatformTools.load("mongodb").ObjectId;
        const id = optionsOrConditions instanceof objectIdInstance || typeof optionsOrConditions === "string" ? optionsOrConditions : undefined;
        const findOneOptionsOrConditions = id ? maybeOptions : optionsOrConditions;
        const query = this.convertFindOneOptionsOrConditionsToMongodbQuery(findOneOptionsOrConditions) || {};
        if (id) {
            query["_id"] = id instanceof objectIdInstance ? id : new objectIdInstance(id);
        }
        const cursor = this.createEntityCursor(entityClassOrName, query);
        const deleteDateColumn = this.connection.getMetadata(entityClassOrName).deleteDateColumn;
        if (FindOptionsUtils_1.FindOptionsUtils.isFindOneOptions(findOneOptionsOrConditions)) {
            if (findOneOptionsOrConditions.select) cursor.project(this.convertFindOptionsSelectToProjectCriteria(findOneOptionsOrConditions.select));
            if (findOneOptionsOrConditions.order) cursor.sort(this.convertFindOptionsOrderToOrderCriteria(findOneOptionsOrConditions.order));
            if (deleteDateColumn && !findOneOptionsOrConditions.withDeleted) {
                this.filterSoftDeleted(cursor, deleteDateColumn, query);
            }
        } else if (deleteDateColumn) {
            this.filterSoftDeleted(cursor, deleteDateColumn, query);
        }
        // const result = await cursor.limit(1).next();
        const result = await cursor.limit(1).toArray();
        return result.length > 0 ? result[0] : null;
    }
    async executeFind(entityClassOrName, optionsOrConditions) {
        const query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions);
        const cursor = this.createEntityCursor(entityClassOrName, query);
        const deleteDateColumn = this.connection.getMetadata(entityClassOrName).deleteDateColumn;
        if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
            if (optionsOrConditions.select) cursor.project(this.convertFindOptionsSelectToProjectCriteria(optionsOrConditions.select));
            if (optionsOrConditions.skip) cursor.skip(optionsOrConditions.skip);
            if (optionsOrConditions.take) cursor.limit(optionsOrConditions.take);
            if (optionsOrConditions.order) cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
            if (deleteDateColumn && !optionsOrConditions.withDeleted) {
                this.filterSoftDeleted(cursor, deleteDateColumn, query);
            }
        } else if (deleteDateColumn) {
            this.filterSoftDeleted(cursor, deleteDateColumn, query);
        }
        return cursor.toArray();
    }
    /**
     * Finds entities that match given find options or conditions.
     */ async executeFindAndCount(entityClassOrName, optionsOrConditions) {
        const query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions);
        const cursor = await this.createEntityCursor(entityClassOrName, query);
        const deleteDateColumn = this.connection.getMetadata(entityClassOrName).deleteDateColumn;
        if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
            if (optionsOrConditions.select) cursor.project(this.convertFindOptionsSelectToProjectCriteria(optionsOrConditions.select));
            if (optionsOrConditions.skip) cursor.skip(optionsOrConditions.skip);
            if (optionsOrConditions.take) cursor.limit(optionsOrConditions.take);
            if (optionsOrConditions.order) cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
            if (deleteDateColumn && !optionsOrConditions.withDeleted) {
                this.filterSoftDeleted(cursor, deleteDateColumn, query);
            }
        } else if (deleteDateColumn) {
            this.filterSoftDeleted(cursor, deleteDateColumn, query);
        }
        const [results, count] = await Promise.all([
            cursor.toArray(),
            this.count(entityClassOrName, query)
        ]);
        return [
            results,
            parseInt(count)
        ];
    }
}
exports.MongoEntityManager = MongoEntityManager; //# sourceMappingURL=MongoEntityManager.js.map
}}),
"[project]/node_modules/typeorm/entity-manager/SqljsEntityManager.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SqljsEntityManager = void 0;
const EntityManager_1 = __turbopack_context__.r("[project]/node_modules/typeorm/entity-manager/EntityManager.js [app-route] (ecmascript)");
/**
 * A special EntityManager that includes import/export and load/save function
 * that are unique to Sql.js.
 */ class SqljsEntityManager extends EntityManager_1.EntityManager {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection, queryRunner){
        super(connection, queryRunner);
        this["@instanceof"] = Symbol.for("SqljsEntityManager");
        this.driver = connection.driver;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Loads either the definition from a file (Node.js) or localstorage (browser)
     * or uses the given definition to open a new database.
     */ async loadDatabase(fileNameOrLocalStorageOrData) {
        await this.driver.load(fileNameOrLocalStorageOrData);
    }
    /**
     * Saves the current database to a file (Node.js) or localstorage (browser)
     * if fileNameOrLocalStorage is not set options.location is used.
     */ async saveDatabase(fileNameOrLocalStorage) {
        await this.driver.save(fileNameOrLocalStorage);
    }
    /**
     * Returns the current database definition.
     */ exportDatabase() {
        return this.driver.export();
    }
}
exports.SqljsEntityManager = SqljsEntityManager; //# sourceMappingURL=SqljsEntityManager.js.map
}}),
"[project]/node_modules/typeorm/entity-manager/EntityManagerFactory.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntityManagerFactory = void 0;
const EntityManager_1 = __turbopack_context__.r("[project]/node_modules/typeorm/entity-manager/EntityManager.js [app-route] (ecmascript)");
const MongoEntityManager_1 = __turbopack_context__.r("[project]/node_modules/typeorm/entity-manager/MongoEntityManager.js [app-route] (ecmascript)");
const SqljsEntityManager_1 = __turbopack_context__.r("[project]/node_modules/typeorm/entity-manager/SqljsEntityManager.js [app-route] (ecmascript)");
/**
 * Helps to create entity managers.
 */ class EntityManagerFactory {
    /**
     * Creates a new entity manager depend on a given connection's driver.
     */ create(connection, queryRunner) {
        if (connection.driver.options.type === "mongodb") return new MongoEntityManager_1.MongoEntityManager(connection);
        if (connection.driver.options.type === "sqljs") return new SqljsEntityManager_1.SqljsEntityManager(connection, queryRunner);
        return new EntityManager_1.EntityManager(connection, queryRunner);
    }
}
exports.EntityManagerFactory = EntityManagerFactory; //# sourceMappingURL=EntityManagerFactory.js.map
}}),
"[project]/node_modules/typeorm/query-runner/BaseQueryRunner.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaseQueryRunner = void 0;
const Query_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/Query.js [app-route] (ecmascript)");
const SqlInMemory_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/SqlInMemory.js [app-route] (ecmascript)");
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
const OrmUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/OrmUtils.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
const SqlTagUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/SqlTagUtils.js [app-route] (ecmascript)");
class BaseQueryRunner {
    constructor(){
        // -------------------------------------------------------------------------
        // Public Properties
        // -------------------------------------------------------------------------
        /**
         * Indicates if connection for this query runner is released.
         * Once its released, query runner cannot run queries anymore.
         */ this.isReleased = false;
        /**
         * Indicates if transaction is in progress.
         */ this.isTransactionActive = false;
        /**
         * Stores temporarily user data.
         * Useful for sharing data with subscribers.
         */ this.data = {};
        /**
         * All synchronized tables in the database.
         */ this.loadedTables = [];
        /**
         * All synchronized views in the database.
         */ this.loadedViews = [];
        /**
         * Indicates if special query runner mode in which sql queries won't be executed is enabled.
         */ this.sqlMemoryMode = false;
        /**
         * Sql-s stored if "sql in memory" mode is enabled.
         */ this.sqlInMemory = new SqlInMemory_1.SqlInMemory();
        /**
         * current depth of transaction.
         * for transactionDepth > 0 will use SAVEPOINT to start and commit/rollback transaction blocks
         */ this.transactionDepth = 0;
        this.cachedTablePaths = {};
    }
    /**
     * Tagged template function that executes raw SQL query and returns raw database results.
     * Template expressions are automatically transformed into database parameters.
     * Raw query execution is supported only by relational databases (MongoDB is not supported).
     * Note: Don't call this as a regular function, it is meant to be used with backticks to tag a template literal.
     * Example: queryRunner.sql`SELECT * FROM table_name WHERE id = ${id}`
     */ async sql(strings, ...values) {
        const { query, parameters } = (0, SqlTagUtils_1.buildSqlTag)({
            driver: this.connection.driver,
            strings: strings,
            expressions: values
        });
        return await this.query(query, parameters);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Called before migrations are run.
     */ async beforeMigration() {
    // Do nothing
    }
    /**
     * Called after migrations are run.
     */ async afterMigration() {
    // Do nothing
    }
    /**
     * Loads given table's data from the database.
     */ async getTable(tablePath) {
        this.loadedTables = await this.loadTables([
            tablePath
        ]);
        return this.loadedTables.length > 0 ? this.loadedTables[0] : undefined;
    }
    /**
     * Loads all tables (with given names) from the database.
     */ async getTables(tableNames) {
        if (!tableNames) {
            // Don't cache in this case.
            // This is the new case & isn't used anywhere else anyway.
            return await this.loadTables(tableNames);
        }
        this.loadedTables = await this.loadTables(tableNames);
        return this.loadedTables;
    }
    /**
     * Loads given view's data from the database.
     */ async getView(viewPath) {
        this.loadedViews = await this.loadViews([
            viewPath
        ]);
        return this.loadedViews.length > 0 ? this.loadedViews[0] : undefined;
    }
    /**
     * Loads given view's data from the database.
     */ async getViews(viewPaths) {
        this.loadedViews = await this.loadViews(viewPaths);
        return this.loadedViews;
    }
    /**
     * Enables special query runner mode in which sql queries won't be executed,
     * instead they will be memorized into a special variable inside query runner.
     * You can get memorized sql using getMemorySql() method.
     */ enableSqlMemory() {
        this.sqlInMemory = new SqlInMemory_1.SqlInMemory();
        this.sqlMemoryMode = true;
    }
    /**
     * Disables special query runner mode in which sql queries won't be executed
     * started by calling enableSqlMemory() method.
     *
     * Previously memorized sql will be flushed.
     */ disableSqlMemory() {
        this.sqlInMemory = new SqlInMemory_1.SqlInMemory();
        this.sqlMemoryMode = false;
    }
    /**
     * Flushes all memorized sqls.
     */ clearSqlMemory() {
        this.sqlInMemory = new SqlInMemory_1.SqlInMemory();
    }
    /**
     * Gets sql stored in the memory. Parameters in the sql are already replaced.
     */ getMemorySql() {
        return this.sqlInMemory;
    }
    /**
     * Executes up sql queries.
     */ async executeMemoryUpSql() {
        for (const { query, parameters } of this.sqlInMemory.upQueries){
            await this.query(query, parameters);
        }
    }
    /**
     * Executes down sql queries.
     */ async executeMemoryDownSql() {
        for (const { query, parameters } of this.sqlInMemory.downQueries.reverse()){
            await this.query(query, parameters);
        }
    }
    getReplicationMode() {
        return this.mode;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Gets view from previously loaded views, otherwise loads it from database.
     */ async getCachedView(viewName) {
        const view = this.loadedViews.find((view)=>view.name === viewName);
        if (view) return view;
        const foundViews = await this.loadViews([
            viewName
        ]);
        if (foundViews.length > 0) {
            this.loadedViews.push(foundViews[0]);
            return foundViews[0];
        } else {
            throw new TypeORMError_1.TypeORMError(`View "${viewName}" does not exist.`);
        }
    }
    /**
     * Gets table from previously loaded tables, otherwise loads it from database.
     */ async getCachedTable(tableName) {
        if (tableName in this.cachedTablePaths) {
            const tablePath = this.cachedTablePaths[tableName];
            const table = this.loadedTables.find((table)=>this.getTablePath(table) === tablePath);
            if (table) {
                return table;
            }
        }
        const foundTables = await this.loadTables([
            tableName
        ]);
        if (foundTables.length > 0) {
            const foundTablePath = this.getTablePath(foundTables[0]);
            const cachedTable = this.loadedTables.find((table)=>this.getTablePath(table) === foundTablePath);
            if (!cachedTable) {
                this.cachedTablePaths[tableName] = this.getTablePath(foundTables[0]);
                this.loadedTables.push(foundTables[0]);
                return foundTables[0];
            } else {
                return cachedTable;
            }
        } else {
            throw new TypeORMError_1.TypeORMError(`Table "${tableName}" does not exist.`);
        }
    }
    /**
     * Replaces loaded table with given changed table.
     */ replaceCachedTable(table, changedTable) {
        const oldTablePath = this.getTablePath(table);
        const foundTable = this.loadedTables.find((loadedTable)=>this.getTablePath(loadedTable) === oldTablePath);
        // Clean up the lookup cache..
        for (const [key, cachedPath] of Object.entries(this.cachedTablePaths)){
            if (cachedPath === oldTablePath) {
                this.cachedTablePaths[key] = this.getTablePath(changedTable);
            }
        }
        if (foundTable) {
            foundTable.database = changedTable.database;
            foundTable.schema = changedTable.schema;
            foundTable.name = changedTable.name;
            foundTable.columns = changedTable.columns;
            foundTable.indices = changedTable.indices;
            foundTable.foreignKeys = changedTable.foreignKeys;
            foundTable.uniques = changedTable.uniques;
            foundTable.checks = changedTable.checks;
            foundTable.justCreated = changedTable.justCreated;
            foundTable.engine = changedTable.engine;
            foundTable.comment = changedTable.comment;
        }
    }
    getTablePath(target) {
        const parsed = this.connection.driver.parseTableName(target);
        return this.connection.driver.buildTableName(parsed.tableName, parsed.schema, parsed.database);
    }
    getTypeormMetadataTableName() {
        const options = this.connection.driver.options;
        return this.connection.driver.buildTableName(this.connection.metadataTableName, options.schema, options.database);
    }
    /**
     * Generates SQL query to select record from typeorm metadata table.
     */ selectTypeormMetadataSql({ database, schema, table, type, name }) {
        const qb = this.connection.createQueryBuilder();
        const selectQb = qb.select().from(this.getTypeormMetadataTableName(), "t").where(`${qb.escape("type")} = :type`, {
            type
        }).andWhere(`${qb.escape("name")} = :name`, {
            name
        });
        if (database) {
            selectQb.andWhere(`${qb.escape("database")} = :database`, {
                database
            });
        }
        if (schema) {
            selectQb.andWhere(`${qb.escape("schema")} = :schema`, {
                schema
            });
        }
        if (table) {
            selectQb.andWhere(`${qb.escape("table")} = :table`, {
                table
            });
        }
        const [query, parameters] = selectQb.getQueryAndParameters();
        return new Query_1.Query(query, parameters);
    }
    /**
     * Generates SQL query to insert a record into typeorm metadata table.
     */ insertTypeormMetadataSql({ database, schema, table, type, name, value }) {
        const [query, parameters] = this.connection.createQueryBuilder().insert().into(this.getTypeormMetadataTableName()).values({
            database: database,
            schema: schema,
            table: table,
            type: type,
            name: name,
            value: value
        }).getQueryAndParameters();
        return new Query_1.Query(query, parameters);
    }
    /**
     * Generates SQL query to delete a record from typeorm metadata table.
     */ deleteTypeormMetadataSql({ database, schema, table, type, name }) {
        const qb = this.connection.createQueryBuilder();
        const deleteQb = qb.delete().from(this.getTypeormMetadataTableName()).where(`${qb.escape("type")} = :type`, {
            type
        }).andWhere(`${qb.escape("name")} = :name`, {
            name
        });
        if (database) {
            deleteQb.andWhere(`${qb.escape("database")} = :database`, {
                database
            });
        }
        if (schema) {
            deleteQb.andWhere(`${qb.escape("schema")} = :schema`, {
                schema
            });
        }
        if (table) {
            deleteQb.andWhere(`${qb.escape("table")} = :table`, {
                table
            });
        }
        const [query, parameters] = deleteQb.getQueryAndParameters();
        return new Query_1.Query(query, parameters);
    }
    /**
     * Checks if at least one of column properties was changed.
     * Does not checks column type, length and autoincrement, because these properties changes separately.
     */ isColumnChanged(oldColumn, newColumn, checkDefault, checkComment, checkEnum = true) {
        // this logs need to debug issues in column change detection. Do not delete it!
        // console.log("charset ---------------");
        // console.log(oldColumn.charset !== newColumn.charset);
        // console.log(oldColumn.charset, newColumn.charset);
        // console.log("collation ---------------");
        // console.log(oldColumn.collation !== newColumn.collation);
        // console.log(oldColumn.collation, newColumn.collation);
        // console.log("precision ---------------");
        // console.log(oldColumn.precision !== newColumn.precision);
        // console.log(oldColumn.precision, newColumn.precision);
        // console.log("scale ---------------");
        // console.log(oldColumn.scale !== newColumn.scale);
        // console.log(oldColumn.scale, newColumn.scale);
        // console.log("default ---------------");
        // console.log((checkDefault && oldColumn.default !== newColumn.default));
        // console.log(oldColumn.default, newColumn.default);
        // console.log("isNullable ---------------");
        // console.log(oldColumn.isNullable !== newColumn.isNullable);
        // console.log(oldColumn.isNullable, newColumn.isNullable);
        // console.log("comment ---------------");
        // console.log((checkComment && oldColumn.comment !== newColumn.comment));
        // console.log(oldColumn.comment, newColumn.comment);
        // console.log("enum ---------------");
        // console.log(!OrmUtils.isArraysEqual(oldColumn.enum || [], newColumn.enum || []));
        // console.log(oldColumn.enum, newColumn.enum);
        return oldColumn.charset !== newColumn.charset || oldColumn.collation !== newColumn.collation || oldColumn.precision !== newColumn.precision || oldColumn.scale !== newColumn.scale || oldColumn.width !== newColumn.width || // MySQL only
        oldColumn.zerofill !== newColumn.zerofill || // MySQL only
        oldColumn.unsigned !== newColumn.unsigned || // MySQL only
        oldColumn.asExpression !== newColumn.asExpression || checkDefault && oldColumn.default !== newColumn.default || oldColumn.onUpdate !== newColumn.onUpdate || // MySQL only
        oldColumn.isNullable !== newColumn.isNullable || checkComment && oldColumn.comment !== newColumn.comment || checkEnum && this.isEnumChanged(oldColumn, newColumn);
    }
    isEnumChanged(oldColumn, newColumn) {
        return !OrmUtils_1.OrmUtils.isArraysEqual(oldColumn.enum || [], newColumn.enum || []);
    }
    /**
     * Checks if column length is by default.
     */ isDefaultColumnLength(table, column, length) {
        // if table have metadata, we check if length is specified in column metadata
        if (this.connection.hasMetadata(table.name)) {
            const metadata = this.connection.getMetadata(table.name);
            const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
            if (columnMetadata) {
                const columnMetadataLength = this.connection.driver.getColumnLength(columnMetadata);
                if (columnMetadataLength) return false;
            }
        }
        if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].length) {
            return this.connection.driver.dataTypeDefaults[column.type].length.toString() === length.toString();
        }
        return false;
    }
    /**
     * Checks if column precision is by default.
     */ isDefaultColumnPrecision(table, column, precision) {
        // if table have metadata, we check if length is specified in column metadata
        if (this.connection.hasMetadata(table.name)) {
            const metadata = this.connection.getMetadata(table.name);
            const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
            if (columnMetadata && columnMetadata.precision !== null && columnMetadata.precision !== undefined) return false;
        }
        if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].precision !== null && this.connection.driver.dataTypeDefaults[column.type].precision !== undefined) return this.connection.driver.dataTypeDefaults[column.type].precision === precision;
        return false;
    }
    /**
     * Checks if column scale is by default.
     */ isDefaultColumnScale(table, column, scale) {
        // if table have metadata, we check if length is specified in column metadata
        if (this.connection.hasMetadata(table.name)) {
            const metadata = this.connection.getMetadata(table.name);
            const columnMetadata = metadata.findColumnWithDatabaseName(column.name);
            if (columnMetadata && columnMetadata.scale !== null && columnMetadata.scale !== undefined) return false;
        }
        if (this.connection.driver.dataTypeDefaults && this.connection.driver.dataTypeDefaults[column.type] && this.connection.driver.dataTypeDefaults[column.type].scale !== null && this.connection.driver.dataTypeDefaults[column.type].scale !== undefined) return this.connection.driver.dataTypeDefaults[column.type].scale === scale;
        return false;
    }
    /**
     * Executes sql used special for schema build.
     */ async executeQueries(upQueries, downQueries) {
        if (InstanceChecker_1.InstanceChecker.isQuery(upQueries)) upQueries = [
            upQueries
        ];
        if (InstanceChecker_1.InstanceChecker.isQuery(downQueries)) downQueries = [
            downQueries
        ];
        this.sqlInMemory.upQueries.push(...upQueries);
        this.sqlInMemory.downQueries.push(...downQueries);
        // if sql-in-memory mode is enabled then simply store sql in memory and return
        if (this.sqlMemoryMode === true) return Promise.resolve();
        for (const { query, parameters } of upQueries){
            await this.query(query, parameters);
        }
    }
    /**
     * Generated an index name for a table and index
     */ generateIndexName(table, index) {
        // new index may be passed without name. In this case we generate index name manually.
        return this.connection.namingStrategy.indexName(table, index.columnNames, index.where);
    }
}
exports.BaseQueryRunner = BaseQueryRunner; //# sourceMappingURL=BaseQueryRunner.js.map
}}),
"[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryResult = void 0;
/**
 * Result object returned by UpdateQueryBuilder execution.
 */ class QueryResult {
    constructor(){
        /**
         * Rows
         */ this.records = [];
    }
}
exports.QueryResult = QueryResult; //# sourceMappingURL=QueryResult.js.map
}}),
"[project]/node_modules/typeorm/query-runner/QueryLock.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryLock = void 0;
class QueryLock {
    constructor(){
        this.queue = [];
    }
    async acquire() {
        let release;
        const waitingPromise = new Promise((ok)=>release = ok);
        // Get track of everyone we need to wait on..
        const otherWaitingPromises = [
            ...this.queue
        ];
        // Put ourselves onto the end of the queue
        this.queue.push(waitingPromise);
        if (otherWaitingPromises.length > 0) {
            await Promise.all(otherWaitingPromises);
        }
        return ()=>{
            release();
            if (this.queue.includes(waitingPromise)) {
                this.queue.splice(this.queue.indexOf(waitingPromise), 1);
            }
        };
    }
}
exports.QueryLock = QueryLock; //# sourceMappingURL=QueryLock.js.map
}}),
"[project]/node_modules/typeorm/container.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.useContainer = useContainer;
exports.getFromContainer = getFromContainer;
/**
 * Container to be used by this library for inversion control. If container was not implicitly set then by default
 * container simply creates a new instance of the given class.
 *
 * @deprecated
 */ const defaultContainer = new class {
    constructor(){
        this.instances = [];
    }
    get(someClass) {
        let instance = this.instances.find((i)=>i.type === someClass);
        if (!instance) {
            instance = {
                type: someClass,
                object: new someClass()
            };
            this.instances.push(instance);
        }
        return instance.object;
    }
}();
let userContainer;
let userContainerOptions;
/**
 * Sets container to be used by this library.
 *
 * @deprecated
 */ function useContainer(iocContainer, options) {
    userContainer = iocContainer;
    userContainerOptions = options;
}
/**
 * Gets the IOC container used by this library.
 *
 * @deprecated
 */ function getFromContainer(someClass) {
    if (userContainer) {
        try {
            const instance = userContainer.get(someClass);
            if (instance) return instance;
            if (!userContainerOptions || !userContainerOptions.fallback) return instance;
        } catch (error) {
            if (!userContainerOptions || !userContainerOptions.fallbackOnErrors) throw error;
        }
    }
    return defaultContainer.get(someClass);
} //# sourceMappingURL=container.js.map
}}),
"[project]/node_modules/typeorm/entity-schema/EntitySchemaEmbeddedError.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntitySchemaEmbeddedError = void 0;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
class EntitySchemaEmbeddedError extends error_1.TypeORMError {
    static createEntitySchemaIsRequiredException(field) {
        return new EntitySchemaEmbeddedError(`EntitySchema is required for ${field} embedded field`);
    }
    static createTargetIsRequired(field) {
        return new EntitySchemaEmbeddedError(`Target field is required for ${field} embedded EntitySchema`);
    }
    constructor(message){
        super(message);
    }
}
exports.EntitySchemaEmbeddedError = EntitySchemaEmbeddedError; //# sourceMappingURL=EntitySchemaEmbeddedError.js.map
}}),
"[project]/node_modules/typeorm/entity-schema/EntitySchemaTransformer.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntitySchemaTransformer = void 0;
const MetadataArgsStorage_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata-args/MetadataArgsStorage.js [app-route] (ecmascript)");
const EntitySchemaEmbeddedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/entity-schema/EntitySchemaEmbeddedError.js [app-route] (ecmascript)");
/**
 * Transforms entity schema into metadata args storage.
 * The result will be just like entities read from decorators.
 */ class EntitySchemaTransformer {
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Transforms entity schema into new metadata args storage object.
     */ transform(schemas) {
        const metadataArgsStorage = new MetadataArgsStorage_1.MetadataArgsStorage();
        schemas.forEach((entitySchema)=>{
            const options = entitySchema.options;
            // add table metadata args from the schema
            const tableMetadata = {
                target: options.target || options.name,
                name: options.tableName,
                database: options.database,
                schema: options.schema,
                type: options.type || "regular",
                orderBy: options.orderBy,
                synchronize: options.synchronize,
                withoutRowid: !!options.withoutRowid,
                expression: options.expression
            };
            metadataArgsStorage.tables.push(tableMetadata);
            const { inheritance } = options;
            if (inheritance) {
                metadataArgsStorage.inheritances.push({
                    target: options.target,
                    pattern: inheritance.pattern ?? "STI",
                    column: inheritance.column ? typeof inheritance.column === "string" ? {
                        name: inheritance.column
                    } : inheritance.column : undefined
                });
            }
            const { discriminatorValue } = options;
            if (discriminatorValue) {
                metadataArgsStorage.discriminatorValues.push({
                    target: options.target || options.name,
                    value: discriminatorValue
                });
            }
            this.transformColumnsRecursive(options, metadataArgsStorage);
        });
        return metadataArgsStorage;
    }
    transformColumnsRecursive(options, metadataArgsStorage) {
        // add columns metadata args from the schema
        Object.keys(options.columns).forEach((columnName)=>{
            const column = options.columns[columnName];
            const regularColumn = column;
            let mode = "regular";
            if (regularColumn.createDate) mode = "createDate";
            if (regularColumn.updateDate) mode = "updateDate";
            if (regularColumn.deleteDate) mode = "deleteDate";
            if (regularColumn.version) mode = "version";
            if (regularColumn.treeChildrenCount) mode = "treeChildrenCount";
            if (regularColumn.treeLevel) mode = "treeLevel";
            if (regularColumn.objectId) mode = "objectId";
            const columnArgs = {
                target: options.target || options.name,
                mode: mode,
                propertyName: columnName,
                options: {
                    type: regularColumn.type,
                    name: regularColumn.objectId ? "_id" : regularColumn.name,
                    primaryKeyConstraintName: regularColumn.primaryKeyConstraintName,
                    length: regularColumn.length,
                    width: regularColumn.width,
                    nullable: regularColumn.nullable,
                    readonly: regularColumn.readonly,
                    update: regularColumn.update,
                    select: regularColumn.select,
                    insert: regularColumn.insert,
                    primary: regularColumn.primary,
                    unique: regularColumn.unique,
                    comment: regularColumn.comment,
                    default: regularColumn.default,
                    onUpdate: regularColumn.onUpdate,
                    precision: regularColumn.precision,
                    scale: regularColumn.scale,
                    zerofill: regularColumn.zerofill,
                    unsigned: regularColumn.unsigned,
                    charset: regularColumn.charset,
                    collation: regularColumn.collation,
                    enum: regularColumn.enum,
                    enumName: regularColumn.enumName,
                    asExpression: regularColumn.asExpression,
                    generatedType: regularColumn.generatedType,
                    hstoreType: regularColumn.hstoreType,
                    array: regularColumn.array,
                    transformer: regularColumn.transformer,
                    spatialFeatureType: regularColumn.spatialFeatureType,
                    srid: regularColumn.srid
                }
            };
            metadataArgsStorage.columns.push(columnArgs);
            if (regularColumn.generated) {
                const generationArgs = {
                    target: options.target || options.name,
                    propertyName: columnName,
                    strategy: typeof regularColumn.generated === "string" ? regularColumn.generated : "increment"
                };
                metadataArgsStorage.generations.push(generationArgs);
            }
            if (regularColumn.unique) metadataArgsStorage.uniques.push({
                target: options.target || options.name,
                columns: [
                    columnName
                ]
            });
            if (regularColumn.foreignKey) {
                const foreignKey = regularColumn.foreignKey;
                const foreignKeyArgs = {
                    target: options.target || options.name,
                    type: foreignKey.target,
                    propertyName: columnName,
                    inverseSide: foreignKey.inverseSide,
                    name: foreignKey.name,
                    onDelete: foreignKey.onDelete,
                    onUpdate: foreignKey.onUpdate,
                    deferrable: foreignKey.deferrable
                };
                metadataArgsStorage.foreignKeys.push(foreignKeyArgs);
            }
        });
        // add relation metadata args from the schema
        if (options.relations) {
            Object.keys(options.relations).forEach((relationName)=>{
                const relationSchema = options.relations[relationName];
                const relation = {
                    target: options.target || options.name,
                    propertyName: relationName,
                    relationType: relationSchema.type,
                    isLazy: relationSchema.lazy || false,
                    type: relationSchema.target,
                    inverseSideProperty: relationSchema.inverseSide,
                    isTreeParent: relationSchema.treeParent,
                    isTreeChildren: relationSchema.treeChildren,
                    options: {
                        eager: relationSchema.eager || false,
                        cascade: relationSchema.cascade,
                        nullable: relationSchema.nullable,
                        onDelete: relationSchema.onDelete,
                        onUpdate: relationSchema.onUpdate,
                        deferrable: relationSchema.deferrable,
                        // primary: relationSchema.primary,
                        createForeignKeyConstraints: relationSchema.createForeignKeyConstraints,
                        persistence: relationSchema.persistence,
                        orphanedRowAction: relationSchema.orphanedRowAction
                    }
                };
                metadataArgsStorage.relations.push(relation);
                // add join column
                if (relationSchema.joinColumn) {
                    if (typeof relationSchema.joinColumn === "boolean") {
                        const joinColumn = {
                            target: options.target || options.name,
                            propertyName: relationName
                        };
                        metadataArgsStorage.joinColumns.push(joinColumn);
                    } else {
                        const joinColumnsOptions = Array.isArray(relationSchema.joinColumn) ? relationSchema.joinColumn : [
                            relationSchema.joinColumn
                        ];
                        for (const joinColumnOption of joinColumnsOptions){
                            const joinColumn = {
                                target: options.target || options.name,
                                propertyName: relationName,
                                name: joinColumnOption.name,
                                referencedColumnName: joinColumnOption.referencedColumnName,
                                foreignKeyConstraintName: joinColumnOption.foreignKeyConstraintName
                            };
                            metadataArgsStorage.joinColumns.push(joinColumn);
                        }
                    }
                }
                // add join table
                if (relationSchema.joinTable) {
                    if (typeof relationSchema.joinTable === "boolean") {
                        const joinTable = {
                            target: options.target || options.name,
                            propertyName: relationName
                        };
                        metadataArgsStorage.joinTables.push(joinTable);
                    } else {
                        const joinTable = {
                            target: options.target || options.name,
                            propertyName: relationName,
                            name: relationSchema.joinTable.name,
                            database: relationSchema.joinTable.database,
                            schema: relationSchema.joinTable.schema,
                            joinColumns: relationSchema.joinTable.joinColumn ? [
                                relationSchema.joinTable.joinColumn
                            ] : relationSchema.joinTable.joinColumns,
                            inverseJoinColumns: relationSchema.joinTable.inverseJoinColumn ? [
                                relationSchema.joinTable.inverseJoinColumn
                            ] : relationSchema.joinTable.inverseJoinColumns
                        };
                        metadataArgsStorage.joinTables.push(joinTable);
                    }
                }
            });
        }
        // add relation id metadata args from the schema
        if (options.relationIds) {
            Object.keys(options.relationIds).forEach((relationIdName)=>{
                const relationIdOptions = options.relationIds[relationIdName];
                const relationId = {
                    propertyName: relationIdName,
                    relation: relationIdOptions.relationName,
                    target: options.target || options.name,
                    alias: relationIdOptions.alias,
                    queryBuilderFactory: relationIdOptions.queryBuilderFactory
                };
                metadataArgsStorage.relationIds.push(relationId);
            });
        }
        // add index metadata args from the schema
        if (options.indices) {
            options.indices.forEach((index)=>{
                const indexArgs = {
                    target: options.target || options.name,
                    name: index.name,
                    unique: index.unique === true ? true : false,
                    spatial: index.spatial === true ? true : false,
                    fulltext: index.fulltext === true ? true : false,
                    nullFiltered: index.nullFiltered === true ? true : false,
                    parser: index.parser,
                    synchronize: index.synchronize === false ? false : true,
                    where: index.where,
                    sparse: index.sparse,
                    columns: index.columns
                };
                metadataArgsStorage.indices.push(indexArgs);
            });
        }
        if (options.foreignKeys) {
            options.foreignKeys.forEach((foreignKey)=>{
                const foreignKeyArgs = {
                    target: options.target || options.name,
                    type: foreignKey.target,
                    columnNames: foreignKey.columnNames,
                    referencedColumnNames: foreignKey.referencedColumnNames,
                    name: foreignKey.name,
                    onDelete: foreignKey.onDelete,
                    onUpdate: foreignKey.onUpdate,
                    deferrable: foreignKey.deferrable
                };
                metadataArgsStorage.foreignKeys.push(foreignKeyArgs);
            });
        }
        // add unique metadata args from the schema
        if (options.uniques) {
            options.uniques.forEach((unique)=>{
                const uniqueArgs = {
                    target: options.target || options.name,
                    name: unique.name,
                    columns: unique.columns,
                    deferrable: unique.deferrable
                };
                metadataArgsStorage.uniques.push(uniqueArgs);
            });
        }
        // add check metadata args from the schema
        if (options.checks) {
            options.checks.forEach((check)=>{
                const checkArgs = {
                    target: options.target || options.name,
                    name: check.name,
                    expression: check.expression
                };
                metadataArgsStorage.checks.push(checkArgs);
            });
        }
        // add exclusion metadata args from the schema
        if (options.exclusions) {
            options.exclusions.forEach((exclusion)=>{
                const exclusionArgs = {
                    target: options.target || options.name,
                    name: exclusion.name,
                    expression: exclusion.expression
                };
                metadataArgsStorage.exclusions.push(exclusionArgs);
            });
        }
        if (options.embeddeds) {
            Object.keys(options.embeddeds).forEach((columnName)=>{
                const embeddedOptions = options.embeddeds[columnName];
                if (!embeddedOptions.schema) throw EntitySchemaEmbeddedError_1.EntitySchemaEmbeddedError.createEntitySchemaIsRequiredException(columnName);
                const embeddedSchema = embeddedOptions.schema.options;
                metadataArgsStorage.embeddeds.push({
                    target: options.target || options.name,
                    propertyName: columnName,
                    isArray: embeddedOptions.array === true,
                    prefix: embeddedOptions.prefix !== undefined ? embeddedOptions.prefix : undefined,
                    type: ()=>embeddedSchema?.target || embeddedSchema.name
                });
                this.transformColumnsRecursive(embeddedSchema, metadataArgsStorage);
            });
        }
    }
}
exports.EntitySchemaTransformer = EntitySchemaTransformer; //# sourceMappingURL=EntitySchemaTransformer.js.map
}}),
"[project]/node_modules/typeorm/entity-schema/EntitySchema.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntitySchema = void 0;
/**
 * Interface for entity metadata mappings stored inside "schemas" instead of models decorated by decorators.
 */ class EntitySchema {
    constructor(options){
        this.options = options;
        this["@instanceof"] = Symbol.for("EntitySchema");
    }
}
exports.EntitySchema = EntitySchema; //# sourceMappingURL=EntitySchema.js.map
}}),
"[project]/node_modules/typeorm/entity-schema/EntitySchemaEmbeddedColumnOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntitySchemaEmbeddedColumnOptions = void 0;
class EntitySchemaEmbeddedColumnOptions {
}
exports.EntitySchemaEmbeddedColumnOptions = EntitySchemaEmbeddedColumnOptions; //# sourceMappingURL=EntitySchemaEmbeddedColumnOptions.js.map
}}),
"[project]/node_modules/typeorm/entity-schema/EntitySchemaOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntitySchemaOptions = void 0;
/**
 * Interface for entity metadata mappings stored inside "schemas" instead of models decorated by decorators.
 */ class EntitySchemaOptions {
}
exports.EntitySchemaOptions = EntitySchemaOptions; //# sourceMappingURL=EntitySchemaOptions.js.map
}}),
"[project]/node_modules/typeorm/logger/AbstractLogger.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AbstractLogger = void 0;
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
class AbstractLogger {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options){
        this.options = options;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Logs query and parameters used in it.
     */ logQuery(query, parameters, queryRunner) {
        if (!this.isLogEnabledFor("query")) {
            return;
        }
        this.writeLog("query", {
            type: "query",
            prefix: "query",
            message: query,
            format: "sql",
            parameters
        }, queryRunner);
    }
    /**
     * Logs query that is failed.
     */ logQueryError(error, query, parameters, queryRunner) {
        if (!this.isLogEnabledFor("query-error")) {
            return;
        }
        this.writeLog("warn", [
            {
                type: "query-error",
                prefix: "query failed",
                message: query,
                format: "sql",
                parameters
            },
            {
                type: "query-error",
                prefix: "error",
                message: error
            }
        ], queryRunner);
    }
    /**
     * Logs query that is slow.
     */ logQuerySlow(time, query, parameters, queryRunner) {
        if (!this.isLogEnabledFor("query-slow")) {
            return;
        }
        this.writeLog("warn", [
            {
                type: "query-slow",
                prefix: "query is slow",
                message: query,
                format: "sql",
                parameters,
                additionalInfo: {
                    time
                }
            },
            {
                type: "query-slow",
                prefix: "execution time",
                message: time
            }
        ], queryRunner);
    }
    /**
     * Logs events from the schema build process.
     */ logSchemaBuild(message, queryRunner) {
        if (!this.isLogEnabledFor("schema-build")) {
            return;
        }
        this.writeLog("schema", {
            type: "schema-build",
            message
        }, queryRunner);
    }
    /**
     * Logs events from the migration run process.
     */ logMigration(message, queryRunner) {
        if (!this.isLogEnabledFor("migration")) {
            return;
        }
        this.writeLog("log", {
            type: "migration",
            message
        }, queryRunner);
    }
    /**
     * Perform logging using given logger, or by default to the console.
     * Log has its own level and message.
     */ log(level, message, queryRunner) {
        switch(level){
            case "log":
                if (!this.isLogEnabledFor("log")) {
                    return;
                }
                this.writeLog("log", {
                    type: "log",
                    message
                }, queryRunner);
                break;
            case "info":
                if (!this.isLogEnabledFor("info")) {
                    return;
                }
                this.writeLog("info", {
                    type: "info",
                    prefix: "info",
                    message
                }, queryRunner);
                break;
            case "warn":
                if (!this.isLogEnabledFor("warn")) {
                    return;
                }
                this.writeLog("warn", {
                    type: "warn",
                    message
                }, queryRunner);
                break;
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Check is logging for level or message type is enabled.
     */ isLogEnabledFor(type) {
        switch(type){
            case "query":
                return this.options === "all" || this.options === true || Array.isArray(this.options) && this.options.indexOf("query") !== -1;
            case "error":
            case "query-error":
                return this.options === "all" || this.options === true || Array.isArray(this.options) && this.options.indexOf("error") !== -1;
            case "query-slow":
                return true;
            case "schema":
            case "schema-build":
                return this.options === "all" || Array.isArray(this.options) && this.options.indexOf("schema") !== -1;
            case "migration":
                return true;
            case "log":
                return this.options === "all" || Array.isArray(this.options) && this.options.indexOf("log") !== -1;
            case "info":
                return this.options === "all" || Array.isArray(this.options) && this.options.indexOf("info") !== -1;
            case "warn":
                return this.options === "all" || Array.isArray(this.options) && this.options.indexOf("warn") !== -1;
            default:
                return false;
        }
    }
    /**
     * Prepare and format log messages
     */ prepareLogMessages(logMessage, options, queryRunner) {
        options = {
            ...{
                addColonToPrefix: true,
                appendParameterAsComment: true,
                highlightSql: true,
                formatSql: false
            },
            ...options
        };
        const messages = Array.isArray(logMessage) ? logMessage : [
            logMessage
        ];
        for (let message of messages){
            if (typeof message !== "object") {
                message = {
                    message
                };
            }
            if (message.format === "sql") {
                let sql = String(message.message);
                if (options.formatSql) {
                    sql = PlatformTools_1.PlatformTools.formatSql(sql, queryRunner?.connection?.options.type);
                }
                if (options.appendParameterAsComment && message.parameters && message.parameters.length) {
                    sql += ` -- PARAMETERS: ${this.stringifyParams(message.parameters)}`;
                }
                if (options.highlightSql) {
                    sql = PlatformTools_1.PlatformTools.highlightSql(sql);
                }
                message.message = sql;
            }
            if (options.addColonToPrefix && message.prefix) {
                message.prefix += ":";
            }
        }
        return messages;
    }
    /**
     * Converts parameters to a string.
     * Sometimes parameters can have circular objects and therefor we are handle this case too.
     */ stringifyParams(parameters) {
        try {
            return JSON.stringify(parameters);
        } catch (error) {
            // most probably circular objects in parameters
            return parameters;
        }
    }
}
exports.AbstractLogger = AbstractLogger; //# sourceMappingURL=AbstractLogger.js.map
}}),
"[project]/node_modules/typeorm/logger/SimpleConsoleLogger.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SimpleConsoleLogger = void 0;
const AbstractLogger_1 = __turbopack_context__.r("[project]/node_modules/typeorm/logger/AbstractLogger.js [app-route] (ecmascript)");
/**
 * Performs logging of the events in TypeORM.
 * This version of logger uses console to log events and does not use syntax highlighting.
 */ class SimpleConsoleLogger extends AbstractLogger_1.AbstractLogger {
    /**
     * Write log to specific output.
     */ writeLog(level, logMessage, queryRunner) {
        const messages = this.prepareLogMessages(logMessage, {
            highlightSql: false
        });
        for (const message of messages){
            switch(message.type ?? level){
                case "log":
                case "schema-build":
                case "migration":
                    console.log(message.message);
                    break;
                case "info":
                case "query":
                    if (message.prefix) {
                        console.info(message.prefix, message.message);
                    } else {
                        console.info(message.message);
                    }
                    break;
                case "warn":
                case "query-slow":
                    if (message.prefix) {
                        console.warn(message.prefix, message.message);
                    } else {
                        console.warn(message.message);
                    }
                    break;
                case "error":
                case "query-error":
                    if (message.prefix) {
                        console.error(message.prefix, message.message);
                    } else {
                        console.error(message.message);
                    }
                    break;
            }
        }
    }
}
exports.SimpleConsoleLogger = SimpleConsoleLogger; //# sourceMappingURL=SimpleConsoleLogger.js.map
}}),
"[project]/node_modules/typeorm/logger/AdvancedConsoleLogger.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AdvancedConsoleLogger = void 0;
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const AbstractLogger_1 = __turbopack_context__.r("[project]/node_modules/typeorm/logger/AbstractLogger.js [app-route] (ecmascript)");
/**
 * Performs logging of the events in TypeORM.
 * This version of logger uses console to log events and use syntax highlighting.
 */ class AdvancedConsoleLogger extends AbstractLogger_1.AbstractLogger {
    /**
     * Write log to specific output.
     */ writeLog(level, logMessage, queryRunner) {
        const messages = this.prepareLogMessages(logMessage);
        for (const message of messages){
            switch(message.type ?? level){
                case "log":
                case "schema-build":
                case "migration":
                    PlatformTools_1.PlatformTools.log(String(message.message));
                    break;
                case "info":
                case "query":
                    if (message.prefix) {
                        PlatformTools_1.PlatformTools.logInfo(message.prefix, message.message);
                    } else {
                        PlatformTools_1.PlatformTools.log(String(message.message));
                    }
                    break;
                case "warn":
                case "query-slow":
                    if (message.prefix) {
                        PlatformTools_1.PlatformTools.logWarn(message.prefix, message.message);
                    } else {
                        console.warn(PlatformTools_1.PlatformTools.warn(String(message.message)));
                    }
                    break;
                case "error":
                case "query-error":
                    if (message.prefix) {
                        PlatformTools_1.PlatformTools.logError(message.prefix, String(message.message));
                    } else {
                        console.error(PlatformTools_1.PlatformTools.error(String(message.message)));
                    }
                    break;
            }
        }
    }
}
exports.AdvancedConsoleLogger = AdvancedConsoleLogger; //# sourceMappingURL=AdvancedConsoleLogger.js.map
}}),
"[project]/node_modules/typeorm/logger/FileLogger.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FileLogger = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
const app_root_path_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/app-root-path/index.js [app-route] (ecmascript)"));
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const AbstractLogger_1 = __turbopack_context__.r("[project]/node_modules/typeorm/logger/AbstractLogger.js [app-route] (ecmascript)");
/**
 * Performs logging of the events in TypeORM.
 * This version of logger logs everything into ormlogs.log file.
 */ class FileLogger extends AbstractLogger_1.AbstractLogger {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options, fileLoggerOptions){
        super(options);
        this.fileLoggerOptions = fileLoggerOptions;
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Write log to specific output.
     */ writeLog(level, logMessage, queryRunner) {
        const messages = this.prepareLogMessages(logMessage, {
            highlightSql: false,
            addColonToPrefix: false
        });
        const strings = [];
        for (const message of messages){
            switch(message.type ?? level){
                case "log":
                    strings.push(`[LOG]: ${message.message}`);
                    break;
                case "schema-build":
                case "migration":
                    strings.push(String(message.message));
                    break;
                case "info":
                    strings.push(`[INFO]: ${message.message}`);
                    break;
                case "query":
                    strings.push(`[QUERY]: ${message.message}`);
                    break;
                case "warn":
                    strings.push(`[WARN]: ${message.message}`);
                    break;
                case "query-slow":
                    if (message.prefix === "execution time") {
                        continue;
                    }
                    this.write(`[SLOW QUERY: ${message.additionalInfo?.time} ms]: ${message.message}`);
                    break;
                case "error":
                case "query-error":
                    if (message.prefix === "query failed") {
                        strings.push(`[FAILED QUERY]: ${message.message}`);
                    } else if (message.type === "query-error") {
                        strings.push(`[QUERY ERROR]: ${message.message}`);
                    } else {
                        strings.push(`[ERROR]: ${message.message}`);
                    }
                    break;
            }
        }
        this.write(strings);
    }
    /**
     * Writes given strings into the log file.
     */ write(strings) {
        strings = Array.isArray(strings) ? strings : [
            strings
        ];
        const basePath = app_root_path_1.default.path + "/";
        let logPath = "ormlogs.log";
        if (this.fileLoggerOptions && this.fileLoggerOptions.logPath) {
            logPath = PlatformTools_1.PlatformTools.pathNormalize(this.fileLoggerOptions.logPath);
        }
        strings = strings.map((str)=>"[" + new Date().toISOString() + "]" + str);
        PlatformTools_1.PlatformTools.appendFileSync(basePath + logPath, strings.join("\r\n") + "\r\n"); // todo: use async or implement promises?
    }
}
exports.FileLogger = FileLogger; //# sourceMappingURL=FileLogger.js.map
}}),
"[project]/node_modules/typeorm/logger/DebugLogger.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DebugLogger = void 0;
const AbstractLogger_1 = __turbopack_context__.r("[project]/node_modules/typeorm/logger/AbstractLogger.js [app-route] (ecmascript)");
const debug_1 = __turbopack_context__.r("[project]/node_modules/typeorm/node_modules/debug/src/index.js [app-route] (ecmascript)");
/**
 * Performs logging of the events in TypeORM via debug library.
 */ class DebugLogger extends AbstractLogger_1.AbstractLogger {
    constructor(){
        super(...arguments);
        /**
         * Object with all debug logger.
         */ this.logger = {
            log: (0, debug_1.debug)("typeorm:log"),
            info: (0, debug_1.debug)("typeorm:info"),
            warn: (0, debug_1.debug)("typeorm:warn"),
            error: (0, debug_1.debug)("typeorm:error"),
            query: (0, debug_1.debug)("typeorm:query:log"),
            "query-error": (0, debug_1.debug)("typeorm:query:error"),
            "query-slow": (0, debug_1.debug)("typeorm:query:slow"),
            "schema-build": (0, debug_1.debug)("typeorm:schema"),
            migration: (0, debug_1.debug)("typeorm:migration")
        };
    }
    /**
     * Check is logging for level or message type is enabled.
     */ isLogEnabledFor(type) {
        switch(type){
            case "query":
                return this.logger["query"].enabled;
            case "query-error":
                return this.logger["query-error"].enabled;
            case "query-slow":
                return true;
            case "schema":
            case "schema-build":
                return this.logger["schema-build"].enabled;
            case "migration":
                return this.logger["migration"].enabled;
            case "log":
                return this.logger["log"].enabled;
            case "info":
                return this.logger["info"].enabled;
            case "warn":
                return this.logger["warn"].enabled;
            default:
                return false;
        }
    }
    /**
     * Write log to specific output.
     */ writeLog(level, logMessage, queryRunner) {
        const messages = this.prepareLogMessages(logMessage, {
            appendParameterAsComment: false
        });
        for (const message of messages){
            const messageTypeOrLevel = message.type ?? level;
            if (messageTypeOrLevel in this.logger) {
                if (message.prefix) {
                    this.logger[messageTypeOrLevel](message.prefix, message.message);
                } else {
                    this.logger[messageTypeOrLevel](message.message);
                }
                if (message.parameters && message.parameters.length) {
                    this.logger[messageTypeOrLevel]("parameters:", message.parameters);
                }
            }
        }
    }
}
exports.DebugLogger = DebugLogger; //# sourceMappingURL=DebugLogger.js.map
}}),
"[project]/node_modules/typeorm/logger/FormattedConsoleLogger.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FormattedConsoleLogger = void 0;
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const AbstractLogger_1 = __turbopack_context__.r("[project]/node_modules/typeorm/logger/AbstractLogger.js [app-route] (ecmascript)");
/**
 * Performs logging of the events in TypeORM.
 * This version of logger uses console to log events, syntax highlighting and formatting.
 */ class FormattedConsoleLogger extends AbstractLogger_1.AbstractLogger {
    /**
     * Write log to specific output.
     */ writeLog(level, logMessage, queryRunner) {
        const messages = this.prepareLogMessages(logMessage, {
            highlightSql: true,
            formatSql: true
        }, queryRunner);
        for (let message of messages){
            switch(message.type ?? level){
                case "log":
                case "schema-build":
                case "migration":
                    PlatformTools_1.PlatformTools.log(String(message.message));
                    break;
                case "info":
                case "query":
                    if (message.prefix) {
                        PlatformTools_1.PlatformTools.logInfo(message.prefix, message.message);
                    } else {
                        PlatformTools_1.PlatformTools.log(String(message.message));
                    }
                    break;
                case "warn":
                case "query-slow":
                    if (message.prefix) {
                        PlatformTools_1.PlatformTools.logWarn(message.prefix, message.message);
                    } else {
                        console.warn(PlatformTools_1.PlatformTools.warn(String(message.message)));
                    }
                    break;
                case "error":
                case "query-error":
                    if (message.prefix) {
                        PlatformTools_1.PlatformTools.logError(message.prefix, String(message.message));
                    } else {
                        console.error(PlatformTools_1.PlatformTools.error(String(message.message)));
                    }
                    break;
            }
        }
    }
}
exports.FormattedConsoleLogger = FormattedConsoleLogger; //# sourceMappingURL=FormattedConsoleLogger.js.map
}}),
"[project]/node_modules/typeorm/logger/LoggerFactory.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LoggerFactory = void 0;
const SimpleConsoleLogger_1 = __turbopack_context__.r("[project]/node_modules/typeorm/logger/SimpleConsoleLogger.js [app-route] (ecmascript)");
const AdvancedConsoleLogger_1 = __turbopack_context__.r("[project]/node_modules/typeorm/logger/AdvancedConsoleLogger.js [app-route] (ecmascript)");
const FileLogger_1 = __turbopack_context__.r("[project]/node_modules/typeorm/logger/FileLogger.js [app-route] (ecmascript)");
const DebugLogger_1 = __turbopack_context__.r("[project]/node_modules/typeorm/logger/DebugLogger.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const FormattedConsoleLogger_1 = __turbopack_context__.r("[project]/node_modules/typeorm/logger/FormattedConsoleLogger.js [app-route] (ecmascript)");
/**
 * Helps to create logger instances.
 */ class LoggerFactory {
    /**
     * Creates a new logger depend on a given connection's driver.
     */ create(logger, options) {
        if (ObjectUtils_1.ObjectUtils.isObject(logger)) return logger;
        if (logger) {
            switch(logger){
                case "simple-console":
                    return new SimpleConsoleLogger_1.SimpleConsoleLogger(options);
                case "file":
                    return new FileLogger_1.FileLogger(options);
                case "advanced-console":
                    return new AdvancedConsoleLogger_1.AdvancedConsoleLogger(options);
                case "formatted-console":
                    return new FormattedConsoleLogger_1.FormattedConsoleLogger(options);
                case "debug":
                    return new DebugLogger_1.DebugLogger();
            }
        }
        return new AdvancedConsoleLogger_1.AdvancedConsoleLogger(options);
    }
}
exports.LoggerFactory = LoggerFactory; //# sourceMappingURL=LoggerFactory.js.map
}}),
"[project]/node_modules/typeorm/logger/Logger.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=Logger.js.map
}}),
"[project]/node_modules/typeorm/logger/LoggerOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=LoggerOptions.js.map
}}),
"[project]/node_modules/typeorm/cache/RedisQueryResultCache.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RedisQueryResultCache = void 0;
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Caches query result into Redis database.
 */ class RedisQueryResultCache {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection, clientType){
        this.connection = connection;
        this.clientType = clientType;
        this.redis = this.loadRedis();
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a connection with given cache provider.
     */ async connect() {
        const cacheOptions = this.connection.options.cache;
        if (this.clientType === "redis") {
            this.client = this.redis.createClient({
                ...cacheOptions?.options,
                legacyMode: true
            });
            if (typeof this.connection.options.cache === "object" && this.connection.options.cache.ignoreErrors) {
                this.client.on("error", (err)=>{
                    this.connection.logger.log("warn", err);
                });
            }
            if ("connect" in this.client) {
                await this.client.connect();
            }
        } else if (this.clientType === "ioredis") {
            if (cacheOptions && cacheOptions.port) {
                if (cacheOptions.options) {
                    this.client = new this.redis(cacheOptions.port, cacheOptions.options);
                } else {
                    this.client = new this.redis(cacheOptions.port);
                }
            } else if (cacheOptions && cacheOptions.options) {
                this.client = new this.redis(cacheOptions.options);
            } else {
                this.client = new this.redis();
            }
        } else if (this.clientType === "ioredis/cluster") {
            if (cacheOptions && cacheOptions.options && Array.isArray(cacheOptions.options)) {
                this.client = new this.redis.Cluster(cacheOptions.options);
            } else if (cacheOptions && cacheOptions.options && cacheOptions.options.startupNodes) {
                this.client = new this.redis.Cluster(cacheOptions.options.startupNodes, cacheOptions.options.options);
            } else {
                throw new TypeORMError_1.TypeORMError(`options.startupNodes required for ${this.clientType}.`);
            }
        }
    }
    /**
     * Disconnects the connection
     */ async disconnect() {
        return new Promise((ok, fail)=>{
            this.client.quit((err, result)=>{
                if (err) return fail(err);
                ok();
                this.client = undefined;
            });
        });
    }
    /**
     * Creates table for storing cache if it does not exist yet.
     */ async synchronize(queryRunner) {}
    /**
     * Get data from cache.
     * Returns cache result if found.
     * Returns undefined if result is not cached.
     */ getFromCache(options, queryRunner) {
        return new Promise((ok, fail)=>{
            if (options.identifier) {
                this.client.get(options.identifier, (err, result)=>{
                    if (err) return fail(err);
                    ok(JSON.parse(result));
                });
            } else if (options.query) {
                this.client.get(options.query, (err, result)=>{
                    if (err) return fail(err);
                    ok(JSON.parse(result));
                });
            } else {
                ok(undefined);
            }
        });
    }
    /**
     * Checks if cache is expired or not.
     */ isExpired(savedCache) {
        return savedCache.time + savedCache.duration < Date.now();
    }
    /**
     * Stores given query result in the cache.
     */ async storeInCache(options, savedCache, queryRunner) {
        return new Promise((ok, fail)=>{
            if (options.identifier) {
                this.client.set(options.identifier, JSON.stringify(options), "PX", options.duration, (err, result)=>{
                    if (err) return fail(err);
                    ok();
                });
            } else if (options.query) {
                this.client.set(options.query, JSON.stringify(options), "PX", options.duration, (err, result)=>{
                    if (err) return fail(err);
                    ok();
                });
            }
        });
    }
    /**
     * Clears everything stored in the cache.
     */ async clear(queryRunner) {
        return new Promise((ok, fail)=>{
            this.client.flushdb((err, result)=>{
                if (err) return fail(err);
                ok();
            });
        });
    }
    /**
     * Removes all cached results by given identifiers from cache.
     */ async remove(identifiers, queryRunner) {
        await Promise.all(identifiers.map((identifier)=>{
            return this.deleteKey(identifier);
        }));
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Removes a single key from redis database.
     */ deleteKey(key) {
        return new Promise((ok, fail)=>{
            this.client.del(key, (err, result)=>{
                if (err) return fail(err);
                ok();
            });
        });
    }
    /**
     * Loads redis dependency.
     */ loadRedis() {
        try {
            if (this.clientType === "ioredis/cluster") {
                return PlatformTools_1.PlatformTools.load("ioredis");
            } else {
                return PlatformTools_1.PlatformTools.load(this.clientType);
            }
        } catch (e) {
            throw new TypeORMError_1.TypeORMError(`Cannot use cache because ${this.clientType} is not installed. Please run "npm i ${this.clientType} --save".`);
        }
    }
}
exports.RedisQueryResultCache = RedisQueryResultCache; //# sourceMappingURL=RedisQueryResultCache.js.map
}}),
"[project]/node_modules/typeorm/cache/DbQueryResultCache.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DbQueryResultCache = void 0;
const MssqlParameter_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlserver/MssqlParameter.js [app-route] (ecmascript)");
const Table_1 = __turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/Table.js [app-route] (ecmascript)");
const uuid_1 = __turbopack_context__.r("[project]/node_modules/typeorm/node_modules/uuid/dist/cjs/index.js [app-route] (ecmascript)");
/**
 * Caches query result into current database, into separate table called "query-result-cache".
 */ class DbQueryResultCache {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        this.connection = connection;
        const { schema } = this.connection.driver.options;
        const database = this.connection.driver.database;
        const cacheOptions = typeof this.connection.options.cache === "object" ? this.connection.options.cache : {};
        const cacheTableName = cacheOptions.tableName || "query-result-cache";
        this.queryResultCacheDatabase = database;
        this.queryResultCacheSchema = schema;
        this.queryResultCacheTable = this.connection.driver.buildTableName(cacheTableName, schema, database);
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a connection with given cache provider.
     */ async connect() {}
    /**
     * Disconnects with given cache provider.
     */ async disconnect() {}
    /**
     * Creates table for storing cache if it does not exist yet.
     */ async synchronize(queryRunner) {
        queryRunner = this.getQueryRunner(queryRunner);
        const driver = this.connection.driver;
        const tableExist = await queryRunner.hasTable(this.queryResultCacheTable); // todo: table name should be configurable
        if (tableExist) return;
        await queryRunner.createTable(new Table_1.Table({
            database: this.queryResultCacheDatabase,
            schema: this.queryResultCacheSchema,
            name: this.queryResultCacheTable,
            columns: [
                {
                    name: "id",
                    isPrimary: true,
                    isNullable: false,
                    type: driver.normalizeType({
                        type: driver.mappedDataTypes.cacheId
                    }),
                    generationStrategy: driver.options.type === "spanner" ? "uuid" : "increment",
                    isGenerated: true
                },
                {
                    name: "identifier",
                    type: driver.normalizeType({
                        type: driver.mappedDataTypes.cacheIdentifier
                    }),
                    isNullable: true
                },
                {
                    name: "time",
                    type: driver.normalizeType({
                        type: driver.mappedDataTypes.cacheTime
                    }),
                    isPrimary: false,
                    isNullable: false
                },
                {
                    name: "duration",
                    type: driver.normalizeType({
                        type: driver.mappedDataTypes.cacheDuration
                    }),
                    isPrimary: false,
                    isNullable: false
                },
                {
                    name: "query",
                    type: driver.normalizeType({
                        type: driver.mappedDataTypes.cacheQuery
                    }),
                    isPrimary: false,
                    isNullable: false
                },
                {
                    name: "result",
                    type: driver.normalizeType({
                        type: driver.mappedDataTypes.cacheResult
                    }),
                    isNullable: false
                }
            ]
        }));
    }
    /**
     * Get data from cache.
     * Returns cache result if found.
     * Returns undefined if result is not cached.
     */ getFromCache(options, queryRunner) {
        queryRunner = this.getQueryRunner(queryRunner);
        const qb = this.connection.createQueryBuilder(queryRunner).select().from(this.queryResultCacheTable, "cache");
        if (options.identifier) {
            return qb.where(`${qb.escape("cache")}.${qb.escape("identifier")} = :identifier`).setParameters({
                identifier: this.connection.driver.options.type === "mssql" ? new MssqlParameter_1.MssqlParameter(options.identifier, "nvarchar") : options.identifier
            }).cache(false) // disable cache to avoid infinite loops when cache is alwaysEnable
            .getRawOne();
        } else if (options.query) {
            if (this.connection.driver.options.type === "oracle") {
                return qb.where(`dbms_lob.compare(${qb.escape("cache")}.${qb.escape("query")}, :query) = 0`, {
                    query: options.query
                }).cache(false) // disable cache to avoid infinite loops when cache is alwaysEnable
                .getRawOne();
            }
            return qb.where(`${qb.escape("cache")}.${qb.escape("query")} = :query`).setParameters({
                query: this.connection.driver.options.type === "mssql" ? new MssqlParameter_1.MssqlParameter(options.query, "nvarchar") : options.query
            }).cache(false) // disable cache to avoid infinite loops when cache is alwaysEnable
            .getRawOne();
        }
        return Promise.resolve(undefined);
    }
    /**
     * Checks if cache is expired or not.
     */ isExpired(savedCache) {
        const duration = typeof savedCache.duration === "string" ? parseInt(savedCache.duration) : savedCache.duration;
        return (typeof savedCache.time === "string" ? parseInt(savedCache.time) : savedCache.time) + duration < Date.now();
    }
    /**
     * Stores given query result in the cache.
     */ async storeInCache(options, savedCache, queryRunner) {
        const shouldCreateQueryRunner = queryRunner === undefined || queryRunner?.getReplicationMode() === "slave";
        if (queryRunner === undefined || shouldCreateQueryRunner) {
            queryRunner = this.connection.createQueryRunner("master");
        }
        let insertedValues = options;
        if (this.connection.driver.options.type === "mssql") {
            // todo: bad abstraction, re-implement this part, probably better if we create an entity metadata for cache table
            insertedValues = {
                identifier: new MssqlParameter_1.MssqlParameter(options.identifier, "nvarchar"),
                time: new MssqlParameter_1.MssqlParameter(options.time, "bigint"),
                duration: new MssqlParameter_1.MssqlParameter(options.duration, "int"),
                query: new MssqlParameter_1.MssqlParameter(options.query, "nvarchar"),
                result: new MssqlParameter_1.MssqlParameter(options.result, "nvarchar")
            };
        }
        if (savedCache && savedCache.identifier) {
            // if exist then update
            const qb = queryRunner.manager.createQueryBuilder().update(this.queryResultCacheTable).set(insertedValues);
            qb.where(`${qb.escape("identifier")} = :condition`, {
                condition: insertedValues.identifier
            });
            await qb.execute();
        } else if (savedCache && savedCache.query) {
            // if exist then update
            const qb = queryRunner.manager.createQueryBuilder().update(this.queryResultCacheTable).set(insertedValues);
            if (this.connection.driver.options.type === "oracle") {
                qb.where(`dbms_lob.compare("query", :condition) = 0`, {
                    condition: insertedValues.query
                });
            } else {
                qb.where(`${qb.escape("query")} = :condition`, {
                    condition: insertedValues.query
                });
            }
            await qb.execute();
        } else {
            // Spanner does not support auto-generated columns
            if (this.connection.driver.options.type === "spanner" && !insertedValues.id) {
                insertedValues.id = (0, uuid_1.v4)();
            }
            // otherwise insert
            await queryRunner.manager.createQueryBuilder().insert().into(this.queryResultCacheTable).values(insertedValues).execute();
        }
        if (shouldCreateQueryRunner) {
            await queryRunner.release();
        }
    }
    /**
     * Clears everything stored in the cache.
     */ async clear(queryRunner) {
        return this.getQueryRunner(queryRunner).clearTable(this.queryResultCacheTable);
    }
    /**
     * Removes all cached results by given identifiers from cache.
     */ async remove(identifiers, queryRunner) {
        const _queryRunner = queryRunner || this.getQueryRunner();
        await Promise.all(identifiers.map((identifier)=>{
            const qb = _queryRunner.manager.createQueryBuilder();
            return qb.delete().from(this.queryResultCacheTable).where(`${qb.escape("identifier")} = :identifier`, {
                identifier
            }).execute();
        }));
        if (!queryRunner) {
            await _queryRunner.release();
        }
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Gets a query runner to work with.
     */ getQueryRunner(queryRunner) {
        if (queryRunner) return queryRunner;
        return this.connection.createQueryRunner();
    }
}
exports.DbQueryResultCache = DbQueryResultCache; //# sourceMappingURL=DbQueryResultCache.js.map
}}),
"[project]/node_modules/typeorm/cache/QueryResultCacheFactory.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryResultCacheFactory = void 0;
const RedisQueryResultCache_1 = __turbopack_context__.r("[project]/node_modules/typeorm/cache/RedisQueryResultCache.js [app-route] (ecmascript)");
const DbQueryResultCache_1 = __turbopack_context__.r("[project]/node_modules/typeorm/cache/DbQueryResultCache.js [app-route] (ecmascript)");
const TypeORMError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/TypeORMError.js [app-route] (ecmascript)");
/**
 * Caches query result into Redis database.
 */ class QueryResultCacheFactory {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(connection){
        this.connection = connection;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Creates a new query result cache based on connection options.
     */ create() {
        if (!this.connection.options.cache) throw new TypeORMError_1.TypeORMError(`To use cache you need to enable it in connection options by setting cache: true or providing some caching options. Example: { host: ..., username: ..., cache: true }`);
        const cache = this.connection.options.cache;
        if (cache.provider && typeof cache.provider === "function") {
            return cache.provider(this.connection);
        }
        if (cache.type === "redis" || cache.type === "ioredis" || cache.type === "ioredis/cluster") {
            return new RedisQueryResultCache_1.RedisQueryResultCache(this.connection, cache.type);
        } else {
            return new DbQueryResultCache_1.DbQueryResultCache(this.connection);
        }
    }
}
exports.QueryResultCacheFactory = QueryResultCacheFactory; //# sourceMappingURL=QueryResultCacheFactory.js.map
}}),
"[project]/node_modules/typeorm/data-source/DataSource.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataSource = void 0;
const query_builder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/index.js [app-route] (ecmascript)");
const DefaultNamingStrategy_1 = __turbopack_context__.r("[project]/node_modules/typeorm/naming-strategy/DefaultNamingStrategy.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const MigrationExecutor_1 = __turbopack_context__.r("[project]/node_modules/typeorm/migration/MigrationExecutor.js [app-route] (ecmascript)");
const EntityMetadataValidator_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata-builder/EntityMetadataValidator.js [app-route] (ecmascript)");
const EntityManagerFactory_1 = __turbopack_context__.r("[project]/node_modules/typeorm/entity-manager/EntityManagerFactory.js [app-route] (ecmascript)");
const DriverFactory_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverFactory.js [app-route] (ecmascript)");
const ConnectionMetadataBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/connection/ConnectionMetadataBuilder.js [app-route] (ecmascript)");
const SelectQueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/SelectQueryBuilder.js [app-route] (ecmascript)");
const LoggerFactory_1 = __turbopack_context__.r("[project]/node_modules/typeorm/logger/LoggerFactory.js [app-route] (ecmascript)");
const QueryResultCacheFactory_1 = __turbopack_context__.r("[project]/node_modules/typeorm/cache/QueryResultCacheFactory.js [app-route] (ecmascript)");
const RelationLoader_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/RelationLoader.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
const RelationIdLoader_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/RelationIdLoader.js [app-route] (ecmascript)");
const DriverUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/driver/DriverUtils.js [app-route] (ecmascript)");
const InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
const SqlTagUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/SqlTagUtils.js [app-route] (ecmascript)");
(0, query_builder_1.registerQueryBuilders)();
/**
 * DataSource is a pre-defined connection configuration to a specific database.
 * You can have multiple data sources connected (with multiple connections in it),
 * connected to multiple databases in your application.
 *
 * Before, it was called `Connection`, but now `Connection` is deprecated
 * because `Connection` isn't the best name for what it's actually is.
 */ class DataSource {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------
    constructor(options){
        this["@instanceof"] = Symbol.for("DataSource");
        /**
         * Migration instances that are registered for this connection.
         */ this.migrations = [];
        /**
         * Entity subscriber instances that are registered for this connection.
         */ this.subscribers = [];
        /**
         * All entity metadatas that are registered for this connection.
         */ this.entityMetadatas = [];
        /**
         * All entity metadatas that are registered for this connection.
         * This is a copy of #.entityMetadatas property -> used for more performant searches.
         */ this.entityMetadatasMap = new Map();
        (0, query_builder_1.registerQueryBuilders)();
        this.name = options.name || "default";
        this.options = options;
        this.logger = new LoggerFactory_1.LoggerFactory().create(this.options.logger, this.options.logging);
        this.driver = new DriverFactory_1.DriverFactory().create(this);
        this.manager = this.createEntityManager();
        this.namingStrategy = options.namingStrategy || new DefaultNamingStrategy_1.DefaultNamingStrategy();
        this.metadataTableName = options.metadataTableName || "typeorm_metadata";
        this.queryResultCache = options.cache ? new QueryResultCacheFactory_1.QueryResultCacheFactory(this).create() : undefined;
        this.relationLoader = new RelationLoader_1.RelationLoader(this);
        this.relationIdLoader = new RelationIdLoader_1.RelationIdLoader(this);
        this.isInitialized = false;
    }
    // -------------------------------------------------------------------------
    // Public Accessors
    // -------------------------------------------------------------------------
    /**
     Indicates if DataSource is initialized or not.
     *
     * @deprecated use .isInitialized instead
     */ get isConnected() {
        return this.isInitialized;
    }
    /**
     * Gets the mongodb entity manager that allows to perform mongodb-specific repository operations
     * with any entity in this connection.
     *
     * Available only in mongodb connections.
     */ get mongoManager() {
        if (!InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.manager)) throw new error_1.TypeORMError(`MongoEntityManager is only available for MongoDB databases.`);
        return this.manager;
    }
    /**
     * Gets a sql.js specific Entity Manager that allows to perform special load and save operations
     *
     * Available only in connection with the sqljs driver.
     */ get sqljsManager() {
        if (!InstanceChecker_1.InstanceChecker.isSqljsEntityManager(this.manager)) throw new error_1.TypeORMError(`SqljsEntityManager is only available for Sqljs databases.`);
        return this.manager;
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * Updates current connection options with provided options.
     */ setOptions(options) {
        Object.assign(this.options, options);
        if (options.logger || options.logging) {
            this.logger = new LoggerFactory_1.LoggerFactory().create(options.logger || this.options.logger, options.logging || this.options.logging);
        }
        if (options.namingStrategy) {
            this.namingStrategy = options.namingStrategy;
        }
        if (options.cache) {
            this.queryResultCache = new QueryResultCacheFactory_1.QueryResultCacheFactory(this).create();
        }
        // todo: we must update the database in the driver as well, if it was set by setOptions method
        //  in the future we need to refactor the code and remove "database" from the driver, and instead
        //  use database (and options) from a single place - data source.
        if (options.database) {
            this.driver.database = DriverUtils_1.DriverUtils.buildDriverOptions(this.options).database;
        }
        // todo: need to take a look if we need to update schema and other "poor" properties
        return this;
    }
    /**
     * Performs connection to the database.
     * This method should be called once on application bootstrap.
     * This method not necessarily creates database connection (depend on database type),
     * but it also can setup a connection pool with database to use.
     */ async initialize() {
        if (this.isInitialized) throw new error_1.CannotConnectAlreadyConnectedError(this.name);
        // connect to the database via its driver
        await this.driver.connect();
        // connect to the cache-specific database if cache is enabled
        if (this.queryResultCache) await this.queryResultCache.connect();
        // set connected status for the current connection
        ObjectUtils_1.ObjectUtils.assign(this, {
            isInitialized: true
        });
        try {
            // build all metadatas registered in the current connection
            await this.buildMetadatas();
            await this.driver.afterConnect();
            // if option is set - drop schema once connection is done
            if (this.options.dropSchema) await this.dropDatabase();
            // if option is set - automatically synchronize a schema
            if (this.options.migrationsRun) await this.runMigrations({
                transaction: this.options.migrationsTransactionMode
            });
            // if option is set - automatically synchronize a schema
            if (this.options.synchronize) await this.synchronize();
        } catch (error) {
            // if for some reason build metadata fail (for example validation error during entity metadata check)
            // connection needs to be closed
            await this.destroy();
            throw error;
        }
        return this;
    }
    /**
     * Performs connection to the database.
     * This method should be called once on application bootstrap.
     * This method not necessarily creates database connection (depend on database type),
     * but it also can setup a connection pool with database to use.
     *
     * @deprecated use .initialize method instead
     */ async connect() {
        return this.initialize();
    }
    /**
     * Closes connection with the database.
     * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.
     */ async destroy() {
        if (!this.isInitialized) throw new error_1.CannotExecuteNotConnectedError(this.name);
        await this.driver.disconnect();
        // disconnect from the cache-specific database if cache was enabled
        if (this.queryResultCache) await this.queryResultCache.disconnect();
        ObjectUtils_1.ObjectUtils.assign(this, {
            isInitialized: false
        });
    }
    /**
     * Closes connection with the database.
     * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.
     *
     * @deprecated use .destroy method instead
     */ async close() {
        return this.destroy();
    }
    /**
     * Creates database schema for all entities registered in this connection.
     * Can be used only after connection to the database is established.
     *
     * @param dropBeforeSync If set to true then it drops the database with all its tables and data
     */ async synchronize(dropBeforeSync = false) {
        if (!this.isInitialized) throw new error_1.CannotExecuteNotConnectedError(this.name);
        if (dropBeforeSync) await this.dropDatabase();
        const schemaBuilder = this.driver.createSchemaBuilder();
        await schemaBuilder.build();
    }
    /**
     * Drops the database and all its data.
     * Be careful with this method on production since this method will erase all your database tables and their data.
     * Can be used only after connection to the database is established.
     */ // TODO rename
    async dropDatabase() {
        const queryRunner = this.createQueryRunner();
        try {
            if (this.driver.options.type === "mssql" || DriverUtils_1.DriverUtils.isMySQLFamily(this.driver) || this.driver.options.type === "aurora-mysql" || DriverUtils_1.DriverUtils.isSQLiteFamily(this.driver)) {
                const databases = [];
                this.entityMetadatas.forEach((metadata)=>{
                    if (metadata.database && databases.indexOf(metadata.database) === -1) databases.push(metadata.database);
                });
                if (databases.length === 0 && this.driver.database) {
                    databases.push(this.driver.database);
                }
                if (databases.length === 0) {
                    await queryRunner.clearDatabase();
                } else {
                    for (const database of databases){
                        await queryRunner.clearDatabase(database);
                    }
                }
            } else {
                await queryRunner.clearDatabase();
            }
        } finally{
            await queryRunner.release();
        }
    }
    /**
     * Runs all pending migrations.
     * Can be used only after connection to the database is established.
     */ async runMigrations(options) {
        if (!this.isInitialized) throw new error_1.CannotExecuteNotConnectedError(this.name);
        const migrationExecutor = new MigrationExecutor_1.MigrationExecutor(this);
        migrationExecutor.transaction = options?.transaction || this.options?.migrationsTransactionMode || "all";
        migrationExecutor.fake = options && options.fake || false;
        const successMigrations = await migrationExecutor.executePendingMigrations();
        return successMigrations;
    }
    /**
     * Reverts last executed migration.
     * Can be used only after connection to the database is established.
     */ async undoLastMigration(options) {
        if (!this.isInitialized) throw new error_1.CannotExecuteNotConnectedError(this.name);
        const migrationExecutor = new MigrationExecutor_1.MigrationExecutor(this);
        migrationExecutor.transaction = options && options.transaction || "all";
        migrationExecutor.fake = options && options.fake || false;
        await migrationExecutor.undoLastMigration();
    }
    /**
     * Lists all migrations and whether they have been run.
     * Returns true if there are pending migrations
     */ async showMigrations() {
        if (!this.isInitialized) {
            throw new error_1.CannotExecuteNotConnectedError(this.name);
        }
        const migrationExecutor = new MigrationExecutor_1.MigrationExecutor(this);
        return await migrationExecutor.showMigrations();
    }
    /**
     * Checks if entity metadata exist for the given entity class, target name or table name.
     */ hasMetadata(target) {
        return !!this.findMetadata(target);
    }
    /**
     * Gets entity metadata for the given entity class or schema name.
     */ getMetadata(target) {
        const metadata = this.findMetadata(target);
        if (!metadata) throw new error_1.EntityMetadataNotFoundError(target);
        return metadata;
    }
    /**
     * Gets repository for the given entity.
     */ getRepository(target) {
        return this.manager.getRepository(target);
    }
    /**
     * Gets tree repository for the given entity class or name.
     * Only tree-type entities can have a TreeRepository, like ones decorated with @Tree decorator.
     */ getTreeRepository(target) {
        return this.manager.getTreeRepository(target);
    }
    /**
     * Gets mongodb-specific repository for the given entity class or name.
     * Works only if connection is mongodb-specific.
     */ getMongoRepository(target) {
        if (!(this.driver.options.type === "mongodb")) throw new error_1.TypeORMError(`You can use getMongoRepository only for MongoDB connections.`);
        return this.manager.getRepository(target);
    }
    /**
     * Gets custom entity repository marked with @EntityRepository decorator.
     *
     * @deprecated use Repository.extend function to create a custom repository
     */ getCustomRepository(customRepository) {
        return this.manager.getCustomRepository(customRepository);
    }
    async transaction(isolationOrRunInTransaction, runInTransactionParam) {
        return this.manager.transaction(isolationOrRunInTransaction, runInTransactionParam);
    }
    /**
     * Executes raw SQL query and returns raw database results.
     *
     * @see [Official docs](https://typeorm.io/data-source-api) for examples.
     */ async query(query, parameters, queryRunner) {
        if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.manager)) throw new error_1.TypeORMError(`Queries aren't supported by MongoDB.`);
        if (queryRunner && queryRunner.isReleased) throw new error_1.QueryRunnerProviderAlreadyReleasedError();
        const usedQueryRunner = queryRunner || this.createQueryRunner();
        try {
            return await usedQueryRunner.query(query, parameters); // await is needed here because we are using finally
        } finally{
            if (!queryRunner) await usedQueryRunner.release();
        }
    }
    /**
     * Tagged template function that executes raw SQL query and returns raw database results.
     * Template expressions are automatically transformed into database parameters.
     * Raw query execution is supported only by relational databases (MongoDB is not supported).
     * Note: Don't call this as a regular function, it is meant to be used with backticks to tag a template literal.
     * Example: dataSource.sql`SELECT * FROM table_name WHERE id = ${id}`
     */ async sql(strings, ...values) {
        const { query, parameters } = (0, SqlTagUtils_1.buildSqlTag)({
            driver: this.driver,
            strings: strings,
            expressions: values
        });
        return await this.query(query, parameters);
    }
    /**
     * Creates a new query builder that can be used to build a SQL query.
     */ createQueryBuilder(entityOrRunner, alias, queryRunner) {
        if (InstanceChecker_1.InstanceChecker.isMongoEntityManager(this.manager)) throw new error_1.TypeORMError(`Query Builder is not supported by MongoDB.`);
        if (alias) {
            alias = DriverUtils_1.DriverUtils.buildAlias(this.driver, undefined, alias);
            const metadata = this.getMetadata(entityOrRunner);
            return new SelectQueryBuilder_1.SelectQueryBuilder(this, queryRunner).select(alias).from(metadata.target, alias);
        } else {
            return new SelectQueryBuilder_1.SelectQueryBuilder(this, entityOrRunner);
        }
    }
    /**
     * Creates a query runner used for perform queries on a single database connection.
     * Using query runners you can control your queries to execute using single database connection and
     * manually control your database transaction.
     *
     * Mode is used in replication mode and indicates whatever you want to connect
     * to master database or any of slave databases.
     * If you perform writes you must use master database,
     * if you perform reads you can use slave databases.
     */ createQueryRunner(mode = "master") {
        const queryRunner = this.driver.createQueryRunner(mode);
        const manager = this.createEntityManager(queryRunner);
        Object.assign(queryRunner, {
            manager: manager
        });
        return queryRunner;
    }
    /**
     * Gets entity metadata of the junction table (many-to-many table).
     */ getManyToManyMetadata(entityTarget, relationPropertyPath) {
        const relationMetadata = this.getMetadata(entityTarget).findRelationWithPropertyPath(relationPropertyPath);
        if (!relationMetadata) throw new error_1.TypeORMError(`Relation "${relationPropertyPath}" was not found in ${entityTarget} entity.`);
        if (!relationMetadata.isManyToMany) throw new error_1.TypeORMError(`Relation "${entityTarget}#${relationPropertyPath}" does not have a many-to-many relationship.` + `You can use this method only on many-to-many relations.`);
        return relationMetadata.junctionEntityMetadata;
    }
    /**
     * Creates an Entity Manager for the current connection with the help of the EntityManagerFactory.
     */ createEntityManager(queryRunner) {
        return new EntityManagerFactory_1.EntityManagerFactory().create(this, queryRunner);
    }
    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------
    /**
     * Finds exist entity metadata by the given entity class, target name or table name.
     */ findMetadata(target) {
        const metadataFromMap = this.entityMetadatasMap.get(target);
        if (metadataFromMap) return metadataFromMap;
        for (const [_, metadata] of this.entityMetadatasMap){
            if (InstanceChecker_1.InstanceChecker.isEntitySchema(target) && metadata.name === target.options.name) {
                return metadata;
            }
            if (typeof target === "string") {
                if (target.indexOf(".") !== -1) {
                    if (metadata.tablePath === target) {
                        return metadata;
                    }
                } else {
                    if (metadata.name === target || metadata.tableName === target) {
                        return metadata;
                    }
                }
            }
            if (ObjectUtils_1.ObjectUtils.isObjectWithName(target) && typeof target.name === "string") {
                if (target.name.indexOf(".") !== -1) {
                    if (metadata.tablePath === target.name) {
                        return metadata;
                    }
                } else {
                    if (metadata.name === target.name || metadata.tableName === target.name) {
                        return metadata;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Builds metadatas for all registered classes inside this connection.
     */ async buildMetadatas() {
        const connectionMetadataBuilder = new ConnectionMetadataBuilder_1.ConnectionMetadataBuilder(this);
        const entityMetadataValidator = new EntityMetadataValidator_1.EntityMetadataValidator();
        // create subscribers instances if they are not disallowed from high-level (for example they can disallowed from migrations run process)
        const flattenedSubscribers = ObjectUtils_1.ObjectUtils.mixedListToArray(this.options.subscribers || []);
        const subscribers = await connectionMetadataBuilder.buildSubscribers(flattenedSubscribers);
        ObjectUtils_1.ObjectUtils.assign(this, {
            subscribers: subscribers
        });
        // build entity metadatas
        const flattenedEntities = ObjectUtils_1.ObjectUtils.mixedListToArray(this.options.entities || []);
        const entityMetadatas = await connectionMetadataBuilder.buildEntityMetadatas(flattenedEntities);
        ObjectUtils_1.ObjectUtils.assign(this, {
            entityMetadatas: entityMetadatas,
            entityMetadatasMap: new Map(entityMetadatas.map((metadata)=>[
                    metadata.target,
                    metadata
                ]))
        });
        // create migration instances
        const flattenedMigrations = ObjectUtils_1.ObjectUtils.mixedListToArray(this.options.migrations || []);
        const migrations = await connectionMetadataBuilder.buildMigrations(flattenedMigrations);
        ObjectUtils_1.ObjectUtils.assign(this, {
            migrations: migrations
        });
        // validate all created entity metadatas to make sure user created entities are valid and correct
        entityMetadataValidator.validateMany(this.entityMetadatas.filter((metadata)=>metadata.tableType !== "view"), this.driver);
        // set current data source to the entities
        for (const entityMetadata of entityMetadatas){
            if (InstanceChecker_1.InstanceChecker.isBaseEntityConstructor(entityMetadata.target)) {
                entityMetadata.target.useDataSource(this);
            }
        }
    }
    /**
     * Get the replication mode SELECT queries should use for this datasource by default
     */ defaultReplicationModeForReads() {
        if ("replication" in this.driver.options && this.driver.options.replication) {
            const value = this.driver.options.replication.defaultMode;
            if (value) {
                return value;
            }
        }
        return "slave";
    }
}
exports.DataSource = DataSource; //# sourceMappingURL=DataSource.js.map
}}),
"[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getMetadataArgsStorage = getMetadataArgsStorage;
exports.getConnectionOptions = getConnectionOptions;
exports.getConnectionManager = getConnectionManager;
exports.createConnection = createConnection;
exports.createConnections = createConnections;
exports.getConnection = getConnection;
exports.getManager = getManager;
exports.getMongoManager = getMongoManager;
exports.getSqljsManager = getSqljsManager;
exports.getRepository = getRepository;
exports.getTreeRepository = getTreeRepository;
exports.getCustomRepository = getCustomRepository;
exports.getMongoRepository = getMongoRepository;
exports.createQueryBuilder = createQueryBuilder;
const MetadataArgsStorage_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata-args/MetadataArgsStorage.js [app-route] (ecmascript)");
const PlatformTools_1 = __turbopack_context__.r("[project]/node_modules/typeorm/platform/PlatformTools.js [app-route] (ecmascript)");
const ConnectionOptionsReader_1 = __turbopack_context__.r("[project]/node_modules/typeorm/connection/ConnectionOptionsReader.js [app-route] (ecmascript)");
const ConnectionManager_1 = __turbopack_context__.r("[project]/node_modules/typeorm/connection/ConnectionManager.js [app-route] (ecmascript)");
const container_1 = __turbopack_context__.r("[project]/node_modules/typeorm/container.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Gets metadata args storage.
 */ function getMetadataArgsStorage() {
    // we should store metadata storage in a global variable otherwise it brings too much problems
    // one of the problem is that if any entity (or any other) will be imported before consumer will call
    // useContainer method with his own container implementation, that entity will be registered in the
    // old old container (default one post probably) and consumer will his entity.
    // calling useContainer before he imports any entity (or any other) is not always convenient.
    // another reason is that when we run migrations typeorm is being called from a global package
    // and it may load entities which register decorators in typeorm of local package
    // this leads to impossibility of usage of entities in migrations and cli related operations
    const globalScope = PlatformTools_1.PlatformTools.getGlobalVariable();
    if (!globalScope.typeormMetadataArgsStorage) globalScope.typeormMetadataArgsStorage = new MetadataArgsStorage_1.MetadataArgsStorage();
    return globalScope.typeormMetadataArgsStorage;
}
/**
 * Reads connection options stored in ormconfig configuration file.
 *
 * @deprecated
 */ async function getConnectionOptions(connectionName = "default") {
    return new ConnectionOptionsReader_1.ConnectionOptionsReader().get(connectionName);
}
/**
 * Gets a ConnectionManager which creates connections.
 *
 * @deprecated
 */ function getConnectionManager() {
    return (0, container_1.getFromContainer)(ConnectionManager_1.ConnectionManager);
}
/**
 * Creates a new connection and registers it in the manager.
 *
 * If connection options were not specified, then it will try to create connection automatically,
 * based on content of ormconfig (json/js/env) file or environment variables.
 * Only one connection from ormconfig will be created (name "default" or connection without name).
 *
 * @deprecated
 */ async function createConnection(optionsOrName) {
    const connectionName = typeof optionsOrName === "string" ? optionsOrName : "default";
    const options = ObjectUtils_1.ObjectUtils.isObject(optionsOrName) ? optionsOrName : await getConnectionOptions(connectionName);
    return getConnectionManager().create(options).connect();
}
/**
 * Creates new connections and registers them in the manager.
 *
 * If connection options were not specified, then it will try to create connection automatically,
 * based on content of ormconfig (json/js/env) file or environment variables.
 * All connections from the ormconfig will be created.
 *
 * @deprecated
 */ async function createConnections(options) {
    if (!options) options = await new ConnectionOptionsReader_1.ConnectionOptionsReader().all();
    const connections = options.map((options)=>getConnectionManager().create(options));
    // Do not use Promise.all or test 8522 will produce a dangling sqlite connection
    for (const connection of connections){
        await connection.connect();
    }
    return connections;
}
/**
 * Gets connection from the connection manager.
 * If connection name wasn't specified, then "default" connection will be retrieved.
 *
 * @deprecated
 */ function getConnection(connectionName = "default") {
    return getConnectionManager().get(connectionName);
}
/**
 * Gets entity manager from the connection.
 * If connection name wasn't specified, then "default" connection will be retrieved.
 *
 * @deprecated
 */ function getManager(connectionName = "default") {
    return getConnectionManager().get(connectionName).manager;
}
/**
 * Gets MongoDB entity manager from the connection.
 * If connection name wasn't specified, then "default" connection will be retrieved.
 *
 * @deprecated
 */ function getMongoManager(connectionName = "default") {
    return getConnectionManager().get(connectionName).manager;
}
/**
 * Gets Sqljs entity manager from connection name.
 * "default" connection is used, when no name is specified.
 * Only works when Sqljs driver is used.
 *
 * @deprecated
 */ function getSqljsManager(connectionName = "default") {
    return getConnectionManager().get(connectionName).manager;
}
/**
 * Gets repository for the given entity class.
 *
 * @deprecated
 */ function getRepository(entityClass, connectionName = "default") {
    return getConnectionManager().get(connectionName).getRepository(entityClass);
}
/**
 * Gets tree repository for the given entity class.
 *
 * @deprecated
 */ function getTreeRepository(entityClass, connectionName = "default") {
    return getConnectionManager().get(connectionName).getTreeRepository(entityClass);
}
/**
 * Gets tree repository for the given entity class.
 *
 * @deprecated
 */ function getCustomRepository(customRepository, connectionName = "default") {
    return getConnectionManager().get(connectionName).getCustomRepository(customRepository);
}
/**
 * Gets mongodb repository for the given entity class or name.
 *
 * @deprecated
 */ function getMongoRepository(entityClass, connectionName = "default") {
    return getConnectionManager().get(connectionName).getMongoRepository(entityClass);
}
/**
 * Creates a new query builder.
 *
 * @deprecated
 */ function createQueryBuilder(entityClass, alias, connectionName = "default") {
    if (entityClass) {
        return getRepository(entityClass, connectionName).createQueryBuilder(alias);
    }
    return getConnection(connectionName).createQueryBuilder();
} //# sourceMappingURL=globals.js.map
}}),
"[project]/node_modules/typeorm/common/EntityTarget.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=EntityTarget.js.map
}}),
"[project]/node_modules/typeorm/common/ObjectType.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=ObjectType.js.map
}}),
"[project]/node_modules/typeorm/common/ObjectLiteral.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=ObjectLiteral.js.map
}}),
"[project]/node_modules/typeorm/common/MixedList.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=MixedList.js.map
}}),
"[project]/node_modules/typeorm/common/DeepPartial.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=DeepPartial.js.map
}}),
"[project]/node_modules/typeorm/common/RelationType.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=RelationType.js.map
}}),
"[project]/node_modules/typeorm/decorator/columns/Column.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Column = Column;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const ColumnTypeUndefinedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/ColumnTypeUndefinedError.js [app-route] (ecmascript)");
/**
 * Column decorator is used to mark a specific class property as a table column.
 * Only properties decorated with this decorator will be persisted to the database when entity be saved.
 */ function Column(typeOrOptions, options) {
    return function(object, propertyName) {
        // normalize parameters
        let type;
        if (typeof typeOrOptions === "string" || typeof typeOrOptions === "function") {
            type = typeOrOptions;
        } else if (typeOrOptions) {
            options = typeOrOptions;
            type = typeOrOptions.type;
        }
        if (!options) options = {};
        // if type is not given explicitly then try to guess it
        const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
        if (!type && reflectMetadataType) // if type is not given explicitly then try to guess it
        type = reflectMetadataType;
        // check if there is no type in column options then set type from first function argument, or guessed one
        if (!options.type && type) options.type = type;
        // specify HSTORE type if column is HSTORE
        if (options.type === "hstore" && !options.hstoreType) options.hstoreType = reflectMetadataType === Object ? "object" : "string";
        if (typeof typeOrOptions === "function") {
            // register an embedded
            (0, globals_1.getMetadataArgsStorage)().embeddeds.push({
                target: object.constructor,
                propertyName: propertyName,
                isArray: reflectMetadataType === Array || options.array === true,
                prefix: options.prefix !== undefined ? options.prefix : undefined,
                type: typeOrOptions
            });
        } else {
            // register a regular column
            // if we still don't have a type then we need to give error to user that type is required
            if (!options.type) throw new ColumnTypeUndefinedError_1.ColumnTypeUndefinedError(object, propertyName);
            // create unique
            if (options.unique === true) (0, globals_1.getMetadataArgsStorage)().uniques.push({
                target: object.constructor,
                columns: [
                    propertyName
                ]
            });
            (0, globals_1.getMetadataArgsStorage)().columns.push({
                target: object.constructor,
                propertyName: propertyName,
                mode: "regular",
                options: options
            });
            if (options.generated) {
                (0, globals_1.getMetadataArgsStorage)().generations.push({
                    target: object.constructor,
                    propertyName: propertyName,
                    strategy: typeof options.generated === "string" ? options.generated : "increment"
                });
            }
        }
    };
} //# sourceMappingURL=Column.js.map
}}),
"[project]/node_modules/typeorm/decorator/columns/CreateDateColumn.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateDateColumn = CreateDateColumn;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * This column will store a creation date of the inserted object.
 * Creation date is generated and inserted only once,
 * at the first time when you create an object, the value is inserted into the table, and is never touched again.
 */ function CreateDateColumn(options) {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().columns.push({
            target: object.constructor,
            propertyName: propertyName,
            mode: "createDate",
            options: options || {}
        });
    };
} //# sourceMappingURL=CreateDateColumn.js.map
}}),
"[project]/node_modules/typeorm/decorator/columns/DeleteDateColumn.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DeleteDateColumn = DeleteDateColumn;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * This column will store a delete date of the soft-deleted object.
 * This date is being updated each time you soft-delete the object.
 */ function DeleteDateColumn(options) {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().columns.push({
            target: object.constructor,
            propertyName: propertyName,
            mode: "deleteDate",
            options: options || {}
        });
    };
} //# sourceMappingURL=DeleteDateColumn.js.map
}}),
"[project]/node_modules/typeorm/decorator/columns/PrimaryGeneratedColumn.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PrimaryGeneratedColumn = PrimaryGeneratedColumn;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Column decorator is used to mark a specific class property as a table column.
 * Only properties decorated with this decorator will be persisted to the database when entity be saved.
 * This column creates an integer PRIMARY COLUMN with generated set to true.
 */ function PrimaryGeneratedColumn(strategyOrOptions, maybeOptions) {
    // normalize parameters
    const options = {};
    let strategy;
    if (strategyOrOptions) {
        if (typeof strategyOrOptions === "string") strategy = strategyOrOptions;
        if (ObjectUtils_1.ObjectUtils.isObject(strategyOrOptions)) {
            strategy = "increment";
            Object.assign(options, strategyOrOptions);
        }
    } else {
        strategy = "increment";
    }
    if (ObjectUtils_1.ObjectUtils.isObject(maybeOptions)) Object.assign(options, maybeOptions);
    return function(object, propertyName) {
        // if column type is not explicitly set then determine it based on generation strategy
        if (!options.type) {
            if (strategy === "increment" || strategy === "identity") {
                options.type = Number;
            } else if (strategy === "uuid") {
                options.type = "uuid";
            } else if (strategy === "rowid") {
                options.type = "int";
            }
        }
        // explicitly set a primary and generated to column options
        options.primary = true;
        // register column metadata args
        (0, globals_1.getMetadataArgsStorage)().columns.push({
            target: object.constructor,
            propertyName: propertyName,
            mode: "regular",
            options: options
        });
        // register generated metadata args
        (0, globals_1.getMetadataArgsStorage)().generations.push({
            target: object.constructor,
            propertyName: propertyName,
            strategy: strategy
        });
    };
} //# sourceMappingURL=PrimaryGeneratedColumn.js.map
}}),
"[project]/node_modules/typeorm/decorator/columns/PrimaryColumn.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PrimaryColumn = PrimaryColumn;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const ColumnTypeUndefinedError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/ColumnTypeUndefinedError.js [app-route] (ecmascript)");
const PrimaryColumnCannotBeNullableError_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/PrimaryColumnCannotBeNullableError.js [app-route] (ecmascript)");
/**
 * Column decorator is used to mark a specific class property as a table column.
 * Only properties decorated with this decorator will be persisted to the database when entity be saved.
 * Primary columns also creates a PRIMARY KEY for this column in a db.
 */ function PrimaryColumn(typeOrOptions, options) {
    return function(object, propertyName) {
        // normalize parameters
        let type;
        if (typeof typeOrOptions === "string" || typeOrOptions === String || typeOrOptions === Boolean || typeOrOptions === Number) {
            type = typeOrOptions;
        } else {
            options = Object.assign({}, typeOrOptions);
        }
        if (!options) options = {};
        // if type is not given explicitly then try to guess it
        const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
        if (!type && reflectMetadataType) type = reflectMetadataType;
        // check if there is no type in column options then set type from first function argument, or guessed one
        if (!options.type && type) options.type = type;
        // if we still don't have a type then we need to give error to user that type is required
        if (!options.type) throw new ColumnTypeUndefinedError_1.ColumnTypeUndefinedError(object, propertyName);
        // check if column is not nullable, because we cannot allow a primary key to be nullable
        if (options.nullable) throw new PrimaryColumnCannotBeNullableError_1.PrimaryColumnCannotBeNullableError(object, propertyName);
        // explicitly set a primary to column options
        options.primary = true;
        // create and register a new column metadata
        (0, globals_1.getMetadataArgsStorage)().columns.push({
            target: object.constructor,
            propertyName: propertyName,
            mode: "regular",
            options: options
        });
        if (options.generated) {
            (0, globals_1.getMetadataArgsStorage)().generations.push({
                target: object.constructor,
                propertyName: propertyName,
                strategy: typeof options.generated === "string" ? options.generated : "increment"
            });
        }
    };
} //# sourceMappingURL=PrimaryColumn.js.map
}}),
"[project]/node_modules/typeorm/decorator/columns/UpdateDateColumn.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdateDateColumn = UpdateDateColumn;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * This column will store an update date of the updated object.
 * This date is being updated each time you persist the object.
 */ function UpdateDateColumn(options) {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().columns.push({
            target: object.constructor,
            propertyName: propertyName,
            mode: "updateDate",
            options: options ? options : {}
        });
    };
} //# sourceMappingURL=UpdateDateColumn.js.map
}}),
"[project]/node_modules/typeorm/decorator/columns/VersionColumn.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VersionColumn = VersionColumn;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * This column will store a number - version of the entity.
 * Every time your entity will be persisted, this number will be increased by one -
 * so you can organize visioning and update strategies of your entity.
 */ function VersionColumn(options) {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().columns.push({
            target: object.constructor,
            propertyName: propertyName,
            mode: "version",
            options: options || {}
        });
    };
} //# sourceMappingURL=VersionColumn.js.map
}}),
"[project]/node_modules/typeorm/decorator/columns/VirtualColumn.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VirtualColumn = VirtualColumn;
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * VirtualColumn decorator is used to mark a specific class property as a Virtual column.
 */ function VirtualColumn(typeOrOptions, options) {
    return function(object, propertyName) {
        // normalize parameters
        let type;
        if (typeof typeOrOptions === "string") {
            type = typeOrOptions;
        } else {
            options = typeOrOptions;
            type = options.type;
        }
        if (!options?.query) {
            throw new Error("Column options must be defined for calculated columns.");
        }
        // if type is not given explicitly then try to guess it
        const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
        if (!type && reflectMetadataType) // if type is not given explicitly then try to guess it
        type = reflectMetadataType;
        // check if there is no type in column options then set type from first function argument, or guessed one
        if (type) options.type = type;
        // specify HSTORE type if column is HSTORE
        if (options.type === "hstore" && !options.hstoreType) options.hstoreType = reflectMetadataType === Object ? "object" : "string";
        // if we still don't have a type then we need to give error to user that type is required
        if (!options.type) throw new error_1.ColumnTypeUndefinedError(object, propertyName);
        (0, globals_1.getMetadataArgsStorage)().columns.push({
            target: object.constructor,
            propertyName: propertyName,
            mode: "virtual-property",
            options: options || {}
        });
    };
} //# sourceMappingURL=VirtualColumn.js.map
}}),
"[project]/node_modules/typeorm/decorator/columns/ViewColumn.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewColumn = ViewColumn;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * ViewColumn decorator is used to mark a specific class property as a view column.
 */ function ViewColumn(options) {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().columns.push({
            target: object.constructor,
            propertyName: propertyName,
            mode: "regular",
            options: options || {}
        });
    };
} //# sourceMappingURL=ViewColumn.js.map
}}),
"[project]/node_modules/typeorm/decorator/columns/ObjectIdColumn.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ObjectIdColumn = ObjectIdColumn;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * Special type of column that is available only for MongoDB database.
 * Marks your entity's column to be an object id.
 */ function ObjectIdColumn(options) {
    return function(object, propertyName) {
        // if column options are not given then create a new empty options
        if (!options) options = {};
        options.primary = true;
        if (!options.name) options.name = "_id";
        // create and register a new column metadata
        (0, globals_1.getMetadataArgsStorage)().columns.push({
            target: object.constructor,
            propertyName: propertyName,
            mode: "objectId",
            options: options
        });
    };
} //# sourceMappingURL=ObjectIdColumn.js.map
}}),
"[project]/node_modules/typeorm/decorator/listeners/AfterInsert.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AfterInsert = AfterInsert;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const EventListenerTypes_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)");
/**
 * Calls a method on which this decorator is applied after this entity insertion.
 */ function AfterInsert() {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
            target: object.constructor,
            propertyName: propertyName,
            type: EventListenerTypes_1.EventListenerTypes.AFTER_INSERT
        });
    };
} //# sourceMappingURL=AfterInsert.js.map
}}),
"[project]/node_modules/typeorm/decorator/listeners/AfterLoad.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AfterLoad = AfterLoad;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const EventListenerTypes_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)");
/**
 * Calls a method on which this decorator is applied after entity is loaded.
 */ function AfterLoad() {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
            target: object.constructor,
            propertyName: propertyName,
            type: EventListenerTypes_1.EventListenerTypes.AFTER_LOAD
        });
    };
} //# sourceMappingURL=AfterLoad.js.map
}}),
"[project]/node_modules/typeorm/decorator/listeners/AfterRemove.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AfterRemove = AfterRemove;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const EventListenerTypes_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)");
/**
 * Calls a method on which this decorator is applied after this entity removal.
 */ function AfterRemove() {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
            target: object.constructor,
            propertyName: propertyName,
            type: EventListenerTypes_1.EventListenerTypes.AFTER_REMOVE
        });
    };
} //# sourceMappingURL=AfterRemove.js.map
}}),
"[project]/node_modules/typeorm/decorator/listeners/AfterSoftRemove.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AfterSoftRemove = AfterSoftRemove;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const EventListenerTypes_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)");
/**
 * Calls a method on which this decorator is applied before this entity soft removal.
 */ function AfterSoftRemove() {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
            target: object.constructor,
            propertyName: propertyName,
            type: EventListenerTypes_1.EventListenerTypes.AFTER_SOFT_REMOVE
        });
    };
} //# sourceMappingURL=AfterSoftRemove.js.map
}}),
"[project]/node_modules/typeorm/decorator/listeners/AfterRecover.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AfterRecover = AfterRecover;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const EventListenerTypes_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)");
/**
 * Calls a method on which this decorator is applied before this entity soft removal.
 */ function AfterRecover() {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
            target: object.constructor,
            propertyName: propertyName,
            type: EventListenerTypes_1.EventListenerTypes.AFTER_RECOVER
        });
    };
} //# sourceMappingURL=AfterRecover.js.map
}}),
"[project]/node_modules/typeorm/decorator/listeners/AfterUpdate.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AfterUpdate = AfterUpdate;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const EventListenerTypes_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)");
/**
 * Calls a method on which this decorator is applied after this entity update.
 */ function AfterUpdate() {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
            target: object.constructor,
            propertyName: propertyName,
            type: EventListenerTypes_1.EventListenerTypes.AFTER_UPDATE
        });
    };
} //# sourceMappingURL=AfterUpdate.js.map
}}),
"[project]/node_modules/typeorm/decorator/listeners/BeforeInsert.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BeforeInsert = BeforeInsert;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const EventListenerTypes_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)");
/**
 * Calls a method on which this decorator is applied before this entity insertion.
 */ function BeforeInsert() {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
            target: object.constructor,
            propertyName: propertyName,
            type: EventListenerTypes_1.EventListenerTypes.BEFORE_INSERT
        });
    };
} //# sourceMappingURL=BeforeInsert.js.map
}}),
"[project]/node_modules/typeorm/decorator/listeners/BeforeRemove.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BeforeRemove = BeforeRemove;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const EventListenerTypes_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)");
/**
 * Calls a method on which this decorator is applied before this entity removal.
 */ function BeforeRemove() {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
            target: object.constructor,
            propertyName: propertyName,
            type: EventListenerTypes_1.EventListenerTypes.BEFORE_REMOVE
        });
    };
} //# sourceMappingURL=BeforeRemove.js.map
}}),
"[project]/node_modules/typeorm/decorator/listeners/BeforeSoftRemove.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BeforeSoftRemove = BeforeSoftRemove;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const EventListenerTypes_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)");
/**
 * Calls a method on which this decorator is applied before this entity soft removal.
 */ function BeforeSoftRemove() {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
            target: object.constructor,
            propertyName: propertyName,
            type: EventListenerTypes_1.EventListenerTypes.BEFORE_SOFT_REMOVE
        });
    };
} //# sourceMappingURL=BeforeSoftRemove.js.map
}}),
"[project]/node_modules/typeorm/decorator/listeners/BeforeRecover.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BeforeRecover = BeforeRecover;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const EventListenerTypes_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)");
/**
 * Calls a method on which this decorator is applied before this entity soft removal.
 */ function BeforeRecover() {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
            target: object.constructor,
            propertyName: propertyName,
            type: EventListenerTypes_1.EventListenerTypes.BEFORE_RECOVER
        });
    };
} //# sourceMappingURL=BeforeRecover.js.map
}}),
"[project]/node_modules/typeorm/decorator/listeners/BeforeUpdate.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BeforeUpdate = BeforeUpdate;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const EventListenerTypes_1 = __turbopack_context__.r("[project]/node_modules/typeorm/metadata/types/EventListenerTypes.js [app-route] (ecmascript)");
/**
 * Calls a method on which this decorator is applied before this entity update.
 */ function BeforeUpdate() {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().entityListeners.push({
            target: object.constructor,
            propertyName: propertyName,
            type: EventListenerTypes_1.EventListenerTypes.BEFORE_UPDATE
        });
    };
} //# sourceMappingURL=BeforeUpdate.js.map
}}),
"[project]/node_modules/typeorm/decorator/listeners/EventSubscriber.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EventSubscriber = EventSubscriber;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * Classes decorated with this decorator will listen to ORM events and their methods will be triggered when event
 * occurs. Those classes must implement EventSubscriberInterface interface.
 */ function EventSubscriber() {
    return function(target) {
        (0, globals_1.getMetadataArgsStorage)().entitySubscribers.push({
            target: target
        });
    };
} //# sourceMappingURL=EventSubscriber.js.map
}}),
"[project]/node_modules/typeorm/decorator/options/ColumnOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=ColumnOptions.js.map
}}),
"[project]/node_modules/typeorm/decorator/options/IndexOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=IndexOptions.js.map
}}),
"[project]/node_modules/typeorm/decorator/options/JoinColumnOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=JoinColumnOptions.js.map
}}),
"[project]/node_modules/typeorm/decorator/options/JoinTableOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=JoinTableOptions.js.map
}}),
"[project]/node_modules/typeorm/decorator/options/RelationOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=RelationOptions.js.map
}}),
"[project]/node_modules/typeorm/decorator/options/EntityOptions.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=EntityOptions.js.map
}}),
"[project]/node_modules/typeorm/decorator/options/ValueTransformer.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=ValueTransformer.js.map
}}),
"[project]/node_modules/typeorm/decorator/relations/JoinColumn.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JoinColumn = JoinColumn;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * JoinColumn decorator used on one-to-one relations to specify owner side of relationship.
 * It also can be used on both one-to-one and many-to-one relations to specify custom column name
 * or custom referenced column.
 */ function JoinColumn(optionsOrOptionsArray) {
    return function(object, propertyName) {
        const options = Array.isArray(optionsOrOptionsArray) ? optionsOrOptionsArray : [
            optionsOrOptionsArray || {}
        ];
        options.forEach((options)=>{
            (0, globals_1.getMetadataArgsStorage)().joinColumns.push({
                target: object.constructor,
                propertyName: propertyName,
                name: options.name,
                referencedColumnName: options.referencedColumnName,
                foreignKeyConstraintName: options.foreignKeyConstraintName
            });
        });
    };
} //# sourceMappingURL=JoinColumn.js.map
}}),
"[project]/node_modules/typeorm/decorator/relations/JoinTable.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JoinTable = JoinTable;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * JoinTable decorator is used in many-to-many relationship to specify owner side of relationship.
 * Its also used to set a custom junction table's name, column names and referenced columns.
 */ function JoinTable(options) {
    return function(object, propertyName) {
        options = options || {};
        (0, globals_1.getMetadataArgsStorage)().joinTables.push({
            target: object.constructor,
            propertyName: propertyName,
            name: options.name,
            joinColumns: options && options.joinColumn ? [
                options.joinColumn
            ] : options.joinColumns,
            inverseJoinColumns: options && options.inverseJoinColumn ? [
                options.inverseJoinColumn
            ] : options.inverseJoinColumns,
            schema: options && options.schema ? options.schema : undefined,
            database: options && options.database ? options.database : undefined,
            synchronize: !(options && options.synchronize === false)
        });
    };
} //# sourceMappingURL=JoinTable.js.map
}}),
"[project]/node_modules/typeorm/decorator/relations/ManyToMany.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ManyToMany = ManyToMany;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Many-to-many is a type of relationship when Entity1 can have multiple instances of Entity2, and Entity2 can have
 * multiple instances of Entity1. To achieve it, this type of relation creates a junction table, where it storage
 * entity1 and entity2 ids. This is owner side of the relationship.
 */ function ManyToMany(typeFunctionOrTarget, inverseSideOrOptions, options) {
    // normalize parameters
    let inverseSideProperty;
    if (ObjectUtils_1.ObjectUtils.isObject(inverseSideOrOptions)) {
        options = inverseSideOrOptions;
    } else {
        inverseSideProperty = inverseSideOrOptions;
    }
    return function(object, propertyName) {
        if (!options) options = {};
        // now try to determine it its lazy relation
        let isLazy = options.lazy === true;
        if (!isLazy && Reflect && Reflect.getMetadata) {
            // automatic determination
            const reflectedType = Reflect.getMetadata("design:type", object, propertyName);
            if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise") isLazy = true;
        }
        (0, globals_1.getMetadataArgsStorage)().relations.push({
            target: object.constructor,
            propertyName: propertyName,
            // propertyType: reflectedType,
            relationType: "many-to-many",
            isLazy: isLazy,
            type: typeFunctionOrTarget,
            inverseSideProperty: inverseSideProperty,
            options: options
        });
    };
} //# sourceMappingURL=ManyToMany.js.map
}}),
"[project]/node_modules/typeorm/decorator/relations/ManyToOne.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ManyToOne = ManyToOne;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * A many-to-one relation allows creating the type of relation where Entity1 can have a single instance of Entity2, but
 * Entity2 can have multiple instances of Entity1. Entity1 is the owner of the relationship, and stores the id of
 * Entity2 on its side of the relation.
 */ function ManyToOne(typeFunctionOrTarget, inverseSideOrOptions, options) {
    // Normalize parameters.
    let inverseSideProperty;
    if (ObjectUtils_1.ObjectUtils.isObject(inverseSideOrOptions)) {
        options = inverseSideOrOptions;
    } else {
        inverseSideProperty = inverseSideOrOptions;
    }
    return function(object, propertyName) {
        if (!options) options = {};
        // Now try to determine if it is a lazy relation.
        let isLazy = options && options.lazy === true;
        if (!isLazy && Reflect && Reflect.getMetadata) {
            // automatic determination
            const reflectedType = Reflect.getMetadata("design:type", object, propertyName);
            if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise") isLazy = true;
        }
        (0, globals_1.getMetadataArgsStorage)().relations.push({
            target: object.constructor,
            propertyName: propertyName,
            // propertyType: reflectedType,
            relationType: "many-to-one",
            isLazy: isLazy,
            type: typeFunctionOrTarget,
            inverseSideProperty: inverseSideProperty,
            options: options
        });
    };
} //# sourceMappingURL=ManyToOne.js.map
}}),
"[project]/node_modules/typeorm/decorator/relations/OneToMany.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OneToMany = OneToMany;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * A one-to-many relation allows creating the type of relation where Entity1 can have multiple instances of Entity2,
 * but Entity2 has only one Entity1. Entity2 is the owner of the relationship, and stores the id of Entity1 on its
 * side of the relation.
 */ function OneToMany(typeFunctionOrTarget, inverseSide, options) {
    return function(object, propertyName) {
        if (!options) options = {};
        // Now try to determine if it is a lazy relation.
        let isLazy = options && options.lazy === true;
        if (!isLazy && Reflect && Reflect.getMetadata) {
            // automatic determination
            const reflectedType = Reflect.getMetadata("design:type", object, propertyName);
            if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise") isLazy = true;
        }
        (0, globals_1.getMetadataArgsStorage)().relations.push({
            target: object.constructor,
            propertyName: propertyName,
            // propertyType: reflectedType,
            isLazy: isLazy,
            relationType: "one-to-many",
            type: typeFunctionOrTarget,
            inverseSideProperty: inverseSide,
            options: options
        });
    };
} //# sourceMappingURL=OneToMany.js.map
}}),
"[project]/node_modules/typeorm/decorator/relations/OneToOne.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OneToOne = OneToOne;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * One-to-one relation allows the creation of a direct relation between two entities. Entity1 has only one Entity2.
 * Entity1 is the owner of the relationship, and stores Entity2 id on its own side.
 */ function OneToOne(typeFunctionOrTarget, inverseSideOrOptions, options) {
    // normalize parameters
    let inverseSideProperty;
    if (ObjectUtils_1.ObjectUtils.isObject(inverseSideOrOptions)) {
        options = inverseSideOrOptions;
    } else {
        inverseSideProperty = inverseSideOrOptions;
    }
    return function(object, propertyName) {
        if (!options) options = {};
        // now try to determine it its lazy relation
        let isLazy = options && options.lazy === true ? true : false;
        if (!isLazy && Reflect && Reflect.getMetadata) {
            // automatic determination
            const reflectedType = Reflect.getMetadata("design:type", object, propertyName);
            if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise") isLazy = true;
        }
        (0, globals_1.getMetadataArgsStorage)().relations.push({
            target: object.constructor,
            propertyName: propertyName,
            // propertyType: reflectedType,
            isLazy: isLazy,
            relationType: "one-to-one",
            type: typeFunctionOrTarget,
            inverseSideProperty: inverseSideProperty,
            options: options
        });
    };
} //# sourceMappingURL=OneToOne.js.map
}}),
"[project]/node_modules/typeorm/decorator/relations/RelationCount.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationCount = RelationCount;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * Holds a number of children in the closure table of the column.
 *
 * @deprecated This decorator will removed in the future versions.
 * Use {@link VirtualColumn} to calculate the count instead.
 */ function RelationCount(relation, alias, queryBuilderFactory) {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().relationCounts.push({
            target: object.constructor,
            propertyName: propertyName,
            relation: relation,
            alias: alias,
            queryBuilderFactory: queryBuilderFactory
        });
    };
} //# sourceMappingURL=RelationCount.js.map
}}),
"[project]/node_modules/typeorm/decorator/relations/RelationId.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RelationId = RelationId;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * Special decorator used to extract relation id into separate entity property.
 *
 * @experimental
 */ function RelationId(relation, alias, queryBuilderFactory) {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().relationIds.push({
            target: object.constructor,
            propertyName: propertyName,
            relation: relation,
            alias: alias,
            queryBuilderFactory: queryBuilderFactory
        });
    };
} //# sourceMappingURL=RelationId.js.map
}}),
"[project]/node_modules/typeorm/decorator/entity/Entity.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Entity = Entity;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * This decorator is used to mark classes that will be an entity (table or document depend on database type).
 * Database schema will be created for all classes decorated with it, and Repository can be retrieved and used for it.
 */ function Entity(nameOrOptions, maybeOptions) {
    const options = (ObjectUtils_1.ObjectUtils.isObject(nameOrOptions) ? nameOrOptions : maybeOptions) || {};
    const name = typeof nameOrOptions === "string" ? nameOrOptions : options.name;
    return function(target) {
        (0, globals_1.getMetadataArgsStorage)().tables.push({
            target: target,
            name: name,
            type: "regular",
            orderBy: options.orderBy ? options.orderBy : undefined,
            engine: options.engine ? options.engine : undefined,
            database: options.database ? options.database : undefined,
            schema: options.schema ? options.schema : undefined,
            synchronize: options.synchronize,
            withoutRowid: options.withoutRowid,
            comment: options.comment ? options.comment : undefined
        });
    };
} //# sourceMappingURL=Entity.js.map
}}),
"[project]/node_modules/typeorm/decorator/entity/ChildEntity.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChildEntity = ChildEntity;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * Special type of the table used in the single-table inherited tables.
 */ function ChildEntity(discriminatorValue) {
    return function(target) {
        // register a table metadata
        (0, globals_1.getMetadataArgsStorage)().tables.push({
            target: target,
            type: "entity-child"
        });
        // register discriminator value if it was provided
        if (typeof discriminatorValue !== "undefined") {
            (0, globals_1.getMetadataArgsStorage)().discriminatorValues.push({
                target: target,
                value: discriminatorValue
            });
        }
    };
} //# sourceMappingURL=ChildEntity.js.map
}}),
"[project]/node_modules/typeorm/decorator/entity/TableInheritance.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TableInheritance = TableInheritance;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * Sets for entity to use table inheritance pattern.
 */ function TableInheritance(options) {
    return function(target) {
        (0, globals_1.getMetadataArgsStorage)().inheritances.push({
            target: target,
            pattern: options && options.pattern ? options.pattern : "STI",
            column: options && options.column ? typeof options.column === "string" ? {
                name: options.column
            } : options.column : undefined
        });
    };
} //# sourceMappingURL=TableInheritance.js.map
}}),
"[project]/node_modules/typeorm/decorator/entity-view/ViewEntity.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ViewEntity = ViewEntity;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * This decorator is used to mark classes that will be an entity view.
 * Database schema will be created for all classes decorated with it, and Repository can be retrieved and used for it.
 */ function ViewEntity(nameOrOptions, maybeOptions) {
    const options = (ObjectUtils_1.ObjectUtils.isObject(nameOrOptions) ? nameOrOptions : maybeOptions) || {};
    const name = typeof nameOrOptions === "string" ? nameOrOptions : options.name;
    return function(target) {
        (0, globals_1.getMetadataArgsStorage)().tables.push({
            target: target,
            name: name,
            expression: options.expression,
            dependsOn: options.dependsOn ? new Set(options.dependsOn) : undefined,
            type: "view",
            database: options.database ? options.database : undefined,
            schema: options.schema ? options.schema : undefined,
            synchronize: options.synchronize === false ? false : true,
            materialized: !!options.materialized
        });
    };
} //# sourceMappingURL=ViewEntity.js.map
}}),
"[project]/node_modules/typeorm/decorator/tree/TreeLevelColumn.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TreeLevelColumn = TreeLevelColumn;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * Creates a "level"/"length" column to the table that holds a closure table.
 */ function TreeLevelColumn() {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().columns.push({
            target: object.constructor,
            propertyName: propertyName,
            mode: "treeLevel",
            options: {}
        });
    };
} //# sourceMappingURL=TreeLevelColumn.js.map
}}),
"[project]/node_modules/typeorm/decorator/tree/TreeParent.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TreeParent = TreeParent;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * Marks a entity property as a parent of the tree.
 * "Tree parent" indicates who owns (is a parent) of this entity in tree structure.
 */ function TreeParent(options) {
    return function(object, propertyName) {
        if (!options) options = {};
        // now try to determine it its lazy relation
        const reflectedType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
        const isLazy = reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise" || false;
        (0, globals_1.getMetadataArgsStorage)().relations.push({
            isTreeParent: true,
            target: object.constructor,
            propertyName: propertyName,
            isLazy: isLazy,
            relationType: "many-to-one",
            type: ()=>object.constructor,
            options: options
        });
    };
} //# sourceMappingURL=TreeParent.js.map
}}),
"[project]/node_modules/typeorm/decorator/tree/TreeChildren.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TreeChildren = TreeChildren;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * Marks a entity property as a children of the tree.
 * "Tree children" will contain all children (bind) of this entity.
 */ function TreeChildren(options) {
    return function(object, propertyName) {
        if (!options) options = {};
        // now try to determine it its lazy relation
        const reflectedType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
        const isLazy = reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise" || false;
        // add one-to-many relation for this
        (0, globals_1.getMetadataArgsStorage)().relations.push({
            isTreeChildren: true,
            target: object.constructor,
            propertyName: propertyName,
            isLazy: isLazy,
            relationType: "one-to-many",
            type: ()=>object.constructor,
            options: options
        });
    };
} //# sourceMappingURL=TreeChildren.js.map
}}),
"[project]/node_modules/typeorm/decorator/tree/Tree.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Tree = Tree;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * Marks entity to work like a tree.
 * Tree pattern that will be used for the tree entity should be specified.
 * @TreeParent decorator must be used in tree entities.
 * TreeRepository can be used to manipulate with tree entities.
 */ function Tree(type, options) {
    return function(target) {
        (0, globals_1.getMetadataArgsStorage)().trees.push({
            target: target,
            type: type,
            options: type === "closure-table" ? options : undefined
        });
    };
} //# sourceMappingURL=Tree.js.map
}}),
"[project]/node_modules/typeorm/decorator/Index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Index = Index;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Creates a database index.
 * Can be used on entity property or on entity.
 * Can create indices with composite columns when used on entity.
 */ function Index(nameOrFieldsOrOptions, maybeFieldsOrOptions, maybeOptions) {
    // normalize parameters
    const name = typeof nameOrFieldsOrOptions === "string" ? nameOrFieldsOrOptions : undefined;
    const fields = typeof nameOrFieldsOrOptions === "string" ? maybeFieldsOrOptions : nameOrFieldsOrOptions;
    let options = ObjectUtils_1.ObjectUtils.isObject(nameOrFieldsOrOptions) && !Array.isArray(nameOrFieldsOrOptions) ? nameOrFieldsOrOptions : maybeOptions;
    if (!options) options = ObjectUtils_1.ObjectUtils.isObject(maybeFieldsOrOptions) && !Array.isArray(maybeFieldsOrOptions) ? maybeFieldsOrOptions : maybeOptions;
    return function(clsOrObject, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().indices.push({
            target: propertyName ? clsOrObject.constructor : clsOrObject,
            name: name,
            columns: propertyName ? [
                propertyName
            ] : fields,
            synchronize: options && options.synchronize === false ? false : true,
            where: options ? options.where : undefined,
            unique: options && options.unique ? true : false,
            spatial: options && options.spatial ? true : false,
            fulltext: options && options.fulltext ? true : false,
            nullFiltered: options && options.nullFiltered ? true : false,
            parser: options ? options.parser : undefined,
            sparse: options && options.sparse ? true : false,
            background: options && options.background ? true : false,
            concurrent: options && options.concurrent ? true : false,
            expireAfterSeconds: options ? options.expireAfterSeconds : undefined
        });
    };
} //# sourceMappingURL=Index.js.map
}}),
"[project]/node_modules/typeorm/decorator/ForeignKey.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ForeignKey = ForeignKey;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Creates a database foreign key. Can be used on entity property or on entity.
 * Can create foreign key with composite columns when used on entity.
 * Warning! Don't use this with relations; relation decorators create foreign keys automatically.
 */ function ForeignKey(typeFunctionOrTarget, inverseSideOrColumnNamesOrOptions, referencedColumnNamesOrOptions, maybeOptions) {
    const inverseSide = typeof inverseSideOrColumnNamesOrOptions === "string" || typeof inverseSideOrColumnNamesOrOptions === "function" ? inverseSideOrColumnNamesOrOptions : undefined;
    const columnNames = Array.isArray(inverseSideOrColumnNamesOrOptions) ? inverseSideOrColumnNamesOrOptions : undefined;
    const referencedColumnNames = Array.isArray(referencedColumnNamesOrOptions) ? referencedColumnNamesOrOptions : undefined;
    const options = ObjectUtils_1.ObjectUtils.isObject(inverseSideOrColumnNamesOrOptions) && !Array.isArray(inverseSideOrColumnNamesOrOptions) ? inverseSideOrColumnNamesOrOptions : ObjectUtils_1.ObjectUtils.isObject(referencedColumnNamesOrOptions) && !Array.isArray(referencedColumnNamesOrOptions) ? referencedColumnNamesOrOptions : maybeOptions;
    return function(clsOrObject, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().foreignKeys.push({
            target: propertyName ? clsOrObject.constructor : clsOrObject,
            propertyName: propertyName,
            type: typeFunctionOrTarget,
            inverseSide,
            columnNames,
            referencedColumnNames,
            ...options
        });
    };
} //# sourceMappingURL=ForeignKey.js.map
}}),
"[project]/node_modules/typeorm/decorator/Unique.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Unique = Unique;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const ObjectUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/ObjectUtils.js [app-route] (ecmascript)");
/**
 * Composite unique constraint must be set on entity classes and must specify entity's fields to be unique.
 */ function Unique(nameOrFieldsOrOptions, maybeFieldsOrOptions, maybeOptions) {
    const name = typeof nameOrFieldsOrOptions === "string" ? nameOrFieldsOrOptions : undefined;
    const fields = typeof nameOrFieldsOrOptions === "string" ? maybeFieldsOrOptions : nameOrFieldsOrOptions;
    let options = ObjectUtils_1.ObjectUtils.isObject(nameOrFieldsOrOptions) && !Array.isArray(nameOrFieldsOrOptions) ? nameOrFieldsOrOptions : maybeOptions;
    if (!options) options = ObjectUtils_1.ObjectUtils.isObject(nameOrFieldsOrOptions) && !Array.isArray(maybeFieldsOrOptions) ? maybeFieldsOrOptions : maybeOptions;
    return function(clsOrObject, propertyName) {
        let columns = fields;
        if (propertyName !== undefined) {
            switch(typeof propertyName){
                case "string":
                    columns = [
                        propertyName
                    ];
                    break;
                case "symbol":
                    columns = [
                        propertyName.toString()
                    ];
                    break;
            }
        }
        const args = {
            target: propertyName ? clsOrObject.constructor : clsOrObject,
            name: name,
            columns,
            deferrable: options ? options.deferrable : undefined
        };
        (0, globals_1.getMetadataArgsStorage)().uniques.push(args);
    };
} //# sourceMappingURL=Unique.js.map
}}),
"[project]/node_modules/typeorm/decorator/Check.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Check = Check;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Creates a database check.
 * Can be used on entity property or on entity.
 * Can create checks with composite columns when used on entity.
 */ function Check(nameOrExpression, maybeExpression) {
    const name = maybeExpression ? nameOrExpression : undefined;
    const expression = maybeExpression ? maybeExpression : nameOrExpression;
    if (!expression) throw new error_1.TypeORMError(`Check expression is required`);
    return function(clsOrObject, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().checks.push({
            target: propertyName ? clsOrObject.constructor : clsOrObject,
            name: name,
            expression: expression
        });
    };
} //# sourceMappingURL=Check.js.map
}}),
"[project]/node_modules/typeorm/decorator/Exclusion.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Exclusion = Exclusion;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)");
/**
 * Creates a database exclusion.
 * Can be used on entity.
 * Can create exclusions with composite columns when used on entity.
 */ function Exclusion(nameOrExpression, maybeExpression) {
    const name = maybeExpression ? nameOrExpression : undefined;
    const expression = maybeExpression ? maybeExpression : nameOrExpression;
    if (!expression) throw new error_1.TypeORMError(`Exclusion expression is required`);
    return function(clsOrObject, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().exclusions.push({
            target: propertyName ? clsOrObject.constructor : clsOrObject,
            name: name,
            expression: expression
        });
    };
} //# sourceMappingURL=Exclusion.js.map
}}),
"[project]/node_modules/typeorm/decorator/Generated.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Generated = Generated;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * Marks a column to generate a value on entity insertion.
 * There are three types of generation strategy - increment, uuid and rowid (cockroachdb only).
 * Increment uses a number which increases by one on each insertion.
 * Uuid generates a special UUID token.
 * Rowid supports only in CockroachDB and uses `unique_rowid()` function
 *
 * Note, some databases do not support non-primary generation columns.
 */ function Generated(strategy = "increment") {
    return function(object, propertyName) {
        (0, globals_1.getMetadataArgsStorage)().generations.push({
            target: object.constructor,
            propertyName: propertyName,
            strategy: strategy
        });
    };
} //# sourceMappingURL=Generated.js.map
}}),
"[project]/node_modules/typeorm/decorator/EntityRepository.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntityRepository = EntityRepository;
const globals_1 = __turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)");
/**
 * Used to declare a class as a custom repository.
 * Custom repository can manage some specific entity or just be generic.
 * Custom repository optionally can extend AbstractRepository, Repository or TreeRepository.
 *
 * @deprecated use Repository.extend function to create a custom repository
 */ function EntityRepository(entity) {
    return function(target) {
        (0, globals_1.getMetadataArgsStorage)().entityRepositories.push({
            target: target,
            entity: entity
        });
    };
} //# sourceMappingURL=EntityRepository.js.map
}}),
"[project]/node_modules/typeorm/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TreeRepositoryUtils = exports.InstanceChecker = exports.EntitySchemaOptions = exports.EntitySchemaEmbeddedColumnOptions = exports.EntitySchema = exports.LegacyOracleNamingStrategy = exports.DefaultNamingStrategy = exports.MigrationExecutor = exports.Migration = exports.MongoEntityManager = exports.QueryResult = exports.DeleteResult = exports.UpdateResult = exports.InsertResult = exports.NotBrackets = exports.Brackets = exports.RelationQueryBuilder = exports.UpdateQueryBuilder = exports.InsertQueryBuilder = exports.DeleteQueryBuilder = exports.SelectQueryBuilder = exports.QueryBuilder = exports.ConnectionManager = exports.Connection = exports.DataSource = exports.ConnectionOptionsReader = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/tslib/tslib.es6.mjs [app-route] (ecmascript)");
/*!
 */ __turbopack_context__.r("[project]/node_modules/reflect-metadata/Reflect.js [app-route] (ecmascript)");
// -------------------------------------------------------------------------
// Commonly Used exports
// -------------------------------------------------------------------------
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/globals.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/container.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/common/EntityTarget.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/common/ObjectType.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/common/ObjectLiteral.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/common/MixedList.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/common/DeepPartial.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/common/RelationType.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/error/index.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/columns/Column.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/columns/CreateDateColumn.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/columns/DeleteDateColumn.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/columns/PrimaryGeneratedColumn.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/columns/PrimaryColumn.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/columns/UpdateDateColumn.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/columns/VersionColumn.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/columns/VirtualColumn.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/columns/ViewColumn.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/columns/ObjectIdColumn.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/listeners/AfterInsert.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/listeners/AfterLoad.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/listeners/AfterRemove.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/listeners/AfterSoftRemove.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/listeners/AfterRecover.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/listeners/AfterUpdate.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/listeners/BeforeInsert.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/listeners/BeforeRemove.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/listeners/BeforeSoftRemove.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/listeners/BeforeRecover.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/listeners/BeforeUpdate.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/listeners/EventSubscriber.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/options/ColumnOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/options/IndexOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/options/JoinColumnOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/options/JoinTableOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/options/RelationOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/options/EntityOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/options/ValueTransformer.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/relations/JoinColumn.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/relations/JoinTable.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/relations/ManyToMany.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/relations/ManyToOne.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/relations/OneToMany.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/relations/OneToOne.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/relations/RelationCount.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/relations/RelationId.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/entity/Entity.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/entity/ChildEntity.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/entity/TableInheritance.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/entity-view/ViewEntity.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/tree/TreeLevelColumn.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/tree/TreeParent.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/tree/TreeChildren.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/tree/Tree.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/Index.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/ForeignKey.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/Unique.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/Check.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/Exclusion.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/Generated.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/decorator/EntityRepository.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/And.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/Or.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/Any.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/ArrayContainedBy.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/ArrayContains.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/ArrayOverlap.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/Between.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/Equal.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/In.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/IsNull.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/LessThan.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/LessThanOrEqual.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/ILike.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/Like.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/MoreThan.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/MoreThanOrEqual.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/Not.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/Raw.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/operator/JsonContains.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/EqualOperator.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindManyOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOneOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperator.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOperatorType.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOptionsOrder.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOptionsRelations.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOptionsSelect.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOptionsUtils.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindOptionsWhere.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/FindTreeOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/JoinOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/find-options/OrderByCondition.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/logger/AbstractLogger.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/logger/Logger.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/logger/LoggerOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/logger/AdvancedConsoleLogger.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/logger/FormattedConsoleLogger.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/logger/SimpleConsoleLogger.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/logger/FileLogger.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/metadata/EntityMetadata.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/entity-manager/EntityManager.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/repository/AbstractRepository.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/repository/Repository.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/repository/BaseEntity.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/repository/TreeRepository.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/repository/MongoRepository.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/repository/RemoveOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/repository/SaveOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableCheck.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableColumn.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableExclusion.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableForeignKey.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableIndex.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/TableUnique.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/table/Table.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/view/View.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/options/TableCheckOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/options/TableColumnOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/options/TableExclusionOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/options/TableForeignKeyOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/options/TableIndexOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/options/TableOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/options/TableUniqueOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/schema-builder/options/ViewOptions.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/driver/mongodb/typings.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/driver/types/DatabaseType.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/driver/types/GeoJsonTypes.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/driver/types/ReplicationMode.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/driver/sqlserver/MssqlParameter.js [app-route] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/typeorm/subscriber/event/QueryEvent.js [app-route] (ecmascript)"), exports);
// export * from "./data-source";
var ConnectionOptionsReader_1 = __turbopack_context__.r("[project]/node_modules/typeorm/connection/ConnectionOptionsReader.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ConnectionOptionsReader", {
    enumerable: true,
    get: function() {
        return ConnectionOptionsReader_1.ConnectionOptionsReader;
    }
});
var DataSource_1 = __turbopack_context__.r("[project]/node_modules/typeorm/data-source/DataSource.js [app-route] (ecmascript)");
Object.defineProperty(exports, "DataSource", {
    enumerable: true,
    get: function() {
        return DataSource_1.DataSource;
    }
});
var Connection_1 = __turbopack_context__.r("[project]/node_modules/typeorm/connection/Connection.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Connection", {
    enumerable: true,
    get: function() {
        return Connection_1.Connection;
    }
});
var ConnectionManager_1 = __turbopack_context__.r("[project]/node_modules/typeorm/connection/ConnectionManager.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ConnectionManager", {
    enumerable: true,
    get: function() {
        return ConnectionManager_1.ConnectionManager;
    }
});
var QueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/QueryBuilder.js [app-route] (ecmascript)");
Object.defineProperty(exports, "QueryBuilder", {
    enumerable: true,
    get: function() {
        return QueryBuilder_1.QueryBuilder;
    }
});
var SelectQueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/SelectQueryBuilder.js [app-route] (ecmascript)");
Object.defineProperty(exports, "SelectQueryBuilder", {
    enumerable: true,
    get: function() {
        return SelectQueryBuilder_1.SelectQueryBuilder;
    }
});
var DeleteQueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/DeleteQueryBuilder.js [app-route] (ecmascript)");
Object.defineProperty(exports, "DeleteQueryBuilder", {
    enumerable: true,
    get: function() {
        return DeleteQueryBuilder_1.DeleteQueryBuilder;
    }
});
var InsertQueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/InsertQueryBuilder.js [app-route] (ecmascript)");
Object.defineProperty(exports, "InsertQueryBuilder", {
    enumerable: true,
    get: function() {
        return InsertQueryBuilder_1.InsertQueryBuilder;
    }
});
var UpdateQueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/UpdateQueryBuilder.js [app-route] (ecmascript)");
Object.defineProperty(exports, "UpdateQueryBuilder", {
    enumerable: true,
    get: function() {
        return UpdateQueryBuilder_1.UpdateQueryBuilder;
    }
});
var RelationQueryBuilder_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/RelationQueryBuilder.js [app-route] (ecmascript)");
Object.defineProperty(exports, "RelationQueryBuilder", {
    enumerable: true,
    get: function() {
        return RelationQueryBuilder_1.RelationQueryBuilder;
    }
});
var Brackets_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/Brackets.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Brackets", {
    enumerable: true,
    get: function() {
        return Brackets_1.Brackets;
    }
});
var NotBrackets_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/NotBrackets.js [app-route] (ecmascript)");
Object.defineProperty(exports, "NotBrackets", {
    enumerable: true,
    get: function() {
        return NotBrackets_1.NotBrackets;
    }
});
var InsertResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/result/InsertResult.js [app-route] (ecmascript)");
Object.defineProperty(exports, "InsertResult", {
    enumerable: true,
    get: function() {
        return InsertResult_1.InsertResult;
    }
});
var UpdateResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/result/UpdateResult.js [app-route] (ecmascript)");
Object.defineProperty(exports, "UpdateResult", {
    enumerable: true,
    get: function() {
        return UpdateResult_1.UpdateResult;
    }
});
var DeleteResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-builder/result/DeleteResult.js [app-route] (ecmascript)");
Object.defineProperty(exports, "DeleteResult", {
    enumerable: true,
    get: function() {
        return DeleteResult_1.DeleteResult;
    }
});
var QueryResult_1 = __turbopack_context__.r("[project]/node_modules/typeorm/query-runner/QueryResult.js [app-route] (ecmascript)");
Object.defineProperty(exports, "QueryResult", {
    enumerable: true,
    get: function() {
        return QueryResult_1.QueryResult;
    }
});
var MongoEntityManager_1 = __turbopack_context__.r("[project]/node_modules/typeorm/entity-manager/MongoEntityManager.js [app-route] (ecmascript)");
Object.defineProperty(exports, "MongoEntityManager", {
    enumerable: true,
    get: function() {
        return MongoEntityManager_1.MongoEntityManager;
    }
});
var Migration_1 = __turbopack_context__.r("[project]/node_modules/typeorm/migration/Migration.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Migration", {
    enumerable: true,
    get: function() {
        return Migration_1.Migration;
    }
});
var MigrationExecutor_1 = __turbopack_context__.r("[project]/node_modules/typeorm/migration/MigrationExecutor.js [app-route] (ecmascript)");
Object.defineProperty(exports, "MigrationExecutor", {
    enumerable: true,
    get: function() {
        return MigrationExecutor_1.MigrationExecutor;
    }
});
var DefaultNamingStrategy_1 = __turbopack_context__.r("[project]/node_modules/typeorm/naming-strategy/DefaultNamingStrategy.js [app-route] (ecmascript)");
Object.defineProperty(exports, "DefaultNamingStrategy", {
    enumerable: true,
    get: function() {
        return DefaultNamingStrategy_1.DefaultNamingStrategy;
    }
});
var LegacyOracleNamingStrategy_1 = __turbopack_context__.r("[project]/node_modules/typeorm/naming-strategy/LegacyOracleNamingStrategy.js [app-route] (ecmascript)");
Object.defineProperty(exports, "LegacyOracleNamingStrategy", {
    enumerable: true,
    get: function() {
        return LegacyOracleNamingStrategy_1.LegacyOracleNamingStrategy;
    }
});
var EntitySchema_1 = __turbopack_context__.r("[project]/node_modules/typeorm/entity-schema/EntitySchema.js [app-route] (ecmascript)");
Object.defineProperty(exports, "EntitySchema", {
    enumerable: true,
    get: function() {
        return EntitySchema_1.EntitySchema;
    }
});
var EntitySchemaEmbeddedColumnOptions_1 = __turbopack_context__.r("[project]/node_modules/typeorm/entity-schema/EntitySchemaEmbeddedColumnOptions.js [app-route] (ecmascript)");
Object.defineProperty(exports, "EntitySchemaEmbeddedColumnOptions", {
    enumerable: true,
    get: function() {
        return EntitySchemaEmbeddedColumnOptions_1.EntitySchemaEmbeddedColumnOptions;
    }
});
var EntitySchemaOptions_1 = __turbopack_context__.r("[project]/node_modules/typeorm/entity-schema/EntitySchemaOptions.js [app-route] (ecmascript)");
Object.defineProperty(exports, "EntitySchemaOptions", {
    enumerable: true,
    get: function() {
        return EntitySchemaOptions_1.EntitySchemaOptions;
    }
});
var InstanceChecker_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/InstanceChecker.js [app-route] (ecmascript)");
Object.defineProperty(exports, "InstanceChecker", {
    enumerable: true,
    get: function() {
        return InstanceChecker_1.InstanceChecker;
    }
});
var TreeRepositoryUtils_1 = __turbopack_context__.r("[project]/node_modules/typeorm/util/TreeRepositoryUtils.js [app-route] (ecmascript)");
Object.defineProperty(exports, "TreeRepositoryUtils", {
    enumerable: true,
    get: function() {
        return TreeRepositoryUtils_1.TreeRepositoryUtils;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/typeorm/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AbstractLogger": (()=>AbstractLogger),
    "AbstractRepository": (()=>AbstractRepository),
    "AdvancedConsoleLogger": (()=>AdvancedConsoleLogger),
    "AfterInsert": (()=>AfterInsert),
    "AfterLoad": (()=>AfterLoad),
    "AfterRecover": (()=>AfterRecover),
    "AfterRemove": (()=>AfterRemove),
    "AfterSoftRemove": (()=>AfterSoftRemove),
    "AfterUpdate": (()=>AfterUpdate),
    "AlreadyHasActiveConnectionError": (()=>AlreadyHasActiveConnectionError),
    "And": (()=>And),
    "Any": (()=>Any),
    "ArrayContainedBy": (()=>ArrayContainedBy),
    "ArrayContains": (()=>ArrayContains),
    "ArrayOverlap": (()=>ArrayOverlap),
    "BSON": (()=>BSON),
    "BSONRegExp": (()=>BSONRegExp),
    "BSONSymbol": (()=>BSONSymbol),
    "BSONType": (()=>BSONType),
    "BaseEntity": (()=>BaseEntity),
    "BeforeInsert": (()=>BeforeInsert),
    "BeforeRecover": (()=>BeforeRecover),
    "BeforeRemove": (()=>BeforeRemove),
    "BeforeSoftRemove": (()=>BeforeSoftRemove),
    "BeforeUpdate": (()=>BeforeUpdate),
    "Between": (()=>Between),
    "Binary": (()=>Binary),
    "Brackets": (()=>Brackets),
    "CannotAttachTreeChildrenEntityError": (()=>CannotAttachTreeChildrenEntityError),
    "CannotConnectAlreadyConnectedError": (()=>CannotConnectAlreadyConnectedError),
    "CannotCreateEntityIdMapError": (()=>CannotCreateEntityIdMapError),
    "CannotDetermineEntityError": (()=>CannotDetermineEntityError),
    "CannotExecuteNotConnectedError": (()=>CannotExecuteNotConnectedError),
    "CannotGetEntityManagerNotConnectedError": (()=>CannotGetEntityManagerNotConnectedError),
    "CannotReflectMethodParameterTypeError": (()=>CannotReflectMethodParameterTypeError),
    "Check": (()=>Check),
    "ChildEntity": (()=>ChildEntity),
    "CircularRelationsError": (()=>CircularRelationsError),
    "Code": (()=>Code),
    "Column": (()=>Column),
    "ColumnTypeUndefinedError": (()=>ColumnTypeUndefinedError),
    "Connection": (()=>Connection),
    "ConnectionIsNotSetError": (()=>ConnectionIsNotSetError),
    "ConnectionManager": (()=>ConnectionManager),
    "ConnectionNotFoundError": (()=>ConnectionNotFoundError),
    "ConnectionOptionsReader": (()=>ConnectionOptionsReader),
    "CreateDateColumn": (()=>CreateDateColumn),
    "CustomRepositoryCannotInheritRepositoryError": (()=>CustomRepositoryCannotInheritRepositoryError),
    "CustomRepositoryDoesNotHaveEntityError": (()=>CustomRepositoryDoesNotHaveEntityError),
    "CustomRepositoryNotFoundError": (()=>CustomRepositoryNotFoundError),
    "DBRef": (()=>DBRef),
    "DataSource": (()=>DataSource),
    "DataTypeNotSupportedError": (()=>DataTypeNotSupportedError),
    "Decimal128": (()=>Decimal128),
    "DefaultNamingStrategy": (()=>DefaultNamingStrategy),
    "DeleteDateColumn": (()=>DeleteDateColumn),
    "DeleteQueryBuilder": (()=>DeleteQueryBuilder),
    "DeleteResult": (()=>DeleteResult),
    "Double": (()=>Double),
    "DriverOptionNotSetError": (()=>DriverOptionNotSetError),
    "DriverPackageNotInstalledError": (()=>DriverPackageNotInstalledError),
    "Entity": (()=>Entity),
    "EntityManager": (()=>EntityManager),
    "EntityMetadata": (()=>EntityMetadata),
    "EntityMetadataNotFoundError": (()=>EntityMetadataNotFoundError),
    "EntityNotFoundError": (()=>EntityNotFoundError),
    "EntityPropertyNotFoundError": (()=>EntityPropertyNotFoundError),
    "EntityRepository": (()=>EntityRepository),
    "EntitySchema": (()=>EntitySchema),
    "EntitySchemaEmbeddedColumnOptions": (()=>EntitySchemaEmbeddedColumnOptions),
    "EntitySchemaOptions": (()=>EntitySchemaOptions),
    "Equal": (()=>Equal),
    "EqualOperator": (()=>EqualOperator),
    "EventSubscriber": (()=>EventSubscriber),
    "Exclusion": (()=>Exclusion),
    "FileLogger": (()=>FileLogger),
    "FindOperator": (()=>FindOperator),
    "FindOptionsUtils": (()=>FindOptionsUtils),
    "FindRelationsNotFoundError": (()=>FindRelationsNotFoundError),
    "ForbiddenTransactionModeOverrideError": (()=>ForbiddenTransactionModeOverrideError),
    "ForeignKey": (()=>ForeignKey),
    "FormattedConsoleLogger": (()=>FormattedConsoleLogger),
    "Generated": (()=>Generated),
    "ILike": (()=>ILike),
    "In": (()=>In),
    "Index": (()=>Index),
    "InitializedRelationError": (()=>InitializedRelationError),
    "InsertQueryBuilder": (()=>InsertQueryBuilder),
    "InsertResult": (()=>InsertResult),
    "InsertValuesMissingError": (()=>InsertValuesMissingError),
    "InstanceChecker": (()=>InstanceChecker),
    "Int32": (()=>Int32),
    "IsNull": (()=>IsNull),
    "JoinColumn": (()=>JoinColumn),
    "JoinTable": (()=>JoinTable),
    "JsonContains": (()=>JsonContains),
    "LegacyOracleNamingStrategy": (()=>LegacyOracleNamingStrategy),
    "LessThan": (()=>LessThan),
    "LessThanOrEqual": (()=>LessThanOrEqual),
    "Like": (()=>Like),
    "LimitOnUpdateNotSupportedError": (()=>LimitOnUpdateNotSupportedError),
    "LockNotSupportedOnGivenDriverError": (()=>LockNotSupportedOnGivenDriverError),
    "Long": (()=>Long),
    "ManyToMany": (()=>ManyToMany),
    "ManyToOne": (()=>ManyToOne),
    "MaxKey": (()=>MaxKey),
    "MetadataAlreadyExistsError": (()=>MetadataAlreadyExistsError),
    "MetadataWithSuchNameAlreadyExistsError": (()=>MetadataWithSuchNameAlreadyExistsError),
    "Migration": (()=>Migration),
    "MigrationExecutor": (()=>MigrationExecutor),
    "MinKey": (()=>MinKey),
    "MissingDeleteDateColumnError": (()=>MissingDeleteDateColumnError),
    "MissingDriverError": (()=>MissingDriverError),
    "MissingJoinColumnError": (()=>MissingJoinColumnError),
    "MissingJoinTableError": (()=>MissingJoinTableError),
    "MissingPrimaryColumnError": (()=>MissingPrimaryColumnError),
    "MongoEntityManager": (()=>MongoEntityManager),
    "MongoRepository": (()=>MongoRepository),
    "MoreThan": (()=>MoreThan),
    "MoreThanOrEqual": (()=>MoreThanOrEqual),
    "MssqlParameter": (()=>MssqlParameter),
    "MustBeEntityError": (()=>MustBeEntityError),
    "NoConnectionForRepositoryError": (()=>NoConnectionForRepositoryError),
    "NoConnectionOptionError": (()=>NoConnectionOptionError),
    "NoNeedToReleaseEntityManagerError": (()=>NoNeedToReleaseEntityManagerError),
    "NoVersionOrUpdateDateColumnError": (()=>NoVersionOrUpdateDateColumnError),
    "Not": (()=>Not),
    "NotBrackets": (()=>NotBrackets),
    "ObjectId": (()=>ObjectId),
    "ObjectIdColumn": (()=>ObjectIdColumn),
    "OffsetWithoutLimitNotSupportedError": (()=>OffsetWithoutLimitNotSupportedError),
    "OneToMany": (()=>OneToMany),
    "OneToOne": (()=>OneToOne),
    "OptimisticLockCanNotBeUsedError": (()=>OptimisticLockCanNotBeUsedError),
    "OptimisticLockVersionMismatchError": (()=>OptimisticLockVersionMismatchError),
    "Or": (()=>Or),
    "PersistedEntityNotFoundError": (()=>PersistedEntityNotFoundError),
    "PessimisticLockTransactionRequiredError": (()=>PessimisticLockTransactionRequiredError),
    "PrimaryColumn": (()=>PrimaryColumn),
    "PrimaryColumnCannotBeNullableError": (()=>PrimaryColumnCannotBeNullableError),
    "PrimaryGeneratedColumn": (()=>PrimaryGeneratedColumn),
    "QueryBuilder": (()=>QueryBuilder),
    "QueryFailedError": (()=>QueryFailedError),
    "QueryResult": (()=>QueryResult),
    "QueryRunnerAlreadyReleasedError": (()=>QueryRunnerAlreadyReleasedError),
    "QueryRunnerProviderAlreadyReleasedError": (()=>QueryRunnerProviderAlreadyReleasedError),
    "Raw": (()=>Raw),
    "RelationCount": (()=>RelationCount),
    "RelationId": (()=>RelationId),
    "RelationQueryBuilder": (()=>RelationQueryBuilder),
    "Repository": (()=>Repository),
    "RepositoryNotTreeError": (()=>RepositoryNotTreeError),
    "ReturningStatementNotSupportedError": (()=>ReturningStatementNotSupportedError),
    "SelectQueryBuilder": (()=>SelectQueryBuilder),
    "SimpleConsoleLogger": (()=>SimpleConsoleLogger),
    "SubjectRemovedAndUpdatedError": (()=>SubjectRemovedAndUpdatedError),
    "SubjectWithoutIdentifierError": (()=>SubjectWithoutIdentifierError),
    "Table": (()=>Table),
    "TableCheck": (()=>TableCheck),
    "TableColumn": (()=>TableColumn),
    "TableExclusion": (()=>TableExclusion),
    "TableForeignKey": (()=>TableForeignKey),
    "TableIndex": (()=>TableIndex),
    "TableInheritance": (()=>TableInheritance),
    "TableUnique": (()=>TableUnique),
    "Timestamp": (()=>Timestamp),
    "TransactionAlreadyStartedError": (()=>TransactionAlreadyStartedError),
    "TransactionNotStartedError": (()=>TransactionNotStartedError),
    "Tree": (()=>Tree),
    "TreeChildren": (()=>TreeChildren),
    "TreeLevelColumn": (()=>TreeLevelColumn),
    "TreeParent": (()=>TreeParent),
    "TreeRepository": (()=>TreeRepository),
    "TreeRepositoryNotSupportedError": (()=>TreeRepositoryNotSupportedError),
    "TreeRepositoryUtils": (()=>TreeRepositoryUtils),
    "TypeORMError": (()=>TypeORMError),
    "Unique": (()=>Unique),
    "UpdateDateColumn": (()=>UpdateDateColumn),
    "UpdateQueryBuilder": (()=>UpdateQueryBuilder),
    "UpdateResult": (()=>UpdateResult),
    "UpdateValuesMissingError": (()=>UpdateValuesMissingError),
    "UsingJoinColumnIsNotAllowedError": (()=>UsingJoinColumnIsNotAllowedError),
    "UsingJoinColumnOnlyOnOneSideAllowedError": (()=>UsingJoinColumnOnlyOnOneSideAllowedError),
    "UsingJoinTableIsNotAllowedError": (()=>UsingJoinTableIsNotAllowedError),
    "UsingJoinTableOnlyOnOneSideAllowedError": (()=>UsingJoinTableOnlyOnOneSideAllowedError),
    "VersionColumn": (()=>VersionColumn),
    "View": (()=>View),
    "ViewColumn": (()=>ViewColumn),
    "ViewEntity": (()=>ViewEntity),
    "VirtualColumn": (()=>VirtualColumn),
    "createConnection": (()=>createConnection),
    "createConnections": (()=>createConnections),
    "createQueryBuilder": (()=>createQueryBuilder),
    "default": (()=>__TURBOPACK__default__export__),
    "deserialize": (()=>deserialize),
    "getConnection": (()=>getConnection),
    "getConnectionManager": (()=>getConnectionManager),
    "getConnectionOptions": (()=>getConnectionOptions),
    "getCustomRepository": (()=>getCustomRepository),
    "getFromContainer": (()=>getFromContainer),
    "getManager": (()=>getManager),
    "getMetadataArgsStorage": (()=>getMetadataArgsStorage),
    "getMongoManager": (()=>getMongoManager),
    "getMongoRepository": (()=>getMongoRepository),
    "getRepository": (()=>getRepository),
    "getSqljsManager": (()=>getSqljsManager),
    "getTreeRepository": (()=>getTreeRepository),
    "serialize": (()=>serialize),
    "useContainer": (()=>useContainer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/typeorm/index.js [app-route] (ecmascript)");
;
const { ConnectionOptionsReader, DataSource, Connection, ConnectionManager, QueryBuilder, SelectQueryBuilder, DeleteQueryBuilder, InsertQueryBuilder, UpdateQueryBuilder, RelationQueryBuilder, Brackets, NotBrackets, InsertResult, UpdateResult, DeleteResult, QueryResult, MongoEntityManager, Migration, MigrationExecutor, DefaultNamingStrategy, LegacyOracleNamingStrategy, EntitySchema, EntitySchemaEmbeddedColumnOptions, EntitySchemaOptions, InstanceChecker, TreeRepositoryUtils, getMetadataArgsStorage, getConnectionOptions, getConnectionManager, createConnection, createConnections, getConnection, getManager, getMongoManager, getSqljsManager, getRepository, getTreeRepository, getCustomRepository, getMongoRepository, createQueryBuilder, useContainer, getFromContainer, CannotReflectMethodParameterTypeError, AlreadyHasActiveConnectionError, SubjectWithoutIdentifierError, CannotConnectAlreadyConnectedError, LockNotSupportedOnGivenDriverError, ConnectionIsNotSetError, CannotCreateEntityIdMapError, MetadataAlreadyExistsError, CannotDetermineEntityError, UpdateValuesMissingError, TreeRepositoryNotSupportedError, CustomRepositoryNotFoundError, TransactionNotStartedError, TransactionAlreadyStartedError, EntityNotFoundError, EntityMetadataNotFoundError, MustBeEntityError, OptimisticLockVersionMismatchError, LimitOnUpdateNotSupportedError, PrimaryColumnCannotBeNullableError, CustomRepositoryCannotInheritRepositoryError, QueryRunnerProviderAlreadyReleasedError, CannotAttachTreeChildrenEntityError, CustomRepositoryDoesNotHaveEntityError, MissingDeleteDateColumnError, NoConnectionForRepositoryError, CircularRelationsError, ReturningStatementNotSupportedError, UsingJoinTableIsNotAllowedError, MissingJoinColumnError, MissingPrimaryColumnError, EntityPropertyNotFoundError, MissingDriverError, DriverPackageNotInstalledError, CannotGetEntityManagerNotConnectedError, ConnectionNotFoundError, NoVersionOrUpdateDateColumnError, InsertValuesMissingError, OptimisticLockCanNotBeUsedError, MetadataWithSuchNameAlreadyExistsError, DriverOptionNotSetError, FindRelationsNotFoundError, PessimisticLockTransactionRequiredError, RepositoryNotTreeError, DataTypeNotSupportedError, InitializedRelationError, MissingJoinTableError, QueryFailedError, NoNeedToReleaseEntityManagerError, UsingJoinColumnOnlyOnOneSideAllowedError, UsingJoinTableOnlyOnOneSideAllowedError, SubjectRemovedAndUpdatedError, PersistedEntityNotFoundError, UsingJoinColumnIsNotAllowedError, ColumnTypeUndefinedError, QueryRunnerAlreadyReleasedError, OffsetWithoutLimitNotSupportedError, CannotExecuteNotConnectedError, NoConnectionOptionError, TypeORMError, ForbiddenTransactionModeOverrideError, Column, CreateDateColumn, DeleteDateColumn, PrimaryGeneratedColumn, PrimaryColumn, UpdateDateColumn, VersionColumn, VirtualColumn, ViewColumn, ObjectIdColumn, AfterInsert, AfterLoad, AfterRemove, AfterSoftRemove, AfterRecover, AfterUpdate, BeforeInsert, BeforeRemove, BeforeSoftRemove, BeforeRecover, BeforeUpdate, EventSubscriber, JoinColumn, JoinTable, ManyToMany, ManyToOne, OneToMany, OneToOne, RelationCount, RelationId, Entity, ChildEntity, TableInheritance, ViewEntity, TreeLevelColumn, TreeParent, TreeChildren, Tree, Index, ForeignKey, Unique, Check, Exclusion, Generated, EntityRepository, And, Or, Any, ArrayContainedBy, ArrayContains, ArrayOverlap, Between, Equal, In, IsNull, LessThan, LessThanOrEqual, ILike, Like, MoreThan, MoreThanOrEqual, Not, Raw, JsonContains, EqualOperator, FindOperator, FindOptionsUtils, AbstractLogger, AdvancedConsoleLogger, FormattedConsoleLogger, SimpleConsoleLogger, FileLogger, EntityMetadata, EntityManager, AbstractRepository, Repository, BaseEntity, TreeRepository, MongoRepository, TableCheck, TableColumn, TableExclusion, TableForeignKey, TableIndex, TableUnique, Table, View, Binary, BSON, BSONRegExp, BSONSymbol, BSONType, Code, DBRef, Decimal128, deserialize, Double, Int32, Long, MaxKey, MinKey, ObjectId, serialize, Timestamp, MssqlParameter } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$typeorm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"];
}}),

};

//# sourceMappingURL=node_modules_typeorm_fcac18dd._.js.map